<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Antlr4.Runtime.v4.0</name>
    </assembly>
    <members>
        <member name="T:Antlr4.Runtime.AntlrFileStream">
            <summary>
            This is an
            <see cref="T:Antlr4.Runtime.AntlrInputStream">AntlrInputStream</see>
            that is loaded from a file all at once
            when you construct the object.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.AntlrInputStream">
            <summary>
            Vacuum all input from a
            <see cref="T:System.IO.StreamReader">System.IO.StreamReader</see>
            /
            <see cref="T:System.IO.Stream">System.IO.Stream</see>
            and then treat it
            like a
            <code>char[]</code>
            buffer. Can also pass in a
            <see cref="T:System.String">string</see>
            or
            <code>char[]</code>
            to use.
            <p/>
            If you need encoding, pass in stream/reader with correct encoding.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer.</summary>
            <remarks>A source of characters for an ANTLR lexer.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.IIntStream">
            <summary>A simple stream of symbols whose values are represented as integers.</summary>
            <remarks>
            A simple stream of symbols whose values are represented as integers. This
            interface provides <em>marked ranges</em> with support for a minimum level
            of buffering necessary to implement arbitrary lookahead during prediction.
            For more information on marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">Mark()</see>
            .
            <p/>
            <strong>Initializing Methods:</strong> Some methods in this interface have
            unspecified behavior if no call to an initializing method has occurred after
            the stream was constructed. The following is a list of initializing methods:
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">La(int)</see>
            </li>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.Consume">Consume()</see>
            </li>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Size">Size()</see>
            </li>
            </ul>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Consume">
            <summary>Consumes the current symbol in the stream.</summary>
            <remarks>
            Consumes the current symbol in the stream. This method has the following
            effects:
            <ul>
            <li><strong>Forward movement:</strong> The value of
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            before calling this method is less than the value of
            <code>index()</code>
            after calling this method.</li>
            <li><strong>Ordered lookahead:</strong> The value of
            <code>LA(1)</code>
            before
            calling this method becomes the value of
            <code>LA(-1)</code>
            after calling
            this method.</li>
            </ul>
            Note that calling this method does not guarantee that
            <code>index()</code>
            is
            incremented by exactly 1, as that would preclude the ability to implement
            filtering streams (e.g.
            <see cref="T:Antlr4.Runtime.CommonTokenStream">CommonTokenStream</see>
            which distinguishes
            between "on-channel" and "off-channel" tokens).
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            if an attempt is made to consume the the
            end of the stream (i.e. if
            <code>LA(1)==</code>
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof">EOF</see>
            before calling
            <code>consume</code>
            ).
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.La(System.Int32)">
            <summary>
            Gets the value of the symbol at offset
            <code>i</code>
            from the current
            position. When
            <code>i==1</code>
            , this method returns the value of the current
            symbol in the stream (which is the next symbol to be consumed). When
            <code>i==-1</code>
            , this method returns the value of the previously read
            symbol in the stream. It is not valid to call this method with
            <code>i==0</code>
            , but the specific behavior is unspecified because this
            method is frequently called from performance-critical code.
            <p/>
            This method is guaranteed to succeed if any of the following are true:
            <ul>
            <li>
            <code>i&gt;0</code>
            </li>
            <li>
            <code>i==-1</code>
            and
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            returns a value greater
            than the value of
            <code>index()</code>
            after the stream was constructed
            and
            <code>LA(1)</code>
            was called in that order. Specifying the current
            <code>index()</code>
            relative to the index after the stream was created
            allows for filtering implementations that do not return every symbol
            from the underlying source. Specifying the call to
            <code>LA(1)</code>
            allows for lazily initialized streams.</li>
            <li>
            <code>LA(i)</code>
            refers to a symbol consumed within a marked region
            that has not yet been released.</li>
            </ul>
            If
            <code>i</code>
            represents a position at or beyond the end of the stream,
            this method returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof">Eof</see>
            .
            <p/>
            The return value is unspecified if
            <code>i&lt;0</code>
            and fewer than
            <code>-i</code>
            calls to
            <see cref="M:Antlr4.Runtime.IIntStream.Consume">consume()</see>
            have occurred from the beginning of
            the stream before calling this method.
            </summary>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the value of the specified symbol
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Mark">
            <summary>
            A mark provides a guarantee that
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek()</see>
            operations will be
            valid over a "marked range" extending from the index where
            <code>mark()</code>
            was called to the current
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            . This allows the use of
            streaming input sources by specifying the minimum buffering requirements
            to support arbitrary lookahead during prediction.
            <p/>
            The returned mark is an opaque handle (type
            <code>int</code>
            ) which is passed
            to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the guarantees provided by the marked
            range are no longer necessary. When calls to
            <code>mark()</code>
            /
            <code>release()</code>
            are nested, the marks must be released
            in reverse order of which they were obtained. Since marked regions are
            used during performance-critical sections of prediction, the specific
            behavior of invalid usage is unspecified (i.e. a mark is not released, or
            a mark is released twice, or marks are not released in reverse order from
            which they were created).
            <p/>
            The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.
            <p/>
            This method does not change the current position in the input stream.
            <p/>
            The following example shows the use of
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            ,
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release(mark)</see>
            ,
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            , and
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek(index)</see>
            as part of an operation to safely work within a
            marked region, then restore the stream position to its original value and
            release the mark.
            <pre>
            IntStream stream = ...;
            int index = -1;
            int mark = stream.mark();
            try {
            index = stream.index();
            // perform work here...
            } finally {
            if (index != -1) {
            stream.seek(index);
            }
            stream.release(mark);
            }
            </pre>
            </summary>
            <returns>
            An opaque marker which should be passed to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the marked range is no longer required.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            This method releases a marked range created by a call to
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            . Calls to
            <code>release()</code>
            must appear in the
            reverse order of the corresponding calls to
            <code>mark()</code>
            . If a mark is
            released twice, or if marks are not released in reverse order of the
            corresponding calls to
            <code>mark()</code>
            , the behavior is unspecified.
            <p/>
            For more information and an example, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">Mark()</see>
            .
            </summary>
            <param name="marker">
            A marker returned by a call to
            <code>mark()</code>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.IIntStream.Mark">Mark()</seealso>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
            Set the input cursor to the position indicated by
            <code>index</code>
            . If the
            specified index lies past the end of the stream, the operation behaves as
            though
            <code>index</code>
            was the index of the EOF symbol. After this method
            returns without throwing an exception, the at least one of the following
            will be true.
            <ul>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            will return the index of the first symbol
            appearing at or after the specified
            <code>index</code>
            . Specifically,
            implementations which filter their sources should automatically
            adjust
            <code>index</code>
            forward the minimum amount required for the
            operation to target a non-ignored symbol.</li>
            <li>
            <code>LA(1)</code>
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof">Eof</see>
            </li>
            </ul>
            This operation is guaranteed to not throw an exception if
            <code>index</code>
            lies within a marked region. For more information on marked regions, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">Mark()</see>
            . The behavior of this method is unspecified if no call to
            an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream
            was constructed.
            </summary>
            <param name="index">The absolute index to seek to.</param>
            <exception cref="T:System.ArgumentException">
            if
            <code>index</code>
            is less than 0
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            seeking to the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Index">
            <summary>
            Return the index into the stream of the input symbol referred to by
            <code>LA(1)</code>
            .
            <p/>
            The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Size">
            <summary>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </summary>
            <remarks>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the size of the stream is
            unknown.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.SourceName">
            <summary>Gets the name of the underlying symbol source.</summary>
            <remarks>
            Gets the name of the underlying symbol source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName">UnknownSourceName</see>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            This method returns the text for a range of characters within this input
            stream.
            </summary>
            <remarks>
            This method returns the text for a range of characters within this input
            stream. This method is guaranteed to not throw an exception if the
            specified
            <code>interval</code>
            lies entirely within a marked range. For more
            information about marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">IIntStream.Mark()</see>
            .
            </remarks>
            <param name="interval">an interval within the stream</param>
            <returns>the text of the specified interval</returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <code>interval</code>
            is
            <code>null</code>
            </exception>
            <exception cref="T:System.ArgumentException">
            if
            <code>interval.a &lt; 0</code>
            , or if
            <code>interval.b &lt; interval.a - 1</code>
            , or if
            <code>interval.b</code>
            lies at or
            past the end of the stream
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            getting the text of the specified interval
            </exception>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.data">
            <summary>The data being scanned</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.n">
            <summary>How many characters are actually in the buffer</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.p">
            <summary>0..n-1 index into string of next char</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.name">
            <summary>What is name or source of this char stream?</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor for strings as no data is copied</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.StreamReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.StreamReader,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.StreamReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Load(System.IO.StreamReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
            <remarks>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Mark">
            <summary>mark/release do nothing; we have entire buffer</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
            <remarks>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine. If we seek backwards, just set p
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.AntlrInputStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.
            </summary>
            <remarks>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.Load(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AbstractPredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.Transition">
            <summary>An ATN transition between any two ATN states.</summary>
            <remarks>
            An ATN transition between any two ATN states.  Subclasses define
            atom, set, epsilon, action, predicate, rule transitions.
            <p/>
            This is a one way link.  It emanates from a state (usually via a list of
            transitions) and has a target state.
            <p/>
            Since we never have to change the ATN transitions once we construct it,
            we can fix these transitions as specific classes. The DFA transitions
            on the other hand need to update the labels as it adds transitions to
            the states. We'll use the term Edge for the DFA to distinguish them from
            ATN transitions.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.Transition.target">
            <summary>The target of this transition.</summary>
            <remarks>The target of this transition.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.Transition.IsEpsilon">
            <summary>Are we epsilon, action, sempred?</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionContext.cachedHashCode">
            <summary>
            Stores the computed hash code of this
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext">PredictionContext</see>
            . The hash
            code is computed in parts to match the following reference algorithm.
            <pre>
            private int referenceHashCode() {
            int hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">Antlr4.Runtime.Misc.MurmurHash.Initialize()
                </see>
            (
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.InitialHash">InitialHash</see>
            );
            for (int i = 0; i &lt;
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size">Size()</see>
            ; i++) {
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">Antlr4.Runtime.Misc.MurmurHash.Update(int, int)
                </see>
            (hash,
            <see cref="M:Antlr4.Runtime.Atn.PredictionContext.GetParent(System.Int32)">GetParent(int)</see>
            (i));
            }
            for (int i = 0; i &lt;
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size">Size()</see>
            ; i++) {
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">Antlr4.Runtime.Misc.MurmurHash.Update(int, int)
                </see>
            (hash,
            <see cref="M:Antlr4.Runtime.Atn.PredictionContext.GetReturnState(System.Int32)">GetReturnState(int)</see>
            (i));
            }
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">Antlr4.Runtime.Misc.MurmurHash.Finish(int, int)
                </see>
            (hash, 2 *
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size">Size()</see>
            );
            return hash;
            }
            </pre>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.decisionToState">
            <summary>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.
            </summary>
            <remarks>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.  This includes
            all the rules, subrules, optional blocks, ()+, ()* etc...
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStartState">
            <summary>Maps from rule index to starting state number.</summary>
            <remarks>Maps from rule index to starting state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStopState">
            <summary>Maps from rule index to stop state number.</summary>
            <remarks>Maps from rule index to stop state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.grammarType">
            <summary>The type of the ATN.</summary>
            <remarks>The type of the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.maxTokenType">
            <summary>The maximum value for any symbol recognized by a transition in the ATN.</summary>
            <remarks>The maximum value for any symbol recognized by a transition in the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToTokenType">
            <summary>For lexer ATNs, this maps the rule index to the resulting token type.</summary>
            <remarks>
            For lexer ATNs, this maps the rule index to the resulting token type.
            <p/>
            This is
            <code>null</code>
            for parser ATNs.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToActionIndex">
            <summary>
            For lexer ATNs, this maps the rule index to the action which should be
            executed following a match.
            </summary>
            <remarks>
            For lexer ATNs, this maps the rule index to the action which should be
            executed following a match.
            <p/>
            This is
            <code>null</code>
            for parser ATNs.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.#ctor(Antlr4.Runtime.Atn.ATNType,System.Int32)">
            <summary>Used for runtime deserialization of ATNs from strings</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute the set of valid tokens that can occur starting in state
            <code>s</code>
            .
            If
            <code>ctx</code>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal">PredictionContext.EmptyLocal</see>
            , the set of tokens will not include what can follow
            the rule surrounding
            <code>s</code>
            . In other words, the set will be
            restricted to tokens reachable staying within
            <code>s</code>
            's rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Compute the set of valid tokens that can occur starting in
            <code>s</code>
            and
            staying in same rule.
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is in set if we reach end of
            rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)">
            <summary>
            Computes the set of input symbols which could follow ATN state number
            <code>stateNumber</code>
            in the specified full
            <code>context</code>
            . This method
            considers the complete parser context, but does not evaluate semantic
            predicates (i.e. all predicates encountered during the calculation are
            assumed true). If a path in the ATN exists from the starting state to the
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            of the outermost context without matching any
            symbols,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the returned set.
            <p/>
            If
            <code>context</code>
            is
            <code>null</code>
            , it is treated as
            <see cref="P:Antlr4.Runtime.ParserRuleContext.EmptyContext"/>
            .
            </summary>
            <param name="stateNumber">the ATN state number</param>
            <param name="context">the full parse context</param>
            <returns>
            The set of potentially valid input symbols which could follow the
            specified state in the specified context.
            </returns>
            <exception cref="T:System.ArgumentException">
            if the ATN does not contain a state with
            number
            <code>stateNumber</code>
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfig">
            <summary>A tuple: (ATN state, predicted alt, syntactic, semantic context).</summary>
            <remarks>
            A tuple: (ATN state, predicted alt, syntactic, semantic context).
            The syntactic context is a graph-structured stack node whose
            path(s) to the root is the rule invocation(s)
            chain used to arrive at the state.  The semantic context is
            the tree of semantic predicates encountered before reaching
            an ATN state.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.state">
            <summary>The ATN state associated with this configuration</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.context">
            <summary>
            The stack of invoking states leading to the rule/states associated
            with this config.
            </summary>
            <remarks>
            The stack of invoking states leading to the rule/states associated
            with this config.  We track only those contexts pushed during
            execution of the ATN simulator.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfig.Equals(System.Object)">
            <summary>
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
            </summary>
            <remarks>
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.State">
            <summary>Gets the ATN state associated with this configuration.</summary>
            <remarks>Gets the ATN state associated with this configuration.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.Alt">
            <summary>What alt (or lexer rule) is predicted by this configuration.</summary>
            <remarks>What alt (or lexer rule) is predicted by this configuration.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.OuterContextDepth">
            <summary>
            We cannot execute predicates dependent upon local context unless
            we know for sure we are in the correct context.
            </summary>
            <remarks>
            We cannot execute predicates dependent upon local context unless
            we know for sure we are in the correct context. Because there is
            no way to do this efficiently, we simply cannot evaluate
            dependent predicates unless we are in the rule that initially
            invokes the ATN simulator.
            closure() tracks the depth of how far we dip into the
            outer context: depth &gt; 0.  Note that it may not be totally
            accurate depth since I don't ever decrement. TODO: make it a boolean then
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfigSet">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.mergedConfigs">
            <summary>
            This maps (state, alt) -&gt; merged
            <see cref="T:Antlr4.Runtime.Atn.ATNConfig">ATNConfig</see>
            . The key does not account for
            the
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.SemanticContext">ATNConfig.SemanticContext()</see>
            of the value, which is only a problem if a single
            <code>ATNConfigSet</code>
            contains two configs with the same state and alternative
            but different semantic contexts. When this case arises, the first config
            added to this map stays, and the remaining configs are placed in
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.unmerged">unmerged</see>
            .
            <p/>
            This map is only used for optimizing the process of adding configs to the set,
            and is
            <code>null</code>
            for read-only sets stored in the DFA.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.unmerged">
            <summary>
            This is an "overflow" list holding configs which cannot be merged with one
            of the configs in
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.mergedConfigs">mergedConfigs</see>
            but have a colliding key. This
            occurs when two configs in the set have the same state and alternative but
            different semantic contexts.
            <p/>
            This list is only used for optimizing the process of adding configs to the set,
            and is
            <code>null</code>
            for read-only sets stored in the DFA.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.configs">
            <summary>This is a list of all configs in this set.</summary>
            <remarks>This is a list of all configs in this set.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.outermostConfigSet">
            <summary>
            When
            <code>true</code>
            , this config set represents configurations where the entire
            outer context has been consumed by the ATN interpreter. This prevents the
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.Closure(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)">ParserATNSimulator.Closure(ATNConfigSet, ATNConfigSet, bool, bool, PredictionContextCache)
                </see>
            from pursuing the global FOLLOW when a
            rule stop state is reached with an empty prediction context.
            <p/>
            Note:
            <code>outermostConfigSet</code>
            and
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.dipsIntoOuterContext">dipsIntoOuterContext</see>
            should never
            be true at the same time.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfigSet.GetRepresentedAlternatives">
            <summary>
            Get the set of all alternatives represented by configurations in this
            set.
            </summary>
            <remarks>
            Get the set of all alternatives represented by configurations in this
            set.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.Error">
            <summary>Must distinguish between missing edge and edge we know leads nowhere</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNState">
            <summary>
            The following images show the relation of states and
            <see cref="F:Antlr4.Runtime.Atn.ATNState.transitions">transitions</see>
            for various grammar constructs.
            <ul>
            <li>Solid edges marked with an Îµ indicate a required
            <see cref="T:Antlr4.Runtime.Atn.EpsilonTransition">EpsilonTransition</see>
            .</li>
            <li>Dashed edges indicate locations where any transition derived from
            <see cref="M:Antlr4.Runtime.Atn.ATNState.Transition(System.Int32)">Transition</see>
            might appear.</li>
            <li>Dashed nodes are place holders for either a sequence of linked
            <see cref="T:Antlr4.Runtime.Atn.BasicState">BasicState</see>
            states or the inclusion of a block representing a nested
            construct in one of the forms below.</li>
            <li>Nodes showing multiple outgoing alternatives with a
            <code>...</code>
            support
            any number of alternatives (one or more). Nodes without the
            <code>...</code>
            only
            support the exact number of alternatives shown in the diagram.</li>
            </ul>
            <h2>Basic Blocks</h2>
            <h3>Rule</h3>
            <embed src="images/Rule.svg" type="image/svg+xml"/>
            <h3>Block of 1 or more alternatives</h3>
            <embed src="images/Block.svg" type="image/svg+xml"/>
            <h2>Greedy Loops</h2>
            <h3>Greedy Closure:
            <code>(...)*</code>
            </h3>
            <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
            <h3>Greedy Positive Closure:
            <code>(...)+</code>
            </h3>
            <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
            <h3>Greedy Optional:
            <code>(...)?</code>
            </h3>
            <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
            <h2>Non-Greedy Loops</h2>
            <h3>Non-Greedy Closure:
            <code>(...)*?</code>
            </h3>
            <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
            <h3>Non-Greedy Positive Closure:
            <code>(...)+?</code>
            </h3>
            <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
            <h3>Non-Greedy Optional:
            <code>(...)??</code>
            </h3>
            <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.atn">
            <summary>Which ATN are we in?</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.transitions">
            <summary>Track the transitions emanating from this ATN state.</summary>
            <remarks>Track the transitions emanating from this ATN state.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.nextTokenWithinRule">
            <summary>Used to cache lookahead during parsing, not used during construction</summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNState.StateNumber">
            <summary>Gets the state number.</summary>
            <remarks>Gets the state number.</remarks>
            <returns>the state number</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNState.NonStopStateNumber">
            <summary>
            For all states except
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            , this returns the state
            number. Returns -1 for stop states.
            </summary>
            <returns>
            -1 for
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            , otherwise the state number
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNType">
            <summary>Represents the type of recognizer an ATN applies to.</summary>
            <remarks>Represents the type of recognizer an ATN applies to.</remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AtomTransition">
            <summary>TODO: make all transitions sets? no, should remove set edges</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.AtomTransition.label">
            <summary>The token type or character value; or, signifies special label.</summary>
            <remarks>The token type or character value; or, signifies special label.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicBlockStartState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockStartState">
            <summary>
            The start of a regular
            <code>(...)</code>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockEndState">
            <summary>
            Terminal node of a simple
            <code>(a|b|c)</code>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator">
            <summary>"dup" of ParserInterpreter</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.startIndex">
            <summary>The current token's starting index into the character stream.</summary>
            <remarks>
            The current token's starting index into the character stream.
            Shared across DFA to ATN simulation in case the ATN fails and the
            DFA did not have a previous accept state. In this case, we use the
            ATN-generated exception object.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.line">
            <summary>line number 1..n within the input</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.charPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.prevAccept">
            <summary>Used during DFA/ATN exec to record the most recent accept configuration info
                </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>Get an existing target state for an edge in the DFA.</summary>
            <remarks>
            Get an existing target state for an edge in the DFA. If the target state
            for the edge has not yet been computed or is otherwise not available,
            this method returns
            <code>null</code>
            .
            </remarks>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The existing target DFA state for the given input symbol
            <code>t</code>
            , or
            <code>null</code>
            if the target state for this edge is not
            already cached
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </summary>
            <remarks>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </remarks>
            <param name="input">The input stream</param>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The computed target DFA state for the given input symbol
            <code>t</code>
            . If
            <code>t</code>
            does not lead to a valid DFA state, this method
            returns
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error">ATNSimulator.Error</see>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetReachableConfigSet(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            <summary>
            Given a starting configuration set, figure out all ATN configurations
            we can reach upon input
            <code>t</code>
            . Parameter
            <code>reach</code>
            is a return
            parameter.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.Closure(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfig,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean)">
            <summary>
            Since the alternatives within any lexer decision are ordered by
            preference, this method stops pursuing the closure as soon as an accept
            state is reached.
            </summary>
            <remarks>
            Since the alternatives within any lexer decision are ordered by
            preference, this method stops pursuing the closure as soon as an accept
            state is reached. After the first accept state is reached by depth-first
            search from
            <code>config</code>
            , all other (potentially reachable) states for
            this rule would have a lower priority.
            </remarks>
            <returns>
            
            <code>true</code>
            if an accept state is reached, otherwise
            <code>false</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.EvaluatePredicate(Antlr4.Runtime.ICharStream,System.Int32,System.Int32,System.Boolean)">
            <summary>Evaluate a predicate specified in the lexer.</summary>
            <remarks>
            Evaluate a predicate specified in the lexer.
            <p/>
            If
            <code>speculative</code>
            is
            <code>true</code>
            , this method was called before
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)">Consume(Antlr4.Runtime.ICharStream)
                </see>
            for the matched character. This method should call
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)">Consume(Antlr4.Runtime.ICharStream)
                </see>
            before evaluating the predicate to ensure position
            sensitive values, including
            <see cref="P:Antlr4.Runtime.Lexer.Text">Antlr4.Runtime.Lexer.Text()</see>
            ,
            <see cref="P:Antlr4.Runtime.Lexer.Line">Antlr4.Runtime.Lexer.Line()</see>
            ,
            and
            <see cref="P:Antlr4.Runtime.Lexer.Column">Antlr4.Runtime.Lexer.Column()</see>
            , properly reflect the current
            lexer state. This method should restore
            <code>input</code>
            and the simulator
            to the original state before returning (i.e. undo the actions made by the
            call to
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)">Consume(Antlr4.Runtime.ICharStream)
                </see>
            .
            </remarks>
            <param name="input">The input stream.</param>
            <param name="ruleIndex">The rule containing the predicate.</param>
            <param name="predIndex">The index of the predicate within the rule.</param>
            <param name="speculative">
            
            <code>true</code>
            if the current index in
            <code>input</code>
            is
            one character before the predicate's location.
            </param>
            <returns>
            
            <code>true</code>
            if the specified predicate evaluates to
            <code>true</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.AddDFAState(Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Add a new DFA state if there isn't one with this set of
            configurations already.
            </summary>
            <remarks>
            Add a new DFA state if there isn't one with this set of
            configurations already. This method also detects the first
            configuration containing an ATN rule stop state. Later, when
            traversing the DFA, we will know which rule to accept.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetText(Antlr4.Runtime.ICharStream)">
            <summary>Get the text matched so far for the current token.</summary>
            <remarks>Get the text matched so far for the current token.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator.SimState">
            <summary>
            When we hit an accept state in either the DFA or the ATN, we
            have to notify the character stream to start buffering characters
            via
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">Antlr4.Runtime.IIntStream.Mark()</see>
            and record the current state. The current sim state
            includes the current index into the input, the current line,
            and current character position in that line. Note that the Lexer is
            tracking the starting line and characterization of the token. These
            variables track the "state" of the simulator when it hits an accept state.
            <p/>
            We track these variables separately for the DFA and ATN simulation
            because the DFA simulation often has to fail over to the ATN
            simulation. If the ATN simulation fails, we need the DFA to fall
            back to its previously accepted state, if any. If the ATN succeeds,
            then the ATN does the accept and the DFA simulator that invoked it
            can simply return the predicted token type.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred">
            <summary>
            Special value added to the lookahead sets to indicate that we hit
            a predicate during analysis if
            <code>seeThruPreds==false</code>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.GetDecisionLookahead(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Calculates the SLL(1) expected lookahead set for each outgoing transition
            of an
            <see cref="T:Antlr4.Runtime.Atn.ATNState">ATNState</see>
            . The returned array has one element for each
            outgoing transition in
            <code>s</code>
            . If the closure from transition
            <em>i</em> leads to a semantic predicate before matching a symbol, the
            element at index <em>i</em> of the result will be
            <code>null</code>
            .
            </summary>
            <param name="s">the ATN state</param>
            <returns>
            the expected symbols for each outgoing transition of
            <code>s</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            <p/>
            If
            <code>ctx</code>
            is
            <code>null</code>
            and the end of the rule containing
            <code>s</code>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set.
            If
            <code>ctx</code>
            is not
            <code>null</code>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof">Antlr4.Runtime.TokenConstants.Eof</see>
            is added to the result set.
            </summary>
            <param name="s">the ATN state</param>
            <param name="ctx">
            the complete parser context, or
            <code>null</code>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            <p/>
            If
            <code>ctx</code>
            is
            <code>null</code>
            and the end of the rule containing
            <code>s</code>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set.
            If
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof"/>
            is not
            <code>null</code>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.
            </summary>
            <param name="s">the ATN state</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState">BlockEndState</see>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            the complete parser context, or
            <code>null</code>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext,Antlr4.Runtime.Misc.IntervalSet,System.Collections.Generic.HashSet{Antlr4.Runtime.Atn.ATNConfig},Sharpen.BitSet,System.Boolean,System.Boolean)">
            <summary>
            Compute set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            <p/>
            If
            <code>ctx</code>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal">PredictionContext.EmptyLocal</see>
            and
            <code>stopState</code>
            or the end of the rule containing
            <code>s</code>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set. If
            <code>ctx</code>
            is not
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal">PredictionContext.EmptyLocal</see>
            and
            <code>addEOF</code>
            is
            <code>true</code>
            and
            <code>stopState</code>
            or the end of the outermost rule is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.
            </summary>
            <param name="s">the ATN state.</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState">BlockEndState</see>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            The outer context, or
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal">PredictionContext.EmptyLocal</see>
            if
            the outer context should not be used.
            </param>
            <param name="look">The result lookahead set.</param>
            <param name="lookBusy">
            A set used for preventing epsilon closures in the ATN
            from causing a stack overflow. Outside code should pass
            <code>new HashSet&lt;ATNConfig&gt;</code>
            for this argument.
            </param>
            <param name="calledRuleStack">
            A set used for preventing left recursion in the
            ATN from causing a stack overflow. Outside code should pass
            <code>new BitSet()</code>
            for this argument.
            </param>
            <param name="seeThruPreds">
            
            <code>true</code>
            to true semantic predicates as
            implicitly
            <code>true</code>
            and "see through them", otherwise
            <code>false</code>
            to treat semantic predicates as opaque and add
            <see cref="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred">HitPred</see>
            to the
            result if one is encountered.
            </param>
            <param name="addEOF">
            Add
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            to the result if the end of the
            outermost context is reached. This parameter has no effect if
            <code>ctx</code>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal">PredictionContext.EmptyLocal</see>
            .
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LoopEndState">
            <summary>Mark the end of a * or + loop.</summary>
            <remarks>Mark the end of a * or + loop.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SetTransition">
            <summary>A transition containing a set of values.</summary>
            <remarks>A transition containing a set of values.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.OrderedATNConfigSet">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParserATNSimulator">
            <summary>The embodiment of the adaptive LL(*) parsing strategy.</summary>
            <remarks>
            The embodiment of the adaptive LL(*) parsing strategy.
            The basic complexity of the adaptive strategy makes it harder to
            understand. We begin with ATN simulation to build paths in a
            DFA. Subsequent prediction requests go through the DFA first. If
            they reach a state without an edge for the current symbol, the
            algorithm fails over to the ATN simulation to complete the DFA
            path for the current input (until it finds a conflict state or
            uniquely predicting state).
            All of that is done without using the outer context because we
            want to create a DFA that is not dependent upon the rule
            invocation stack when we do a prediction.  One DFA works in all
            contexts. We avoid using context not necessarily because it
            slower, although it can be, but because of the DFA caching
            problem.  The closure routine only considers the rule invocation
            stack created during prediction beginning in the entry rule.  For
            example, if prediction occurs without invoking another rule's
            ATN, there are no context stacks in the configurations. When this
            leads to a conflict, we don't know if it's an ambiguity or a
            weakness in the strong LL(*) parsing strategy (versus full
            LL(*)).
            So, we simply retry the ATN simulation again, this time
            using full outer context and filling a dummy DFA (to avoid
            polluting the context insensitive DFA). Configuration context
            stacks will be the full invocation stack from the start rule. If
            we get a conflict using full context, then we can definitively
            say we have a true ambiguity for that input sequence. If we don't
            get a conflict, it implies that the decision is sensitive to the
            outer context. (It is not context-sensitive in the sense of
            context sensitive grammars.) We create a special DFA accept state
            that maps rule context to a predicted alternative. That is the
            only modification needed to handle full LL(*) prediction. In
            general, full context prediction will use more lookahead than
            necessary, but it pays to share the same DFA. For a schedule
            proof that full context prediction uses that most the same amount
            of lookahead as a context insensitive prediction, see the comment
            on method retryWithContext().
            So, the strategy is complex because we bounce back and forth from
            the ATN to the DFA, simultaneously performing predictions and
            extending the DFA according to previously unseen input
            sequences. The retry with full context is a recursive call to the
            same function naturally because it does the same thing, just with
            a different initial context. The problem is, that we need to pass
            in a "full context mode" parameter so that it knows to report
            conflicts differently. It also knows not to do a retry, to avoid
            infinite recursion, if it is already using full context.
            Retry a simulation using full outer context.
            One of the key assumptions here is that using full context
            can use at most the same amount of input as a simulation
            that is not useful context (i.e., it uses all possible contexts
            that could invoke our entry rule. I believe that this is true
            and the proof might go like this.
            THEOREM:  The amount of input consumed during a full context
            simulation is at most the amount of input consumed during a
            non full context simulation.
            PROOF: Let D be the DFA state at which non-context simulation
            terminated. That means that D does not have a configuration for
            which we can legally pursue more input. (It is legal to work only
            on configurations for which there is no conflict with another
            configuration.) Now we restrict ourselves to following ATN edges
            associated with a single context. Choose any DFA state D' along
            the path (same input) to D. That state has either the same number
            of configurations or fewer. (If the number of configurations is
            the same, then we have degenerated to the non-context case.) Now
            imagine that we restrict to following edges associated with
            another single context and that we reach DFA state D'' for the
            same amount of input as D'. The non-context simulation merges D'
            and D''. The union of the configuration sets either has the same
            number of configurations as both D' and D'' or it has more. If it
            has the same number, we are no worse off and the merge does not
            force us to look for more input than we would otherwise have to
            do. If the union has more configurations, it can introduce
            conflicts but not new alternatives--we cannot conjure up alternatives
            by computing closure on the DFA state.  Here are the cases for
            D' union D'':
            1. No increase in configurations, D' = D''
            2. Add configuration that introduces a new alternative number.
            This cannot happen because no new alternatives are introduced
            while computing closure, even during start state computation.
            3. D'' adds a configuration that does not conflict with any
            configuration in D'.  Simulating without context would then have
            forced us to use more lookahead than D' (full context) alone.
            3. D'' adds a configuration that introduces a conflict with a
            configuration in D'. There are 2 cases:
            a. The conflict does not cause termination (D' union D''
            is added to the work list). Again no context simulation requires
            more input.
            b. The conflict does cause termination, but this cannot happen.
            By definition, we know that with ALL contexts merged we
            don't terminate until D and D' uses less input than D. Therefore
            no context simulation requires more input than full context
            simulation.
            We have covered all the cases and there is never a situation where
            a single, full context simulation requires more input than a
            no context simulation.
            I spent a bunch of time thinking about this problem after finding
            a case where context-sensitive ATN simulation looks beyond what they
            no context simulation uses. the no context simulation for if then else
            stops at the else whereas full context scans through to the end of the
            statement to decide that the "else statement" clause is ambiguous. And
            sometimes it is not ambiguous! Ok, I made an untrue assumption in my
            proof which I won't bother going to. the important thing is what I'm
            going to do about it. I thought I had a simple answer, but nope. It
            turns out that the if then else case is perfect example of something
            that has the following characteristics:
            no context conflicts at k=1
            full context at k=(1 + length of statement) can be both ambiguous and not
            ambiguous depending on the input, though I think from different contexts.
            But, the good news is that the k=1 case is a special case in that
            SLL(1) and LL(1) have exactly the same power so we can conclude that
            conflicts at k=1 are true ambiguities and we do not need to pursue
            context-sensitive parsing. That covers a huge number of cases
            including the if then else clause and the predicated precedence
            parsing mechanism. whew! because that could be extremely expensive if
            we had to do context.
            Further, there is no point in doing full context if none of the
            configurations dip into the outer context. This nicely handles cases
            such as super constructor calls versus function calls. One grammar
            might look like this:
            ctorBody : '{' superCall? stat* '}' ;
            Or, you might see something like
            stat : superCall ';' | expression ';' | ... ;
            In both cases I believe that no closure operations will dip into the
            outer context. In the first case ctorBody in the worst case will stop
            at the '}'. In the 2nd case it should stop at the ';'. Both cases
            should stay within the entry rule and not dip into the outer context.
            So, we now cover what I hope is the vast majority of the cases (in
            particular the very important precedence parsing case). Anything that
            needs k&gt;1 and dips into the outer context requires a full context
            retry. In this case, I'm going to start out with a brain-dead solution
            which is to mark the DFA state as context-sensitive when I get a
            conflict. Any further DFA simulation that reaches that state will
            launch an ATN simulation to get the prediction, without updating the
            DFA or storing any context information. Later, I can make this more
            efficient, but at least in this case I can guarantee that it will
            always do the right thing. We are not making any assumptions about
            lookahead depth.
            Ok, writing this up so I can put in a comment.
            Upon conflict in the no context simulation:
            if k=1, report ambiguity and resolve to the minimum conflicting alternative
            if k=1 and predicates, no report and include the predicate to
            predicted alternative map in the DFA state
            if k=* and we did not dip into the outer context, report ambiguity
            and resolve to minimum conflicting alternative
            if k&gt;1 and we dip into outer context, retry with full context
            if conflict, report ambiguity and resolve to minimum conflicting
            alternative, mark DFA as context-sensitive
            If no conflict, report ctx sensitivity and mark DFA as context-sensitive
            Technically, if full context k is less than no context k, we can
            reuse the conflicting DFA state so we don't have to create special
            DFA paths branching from context, but we can leave that for
            optimization later if necessary.
            if non-greedy, no report and resolve to the exit alternative
            By default we do full context-sensitive LL(*) parsing not
            Strong LL(*) parsing. If we fail with Strong LL(*) we
            try full LL(*). That means we rewind and use context information
            when closure operations fall off the end of the rule that
            holds the decision were evaluating
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.reportAmbiguities">
            <summary>
            When
            <code>true</code>
            , ambiguous alternatives are reported when they are
            encountered within
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">ExecATN(Antlr4.Runtime.Dfa.DFA, Antlr4.Runtime.ITokenStream, int, SimulatorState)
                </see>
            . When
            <code>false</code>
            , these messages
            are suppressed. The default is
            <code>false</code>
            .
            <p/>
            When messages about ambiguous alternatives are not required, setting this
            to
            <code>false</code>
            enables additional internal optimizations which may lose
            this information.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.userWantsCtxSensitive">
            <summary>
            By default we do full context-sensitive LL(*) parsing not
            Strong LL(*) parsing.
            </summary>
            <remarks>
            By default we do full context-sensitive LL(*) parsing not
            Strong LL(*) parsing. If we fail with Strong LL(*) we
            try full LL(*). That means we rewind and use context information
            when closure operations fall off the end of the rule that
            holds the decision were evaluating.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.#ctor(Antlr4.Runtime.Atn.ATN)">
            <summary>Testing only!</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            Performs ATN simulation to compute a predicted alternative based
            upon the remaining input, but also updates the DFA cache to avoid
            having to traverse the ATN again for the same input sequence.
            </summary>
            <remarks>
            Performs ATN simulation to compute a predicted alternative based
            upon the remaining input, but also updates the DFA cache to avoid
            having to traverse the ATN again for the same input sequence.
            There are some key conditions we're looking for after computing a new
            set of ATN configs (proposed DFA state):
            if the set is empty, there is no viable alternative for current symbol
            does the state uniquely predict an alternative?
            does the state have a conflict that would prevent us from
            putting it on the work list?
            if in non-greedy decision is there a config at a rule stop state?
            We also have some key operations to do:
            add an edge from previous DFA state to potentially new DFA state, D,
            upon current symbol but only if adding to work list, which means in all
            cases except no viable alternative (and possibly non-greedy decisions?)
            collecting predicates and adding semantic context to DFA accept states
            adding rule context to context-sensitive DFA accept states
            consuming an input symbol
            reporting a conflict
            reporting an ambiguity
            reporting a context sensitivity
            reporting insufficient predicates
            We should isolate those operations, which are side-effecting, to the
            main work loop. We can isolate lots of code into other functions, but
            they should be side effect free. They can return package that
            indicates whether we should report something, whether we need to add a
            DFA edge, whether we need to augment accept state with semantic
            context or rule invocation context. Actually, it seems like we always
            add predicates if they exist, so that can simply be done in the main
            loop for any accept state creation or modification request.
            cover these cases:
            dead end
            single alt
            single alt + preds
            conflict
            conflict + preds
            TODO: greedy + those
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>Get an existing target state for an edge in the DFA.</summary>
            <remarks>
            Get an existing target state for an edge in the DFA. If the target state
            for the edge has not yet been computed or is otherwise not available,
            this method returns
            <code>null</code>
            .
            </remarks>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The existing target DFA state for the given input symbol
            <code>t</code>
            , or
            <code>null</code>
            if the target state for this edge is not
            already cached
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </summary>
            <remarks>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </remarks>
            <param name="dfa"></param>
            <param name="s">The current DFA state</param>
            <param name="remainingGlobalContext"></param>
            <param name="t">The next input symbol</param>
            <param name="useContext"></param>
            <param name="contextCache"></param>
            <returns>
            The computed target DFA state for the given input symbol
            <code>t</code>
            . If
            <code>t</code>
            does not lead to a valid DFA state, this method
            returns
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error">ATNSimulator.Error</see>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.RemoveAllConfigsNotInRuleStopState(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            Return a configuration set containing only the configurations from
            <code>configs</code>
            which are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            . If all
            configurations in
            <code>configs</code>
            are already in a rule stop state, this
            method simply returns
            <code>configs</code>
            .
            </summary>
            <param name="configs">the configuration set to update</param>
            <param name="contextCache">
            the
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext">PredictionContext</see>
            cache
            </param>
            <returns>
            
            <code>configs</code>
            if all configurations in
            <code>configs</code>
            are in a
            rule stop state, otherwise return a new configuration set containing only
            the configurations from
            <code>configs</code>
            which are in a rule stop state
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.PredicateDFAState(Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            <summary>collect and set D's semantic context</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.DFAState.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)">
            <summary>
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win.
            </summary>
            <remarks>
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win. A
            <code>null</code>
            predicate indicates an alt containing an
            unpredicated config which behaves as "always true."
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAContextState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>See comment on LexerInterpreter.addDFAState.</summary>
            <remarks>See comment on LexerInterpreter.addDFAState.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>See comment on LexerInterpreter.addDFAState.</summary>
            <remarks>See comment on LexerInterpreter.addDFAState.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>If context sensitive parsing, we know it's ambiguity not conflict</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusBlockStartState">
            <summary>
            Start of
            <code>(A|B|...)+</code>
            loop. Technically a decision state, but
            we don't use for code generation; somebody might need it, so I'm defining
            it for completeness. In reality, the
            <see cref="T:Antlr4.Runtime.Atn.PlusLoopbackState">PlusLoopbackState</see>
            node is the
            real decision-making note for
            <code>A+</code>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusLoopbackState">
            <summary>
            Decision state for
            <code>A+</code>
            and
            <code>(A|B)+</code>
            .  It has two transitions:
            one to the loop back to start of the block and one to exit.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PrecedencePredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateTransition">
            <summary>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            </summary>
            <remarks>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            In the ATN, labels will always be exactly one predicate, but the DFA
            may have to combine a bunch of them as it collects predicates from
            multiple ATN configurations into a single DFA state.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionContextCache">
            <summary>
            Used to cache
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext">PredictionContext</see>
            objects. Its used for the shared
            context cash associated with contexts in DFA states. This cache
            can be used for both lexers and parsers.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.Sll">
            <summary>
            Do only local context prediction (SLL style) and using
            heuristic which almost always works but is much faster
            than precise answer.
            </summary>
            <remarks>
            Do only local context prediction (SLL style) and using
            heuristic which almost always works but is much faster
            than precise answer.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.Ll">
            <summary>Full LL(*) that always gets right answer.</summary>
            <remarks>
            Full LL(*) that always gets right answer. For speed
            reasons, we terminate the prediction process when we know for
            sure which alt to predict. We don't always know what
            the ambiguity is in this mode.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection">
            <summary>
            Tell the full LL prediction algorithm to pursue lookahead until
            it has uniquely predicted an alternative without conflict or it's
            certain that it's found an ambiguous input sequence.
            </summary>
            <remarks>
            Tell the full LL prediction algorithm to pursue lookahead until
            it has uniquely predicted an alternative without conflict or it's
            certain that it's found an ambiguous input sequence.  when this
            variable is false. When true, the prediction process will
            continue looking for the exact ambiguous sequence even if
            it has already figured out which alternative to predict.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasSLLConflictTerminatingPrediction(Antlr4.Runtime.Atn.PredictionMode,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>Computes the SLL prediction termination condition.</summary>
            <remarks>
            Computes the SLL prediction termination condition.
            <p/>
            This method computes the SLL prediction termination condition for both of
            the following cases.
            <ul>
            <li>The usual SLL+LL fallback upon SLL conflict</li>
            <li>Pure SLL without LL fallback</li>
            </ul>
            <p/>
            <strong>COMBINED SLL+LL PARSING</strong>
            <p/>
            When LL-fallback is enabled upon SLL conflict, correct predictions are
            ensured regardless of how the termination condition is computed by this
            method. Due to the substantially higher cost of LL prediction, the
            prediction should only fall back to LL when the additional lookahead
            cannot lead to a unique SLL prediction.
            <p/>
            Assuming combined SLL+LL parsing, an SLL configuration set with only
            conflicting subsets should fall back to full LL, even if the
            configuration sets don't resolve to the same alternative (e.g.
            <code></code>
            
            1,2}} and
            <code></code>
            
            3,4}}. If there is at least one non-conflicting
            configuration, SLL could continue with the hopes that more lookahead will
            resolve via one of those non-conflicting configurations.
            <p/>
            Here's the prediction termination rule them: SLL (for SLL+LL parsing)
            stops when it sees only conflicting configuration subsets. In contrast,
            full LL keeps going when there is uncertainty.
            <p/>
            <strong>HEURISTIC</strong>
            <p/>
            As a heuristic, we stop prediction when we see any conflicting subset
            unless we see a state that only has one alternative associated with it.
            The single-alt-state thing lets prediction continue upon rules like
            (otherwise, it would admit defeat too soon):
            <p/>
            <code>[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;</code>
            <p/>
            When the ATN simulation reaches the state before
            <code>';'</code>
            , it has a
            DFA state that looks like:
            <code>[12|1|[], 6|2|[], 12|2|[]]</code>
            . Naturally
            <code>12|1|[]</code>
            and
            <code>12|2|[]</code>
            conflict, but we cannot stop
            processing this node because alternative to has another way to continue,
            via
            <code>[6|2|[]]</code>
            .
            <p/>
            It also let's us continue for this rule:
            <p/>
            <code>[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;</code>
            <p/>
            After matching input A, we reach the stop state for rule A, state 1.
            State 8 is the state right before B. Clearly alternatives 1 and 2
            conflict and no amount of further lookahead will separate the two.
            However, alternative 3 will be able to continue and so we do not stop
            working on this state. In the previous example, we're concerned with
            states associated with the conflicting alternatives. Here alt 3 is not
            associated with the conflicting configs, but since we can continue
            looking for input reasonably, don't declare the state done.
            <p/>
            <strong>PURE SLL PARSING</strong>
            <p/>
            To handle pure SLL parsing, all we have to do is make sure that we
            combine stack contexts for configurations that differ only by semantic
            predicate. From there, we can do the usual SLL termination heuristic.
            <p/>
            <strong>PREDICATES IN SLL+LL PARSING</strong>
            <p/>
            SLL decisions don't evaluate predicates until after they reach DFA stop
            states because they need to create the DFA cache that works in all
            semantic situations. In contrast, full LL evaluates predicates collected
            during start state computation so it can ignore predicates thereafter.
            This means that SLL termination detection can totally ignore semantic
            predicates.
            <p/>
            Implementation-wise,
            <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet">ATNConfigSet</see>
            combines stack contexts but not
            semantic predicate contexts so we might see two configurations like the
            following.
            <p/>
            <code></code>
            (s, 1, x,
            ), (s, 1, x', {p})}
            <p/>
            Before testing these configurations against others, we have to merge
            <code>x</code>
            and
            <code>x'</code>
            (without modifying the existing configurations).
            For example, we test
            <code>(x+x')==x''</code>
            when looking for conflicts in
            the following configurations.
            <p/>
            <code></code>
            (s, 1, x,
            ), (s, 1, x', {p}), (s, 2, x'', {})}
            <p/>
            If the configuration set has predicates (as indicated by
            <see cref="P:Antlr4.Runtime.Atn.ATNConfigSet.HasSemanticContext">ATNConfigSet.HasSemanticContext()</see>
            ), this algorithm makes a copy of
            the configurations to strip out all of the predicates so that a standard
            <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet">ATNConfigSet</see>
            will merge everything ignoring predicates.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConfigInRuleStopState(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>
            Checks if any configuration in
            <code>configs</code>
            is in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            . Configurations meeting this condition have reached
            the end of the decision rule (local context) or end of start rule (full
            context).
            </summary>
            <param name="configs">the configuration set to test</param>
            <returns>
            
            <code>true</code>
            if any configuration in
            <code>configs</code>
            is in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            , otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllConfigsInRuleStopStates(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>
            Checks if all configurations in
            <code>configs</code>
            are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            . Configurations meeting this condition have reached
            the end of the decision rule (local context) or end of start rule (full
            context).
            </summary>
            <param name="configs">the configuration set to test</param>
            <returns>
            
            <code>true</code>
            if all configurations in
            <code>configs</code>
            are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState">RuleStopState</see>
            , otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.ResolvesToJustOneViableAlt(System.Collections.Generic.IEnumerable{Sharpen.BitSet})">
            <summary>Full LL prediction termination.</summary>
            <remarks>
            Full LL prediction termination.
            <p/>
            Can we stop looking ahead during ATN simulation or is there some
            uncertainty as to which alternative we will ultimately pick, after
            consuming more input? Even if there are partial conflicts, we might know
            that everything is going to resolve to the same minimum alternative. That
            means we can stop since no more lookahead will change that fact. On the
            other hand, there might be multiple conflicts that resolve to different
            minimums. That means we need more look ahead to decide which of those
            alternatives we should predict.
            <p/>
            The basic idea is to split the set of configurations
            <code>C</code>
            , into
            conflicting subsets
            <code>(s, _, ctx, _)</code>
            and singleton subsets with
            non-conflicting configurations. Two configurations conflict if they have
            identical
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.state">ATNConfig#state</see>
            and
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.context">ATNConfig#context</see>
            values
            but different
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">ATNConfig.Alt()</see>
            value, e.g.
            <code>(s, i, ctx, _)</code>
            and
            <code>(s, j, ctx, _)</code>
            for
            <code>i!=j</code>
            .
            <p/>
            Reduce these configuration subsets to the set of possible alternatives.
            You can compute the alternative subsets in one pass as follows:
            <p/>
            <code></code>
            A_s,ctx =
            i | (s, i, ctx, _)}} for each configuration in
            <code>C</code>
            holding
            <code>s</code>
            and
            <code>ctx</code>
            fixed.
            <p/>
            Or in pseudo-code, for each configuration
            <code>c</code>
            in
            <code>C</code>
            :
            <pre>
            map[c] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            <p/>
            The values in
            <code>map</code>
            are the set of
            <code>A_s,ctx</code>
            sets.
            <p/>
            If
            <code>|A_s,ctx|=1</code>
            then there is no conflict associated with
            <code>s</code>
            and
            <code>ctx</code>
            .
            <p/>
            Reduce the subsets to singletons by choosing a minimum of each subset. If
            the union of these alternative subsets is a singleton, then no amount of
            more lookahead will help us. We will always pick that alternative. If,
            however, there is more than one alternative, then we are uncertain which
            alternative to predict and must continue looking for resolution. We may
            or may not discover an ambiguity in the future, even if there are no
            conflicting subsets this round.
            <p/>
            The biggest sin is to terminate early because it means we've made a
            decision but were uncertain as to the eventual outcome. We haven't used
            enough lookahead. On the other hand, announcing a conflict too late is no
            big deal; you will still have the conflict. It's just inefficient. It
            might even look until the end of file.
            <p/>
            No special consideration for semantic predicates is required because
            predicates are evaluated on-the-fly for full LL prediction, ensuring that
            no configuration contains a semantic context during the termination
            check.
            <p/>
            <strong>CONFLICTING CONFIGS</strong>
            <p/>
            Two configurations
            <code>(s, i, x)</code>
            and
            <code>(s, j, x')</code>
            , conflict
            when
            <code>i!=j</code>
            but
            <code>x=x'</code>
            . Because we merge all
            <code>(s, i, _)</code>
            configurations together, that means that there are at
            most
            <code>n</code>
            configurations associated with state
            <code>s</code>
            for
            <code>n</code>
            possible alternatives in the decision. The merged stacks
            complicate the comparison of configuration contexts
            <code>x</code>
            and
            <code>x'</code>
            . Sam checks to see if one is a subset of the other by calling
            merge and checking to see if the merged result is either
            <code>x</code>
            or
            <code>x'</code>
            . If the
            <code>x</code>
            associated with lowest alternative
            <code>i</code>
            is the superset, then
            <code>i</code>
            is the only possible prediction since the
            others resolve to
            <code>min(i)</code>
            as well. However, if
            <code>x</code>
            is
            associated with
            <code>j&gt;i</code>
            then at least one stack configuration for
            <code>j</code>
            is not in conflict with alternative
            <code>i</code>
            . The algorithm
            should keep going, looking for more lookahead due to the uncertainty.
            <p/>
            For simplicity, I'm doing a equality check between
            <code>x</code>
            and
            <code>x'</code>
            that lets the algorithm continue to consume lookahead longer
            than necessary. The reason I like the equality is of course the
            simplicity but also because that is the test you need to detect the
            alternatives that are actually in conflict.
            <p/>
            <strong>CONTINUE/STOP RULE</strong>
            <p/>
            Continue if union of resolved alternative sets from non-conflicting and
            conflicting alternative subsets has more than one alternative. We are
            uncertain about which alternative to predict.
            <p/>
            The complete set of alternatives,
            <code>[i for (_,i,_)]</code>
            , tells us which
            alternatives are still in the running for the amount of input we've
            consumed at this point. The conflicting sets let us to strip away
            configurations that won't lead to more states because we resolve
            conflicts to the configuration with a minimum alternate for the
            conflicting set.
            <p/>
            <strong>CASES</strong>
            <ul>
            <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s, 3, z)</code>
            ,
            <code>(s', 1, y)</code>
            ,
            <code>(s', 2, y)</code>
            yields non-conflicting set
            <code></code>
            
            3}} U conflicting sets
            <code></code>
            min(
            1,2})} U
            <code></code>
            min(
            1,2})} =
            <code></code>
            
            1,3}} =&gt; continue
            </li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 1, y)</code>
            ,
            <code>(s', 2, y)</code>
            ,
            <code>(s'', 1, z)</code>
            yields non-conflicting set
            <code></code>
            
            1}} U conflicting sets
            <code></code>
            min(
            1,2})} U
            <code></code>
            min(
            1,2})} =
            <code></code>
            
            1}} =&gt; stop and predict 1</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 1, y)</code>
            ,
            <code>(s', 2, y)</code>
            yields conflicting, reduced sets
            <code></code>
            
            1}} U
            <code></code>
            
            1}} =
            <code></code>
            
            1}} =&gt; stop and predict 1, can announce
            ambiguity
            <code></code>
            
            1,2}}</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 2, y)</code>
            ,
            <code>(s', 3, y)</code>
            yields conflicting, reduced sets
            <code></code>
            
            1}} U
            <code></code>
            
            2}} =
            <code></code>
            
            1,2}} =&gt; continue</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 3, y)</code>
            ,
            <code>(s', 4, y)</code>
            yields conflicting, reduced sets
            <code></code>
            
            1}} U
            <code></code>
            
            3}} =
            <code></code>
            
            1,3}} =&gt; continue</li>
            </ul>
            <strong>EXACT AMBIGUITY DETECTION</strong>
            <p/>
            If all states report the same conflicting set of alternatives, then we
            know we have the exact ambiguity set.
            <p/>
            <code>|A_<em>i</em>|&gt;1</code> and
            <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.
            <p/>
            In other words, we continue examining lookahead until all
            <code>A_i</code>
            have more than one alternative and all
            <code>A_i</code>
            are the same. If
            <code></code>
            A=
            {1,2}, {1,3}}}, then regular LL prediction would terminate
            because the resolved set is
            <code></code>
            
            1}}. To determine what the real
            ambiguity is, we have to know whether the ambiguity is between one and
            two or one and three so we keep going. We can only stop prediction when
            we need exact ambiguity detection when the sets look like
            <code></code>
            A=
            {1,2}}} or
            <code></code>
            
            {1,2},{1,2}}}, etc...
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsConflict(System.Collections.Generic.IEnumerable{Sharpen.BitSet})">
            <summary>
            Determines if every alternative subset in
            <code>altsets</code>
            contains more
            than one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if every
            <see cref="T:Sharpen.BitSet">Sharpen.BitSet</see>
            in
            <code>altsets</code>
            has
            <see cref="M:Sharpen.BitSet.Cardinality">cardinality</see>
            &gt; 1, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasNonConflictingAltSet(System.Collections.Generic.IEnumerable{Sharpen.BitSet})">
            <summary>
            Determines if any single alternative subset in
            <code>altsets</code>
            contains
            exactly one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if
            <code>altsets</code>
            contains a
            <see cref="T:Sharpen.BitSet">Sharpen.BitSet</see>
            with
            <see cref="M:Sharpen.BitSet.Cardinality">cardinality</see>
            1, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConflictingAltSet(System.Collections.Generic.IEnumerable{Sharpen.BitSet})">
            <summary>
            Determines if any single alternative subset in
            <code>altsets</code>
            contains
            more than one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if
            <code>altsets</code>
            contains a
            <see cref="T:Sharpen.BitSet">Sharpen.BitSet</see>
            with
            <see cref="M:Sharpen.BitSet.Cardinality">cardinality</see>
            &gt; 1, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsEqual(System.Collections.Generic.IEnumerable{Sharpen.BitSet})">
            <summary>
            Determines if every alternative subset in
            <code>altsets</code>
            is equivalent.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if every member of
            <code>altsets</code>
            is equal to the
            others, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetUniqueAlt(System.Collections.Generic.IEnumerable{Sharpen.BitSet})">
            <summary>
            Returns the unique alternative predicted by all alternative subsets in
            <code>altsets</code>
            . If no such alternative exists, this method returns
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber">ATN.InvalidAltNumber</see>
            .
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetAlts(System.Collections.Generic.IEnumerable{Sharpen.BitSet})">
            <summary>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets.
            </summary>
            <remarks>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets. This method returns the union of each
            <see cref="T:Sharpen.BitSet">Sharpen.BitSet</see>
            in
            <code>altsets</code>
            .
            </remarks>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            the set of represented alternatives in
            <code>altsets</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetConflictingAltSubsets(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>This function gets the conflicting alt subsets from a configuration set.
                </summary>
            <remarks>
            This function gets the conflicting alt subsets from a configuration set.
            For each configuration
            <code>c</code>
            in
            <code>configs</code>
            :
            <pre>
            map[c] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetStateToAltMap(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>Get a map from state to alt subset from a configuration set.</summary>
            <remarks>
            Get a map from state to alt subset from a configuration set. For each
            configuration
            <code>c</code>
            in
            <code>configs</code>
            :
            <pre>
            map[c.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.state">state</see>
            ] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">getAlt()</see>
            </pre>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode.AltAndContextMap">
            <summary>A Map that uses just the state and the stack context as the key.</summary>
            <remarks>A Map that uses just the state and the stack context as the key.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AltAndContextConfigEqualityComparator.GetHashCode(Antlr4.Runtime.Atn.ATNConfig)">
            <summary>Code is function of (s, _, ctx, _)</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.RuleStopState">
            <summary>The last node in the ATN for a rule, unless that rule is the start symbol.
                </summary>
            <remarks>
            The last node in the ATN for a rule, unless that rule is the start symbol.
            In that case, there is one transition to EOF. Later, we might encode
            references to all calls to this rule to compute FOLLOW sets for
            error handling.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.ruleIndex">
            <summary>Ptr to the rule definition object for this rule ref</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.followState">
            <summary>What node to begin computations following ref to rule</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext">
            <summary>
            A tree structure used to record the semantic context in which
            an ATN configuration is valid.
            </summary>
            <remarks>
            A tree structure used to record the semantic context in which
            an ATN configuration is valid.  It's either a single predicate,
            a conjunction
            <code>p1&amp;&amp;p2</code>
            , or a sum of products
            <code>p1||p2</code>
            .
            <p/>
            I have scoped the
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.AND">AND</see>
            ,
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.OR">OR</see>
            , and
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.Predicate">Predicate</see>
            subclasses of
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext">SemanticContext</see>
            within the scope of this outer class.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>
            For context independent predicates, we evaluate them without a local
            context (i.e., null context).
            </summary>
            <remarks>
            For context independent predicates, we evaluate them without a local
            context (i.e., null context). That way, we can evaluate them without
            having to create proper rule-specific context during prediction (as
            opposed to the parser, which creates them naturally). In a practical
            sense, this avoids a cast exception from RuleContext to myruleContext.
            <p/>
            For context dependent predicates, we must pass in a local context so that
            references such as $arg evaluate properly as _localctx.arg. We only
            capture context dependent predicates in the context in which we begin
            prediction, so we passed in the outer context here in case of context
            dependent predicate evaluation.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.Or(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.Atn.SemanticContext)">
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetPredsForAmbigAlts(Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">ParserATNSimulator.GetPredsForAmbigAlts(Sharpen.BitSet, ATNConfigSet, int)</seealso>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SimulatorState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.StarBlockStartState">
            <summary>The block that begins a closure loop.</summary>
            <remarks>The block that begins a closure loop.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.TokensStartState">
            <summary>The Tokens rule start state linking to each lexer rule start state</summary>
        </member>
        <member name="T:Antlr4.Runtime.BailErrorStrategy">
            <summary>Bail out of parser at first syntax error.</summary>
            <remarks>
            Bail out of parser at first syntax error. Do this to use it:
            <p/>
            <code>myparser.setErrorHandler(new BailErrorStrategy());</code>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.DefaultErrorStrategy">
            <summary>
            This is the default error handling mechanism for ANTLR parsers
            and tree parsers.
            </summary>
            <remarks>
            This is the default error handling mechanism for ANTLR parsers
            and tree parsers.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorStrategy">
            <summary>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers.
            </summary>
            <remarks>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers. We distinguish between three
            different kinds of errors:
            <ul>
            <li>The parser could not figure out which path to take in the ATN (none of
            the available alternatives could possibly match)</li>
            <li>The current input does not match what we were looking for</li>
            <li>A predicate evaluated to false</li>
            </ul>
            Implementations of this interface report syntax errors by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">Parser.NotifyErrorListeners(string)
                </see>
            .
            <p/>
            TODO: what to do about lexers
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            Reset the error handler state for the specified
            <code>recognizer</code>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            This method is called when an unexpected symbol is encountered during an
            inline match operation, such as
            <see cref="M:Antlr4.Runtime.Parser.Match(System.Int32)">Parser.Match(int)</see>
            . If the error
            strategy successfully recovers from the match failure, this method
            returns the
            <see cref="T:Antlr4.Runtime.IToken">IToken</see>
            instance which should be treated as the
            successful result of the match.
            <p/>
            Note that the calling code will not report an error if this method
            returns successfully. The error strategy implementation is responsible
            for calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">Parser.NotifyErrorListeners(string)
                </see>
            as appropriate.
            </summary>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy was not able to
            recover from the unexpected input symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            This method is called to recover from exception
            <code>e</code>
            . This method is
            called after
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </see>
            by the default exception handler
            generated for a rule method.
            </summary>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </seealso>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to recover from</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy could not recover from
            the recognition exception
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            This method provides the error handler with an opportunity to handle
            syntactic or semantic errors in the input stream before they result in a
            <see cref="T:Antlr4.Runtime.RecognitionException">RecognitionException</see>
            .
            <p/>
            The generated code currently contains calls to
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)">Sync(Parser)</see>
            after
            entering the decision state of a closure block (
            <code>(...)*</code>
            or
            <code>(...)+</code>
            ).
            <p/>
            For an implementation based on Jim Idle's "magic sync" mechanism, see
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">DefaultErrorStrategy.Sync(Parser)</see>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">DefaultErrorStrategy.Sync(Parser)
                </seealso>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if an error is detected by the error
            strategy but cannot be automatically recovered at the current state in
            the parsing process
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary>
            Tests whether or not
            <code>recognizer</code>
            is in the process of recovering
            from an error. In error recovery mode,
            <see cref="M:Antlr4.Runtime.Parser.Consume">Parser.Consume()</see>
            adds
            symbols to the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)">ParserRuleContext.AddErrorNode(IToken)
                </see>
            instead of
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)">ParserRuleContext.AddChild(IToken)
                </see>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
            <returns>
            
            <code>true</code>
            if the parser is currently recovering from a parse
            error, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            This method is called by when the parser successfully matches an input
            symbol.
            </summary>
            <remarks>
            This method is called by when the parser successfully matches an input
            symbol.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Report any kind of
            <see cref="T:Antlr4.Runtime.RecognitionException">RecognitionException</see>
            . This method is called by
            the default exception handler generated for a rule method.
            </summary>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to report</param>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.errorRecoveryMode">
            <summary>
            This is true after we see an error and before having successfully
            matched a token.
            </summary>
            <remarks>
            This is true after we see an error and before having successfully
            matched a token. Prevents generation of more than one error message
            per error.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">InErrorRecoveryMode(Parser)</seealso>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.lastErrorIndex">
            <summary>The index into the input stream where the last error occurred.</summary>
            <remarks>
            The index into the input stream where the last error occurred.
            This is used to prevent infinite loops where an error is found
            but no token is consumed during recovery...another error is found,
            ad nauseum.  This is a failsafe mechanism to guarantee that at least
            one token/tree node is consumed for two errors.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)">EndErrorCondition(Parser)</see>
            to
            ensure that the handler is not in error recovery mode.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </summary>
            <remarks>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary><inheritDoc></inheritDoc></summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </summary>
            <remarks>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </remarks>
            <param name="recognizer"></param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)">EndErrorCondition(Parser)</see>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation returns immediately if the handler is already
            in error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">BeginErrorCondition(Parser)</see>
            and dispatches the reporting task based on the runtime type of
            <code>e</code>
            according to the following table.
            <ul>
            <li>
            <see cref="T:Antlr4.Runtime.NoViableAltException">NoViableAltException</see>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)">ReportNoViableAlternative(Parser, NoViableAltException)
                </see>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.InputMismatchException">InputMismatchException</see>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)">ReportInputMismatch(Parser, InputMismatchException)
                </see>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.FailedPredicateException">FailedPredicateException</see>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)">ReportFailedPredicate(Parser, FailedPredicateException)
                </see>
            </li>
            <li>All other types: calls
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">Parser.NotifyErrorListeners(string)
                </see>
            to report
            the exception</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation resynchronizes the parser by consuming tokens
            until we find one in the resynchronization set--loosely the set of tokens
            that can follow the current rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            The default implementation of
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)">IAntlrErrorStrategy.Sync(Parser)</see>
            makes sure
            that the current lookahead symbol is consistent with what were expecting
            at this point in the ATN. You can call this anytime but ANTLR only
            generates code to check before subrules/loops and each iteration.
            <p/>
            Implements Jim Idle's magic sync mechanism in closures and optional
            subrules. E.g.,
            <pre>
            a : sync ( stuff sync )* ;
            sync : {consume to what can follow sync} ;
            </pre>
            At the start of a sub rule upon error,
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">Sync(Parser)</see>
            performs single
            token deletion, if possible. If it can't do that, it bails on the current
            rule and uses the default error recovery, which consumes until the
            resynchronization set of the current rule.
            <p/>
            If the sub rule is optional (
            <code>(...)?</code>
            ,
            <code>(...)*</code>
            , or block
            with an empty alternative), then the expected set includes what follows
            the subrule.
            <p/>
            During loop iteration, it consumes until it sees a token that can start a
            sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
            stay in the loop as long as possible.
            <p/>
            <strong>ORIGINS</strong>
            <p/>
            Previous versions of ANTLR did a poor job of their recovery within loops.
            A single mismatch token or missing token would force the parser to bail
            out of the entire rules surrounding the loop. So, for rule
            <pre>
            classDef : 'class' ID '{' member* '}'
            </pre>
            input with an extra token between members would force the parser to
            consume until it found the next class definition rather than the next
            member definition of the current class.
            <p/>
            This functionality cost a little bit of effort because the parser has to
            compare token set at the start of the loop and at each iteration. If for
            some reason speed is suffering for you, you can turn off this
            functionality by simply overriding this method as a blank { }.
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </see>
            when the exception is a
            <see cref="T:Antlr4.Runtime.NoViableAltException">NoViableAltException</see>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </seealso>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </see>
            when the exception is an
            <see cref="T:Antlr4.Runtime.InputMismatchException">InputMismatchException</see>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </seealso>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </see>
            when the exception is a
            <see cref="T:Antlr4.Runtime.FailedPredicateException">FailedPredicateException</see>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">ReportError(Parser, RecognitionException)
                </seealso>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream. At the time this method is called, the
            erroneous symbol is current
            <code>LT(1)</code>
            symbol and has not yet been
            removed from the input stream. When this method returns,
            <code>recognizer</code>
            is in error recovery mode.
            <p/>
            This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)">SingleTokenDeletion(Parser)</see>
            identifies
            single-token deletion as a viable recovery strategy for a mismatched
            input error.
            <p/>
            The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">BeginErrorCondition(Parser)</see>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">Parser.NotifyErrorListeners(string)
                </see>
            .
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMissingToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream. At the time this
            method is called, the missing token has not yet been inserted. When this
            method returns,
            <code>recognizer</code>
            is in error recovery mode.
            <p/>
            This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)">SingleTokenInsertion(Parser)</see>
            identifies
            single-token insertion as a viable recovery strategy for a mismatched
            input error.
            <p/>
            The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">BeginErrorCondition(Parser)</see>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">Parser.NotifyErrorListeners(string)
                </see>
            .
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation attempts to recover from the mismatched input
            by using single token insertion and deletion as described below. If the
            recovery attempt fails, this method throws an
            <see cref="T:Antlr4.Runtime.InputMismatchException">InputMismatchException</see>
            .
            <p/>
            <strong>EXTRA TOKEN</strong> (single token deletion)
            <p/>
            <code>LA(1)</code>
            is not what we are looking for. If
            <code>LA(2)</code>
            has the
            right token, however, then assume
            <code>LA(1)</code>
            is some extra spurious
            token and delete it. Then consume and return the next token (which was
            the
            <code>LA(2)</code>
            token) as the successful result of the match operation.
            <p/>
            This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)">SingleTokenDeletion(Parser)</see>
            .
            <p/>
            <strong>MISSING TOKEN</strong> (single token insertion)
            <p/>
            If current token (at
            <code>LA(1)</code>
            ) is consistent with what could come
            after the expected
            <code>LA(1)</code>
            token, then assume the token is missing
            and use the parser's
            <see cref="T:Antlr4.Runtime.ITokenFactory">ITokenFactory</see>
            to create it on the fly. The
            "insertion" is performed by returning the created token as the successful
            result of the match operation.
            <p/>
            This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)">SingleTokenInsertion(Parser)</see>
            .
            <p/>
            <strong>EXAMPLE</strong>
            <p/>
            For example, Input
            <code>i=(3;</code>
            is clearly missing the
            <code>')'</code>
            . When
            the parser returns from the nested call to
            <code>expr</code>
            , it will have
            call chain:
            <pre>
            stat -&gt; expr -&gt; atom
            </pre>
            and it will be trying to match the
            <code>')'</code>
            at this point in the
            derivation:
            <pre>
            =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
            ^
            </pre>
            The attempt to match
            <code>')'</code>
            will fail when it sees
            <code>';'</code>
            and
            call
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">RecoverInline(Parser)</see>
            . To recover, it sees that
            <code>LA(1)==';'</code>
            is in the set of tokens that can follow the
            <code>')'</code>
            token reference
            in rule
            <code>atom</code>
            . It can assume that you forgot the
            <code>')'</code>
            .
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token insertion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token insertion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">RecoverInline(Parser)</see>
            if the single-token
            deletion strategy fails to recover from the mismatched input. If this
            method returns
            <code>true</code>
            ,
            <code>recognizer</code>
            will be in error recovery
            mode.
            <p/>
            This method determines whether or not single-token insertion is viable by
            checking if the
            <code>LA(1)</code>
            input symbol could be successfully matched
            if it were instead the
            <code>LA(2)</code>
            symbol. If this method returns
            <code>true</code>
            , the caller is responsible for creating and inserting a
            token with the correct type to produce this behavior.
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>
            
            <code>true</code>
            if single-token insertion is a viable recovery
            strategy for the current mismatched input, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token deletion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token deletion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">RecoverInline(Parser)</see>
            to attempt to recover
            from mismatched input. If this method returns null, the parser and error
            handler state will not have changed. If this method returns non-null,
            <code>recognizer</code>
            will <em>not</em> be in error recovery mode since the
            returned token was a successful match.
            <p/>
            If the single-token deletion is successful, this method calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)">ReportUnwantedToken(Parser)</see>
            to report the error, followed by
            <see cref="M:Antlr4.Runtime.Parser.Consume">Parser.Consume()</see>
            to actually "delete" the extraneous token. Then,
            before returning
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">ReportMatch(Parser)</see>
            is called to signal a successful
            match.
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>
            the successfully matched
            <see cref="T:Antlr4.Runtime.IToken">IToken</see>
            instance if single-token
            deletion successfully recovers from the mismatched input, otherwise
            <code>null</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetMissingSymbol(Antlr4.Runtime.Parser)">
            <summary>Conjure up a missing token during error recovery.</summary>
            <remarks>
            Conjure up a missing token during error recovery.
            The recognizer attempts to recover from single missing
            symbols. But, actions might refer to that missing symbol.
            For example, x=ID {f($x);}. The action clearly assumes
            that there has been an identifier matched previously and that
            $x points at that token. If that token is missing, but
            the next token in the stream is what we want we assume that
            this token is missing and we keep going. Because we
            have to return some token to replace the missing token,
            we have to conjure one up. This method gives the user control
            over the tokens returned for missing tokens. Mostly,
            you will want to create something special for identifier
            tokens. For literals such as '{' and ',', the default
            action in the parser or tree parser works. It simply creates
            a CommonToken of the appropriate type. The text will be the token.
            If you change what tokens must be created by the lexer,
            override this method to create the appropriate tokens.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ConsumeUntil(Antlr4.Runtime.Parser,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Consume tokens until one matches the given token set.</summary>
            <remarks>Consume tokens until one matches the given token set.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Instead of recovering from exception
            <code>e</code>
            , re-throw it wrapped
            in a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException">ParseCanceledException</see>
            so it is not caught by the
            rule function catches.  Use
            <see cref="P:System.Exception.InnerException">System.Exception.InnerException()</see>
            to get the
            original
            <see cref="T:Antlr4.Runtime.RecognitionException">RecognitionException</see>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </summary>
            <remarks>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </remarks>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>Make sure we don't attempt to recover from problems in subrules.</summary>
            <remarks>Make sure we don't attempt to recover from problems in subrules.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.BaseErrorListener">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.IParserErrorListener">
            <summary>How to emit recognition errors for parsers.</summary>
            <remarks>How to emit recognition errors for parsers.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorListener`1">
            <summary>How to emit recognition errors.</summary>
            <remarks>How to emit recognition errors.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>Upon syntax error, notify any interested parties.</summary>
            <remarks>
            Upon syntax error, notify any interested parties. This is not how to
            recover from errors or compute error messages.
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy">IAntlrErrorStrategy</see>
            specifies how to recover from syntax errors and how to compute error
            messages. This listener's job is simply to emit a computed message,
            though it has enough information to create its own message in many cases.
            <p/>
            The
            <see cref="T:Antlr4.Runtime.RecognitionException">RecognitionException</see>
            is non-null for all syntax errors except
            when we discover mismatched token errors that we can recover from
            in-line, without returning from the surrounding rule (via the single
            token insertion and deletion mechanism).
            </remarks>
            <param name="recognizer">
            What parser got the error. From this
            object, you can access the context as well
            as the input stream.
            </param>
            <param name="offendingSymbol">
            The offending token in the input token
            stream, unless recognizer is a lexer (then it's null). If
            no viable alternative error,
            <code>e</code>
            has token at which we
            started production for the decision.
            </param>
            <param name="line">The line number in the input where the error occurred.</param>
            <param name="charPositionInLine">The character position within that line where the error occurred.
                </param>
            <param name="msg">The message to emit.</param>
            <param name="e">
            The exception generated by the parser that led to
            the reporting of an error. It is null in the case where
            the parser was able to recover in line without exiting the
            surrounding rule.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            This method is called by the parser when a full-context prediction
            results in an ambiguity.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction
            results in an ambiguity.
            <p/>
            When
            <code>exact</code>
            is
            <code>true</code>
            , <em>all</em> of the alternatives in
            <code>ambigAlts</code>
            are viable, i.e. this is reporting an exact ambiguity.
            When
            <code>exact</code>
            is
            <code>false</code>
            , <em>at least two</em> of the
            alternatives in
            <code>ambigAlts</code>
            are viable for the current input, but
            the prediction algorithm terminated as soon as it determined that at
            least the <em>minimum</em> alternative in
            <code>ambigAlts</code>
            is viable.
            <p/>
            When the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection">Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection
                </see>
            prediction mode
            is used, the parser is required to identify exact ambiguities so
            <code>exact</code>
            will always be
            <code>true</code>
            .
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input input where the ambiguity is reported</param>
            <param name="exact">
            
            <code>true</code>
            if the ambiguity is exactly known, otherwise
            <code>false</code>
            . This is always
            <code>true</code>
            when
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection">Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection
                </see>
            is used.
            </param>
            <param name="ambigAlts">the potentially ambiguous alternatives</param>
            <param name="configs">
            the ATN configuration set where the ambiguity was
            determined
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAttemptingFullContext(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,Sharpen.BitSet,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            </summary>
            <remarks>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            <p/>
            If one or more configurations in
            <code>configs</code>
            contains a semantic
            predicate, the predicates are evaluated before this method is called. The
            subset of alternatives which are still viable after predicates are
            evaluated is reported in
            <code>conflictingAlts</code>
            .
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input index where the SLL conflict occurred</param>
            <param name="conflictingAlts">
            The specific conflicting alternatives. If this is
            <code>null</code>
            , the conflicting alternatives are all alternatives
            represented in
            <code>configs</code>
            .
            </param>
            <param name="conflictState">
            the simulator state when the SLL conflict was
            detected
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called by the parser when a full-context prediction has a
            unique result.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction has a
            unique result.
            <p/>
            For prediction implementations that only evaluate full-context
            predictions when an SLL conflict is found (including the default
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator">Antlr4.Runtime.Atn.ParserATNSimulator
                </see>
            implementation), this method reports cases
            where SLL conflicts were resolved to unique full-context predictions,
            i.e. the decision was context-sensitive. This report does not necessarily
            indicate a problem, and it may appear even in completely unambiguous
            grammars.
            <p/>
            <code>configs</code>
            may have more than one represented alternative if the
            full-context prediction algorithm does not evaluate predicates before
            beginning the full-context prediction. In all cases, the final prediction
            is passed as the
            <code>prediction</code>
            argument.
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">
            the input index where the context sensitivity was
            finally determined
            </param>
            <param name="prediction">the unambiguous result of the full-context prediction</param>
            <param name="acceptState">
            the simulator state when the unambiguous prediction
            was determined
            </param>
        </member>
        <member name="T:Antlr4.Runtime.BufferedTokenStream">
            <summary>Buffer all input tokens but do on-demand fetching of new tokens from lexer.
                </summary>
            <remarks>
            Buffer all input tokens but do on-demand fetching of new tokens from lexer.
            Useful when the parser or lexer has to set context/mode info before proper
            lexing of future tokens. The ST template parser needs this, for example,
            because it has to constantly flip back and forth between inside/output
            templates. E.g.,
            <code></code>
            &lt;names:
            hi, &lt;it&gt;}&gt;} has to parse names as part of an
            expression but
            <code>"hi, &lt;it&gt;"</code>
            as a nested template.
            <p/>
            You can't use this stream if you pass whitespace or other off-channel tokens
            to the parser. The stream can't ignore off-channel tokens.
            (
            <see cref="T:Antlr4.Runtime.UnbufferedTokenStream">UnbufferedTokenStream</see>
            is the same way.) Use
            <see cref="T:Antlr4.Runtime.CommonTokenStream">CommonTokenStream</see>
            .
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ITokenStream">
            <summary>
            An
            <see cref="T:Antlr4.Runtime.IIntStream">IIntStream</see>
            whose symbols are
            <see cref="T:Antlr4.Runtime.IToken">IToken</see>
            instances.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Lt(System.Int32)">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.IToken">IToken</see>
            instance associated with the value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">LA(k)</see>
            . This method has the same pre- and post-conditions as
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">IIntStream.La(int)</see>
            . In addition, when the preconditions of this method
            are met, the return value is non-null and the value of
            <code>LT(k).getType()==LA(k)</code>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">IIntStream.La(int)</seealso>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IToken">IToken</see>
            at the specified
            <code>index</code>
            in the stream. When
            the preconditions of this method are met, the return value is non-null.
            <p/>
            The preconditions for this method are the same as the preconditions of
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">IIntStream.Seek(int)</see>
            . If the behavior of
            <code>seek(index)</code>
            is
            unspecified for the current state and given
            <code>index</code>
            , then the
            behavior of this method is also unspecified.
            <p/>
            The symbol referred to by
            <code>index</code>
            differs from
            <code>seek()</code>
            only
            in the case of filtering streams where
            <code>index</code>
            lies before the end
            of the stream. Unlike
            <code>seek()</code>
            , this method does not adjust
            <code>index</code>
            to point to a non-ignored symbol.
            </summary>
            <exception cref="T:System.ArgumentException">if {code index} is less than 0</exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the token at the specified index
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text of all tokens within the specified
            <code>interval</code>
            . This
            method behaves like the following code (including potential exceptions
            for violating preconditions of
            <see cref="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)">Get(int)</see>
            , but may be optimized by the
            specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = interval.a; i &lt;= interval.b; i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="interval">
            The interval of tokens within this stream to get text
            for.
            </param>
            <returns>
            The text of all tokens within the specified interval in this
            stream.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <code>interval</code>
            is
            <code>null</code>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText">
            <summary>Return the text of all tokens in the stream.</summary>
            <remarks>
            Return the text of all tokens in the stream. This method behaves like the
            following code, including potential exceptions from the calls to
            <see cref="P:Antlr4.Runtime.IIntStream.Size">IIntStream.Size()</see>
            and
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)">GetText(Antlr4.Runtime.Misc.Interval)
                </see>
            , but may be
            optimized by the specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(new Interval(0, stream.size()));
            </pre>
            </remarks>
            <returns>The text of all tokens in the stream.</returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.RuleContext)">
            <summary>
            Return the text of all tokens in the source interval of the specified
            context.
            </summary>
            <remarks>
            Return the text of all tokens in the source interval of the specified
            context. This method behaves like the following code, including potential
            exceptions from the call to
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)">GetText(Antlr4.Runtime.Misc.Interval)
                </see>
            , but may be
            optimized by the specific implementation.
            <p/>
            If
            <code>ctx.getSourceInterval()</code>
            does not return a valid interval of
            tokens provided by this stream, the behavior is unspecified.
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(ctx.getSourceInterval());
            </pre>
            </remarks>
            <param name="ctx">
            The context providing the source interval of tokens to get
            text for.
            </param>
            <returns>
            The text of all tokens within the source interval of
            <code>ctx</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.IToken,Antlr4.Runtime.IToken)">
            <summary>
            Return the text of all tokens in this stream between
            <code>start</code>
            and
            <code>stop</code>
            (inclusive).
            <p/>
            If the specified
            <code>start</code>
            or
            <code>stop</code>
            token was not provided by
            this stream, or if the
            <code>stop</code>
            occurred before the
            <code>start</code>
            token, the behavior is unspecified.
            <p/>
            For streams which ensure that the
            <see cref="P:Antlr4.Runtime.IToken.TokenIndex">IToken.TokenIndex()</see>
            method is
            accurate for all of its provided tokens, this method behaves like the
            following code. Other streams may implement this method in other ways
            provided the behavior is consistent with this at a high level.
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = start.getTokenIndex(); i &lt;= stop.getTokenIndex(); i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="start">The first token in the interval to get text for.</param>
            <param name="stop">The last token in the interval to get text for (inclusive).</param>
            <returns>
            The text of all tokens lying between the specified
            <code>start</code>
            and
            <code>stop</code>
            tokens.
            </returns>
            <exception cref="T:System.NotSupportedException">
            if this stream does not support
            this method for the specified tokens
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ITokenStream.TokenSource">
            <summary>
            Gets the underlying
            <see cref="T:Antlr4.Runtime.ITokenSource">ITokenSource</see>
            which provides tokens for this
            stream.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.tokens">
            <summary>
            Record every single token pulled from the source so we can reproduce
            chunks of it later.
            </summary>
            <remarks>
            Record every single token pulled from the source so we can reproduce
            chunks of it later. This list captures everything so we can access
            complete input text.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.p">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens">tokens</see>
            of the current token (next token to
            consume).
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens">tokens</see>
            <code>[</code>
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p">p</see>
            <code>]</code>
            should be
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Lt(System.Int32)">LT(1)</see>
            .
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p">p</see>
            <code>=-1</code>
            indicates need to initialize
            with first token. The constructor doesn't get a token. First call to
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Lt(System.Int32)">LT(1)</see>
            or whatever gets the first token and sets
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p">p</see>
            <code>=0;</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF">
            <summary>
            Set to
            <code>true</code>
            when the EOF token is fetched. Do not continue fetching
            tokens after that point, or multiple EOF tokens could end up in the
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens">tokens</see>
            array.
            </summary>
            <seealso cref="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)">Fetch(int)</seealso>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure index
            <code>i</code>
            in tokens has a token.
            </summary>
            <returns>
            
            <code>true</code>
            if a token is located at index
            <code>i</code>
            , otherwise
            <code>false</code>
            .
            </returns>
            <seealso cref="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32)">Get(int)</seealso>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            <summary>
            Add
            <code>n</code>
            elements to buffer.
            </summary>
            <returns>The actual number of elements added to the buffer.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32,System.Int32)">
            <summary>Get all tokens from start..stop inclusively.</summary>
            <remarks>Get all tokens from start..stop inclusively.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.AdjustSeekIndex(System.Int32)">
            <summary>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation.
            </summary>
            <remarks>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation. The default implementation simply returns
            <code>i</code>
            . If an
            exception is thrown in this method, the current stream index should not be
            changed.
            <p/>
            For example,
            <see cref="T:Antlr4.Runtime.CommonTokenStream">CommonTokenStream</see>
            overrides this method to ensure that
            the seek target is always an on-channel token.
            </remarks>
            <param name="i">The target token index.</param>
            <returns>The adjusted target token index.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary>
            <remarks>Reset this token stream by setting its token source.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Sharpen.BitSet)">
            <summary>
            Given a start and stop index, return a
            <code>List</code>
            of all tokens in
            the token type
            <code>BitSet</code>
            .  Return
            <code>null</code>
            if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.NextTokenOnChannel(System.Int32,System.Int32)">
            <summary>Given a starting index, return the index of the next token on channel.</summary>
            <remarks>
            Given a starting index, return the index of the next token on channel.
            Return
            <code>i</code>
            if
            <code>tokens[i]</code>
            is on channel.  Return
            <code>-1</code>
            if there are no tokens
            on channel between
            <code>i</code>
            and EOF.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.PreviousTokenOnChannel(System.Int32,System.Int32)">
            <summary>Given a starting index, return the index of the previous token on channel.
                </summary>
            <remarks>
            Given a starting index, return the index of the previous token on channel.
            Return
            <code>i</code>
            if
            <code>tokens[i]</code>
            is on channel. Return
            <code>-1</code>
            if there are no tokens
            on channel between
            <code>i</code>
            and
            <code>0</code>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel">Lexer.DefaultTokenChannel</see>
            or
            EOF. If
            <code>channel</code>
            is
            <code>-1</code>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel">Lexer.DefaultTokenChannel</see>
            or EOF.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel">Lexer.DefaultTokenChannel</see>
            .
            If
            <code>channel</code>
            is
            <code>-1</code>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel">Lexer.DefaultTokenChannel</see>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetText">
            <summary>Get the text of all tokens in this buffer.</summary>
            <remarks>Get the text of all tokens in this buffer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fill">
            <summary>Get all tokens from lexer until EOF.</summary>
            <remarks>Get all tokens from lexer until EOF.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.IToken">
            <summary>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </summary>
            <remarks>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Text">
            <summary>Get the text of the token.</summary>
            <remarks>Get the text of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Type">
            <summary>Get the token type of the token.</summary>
            <remarks>Get the token type of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Line">
            <summary>
            The line number on which the 1st character of this token was matched,
            line=1..n
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Column">
            <summary>
            The index of the first character of this token relative to the
            beginning of the line at which it occurs, 0..n-1
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Channel">
            <summary>Return the channel this token.</summary>
            <remarks>
            Return the channel this token. Each token can arrive at the parser
            on a different channel, but the parser only "tunes" to a single channel.
            The parser ignores everything not on DEFAULT_CHANNEL.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenIndex">
            <summary>An index from 0..n-1 of the token object in the input stream.</summary>
            <remarks>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to print token streams and
            use TokenRewriteStream.
            Return -1 to indicate that this token was conjured up since
            it doesn't have a valid index.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StartIndex">
            <summary>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </summary>
            <remarks>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StopIndex">
            <summary>The last character index of the token.</summary>
            <remarks>
            The last character index of the token.
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenSource">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenSource">ITokenSource</see>
            which created this token.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.InputStream">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ICharStream">ICharStream</see>
            from which this token was derived.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.text">
            <summary>We need to be able to change the text once in a while.</summary>
            <remarks>
            We need to be able to change the text once in a while.  If
            this is non-null, then getText should return this.  Note that
            start/stop are not affected by changing this.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.index">
            <summary>What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index
                </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.start">
            <summary>The char position into the input buffer where this token starts</summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.stop">
            <summary>The char position into the input buffer where this token stops</summary>
        </member>
        <member name="P:Antlr4.Runtime.CommonToken.Text">
            <summary>Override the text for this token.</summary>
            <remarks>
            Override the text for this token.  getText() will return this text
            rather than pulling from the buffer.  Note that this does not mean
            that start/stop indexes are not valid.  It means that that input
            was converted to a new string in the token object.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ITokenFactory">
            <summary>The default mechanism for creating tokens.</summary>
            <remarks>
            The default mechanism for creating tokens. It's used by default in Lexer and
            the error handling strategy (to create missing tokens).  Notifying the parser
            of a new factory means that it notifies it's token source and error strategy.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Tuple{Antlr4.Runtime.ITokenSource,Antlr4.Runtime.ICharStream},System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This is the method used to create tokens in the lexer and in the
            error handling strategy.
            </summary>
            <remarks>
            This is the method used to create tokens in the lexer and in the
            error handling strategy. If text!=null, than the start and stop positions
            are wiped to -1 in the text override is set in the CommonToken.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Int32,System.String)">
            <summary>Generically useful</summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.copyText">
            <summary>Copy text for token out of input char stream.</summary>
            <remarks>
            Copy text for token out of input char stream. Useful when input
            stream is unbuffered.
            </remarks>
            <seealso cref="T:Antlr4.Runtime.UnbufferedCharStream">UnbufferedCharStream</seealso>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor(System.Boolean)">
            <summary>
            Create factory and indicate whether or not the factory copy
            text out of the char stream.
            </summary>
            <remarks>
            Create factory and indicate whether or not the factory copy
            text out of the char stream.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenStream">
            <summary>
            The most common stream of tokens where every token is buffered up
            and tokens are filtered for a certain channel (the parser will only
            see these tokens).
            </summary>
            <remarks>
            The most common stream of tokens where every token is buffered up
            and tokens are filtered for a certain channel (the parser will only
            see these tokens).
            Even though it buffers all of the tokens, this token stream pulls tokens
            from the tokens source on demand. In other words, until you ask for a
            token using consume(), LT(), etc. the stream does not pull from the lexer.
            The only difference between this stream and
            <see cref="T:Antlr4.Runtime.BufferedTokenStream">BufferedTokenStream</see>
            superclass
            is that this stream knows how to ignore off channel tokens. There may be
            a performance advantage to using the superclass if you don't pass
            whitespace and comments etc. to the parser on a hidden channel (i.e.,
            you set
            <code>$channel</code>
            instead of calling
            <code>skip()</code>
            in lexer rules.)
            </remarks>
            <seealso cref="T:Antlr4.Runtime.UnbufferedTokenStream">UnbufferedTokenStream</seealso>
            <seealso cref="T:Antlr4.Runtime.BufferedTokenStream">BufferedTokenStream</seealso>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenStream.channel">
            <summary>Skip tokens on any channel but this one; this is how we skip whitespace...
                </summary>
            <remarks>Skip tokens on any channel but this one; this is how we skip whitespace...
                </remarks>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.GetNumberOfOnChannelTokens">
            <summary>Count EOF just once.</summary>
            <remarks>Count EOF just once.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.ConsoleErrorListener`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dependents">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.IEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.ArrayEdgeMap`1">
            <author>sam</author>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.states">
            <summary>A set of all DFA states.</summary>
            <remarks>
            A set of all DFA states. Use
            <see cref="T:System.Collections.Generic.IDictionary`2">IDictionary&lt;TKey, TValue&gt;
                </see>
            so we can get old state back
            (
            <see cref="T:System.Collections.Generic.HashSet`1">HashSet&lt;T&gt;</see>
            only allows you to see if it's there).
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.atnStartState">
            <summary>From which ATN state did we create this DFA?</summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFASerializer">
            <summary>A DFA walker that knows how to dump them to serialized strings.</summary>
            <remarks>A DFA walker that knows how to dump them to serialized strings.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState">
            <summary>A DFA state represents a set of possible ATN configurations.</summary>
            <remarks>
            A DFA state represents a set of possible ATN configurations.
            As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
            to keep track of all possible states the ATN can be in after
            reading each input symbol.  That is to say, after reading
            input a1a2..an, the DFA is in a state that represents the
            subset T of the states of the ATN that are reachable from the
            ATN's start state along some path labeled a1a2..an."
            In conventional NFA-&gt;DFA conversion, therefore, the subset T
            would be a bitset representing the set of states the
            ATN could be in.  We need to track the alt predicted by each
            state as well, however.  More importantly, we need to maintain
            a stack of states, tracking the closure operations as they
            jump from rule to rule, emulating rule invocations (method calls).
            I have to add a stack to simulate the proper lookahead sequences for
            the underlying LL grammar from which the ATN was derived.
            <p/>
            I use a set of ATNConfig objects not simple states.  An ATNConfig
            is both a state (ala normal conversion) and a RuleContext describing
            the chain of rules (if any) followed to arrive at that state.
            <p/>
            A DFA state may have multiple references to a particular state,
            but with different ATN contexts (with same or different alts)
            meaning that state was reached via a different set of rule invocations.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.edges">
            <summary>
            <code>edges.get(symbol)</code>
            points to target of symbol.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.prediction">
            <summary>
            if accept state, what ttype do we match or alt do we predict?
            This is set to
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber">Antlr4.Runtime.Atn.ATN.InvalidAltNumber
                </see>
            when
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.predicates">predicates</see>
            <code>!=null</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.contextEdges">
            <summary>These keys for these edges are the top level element of the global context.
                </summary>
            <remarks>These keys for these edges are the top level element of the global context.
                </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.contextSymbols">
            <summary>Symbols in this set require a global context transition before matching an input symbol.
                </summary>
            <remarks>Symbols in this set require a global context transition before matching an input symbol.
                </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.predicates">
            <summary>
            This list is computed by
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.PredicateDFAState(Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">Antlr4.Runtime.Atn.ParserATNSimulator.PredicateDFAState(DFAState, Antlr4.Runtime.Atn.ATNConfigSet, int)
                </see>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFAState.Equals(System.Object)">
            <summary>
            Two
            <see cref="T:Antlr4.Runtime.Dfa.DFAState">DFAState</see>
            instances are equal if their ATN configuration sets
            are the same. This method is used to see if a state already exists.
            <p/>
            Because the number of alternatives and number of ATN configurations are
            finite, there is a finite number of DFA states that can be processed.
            This is necessary to show that the algorithm terminates.
            <p/>
            Cannot test the DFA state numbers here because in
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)">Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(DFA, Antlr4.Runtime.Atn.ATNConfigSet, Antlr4.Runtime.Atn.PredictionContextCache)
                </see>
            we need to know if any other state
            exists that has this exact set of ATN configurations. The
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.stateNumber">stateNumber</see>
            is irrelevant.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState.PredPrediction">
            <summary>Map a predicate to a predicted alternative.</summary>
            <remarks>Map a predicate to a predicted alternative.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SingletonEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SparseEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.DiagnosticErrorListener">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            can be used to identify
            certain potential correctness and performance problems in grammars. "Reports"
            are made by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">Parser.NotifyErrorListeners(string)
                </see>
            with the appropriate
            message.
            <ul>
            <li><b>Ambiguities</b>: These are cases where more than one path through the
            grammar can match the input.</li>
            <li><b>Weak context sensitivity</b>: These are cases where full-context
            prediction resolved an SLL conflict to a unique alternative which equaled the
            minimum alternative of the SLL conflict.</li>
            <li><b>Strong (forced) context sensitivity</b>: These are cases where the
            full-context prediction resolved an SLL conflict to a unique alternative,
            <em>and</em> the minimum alternative of the SLL conflict was found to not be
            a truly viable alternative. Two-stage parsing cannot be used for inputs where
            this situation occurs.</li>
            </ul>
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.DiagnosticErrorListener.exactOnly">
            <summary>
            When
            <code>true</code>
            , only exactly known ambiguities are reported.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener">DiagnosticErrorListener</see>
            which only
            reports exact ambiguities.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener">DiagnosticErrorListener</see>
            , specifying
            whether all ambiguities or only exact ambiguities are reported.
            </summary>
            <param name="exactOnly">
            
            <code>true</code>
            to report only exact ambiguities, otherwise
            <code>false</code>
            to report all ambiguities.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.GetConflictingAlts(Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </summary>
            <remarks>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </remarks>
            <param name="reportedAlts">
            The set of conflicting or ambiguous alternatives, as
            reported by the parser.
            </param>
            <param name="configs">The conflicting or ambiguous configuration set.</param>
            <returns>
            Returns
            <code>reportedAlts</code>
            if it is not
            <code>null</code>
            , otherwise
            returns the set of alternatives represented in
            <code>configs</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.FailedPredicateException">
            <summary>A semantic predicate failed during validation.</summary>
            <remarks>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we test a predicate during
            prediction.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            <remarks>
            The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
            3 kinds of errors: prediction errors, failed predicate errors, and
            mismatched input errors. In each case, the parser knows where it is
            in the input, where it is in the ATN, the rule invocation stack,
            and what kind of problem occurred.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.recognizer">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception originated.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.offendingToken">
            <summary>
            The current
            <see cref="T:Antlr4.Runtime.IToken">IToken</see>
            when an error occurred. Since not all streams
            support accessing symbols by index, we have to track the
            <see cref="T:Antlr4.Runtime.IToken">IToken</see>
            instance itself.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.RecognitionException.GetExpectedTokens">
            <summary>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            </summary>
            <remarks>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            <p/>
            If the set of expected tokens is not known and could not be computed,
            this method returns
            <code>null</code>
            .
            </remarks>
            <returns>
            The set of token types that could potentially follow the current
            state in the ATN, or
            <code>null</code>
            if the information is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.OffendingState">
            <summary>
            Get the ATN state number the parser was in at the time the error
            occurred.
            </summary>
            <remarks>
            Get the ATN state number the parser was in at the time the error
            occurred. For
            <see cref="T:Antlr4.Runtime.NoViableAltException">NoViableAltException</see>
            and
            <see cref="T:Antlr4.Runtime.LexerNoViableAltException">LexerNoViableAltException</see>
            exceptions, this is the
            <see cref="T:Antlr4.Runtime.Atn.DecisionState">Antlr4.Runtime.Atn.DecisionState</see>
            number. For others, it is the state whose outgoing
            edge we couldn't match.
            <p/>
            If the state number is not known, this method returns -1.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Context">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.RuleContext">RuleContext</see>
            at the time this exception was thrown.
            <p/>
            If the context is not available, this method returns
            <code>null</code>
            .
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.RuleContext">RuleContext</see>
            at the time this exception was thrown.
            If the context is not available, this method returns
            <code>null</code>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.InputStream">
            <summary>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            </summary>
            <remarks>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            <p/>
            If the input stream is not available, this method returns
            <code>null</code>
            .
            </remarks>
            <returns>
            The input stream which is the symbol source for the recognizer
            where this exception was thrown, or
            <code>null</code>
            if the stream is not
            available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Recognizer">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception occurred.
            <p/>
            If the recognizer is not available, this method returns
            <code>null</code>
            .
            </summary>
            <returns>
            The recognizer where this exception occurred, or
            <code>null</code>
            if
            the recognizer is not available.
            </returns>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.Eof">
            <summary>
            The value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">LA()</see>
            when the end of the stream is
            reached.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName">
            <summary>
            The value returned by
            <see cref="P:Antlr4.Runtime.IIntStream.SourceName">SourceName()</see>
            when the actual name of the
            underlying source is not known.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.InputMismatchException">
            <summary>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </summary>
            <remarks>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.Epsilon">
            <summary>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </summary>
            <remarks>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.DefaultChannel">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".
            </summary>
            <remarks>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.HiddenChannel">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
            <remarks>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ITokenSource">
            <summary>
            A source of tokens must provide a sequence of tokens via nextToken()
            and also must reveal it's source of characters; CommonToken's text is
            computed from a CharStream; it only store indices into the char stream.
            </summary>
            <remarks>
            A source of tokens must provide a sequence of tokens via nextToken()
            and also must reveal it's source of characters; CommonToken's text is
            computed from a CharStream; it only store indices into the char stream.
            Errors from the lexer are never passed to the parser.  Either you want
            to keep going or you do not upon token recognition error.  If you do not
            want to continue lexing then you do not want to continue parsing.  Just
            throw an exception not under RecognitionException and Java will naturally
            toss you all the way out of the recognizers.  If you want to continue
            lexing then you should not throw an exception to the parser--it has already
            requested a token.  Keep lexing until you get a valid one.  Just report
            errors and keep going, looking for a valid token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenSource.NextToken">
            <summary>Return a Token object from your input stream (usually a CharStream).</summary>
            <remarks>
            Return a Token object from your input stream (usually a CharStream).
            Do not fail/return upon lexing error; keep chewing on the characters
            until you get a good one; errors are not passed through to the parser.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.InputStream">
            <summary>
            From what character stream was this token created?  You don't have to
            implement but it's nice to know where a Token comes from if you have
            include files etc...
            </summary>
            <remarks>
            From what character stream was this token created?  You don't have to
            implement but it's nice to know where a Token comes from if you have
            include files etc... on the input.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.SourceName">
            <summary>
            Where are you getting tokens from? normally the implication will simply
            ask lexers input stream.
            </summary>
            <remarks>
            Where are you getting tokens from? normally the implication will simply
            ask lexers input stream.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.TokenFactory">
            <summary>Gets the factory used for constructing tokens.</summary>
            <remarks>Gets the factory used for constructing tokens.</remarks>
            <summary>Optional method that lets users set factory in lexer or other source</summary>
        </member>
        <member name="T:Antlr4.Runtime.Lexer">
            <summary>A lexer is recognizer that draws input symbols from a character stream.</summary>
            <remarks>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetErrorHeader(Antlr4.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.AddErrorListener(Antlr4.Runtime.IAntlrErrorListener{`0})">
            <exception cref="T:System.ArgumentNullException">
            if
            <code>listener</code>
            is
            <code>null</code>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.
            </summary>
            <remarks>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.GrammarFileName">
            <summary>For debugging and other purposes, might want the grammar name.</summary>
            <remarks>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.State">
            <summary>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.
            </summary>
            <remarks>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.  This way we always know
            where we are in the ATN as the parser goes along. The rule
            context objects form a stack that lets us see the stack of
            invoking rules. Combine this and we have complete ATN
            configuration information.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._factory">
            <summary>How to create token objects</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._token">
            <summary>The goal of all lexer rules/methods is to create a token object.</summary>
            <remarks>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.
            </summary>
            <remarks>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartLine">
            <summary>The line on which the first character of the token resides</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartCharPositionInLine">
            <summary>The character position of first character within the line</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._hitEOF">
            <summary>Once we see EOF on char stream, next token will be EOF.</summary>
            <remarks>
            Once we see EOF on char stream, next token will be EOF.
            If you have DONE : EOF ; then you see DONE EOF.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._channel">
            <summary>The channel number for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._type">
            <summary>The token type for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.
            </summary>
            <remarks>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.NextToken">
            <summary>
            Return a token from this source; i.e., match a token on the char
            stream.
            </summary>
            <remarks>
            Return a token from this source; i.e., match a token on the char
            stream.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.
            </summary>
            <remarks>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.SetInputStream(Antlr4.Runtime.ICharStream)">
            <summary>Set the char stream and reset the lexer</summary>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit(Antlr4.Runtime.IToken)">
            <summary>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.
            </summary>
            <remarks>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method, nextToken,
            and getToken (to push tokens into a list and pull from that list
            rather than a single variable as this implementation does).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit">
            <summary>
            The standard method called to automatically emit a token at the
            outermost lexical rule.
            </summary>
            <remarks>
            The standard method called to automatically emit a token at the
            outermost lexical rule.  The token object should point into the
            char buffer start..stop.  If there is a text override in 'text',
            use that to set the token's text.  Override this method to emit
            custom Token objects or provide a new factory.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.GetAllTokens">
            <summary>Return a list of all Token objects in input char stream.</summary>
            <remarks>
            Return a list of all Token objects in input char stream.
            Forces load of all tokens. Does not include EOF token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Recover(Antlr4.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.
            </summary>
            <remarks>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Text">
            <summary>
            Return the text matched so far for the current token or any text
            override.
            </summary>
            <remarks>
            Return the text matched so far for the current token or any text
            override.
            </remarks>
            <summary>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </summary>
            <remarks>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Token">
            <summary>Override if emitting multiple tokens.</summary>
            <remarks>Override if emitting multiple tokens.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.
            </summary>
            <remarks>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.startIndex">
            <summary>Matching attempted at what input index?</summary>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LA(1)?
                </summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Args">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Args.NotNull(System.String,System.Object)">
            <exception cref="T:System.ArgumentNullException">
            if
            <code>value</code>
            is
            <code>null</code>
            .
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Misc.MurmurHash">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">
            <summary>Initialize the hash using the default seed value.</summary>
            <remarks>Initialize the hash using the default seed value.</remarks>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize(System.Int32)">
            <summary>
            Initialize the hash using the specified
            <code>seed</code>
            .
            </summary>
            <param name="seed">the seed</param>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">
            <summary>
            Update the intermediate hash value for the next input
            <code>value</code>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Object)">
            <summary>
            Update the intermediate hash value for the next input
            <code>value</code>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">
            <summary>
            Apply the final computation steps to the intermediate value
            <code>hash</code>
            to form the final result of the MurmurHash 3 hash function.
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="numberOfWords">the number of integer values added to the hash</param>
            <returns>the final hash result</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.HashCode``1(``0[],System.Int32)">
            <summary>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </summary>
            <remarks>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </remarks>
            <param name="data">the array data</param>
            <param name="seed">the seed for the MurmurHash algorithm</param>
            <returns>the hash code of the data</returns>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IIntSet">
            <summary>A generic set of ints.</summary>
            <remarks>A generic set of ints.</remarks>
            <seealso cref="T:Antlr4.Runtime.Misc.IntervalSet">IntervalSet</seealso>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Add(System.Int32)">
            <summary>Add an element to the set</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)">
            <summary>Add all elements from incoming set to this set.</summary>
            <remarks>
            Add all elements from incoming set to this set.  Can limit
            to set of its own type. Return "this" so we can chain calls.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return the intersection of this set with the argument, creating
            a new set.
            </summary>
            <remarks>
            Return the intersection of this set with the argument, creating
            a new set.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Size">
            <summary>
            Return the size of this set (not the underlying implementation's
            allocated memory size, for example).
            </summary>
            <remarks>
            Return the size of this set (not the underlying implementation's
            allocated memory size, for example).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Remove(System.Int32)">
            <summary>remove this element from this set</summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Interval">
            <summary>An immutable inclusive interval a..b.</summary>
            <remarks>An immutable inclusive interval a..b.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.a">
            <summary>The start of the interval.</summary>
            <remarks>The start of the interval.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.b">
            <summary>The end of the interval (inclusive).</summary>
            <remarks>The end of the interval (inclusive).</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Of(System.Int32,System.Int32)">
            <summary>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.
            </summary>
            <remarks>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.  Use an array as a perfect hash.
            Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
            Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
            have a..a (set with 1 element).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely before other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start at or before other? Nondisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfter(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this.a start after other.b? May or may not be disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely after other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start after other? NonDisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Disjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Are both ranges disjoint? I.e., no overlap?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Adjacent(Antlr4.Runtime.Misc.Interval)">
            <summary>Are two intervals adjacent such as 0..41 and 42..42?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Union(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval computed from combining this and other</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Intersection(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval in common between this and o</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.DifferenceNotProperlyContained(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the interval with elements from
            <code>this</code>
            not in
            <code>other</code>
            ;
            <code>other</code>
            must not be totally enclosed (properly contained)
            within
            <code>this</code>
            , which would result in two disjoint intervals
            instead of the single one returned by this method.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.Interval.Length">
            <summary>return number of elements between a and b inclusively.</summary>
            <remarks>
            return number of elements between a and b inclusively. x..x is length 1.
            if b &lt; a, then length is 0. 9..10 has length 2.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IntervalSet">
            <summary>
            A set of integers that relies on ranges being common to do
            "run-length-encoded" like compression (if you view an IntSet like
            a BitSet with runs of 0s and 1s).
            </summary>
            <remarks>
            A set of integers that relies on ranges being common to do
            "run-length-encoded" like compression (if you view an IntSet like
            a BitSet with runs of 0s and 1s).  Only ranges are recorded so that
            a few ints up near value 1000 don't cause massive bitsets, just two
            integer intervals.
            element values may be negative.  Useful for sets of EPSILON and EOF.
            0..9 char range is index pair ['\u0030','\u0039'].
            Multiple ranges are encoded with multiple index pairs.  Isolated
            elements are encoded with an index pair where both intervals are the same.
            The ranges are ordered and disjoint so that 2..6 appears before 101..103.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.IntervalSet.intervals">
            <summary>The list of sorted, disjoint intervals.</summary>
            <remarks>The list of sorted, disjoint intervals.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32)">
            <summary>Create a set with a single element, el.</summary>
            <remarks>Create a set with a single element, el.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32,System.Int32)">
            <summary>Create a set with all ints within range [a..b] (inclusive)</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32)">
            <summary>Add a single element to the set.</summary>
            <remarks>
            Add a single element to the set.  An isolated element is stored
            as a range el..el.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32,System.Int32)">
            <summary>Add interval; i.e., add all integers from a to b to set.</summary>
            <remarks>
            Add interval; i.e., add all integers from a to b to set.
            If b&lt;a, do nothing.
            Keep list in sorted order (by left range value).
            If overlap, combine ranges.  For example,
            If this is {1..5, 10..20}, adding 6..7 yields
            {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Or(Antlr4.Runtime.Misc.IntervalSet[])">
            <summary>combine all sets in the array returned the or'd value</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Given the set of possible values (rather than, say UNICODE or MAXINT),
            return a new set containing all elements in vocabulary, but not in
            this.
            </summary>
            <remarks>
            Given the set of possible values (rather than, say UNICODE or MAXINT),
            return a new set containing all elements in vocabulary, but not in
            this.  The computation is (vocabulary - this).
            'this' is assumed to be either a subset or equal to vocabulary.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Subtract(Antlr4.Runtime.Misc.IIntSet)">
            <summary>Compute this-other via this&amp;~other.</summary>
            <remarks>
            Compute this-other via this&amp;~other.
            Return a new set containing all elements in this but not in other.
            other is assumed to be a subset of this;
            anything that is in other but not in this will be ignored.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>Return a new set with the intersection of this set with other.</summary>
            <remarks>
            Return a new set with the intersection of this set with other.  Because
            the intervals are sorted, we can use an iterator for each list and
            just walk them together.  This is roughly O(min(n,m)) for interval
            list lengths n and m.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Contains(System.Int32)">
            <summary>Is el in any range of this set?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.IsNil">
            <summary>return true if this set has no members</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.GetSingleElement">
            <summary>If this set is a single integer, return it otherwise Token.INVALID_TYPE</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.GetMinElement">
            <summary>Return minimum element &gt;= 0</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.GetIntervals">
            <summary>Return a list of Interval objects.</summary>
            <remarks>Return a list of Interval objects.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Equals(System.Object)">
            <summary>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.
            </summary>
            <remarks>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.  Interval.equals() is used
            by the List.equals() method to check the ranges.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Misc.ParseCanceledException">
            <summary>This exception is thrown to cancel a parsing operation.</summary>
            <remarks>
            This exception is thrown to cancel a parsing operation. This exception does
            not extend
            <see cref="T:Antlr4.Runtime.RecognitionException">Antlr4.Runtime.RecognitionException
                </see>
            , allowing it to bypass the standard
            error recovery mechanisms.
            <see cref="T:Antlr4.Runtime.BailErrorStrategy">Antlr4.Runtime.BailErrorStrategy</see>
            throws this exception in
            response to a parse error.
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Misc.RuleDependencyChecker">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.NoViableAltException">
            <summary>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input.
            </summary>
            <remarks>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input. It tracks the starting token
            of the offending input and also knows where the parser was
            in the various paths when the error. Reported by reportNoViableAlternative()
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LT(1)?
                </summary>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.startToken">
            <summary>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it.
            </summary>
            <remarks>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it. (At the
            time the error occurred, of course the stream needs to keep a
            buffer all of the tokens but later we might not have access to those.)
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Parser">
            <summary>This is all the parsing support code essentially; most of it is error recovery stuff.
                </summary>
            <remarks>This is all the parsing support code essentially; most of it is error recovery stuff.
                </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Parser._errHandler">
            <summary>The error handling strategy for the parser.</summary>
            <remarks>
            The error handling strategy for the parser. The default value is a new
            instance of
            <see cref="T:Antlr4.Runtime.DefaultErrorStrategy">DefaultErrorStrategy</see>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._input">
            <summary>The input stream.</summary>
            <remarks>The input stream.</remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.InputStream">InputStream()</seealso>
            <seealso cref="M:Antlr4.Runtime.Parser.SetInputStream(Antlr4.Runtime.ITokenStream)">SetInputStream(ITokenStream)</seealso>
        </member>
        <member name="F:Antlr4.Runtime.Parser._ctx">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ParserRuleContext">ParserRuleContext</see>
            object for the currently executing rule.
            This is always non-null during the parsing process.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._buildParseTrees">
            <summary>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process.
            </summary>
            <remarks>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process. The default value is
            <code>true</code>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._tracer">
            <summary>
            When
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <code>(true)</code>
            is called, a reference to the
            <see cref="T:Antlr4.Runtime.Parser.TraceListener">TraceListener</see>
            is stored here so it can be easily removed in a
            later call to
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <code>(false)</code>
            . The listener itself is
            implemented as a parser listener so this field is not directly used by
            other parser methods.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._parseListeners">
            <summary>
            The list of
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeListener">Antlr4.Runtime.Tree.IParseTreeListener
                </see>
            listeners registered to receive
            events during the parse.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)
                </seealso>
        </member>
        <member name="F:Antlr4.Runtime.Parser._syntaxErrors">
            <summary>The number of syntax errors reported during parsing.</summary>
            <remarks>
            The number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">NotifyErrorListeners(string)</see>
            is called.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Reset">
            <summary>reset the parser's state</summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Match(System.Int32)">
            <summary>
            Match current input symbol against
            <code>ttype</code>
            . If the symbol type
            matches,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">IAntlrErrorStrategy.ReportMatch(Parser)
                </see>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume">Consume()</see>
            are
            called to complete the match process.
            <p/>
            If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">IAntlrErrorStrategy.RecoverInline(Parser)
                </see>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree">BuildParseTree()</see>
            is
            <code>true</code>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">IAntlrErrorStrategy.RecoverInline(Parser)
                </see>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)">ParserRuleContext.AddErrorNode(IToken)
                </see>
            .
            </summary>
            <param name="ttype">the token type to match</param>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            <code>ttype</code>
            and the error strategy could not recover from the
            mismatched symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.MatchWildcard">
            <summary>Match current input symbol as a wildcard.</summary>
            <remarks>
            Match current input symbol as a wildcard. If the symbol type matches
            (i.e. has a value greater than 0),
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">IAntlrErrorStrategy.ReportMatch(Parser)
                </see>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume">Consume()</see>
            are called to complete the match process.
            <p/>
            If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">IAntlrErrorStrategy.RecoverInline(Parser)
                </see>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree">BuildParseTree()</see>
            is
            <code>true</code>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">IAntlrErrorStrategy.RecoverInline(Parser)
                </see>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)">ParserRuleContext.AddErrorNode(IToken)
                </see>
            .
            </remarks>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            a wildcard and the error strategy could not recover from the mismatched
            symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Registers
            <code>listener</code>
            to receive events during the parsing process.
            <p/>
            To support output-preserving grammar transformations (including but not
            limited to left-recursion removal, automated left-factoring, and
            optimized code generation), calls to listener methods during the parse
            may differ substantially from calls made by
            <see cref="F:Antlr4.Runtime.Tree.ParseTreeWalker.Default">Antlr4.Runtime.Tree.ParseTreeWalker.Default
                </see>
            used after the parse is complete. In
            particular, rule entry and exit events may occur in a different order
            during the parse than after the parser. In addition, calls to certain
            rule entry methods may be omitted.
            <p/>
            With the following specific exceptions, calls to listener events are
            <em>deterministic</em>, i.e. for identical input the calls to listener
            methods will be the same.
            <ul>
            <li>Alterations to the grammar used to generate code may change the
            behavior of the listener calls.</li>
            <li>Alterations to the command line options passed to ANTLR 4 when
            generating the parser may change the behavior of the listener calls.</li>
            <li>Changing the version of the ANTLR Tool used to generate the parser
            may change the behavior of the listener calls.</li>
            </ul>
            </summary>
            <param name="listener">the listener to add</param>
            <exception cref="T:System.ArgumentNullException">
            if
            <code></code>
            listener is
            <code>null</code>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Remove
            <code>listener</code>
            from the list of parse listeners.
            <p/>
            If
            <code>listener</code>
            is
            <code>null</code>
            or has not been added as a parse
            listener, this method does nothing.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)
                </seealso>
            <param name="listener">the listener to remove</param>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListeners">
            <summary>Remove all parse listeners.</summary>
            <remarks>Remove all parse listeners.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)
                </seealso>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerEnterRuleEvent">
            <summary>Notify any parse listeners of an enter rule event.</summary>
            <remarks>Notify any parse listeners of an enter rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)
                </seealso>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerExitRuleEvent">
            <summary>Notify any parse listeners of an exit rule event.</summary>
            <remarks>Notify any parse listeners of an exit rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)
                </seealso>
        </member>
        <member name="M:Antlr4.Runtime.Parser.SetInputStream(Antlr4.Runtime.ITokenStream)">
            <summary>Set the token stream and reset the parser.</summary>
            <remarks>Set the token stream and reset the parser.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Consume">
            <summary>
            Consume and return the
            <linkplain>
            #getCurrentToken
            current symbol
            </linkplain>
            .
            <p/>
            E.g., given the following input with
            <code>A</code>
            being the current
            lookahead symbol, this function moves the cursor to
            <code>B</code>
            and returns
            <code>A</code>
            .
            <pre>
            A B
            ^
            </pre>
            If the parser is not in error recovery mode, the consumed symbol is added
            to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)">ParserRuleContext.AddChild(IToken)
                </see>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">Antlr4.Runtime.Tree.IParseTreeListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)
                </see>
            is called on any parse listeners.
            If the parser <em>is</em> in error recovery mode, the consumed symbol is
            added to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)">ParserRuleContext.AddErrorNode(IToken)
                </see>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">Antlr4.Runtime.Tree.IParseTreeListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)
                </see>
            is called on any parse
            listeners.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>Always called by generated parsers upon entry to a rule.</summary>
            <remarks>
            Always called by generated parsers upon entry to a rule. Access field
            <see cref="F:Antlr4.Runtime.Parser._ctx">_ctx</see>
            get the current context.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.PushNewRecursionContext(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Like
            <see cref="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">EnterRule(ParserRuleContext, int, int)
                </see>
            but for recursive rules.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.IsExpectedToken(System.Int32)">
            <summary>
            Checks whether or not
            <code>symbol</code>
            can follow the current state in the
            ATN. The behavior of this method is equivalent to the following, but is
            implemented such that the complete context-sensitive follow set does not
            need to be explicitly constructed.
            <pre>
            return getExpectedTokens().contains(symbol);
            </pre>
            </summary>
            <param name="symbol">the symbol type to check</param>
            <returns>
            
            <code>true</code>
            if
            <code>symbol</code>
            can follow the current state in
            the ATN, otherwise
            <code>false</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetExpectedTokens">
            <summary>
            Computes the set of input symbols which could follow the current parser
            state and context, as given by
            <see cref="P:Antlr4.Runtime.Recognizer`2.State">Recognizer&lt;Symbol, ATNInterpreter&gt;.State()
                </see>
            and
            <see cref="P:Antlr4.Runtime.Parser.Context">Context()</see>
            ,
            respectively.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)">Antlr4.Runtime.Atn.ATN.GetExpectedTokens(int, RuleContext)
                </seealso>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleInvocationStack">
            <summary>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.
            </summary>
            <remarks>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.  You could override if
            you want more details such as the file/line info of where
            in the ATN a rule is invoked.
            This is very useful for error messages.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetDFAStrings">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.DumpDFA">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.BuildParseTree">
            <summary>
            Track the
            <see cref="T:Antlr4.Runtime.ParserRuleContext">ParserRuleContext</see>
            objects during the parse and hook
            them up using the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children">ParserRuleContext.children</see>
            list so that it
            forms a parse tree. The
            <see cref="T:Antlr4.Runtime.ParserRuleContext">ParserRuleContext</see>
            returned from the start
            rule represents the root of the parse tree.
            <p/>
            Note that if we are not building parse trees, rule contexts only point
            upwards. When a rule exits, it returns the context but that gets garbage
            collected if nobody holds a reference. It points upwards but nobody
            points at it.
            <p/>
            When we build parse trees, we are adding all of these contexts to
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children">ParserRuleContext.children</see>
            list. Contexts are then not candidates
            for garbage collection.
            </summary>
            <summary>
            Gets whether or not a complete parse tree will be constructed while
            parsing.
            </summary>
            <remarks>
            Gets whether or not a complete parse tree will be constructed while
            parsing. This property is
            <code>true</code>
            for a newly constructed parser.
            </remarks>
            <returns>
            
            <code>true</code>
            if a complete parse tree will be constructed while
            parsing, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.TrimParseTree">
            <summary>Trim the internal lists of the parse tree during parsing to conserve memory.
                </summary>
            <remarks>
            Trim the internal lists of the parse tree during parsing to conserve memory.
            This property is set to
            <code>false</code>
            by default for a newly constructed parser.
            </remarks>
            <value>
            
            <code>true</code>
            to trim the capacity of the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children">ParserRuleContext.children</see>
            list to its size after a rule is parsed.
            </value>
            <returns>
            
            <code>true</code>
            if the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children">ParserRuleContext.children</see>
            list is trimmed
            using the default
            <see cref="T:Antlr4.Runtime.Parser.TrimToSizeListener">TrimToSizeListener</see>
            during the parse process.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.NumberOfSyntaxErrors">
            <summary>Gets the number of syntax errors reported during parsing.</summary>
            <remarks>
            Gets the number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">NotifyErrorListeners(string)</see>
            is called.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)">NotifyErrorListeners(string)</seealso>
        </member>
        <member name="P:Antlr4.Runtime.Parser.CurrentToken">
            <summary>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </summary>
            <remarks>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Trace">
            <summary>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches.
            </summary>
            <remarks>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches. This is for quick and dirty debugging.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ParserRuleContext">
            <summary>A rule invocation record for parsing.</summary>
            <remarks>
            A rule invocation record for parsing.
            Contains all of the information about the current rule not stored in the
            RuleContext. It handles parse tree children list, Any ATN state
            tracing, and the default values available for rule indications:
            start, stop, rule index, current alt number, current
            ATN state.
            Subclasses made for each rule and grammar track the parameters,
            return values, locals, and labels specific to that rule. These
            are the objects that are returned from rules.
            Note text is not an actual field of a rule return value; it is computed
            from start and stop using the input stream's toString() method.  I
            could add a ctor to this so that we can pass in and store the input
            stream, but I'm not sure we want to do that.  It would seem to be undefined
            to get the .text property anyway if the rule matches tokens from multiple
            input streams.
            I do not use getters for fields of objects that are used simply to
            group values such as this aggregate.  The getters/setters are there to
            satisfy the superclass interface.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.RuleContext">
            <summary>A rule context is a record of a single rule invocation.</summary>
            <remarks>
            A rule context is a record of a single rule invocation. It knows
            which context invoked it, if any. If there is no parent context, then
            naturally the invoking state is not valid.  The parent link
            provides a chain upwards from the current rule invocation to the root
            of the invocation tree, forming a stack. We actually carry no
            information about the rule associated with this context (except
            when parsing). We keep only the state number of the invoking state from
            the ATN submachine that invoked this. Contrast this with the s
            pointer inside ParserRuleContext that tracks the current state
            being "executed" for the current rule.
            The parent contexts are useful for computing lookahead sets and
            getting error information.
            These objects are used during parsing and prediction.
            For the special case of parsers and tree parsers, we use the subclass
            ParserRuleContext.
            </remarks>
            <seealso cref="T:Antlr4.Runtime.ParserRuleContext">ParserRuleContext</seealso>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTree">
            <summary>
            An interface to access the tree of
            <see cref="T:Antlr4.Runtime.RuleContext">Antlr4.Runtime.RuleContext</see>
            objects created
            during a parse that makes the data structure look like a simple parse tree.
            This node represents both internal nodes, rule invocations,
            and leaf nodes, token matches.
            <p/>
            The payload is either a
            <see cref="T:Antlr4.Runtime.IToken">Antlr4.Runtime.IToken</see>
            or a
            <see cref="T:Antlr4.Runtime.RuleContext">Antlr4.Runtime.RuleContext</see>
            object.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ISyntaxTree">
            <summary>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree.
            </summary>
            <remarks>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree. Subinterfaces distinguish
            between parse trees and other kinds of syntax trees we might want to create.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ITree">
            <summary>The basic notion of a tree has a parent, a payload, and a list of children.
                </summary>
            <remarks>
            The basic notion of a tree has a parent, a payload, and a list of children.
            It is the most abstract interface for all the trees used by ANTLR.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.GetChild(System.Int32)">
            <summary>
            If there are children, get the
            <code>i</code>
            th value indexed from 0.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.ToStringTree">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            <code>(root child1 .. childN)</code>
            . Print just a node if this is a leaf.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Parent">
            <summary>The parent of this node.</summary>
            <remarks>
            The parent of this node. If the return value is null, then this
            node is the root of the tree.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Payload">
            <summary>This method returns whatever object represents the data at this note.</summary>
            <remarks>
            This method returns whatever object represents the data at this note. For
            example, for parse trees, the payload can be a
            <see cref="T:Antlr4.Runtime.IToken">Antlr4.Runtime.IToken</see>
            representing
            a leaf node or a
            <see cref="T:Antlr4.Runtime.RuleContext">Antlr4.Runtime.RuleContext</see>
            object representing a rule
            invocation. For abstract syntax trees (ASTs), this is a
            <see cref="T:Antlr4.Runtime.IToken">Antlr4.Runtime.IToken</see>
            object.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.ChildCount">
            <summary>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </summary>
            <remarks>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ISyntaxTree.SourceInterval">
            <summary>
            Return an
            <see cref="T:Antlr4.Runtime.Misc.Interval">Antlr4.Runtime.Misc.Interval</see>
            indicating the index in the
            <see cref="T:Antlr4.Runtime.ITokenStream">Antlr4.Runtime.ITokenStream</see>
            of the first and last token associated with this
            subtree. If this node is a leaf, then the interval represents a single
            token.
            <p/>
            If source interval is unknown, this returns
            <see cref="F:Antlr4.Runtime.Misc.Interval.Invalid">Antlr4.Runtime.Misc.Interval.Invalid
                </see>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1">IParseTreeVisitor&lt;Result&gt;</see>
            needs a double dispatch method.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.GetText">
            <summary>Return the combined text of all leaf nodes.</summary>
            <remarks>
            Return the combined text of all leaf nodes. Does not get any
            off-channel tokens (if any) so won't return whitespace and
            comments if they are sent to parser on hidden channel.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </summary>
            <remarks>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext.parent">
            <summary>What context invoked this rule?</summary>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext.invokingState">
            <summary>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </summary>
            <remarks>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.IsEmpty">
            <summary>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </summary>
            <remarks>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.GetText">
            <summary>Return the combined text of all child nodes.</summary>
            <remarks>
            Return the combined text of all child nodes. This method only considers
            tokens which have been added to the parse tree.
            <p/>
            Since tokens on hidden channels (e.g. whitespace or comments) are not
            added to the parse trees, they will not appear in the output of this
            method.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            We have to know the recognizer so we can get rule names.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(System.Collections.Generic.IList{System.String})">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.children">
            <summary>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context.
            </summary>
            <remarks>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context. This is empty for parsing w/o tree constr.
            operation because we don't the need to track the details about
            how we parse this rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.start">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.stop">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.exception">
            <summary>The exception which forced this rule to return.</summary>
            <remarks>
            The exception which forced this rule to return. If the rule successfully
            completed, this is
            <code>null</code>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.CopyFrom(Antlr4.Runtime.ParserRuleContext)">
            <summary>COPY a ctx (I'm deliberately not using copy constructor)</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Does not set parent link; other add methods do that</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.RemoveLastChild">
            <summary>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule.
            </summary>
            <remarks>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule. If we have # label, we will need to remove
            generic ruleContext object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.ToInfoString(Antlr4.Runtime.Parser)">
            <summary>Used for rule context info debugging during parse-time, not so much for ATN debugging
                </summary>
        </member>
        <member name="T:Antlr4.Runtime.ProxyErrorListener`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            dispatches all calls to a
            collection of delegate listeners. This reduces the effort required to support multiple
            listeners.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.ProxyParserErrorListener">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Sharpen.CRC32.DO1(System.UInt32@,System.Byte*@)">
            * ========================================================================= */
        </member>
        <member name="M:Sharpen.CRC32.DOLIT4(System.UInt32@,System.UInt32*@)">
            * ========================================================================= */
        </member>
        <member name="M:Sharpen.CRC32.DOBIG4(System.UInt32@,System.UInt32*@)">
            * ========================================================================= */
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter">
            <summary>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            </summary>
            <remarks>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            You can insert stuff, replace, and delete chunks.  Note that the
            operations are done lazily--only if you convert the buffer to a
            String with getText(). This is very efficient because you are not moving
            data around all the time.  As the buffer of tokens is converted to strings,
            the getText() method(s) scan the input token stream and check
            to see if there is an operation at the current index.
            If so, the operation is done and then normal String
            rendering continues on the buffer.  This is like having multiple Turing
            machine instruction streams (programs) operating on a single input tape. :)
            This rewriter makes no modifications to the token stream. It does not
            ask the stream to fill itself up nor does it advance the input cursor.
            The token stream index() will return the same value before and after
            any getText() call.
            The rewriter only works on tokens that you have in the buffer and
            ignores the current input cursor. If you are buffering tokens on-demand,
            calling getText() halfway through the input will only do rewrites
            for those tokens in the first half of the file.
            Since the operations are done lazily at getText-time, operations do not
            screw up the token index values.  That is, an insert operation at token
            index i does not change the index values for tokens i+1..n-1.
            Because operations never actually alter the buffer, you may always get
            the original token stream back without undoing anything.  Since
            the instructions are queued up, you can easily simulate transactions and
            roll back any changes if there is an error just by removing instructions.
            For example,
            CharStream input = new ANTLRFileStream("input");
            TLexer lex = new TLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lex);
            T parser = new T(tokens);
            TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);
            parser.startRule();
            Then in the rules, you can execute (assuming rewriter is visible):
            Token t,u;
            ...
            rewriter.insertAfter(t, "text to put after t");}
            rewriter.insertAfter(u, "text after u");}
            System.out.println(tokens.toString());
            You can also have multiple "instruction streams" and get multiple
            rewrites from a single pass over the input.  Just name the instruction
            streams and use that name again when printing the buffer.  This could be
            useful for generating a C file and also its header file--all from the
            same buffer:
            tokens.insertAfter("pass1", t, "text to put after t");}
            tokens.insertAfter("pass2", u, "text after u");}
            System.out.println(tokens.toString("pass1"));
            System.out.println(tokens.toString("pass2"));
            If you don't use named rewrite streams, a "default" stream is used as
            the first example shows.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.tokens">
            <summary>Our source stream</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.programs">
            <summary>You may have multiple, named streams of rewrite operations.</summary>
            <remarks>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) -&gt; rewrite (List)
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.lastRewriteTokenIndexes">
            <summary>Map String (program name) -&gt; Integer index</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.
            </summary>
            <remarks>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.  UNTESTED!
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText">
            <summary>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </summary>
            <remarks>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            </summary>
            <remarks>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            The interval refers to the indexes in the original token stream.
            We do not alter the token stream in any way, so the indexes
            and intervals are still consistent. Includes any operations done
            to the first and last token in the interval. So, if you did an
            insertBefore on the first token, you would get that insertion.
            The same is true if you do an insertAfter the stop token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation})">
            <summary>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested).
            </summary>
            <remarks>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested).  Inserts to
            same index need to be combined etc...   Here are the cases:
            I.i.u I.j.v								leave alone, nonoverlapping
            I.i.u I.i.v								combine: Iivu
            R.i-j.u R.x-y.v	| i-j in x-y			delete first R
            R.i-j.u R.i-j.v							delete first R
            R.i-j.u R.x-y.v	| x-y in i-j			ERROR
            R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            Delete special case of replace (text==null):
            D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
            we're not deleting i)
            I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
            R.x-y.v I.i.u | i in x-y				ERROR
            R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
            R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            I.i.u = insert u before op @ index i
            R.x-y.u = replace x-y indexed tokens with u
            First we need to examine replaces.  For any replace op:
            1. wipe out any insertions before op within that range.
            2. Drop any replace op before that is contained completely within
            that range.
            3. Throw exception upon boundary overlap with any previous replace.
            Then we can deal with inserts:
            1. for any inserts to same index, combine even if not adjacent.
            2. for any prior replace with same left boundary, combine this
            insert with replace and delete this replace.
            3. throw exception if index in same range as previous replace
            Don't actually delete; make op null in list. Easier to walk list.
            Later we can throw as we add to index -&gt; op map.
            Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
            inserted stuff would be before the replace range.  But, if you
            add tokens in front of a method body '{' and then delete the method
            body, I think the stuff before the '{' you added should disappear too.
            Return a map from token index to operation.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetKindOfOps``1(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation},System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.index">
            <summary>Token buffer index.</summary>
            <remarks>Token buffer index.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>Execute the rewrite operation by possibly adding to the buffer.</summary>
            <remarks>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
            <remarks>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1">
            <summary>This interface defines the basic notion of a parse tree visitor.</summary>
            <remarks>
            This interface defines the basic notion of a parse tree visitor. Generated
            visitors implement this interface and the
            <code>XVisitor</code>
            interface for
            grammar
            <code>X</code>
            .
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Visit a parse tree, and return a user-defined result of the operation.</summary>
            <remarks>Visit a parse tree, and return a user-defined result of the operation.</remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree">IParseTree</see>
            to visit.
            </param>
            <returns>The result of visiting the parse tree.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </summary>
            <remarks>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode">IRuleNode</see>
            whose children should be visited.
            </param>
            <returns>The result of visiting the children of the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Visit a terminal node, and return a user-defined result of the operation.
                </summary>
            <remarks>Visit a terminal node, and return a user-defined result of the operation.
                </remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.ITerminalNode">ITerminalNode</see>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>Visit an error node, and return a user-defined result of the operation.</summary>
            <remarks>Visit an error node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IErrorNode">IErrorNode</see>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation calls
            <see cref="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})">IParseTree.Accept&lt;T&gt;(IParseTreeVisitor&lt;Result&gt;)
                </see>
            on the
            specified tree.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation initializes the aggregate result to
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult()</see>
            . Before visiting each child, it
            calls
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">shouldVisitNextChild</see>
            ; if the result
            is
            <code>false</code>
            no more children are visited and the current aggregate
            result is returned. After visiting a child, the aggregate result is
            updated by calling
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">aggregateResult
                </see>
            with the
            previous aggregate result and the result of visiting the child.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation returns the result of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>
            <inheritDoc></inheritDoc>
            <p/>
            The default implementation returns the result of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">
            <summary>Gets the default value returned by visitor methods.</summary>
            <remarks>
            Gets the default value returned by visitor methods. This value is
            returned by the default implementations of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">visitTerminal
                </see>
            ,
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">visitErrorNode
                </see>
            .
            The default implementation of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">visitChildren
                </see>
            initializes its aggregate result to this value.
            <p/>
            The base implementation returns
            <code>null</code>
            .
            </remarks>
            <returns>The default value returned by visitor methods.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">
            <summary>Aggregates the results of visiting multiple children of a node.</summary>
            <remarks>
            Aggregates the results of visiting multiple children of a node. After
            either all children are visited or
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">AbstractParseTreeVisitor&lt;Result&gt;.ShouldVisitNextChild(IRuleNode, object)
                </see>
            returns
            <code>false</code>
            , the aggregate value is returned as the result of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">AbstractParseTreeVisitor&lt;Result&gt;.VisitChildren(IRuleNode)
                </see>
            .
            <p/>
            The default implementation returns
            <code>nextResult</code>
            , meaning
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">AbstractParseTreeVisitor&lt;Result&gt;.VisitChildren(IRuleNode)
                </see>
            will return the result of the last child visited
            (or return the initial value if the node has no children).
            </remarks>
            <param name="aggregate">
            The previous aggregate value. In the default
            implementation, the aggregate value is initialized to
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">AbstractParseTreeVisitor&lt;Result&gt;.DefaultResult()
                </see>
            , which is passed as the
            <code>aggregate</code>
            argument
            to this method after the first child node is visited.
            </param>
            <param name="nextResult">
            The result of the immediately preceeding call to visit
            a child node.
            </param>
            <returns>The updated aggregate result.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">
            <summary>
            This method is called after visiting each child in
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">AbstractParseTreeVisitor&lt;Result&gt;.VisitChildren(IRuleNode)
                </see>
            . This method is first called before the first
            child is visited; at that point
            <code>currentResult</code>
            will be the initial
            value (in the default implementation, the initial value is returned by a
            call to
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">AbstractParseTreeVisitor&lt;Result&gt;.DefaultResult()
                </see>
            . This method is not called after the last
            child is visited.
            <p/>
            The default implementation always returns
            <code>true</code>
            , indicating that
            <code>visitChildren</code>
            should only return after all children are visited.
            One reason to override this method is to provide a "short circuit"
            evaluation option for situations where the result of visiting a single
            child has the potential to determine the result of the visit operation as
            a whole.
            </summary>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode">IRuleNode</see>
            whose children are currently being
            visited.
            </param>
            <param name="currentResult">
            The current aggregate result of the children visited
            to the current point.
            </param>
            <returns>
            
            <code>true</code>
            to continue visiting children. Otherwise return
            <code>false</code>
            to stop visiting children and immediately return the
            current aggregate result from
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">AbstractParseTreeVisitor&lt;Result&gt;.VisitChildren(IRuleNode)
                </see>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ErrorNodeImpl">
            <summary>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation.
            </summary>
            <remarks>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation. For example,
            we will create this kind of a node during single token insertion
            and deletion as well as during "consume until error recovery set"
            upon no viable alternative exceptions.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ParseTreeProperty`1">
            <summary>Associate a property with a parse tree node.</summary>
            <remarks>
            Associate a property with a parse tree node. Useful with parse tree listeners
            that need to associate values with particular tree nodes, kind of like
            specifying a return value for the listener event method that visited a
            particular node. Example:
            <pre>
            ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
            values.put(tree, 36);
            int x = values.get(tree);
            values.removeFrom(tree);
            </pre>
            You would make one decl (values here) in the listener and use lots of times
            in your event methods.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ParseTreeWalker.EnterRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            The discovery of a rule node, involves sending two events: the generic
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">IParseTreeListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)
                </see>
            and a
            <see cref="T:Antlr4.Runtime.RuleContext">Antlr4.Runtime.RuleContext</see>
            -specific event. First we trigger the generic and then
            the rule specific. We to them in reverse order upon finishing the node.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Trees">
            <summary>A set of utility routines useful for all kinds of ANTLR trees.</summary>
            <remarks>A set of utility routines useful for all kinds of ANTLR trees.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">GetNodeText(ITree, Antlr4.Runtime.Parser)
                </see>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">GetNodeText(ITree, Antlr4.Runtime.Parser)
                </see>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,System.Collections.Generic.IList{System.String})">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">GetNodeText(ITree, Antlr4.Runtime.Parser)
                </see>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetAncestors(Antlr4.Runtime.Tree.ITree)">
            <summary>Return a list of all ancestors of this node.</summary>
            <remarks>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.UnbufferedCharStream">
            <summary>Do not buffer up the entire char stream.</summary>
            <remarks>
            Do not buffer up the entire char stream. It does keep a small buffer
            for efficiency and also buffers while a mark exists (set by the
            lookahead prediction in parser). "Unbuffered" here refers to fact
            that it doesn't buffer all data, not that's it's on demand loading of char.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.data">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.n">
            <summary>
            The number of characters currently in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            .
            <p/>
            This is not the buffer capacity, that's
            <code>data.length</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            of next character.
            <p/>
            The
            <code>LA(1)</code>
            character is
            <code>data[p]</code>
            . If
            <code>p == n</code>
            , we are
            out of buffered characters.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">release()</see>
            . When we
            <code>release()</code>
            the last mark,
            <code>numMarkers</code>
            reaches 0 and we reset the buffer. Copy
            <code>data[p]..data[n-1]</code>
            to
            <code>data[0]..data[(n-1)-p]</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastChar">
            <summary>
            This is the
            <code>LA(-1)</code>
            character for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastCharBufferStart">
            <summary>
            When
            <code>numMarkers &gt; 0</code>
            , this is the
            <code>LA(-1)</code>
            character for the
            first character in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            . Otherwise, this is unspecified.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.currentCharIndex">
            <summary>Absolute character index.</summary>
            <remarks>
            Absolute character index. It's the index of the character about to be
            read via
            <code>LA(1)</code>
            . Goes from 0 to the number of characters in the
            entire stream, although the stream size is unknown before the end is
            reached.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.name">
            <summary>The name or source of this char stream.</summary>
            <remarks>The name or source of this char stream.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor(System.Int32)">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.p">p</see>
            .
            Last valid
            <code>p</code>
            index is
            <code>data.length-1</code>
            .
            <code>p+need-1</code>
            is
            the char index 'need' elements ahead. If we need 1 element,
            <code>(p+1-1)==p</code>
            must be less than
            <code>data.length</code>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Fill(System.Int32)">
            <summary>
            Add
            <code>n</code>
            characters to the buffer. Returns the number of characters
            actually added to the buffer. If the return value is less than
            <code>n</code>
            ,
            then EOF was reached before
            <code>n</code>
            characters could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.NextChar">
            <summary>
            Override to provide different source of characters than
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.input">input</see>
            .
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p/>
            The specific marker value used for this class allows for some level of
            protection against misuse where
            <code>seek()</code>
            is called on a mark or
            <code>release()</code>
            is called in the wrong order.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">
            <summary>Decrement number of markers, resetting buffer if we hit 0.</summary>
            <remarks>Decrement number of markers, resetting buffer if we hit 0.</remarks>
            <param name="marker"></param>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Seek(System.Int32)">
            <summary>
            Seek to absolute character index, which might not be in the current
            sliding window.
            </summary>
            <remarks>
            Seek to absolute character index, which might not be in the current
            sliding window.  Move
            <code>p</code>
            to
            <code>index-bufferStartIndex</code>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.n">
            <summary>
            The number of tokens currently in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            .
            <p/>
            This is not the buffer capacity, that's
            <code>tokens.length</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            of next token.
            <p/>
            The
            <code>LT(1)</code>
            token is
            <code>tokens[p]</code>
            . If
            <code>p == n</code>
            , we are
            out of buffered tokens.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Release(System.Int32)">release()</see>
            . When we
            <code>release()</code>
            the last mark,
            <code>numMarkers</code>
            reaches 0 and we reset the buffer. Copy
            <code>tokens[p]..tokens[n-1]</code>
            to
            <code>tokens[0]..tokens[(n-1)-p]</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastToken">
            <summary>
            This is the
            <code>LT(-1)</code>
            token for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastTokenBufferStart">
            <summary>
            When
            <code>numMarkers &gt; 0</code>
            , this is the
            <code>LT(-1)</code>
            token for the
            first token in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            . Otherwise, this is
            <code>null</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.currentTokenIndex">
            <summary>Absolute token index.</summary>
            <remarks>
            Absolute token index. It's the index of the token about to be read via
            <code>LT(1)</code>
            . Goes from 0 to the number of tokens in the entire stream,
            although the stream size is unknown before the end is reached.
            <p/>
            This value is used to set the token indexes if the stream provides tokens
            that implement
            <see cref="T:Antlr4.Runtime.IWritableToken">IWritableToken</see>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.p">p</see>
            . Last valid
            <code>p</code>
            index is
            <code>tokens.length-1</code>
            .
            <code>p+need-1</code>
            is the tokens index 'need' elements
            ahead.  If we need 1 element,
            <code>(p+1-1)==p</code>
            must be less than
            <code>tokens.length</code>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Fill(System.Int32)">
            <summary>
            Add
            <code>n</code>
            elements to the buffer. Returns the number of tokens
            actually added to the buffer. If the return value is less than
            <code>n</code>
            ,
            then EOF was reached before
            <code>n</code>
            tokens could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p/>
            The specific marker value used for this class allows for some level of
            protection against misuse where
            <code>seek()</code>
            is called on a mark or
            <code>release()</code>
            is called in the wrong order.
            </remarks>
        </member>
    </members>
</doc>
