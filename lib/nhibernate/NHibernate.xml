<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NHibernate</name>
    </assembly>
    <members>
        <member name="T:NHibernate.Action.BulkOperationCleanupAction">
            <summary>
            Implementation of BulkOperationCleanupAction.
            </summary>
        </member>
        <member name="T:NHibernate.Action.IExecutable">
            <summary>
            An operation which may be scheduled for later execution.
            Usually, the operation is a database insert/update/delete,
            together with required second-level cache management.
            </summary>
        </member>
        <member name="M:NHibernate.Action.IExecutable.BeforeExecutions">
            <summary> Called before executing any actions</summary>
        </member>
        <member name="M:NHibernate.Action.IExecutable.Execute">
            <summary> Execute this action</summary>
        </member>
        <member name="P:NHibernate.Action.IExecutable.PropertySpaces">
            <summary>
            What spaces (tables) are affected by this action?
            </summary>
        </member>
        <member name="P:NHibernate.Action.IExecutable.BeforeTransactionCompletionProcess">
            <summary>
            Get the before-transaction-completion process, if any, for this action.
            </summary>
        </member>
        <member name="P:NHibernate.Action.IExecutable.AfterTransactionCompletionProcess">
            <summary>
            Get the after-transaction-completion process, if any, for this action.
            </summary>
        </member>
        <member name="M:NHibernate.Action.BulkOperationCleanupAction.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.Generic.ISet{System.String})">
            <summary>
            Create an action that will evict collection and entity regions based on queryspaces (table names).  
            </summary>
        </member>
        <member name="T:NHibernate.Action.CollectionAction">
            <summary>
            Any action relating to insert/update/delete of a collection
            </summary>
        </member>
        <member name="M:NHibernate.Action.CollectionAction.#ctor(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Action.CollectionAction"/>.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="collection">The Persistent collection.</param>
            <param name="key">The identifier of the Collection.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occurring in.</param>
        </member>
        <member name="M:NHibernate.Action.CollectionAction.BeforeExecutions">
            <summary> Called before executing any actions</summary>
        </member>
        <member name="M:NHibernate.Action.CollectionAction.Execute">
            <summary>Execute this action</summary>
        </member>
        <member name="M:NHibernate.Action.CollectionAction.CompareTo(NHibernate.Action.CollectionAction)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the other parameter.Zero This object is equal to other. Greater than zero This object is greater than other. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:NHibernate.Action.CollectionAction.PropertySpaces">
            <summary>
            What spaces (tables) are affected by this action?
            </summary>
        </member>
        <member name="M:NHibernate.Action.CollectionRecreateAction.Execute">
            <summary> Execute this action</summary>
            <remarks>
            This method is called when a new non-null collection is persisted
            or when an existing (non-null) collection is moved to a new owner
            </remarks>
        </member>
        <member name="M:NHibernate.Action.CollectionRemoveAction.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Removes a persistent collection from its loaded owner. 
            </summary>
            <param name="collection">The collection to to remove; must be non-null </param>
            <param name="persister"> The collection's persister </param>
            <param name="id">The collection key </param>
            <param name="emptySnapshot">Indicates if the snapshot is empty </param>
            <param name="session">The session </param>
            <remarks>Use this constructor when the collection is non-null.</remarks>
        </member>
        <member name="M:NHibernate.Action.CollectionRemoveAction.#ctor(System.Object,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Removes a persistent collection from a specified owner. 
            </summary>
            <param name="affectedOwner">The collection's owner; must be non-null </param>
            <param name="persister"> The collection's persister </param>
            <param name="id">The collection key </param>
            <param name="emptySnapshot">Indicates if the snapshot is empty </param>
            <param name="session">The session </param>
            <remarks> Use this constructor when the collection to be removed has not been loaded. </remarks>
        </member>
        <member name="T:NHibernate.Action.DelayedPostInsertIdentifier">
            <summary>
            Acts as a stand-in for an entity identifier which is supposed to be
            generated on insert (like an IDENTITY column) where the insert needed to
            be delayed because we were outside a transaction when the persist
            occurred (save currently still performs the insert).
            
            The stand-in is only used within the see cref="NHibernate.Engine.PersistenceContext"
            in order to distinguish one instance from another; it is never injected into
            the entity instance or returned to the client...
            </summary>
        </member>
        <member name="T:NHibernate.Action.EntityAction">
            <summary>
            Base class for actions relating to insert/update/delete of an entity
            instance.
            </summary>
        </member>
        <member name="M:NHibernate.Action.EntityAction.#ctor(NHibernate.Engine.ISessionImplementor,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Instantiate an action.
            </summary>
            <param name="session">The session from which this action is coming.</param>
            <param name="id">The id of the entity</param>
            <param name="instance">The entity instance</param>
            <param name="persister">The entity persister</param>
        </member>
        <member name="P:NHibernate.Action.EntityAction.EntityName">
            <summary>
            Entity name accessor
            </summary>
        </member>
        <member name="P:NHibernate.Action.EntityAction.Id">
            <summary>
            Entity Id accessor
            </summary>
        </member>
        <member name="P:NHibernate.Action.EntityAction.Instance">
            <summary>
            Entity Instance
            </summary>
        </member>
        <member name="P:NHibernate.Action.EntityAction.Session">
            <summary>
            Session from which this action originated
            </summary>
        </member>
        <member name="P:NHibernate.Action.EntityAction.Persister">
            <summary>
            The entity persister.
            </summary>
        </member>
        <member name="T:NHibernate.Action.BeforeTransactionCompletionProcessDelegate">
            <summary>
            Delegate representing some process that needs to occur before transaction completion.
            </summary>
            <remarks>
            NH specific: C# does not support dynamic interface proxies so a delegate is used in
            place of the Hibernate interface (see Action/BeforeTransactionCompletionProcess). The
            delegate omits the <see cref="T:NHibernate.Engine.ISessionImplementor"/> parameter as it is not used.
            </remarks>
        </member>
        <member name="T:NHibernate.Action.AfterTransactionCompletionProcessDelegate">
            <summary>
            Delegate representing some process that needs to occur after transaction completion.
            </summary>
            <param name="success"> Did the transaction complete successfully? True means it did.</param>
            <remarks>
            NH specific: C# does not support dynamic interface proxies so a delegate is used in
            place of the Hibernate interface (see Action/AfterTransactionCompletionProcess). The
            delegate omits the <see cref="T:NHibernate.Engine.ISessionImplementor"/> parameter as it is not used.
            </remarks>
        </member>
        <member name="M:NHibernate.AdoNet.Util.DdlFormatter.Format(System.String)">
            <summary> Format an SQL statement using simple rules:
            a) Insert newline after each comma;
            b) Indent three spaces after each inserted newline;
            If the statement contains single/double quotes return unchanged,
            it is too complex and could be broken by simple formatting.
            </summary>
        </member>
        <member name="T:NHibernate.AdoNet.Util.FormatStyle">
            <summary> Represents the the understood types or styles of formatting.  </summary>
        </member>
        <member name="T:NHibernate.AdoNet.Util.SqlStatementLogger">
            <summary> Centralize logging handling for SQL statements. </summary>
        </member>
        <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.#ctor">
            <summary> Constructs a new SqlStatementLogger instance.</summary>
        </member>
        <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.#ctor(System.Boolean,System.Boolean)">
            <summary> Constructs a new SqlStatementLogger instance. </summary>
            <param name="logToStdout">Should we log to STDOUT in addition to our internal logger. </param>
            <param name="formatSql">Should we format SQL ('prettify') prior to logging. </param>
        </member>
        <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.LogCommand(System.String,System.Data.IDbCommand,NHibernate.AdoNet.Util.FormatStyle)">
            <summary> Log a IDbCommand. </summary>
            <param name="message">Title</param>
            <param name="command">The SQL statement. </param>
            <param name="style">The requested formatting style. </param>
        </member>
        <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.LogCommand(System.Data.IDbCommand,NHibernate.AdoNet.Util.FormatStyle)">
            <summary> Log a IDbCommand. </summary>
            <param name="command">The SQL statement. </param>
            <param name="style">The requested formatting style. </param>
        </member>
        <member name="T:NHibernate.AdoNet.AbstractBatcher">
            <summary>
            Manages prepared statements and batching. Class exists to enforce separation of concerns
            </summary>
        </member>
        <member name="T:NHibernate.Engine.IBatcher">
            <summary>
            Manages <see cref="T:System.Data.IDbCommand"/>s and <see cref="T:System.Data.IDataReader"/>s 
            for an <see cref="T:NHibernate.ISession"/>. 
            </summary>
            <remarks>
            <p>
            Abstracts ADO.NET batching to maintain the illusion that a single logical batch 
            exists for the whole session, even when batching is disabled.
            Provides transparent <c>IDbCommand</c> caching.
            </p>
            <p>
            This will be useful once ADO.NET gets support for batching.  Until that point
            no code exists that will do batching, but this will provide a good point to do
            error checking and making sure the correct number of rows were affected.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareQueryCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Get an <see cref="T:System.Data.IDbCommand"/> for using in loading / querying.
            </summary>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <param name="commandType">The <see cref="T:System.Data.CommandType"/> of the command.</param>
            <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql"/>.</param>
            <returns>
            An <see cref="T:System.Data.IDbCommand"/> that is ready to be executed.
            </returns>
            <remarks>
            <para>
            If not explicitly released by <see cref="M:NHibernate.Engine.IBatcher.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)"/>, it will be 
            released when the session is closed or disconnected.
            </para>
            <para>
            This does NOT add anything to the batch - it only creates the IDbCommand and 
            does NOT cause the batch to execute...
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Get a non-batchable an <see cref="T:System.Data.IDbCommand"/> to use for inserting / deleting / updating.
            Must be explicitly released by <c>CloseCommand()</c>
            </summary>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <param name="commandType">The <see cref="T:System.Data.CommandType"/> of the command.</param>
            <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql"/>.</param>
            <returns>
            An <see cref="T:System.Data.IDbCommand"/> that is ready to have the parameter values set
            and then executed.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)">
            <summary>
            Close a <see cref="T:System.Data.IDbCommand"/> opened using <c>PrepareCommand()</c>
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to ensure is closed.</param>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to ensure is closed.</param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseReader(System.Data.IDataReader)">
            <summary>
            Close a <see cref="T:System.Data.IDataReader"/> opened using <see cref="M:NHibernate.Engine.IBatcher.ExecuteReader(System.Data.IDbCommand)"/>
            </summary>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to ensure is closed.</param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareBatchCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Get a batchable <see cref="T:System.Data.IDbCommand"/> to use for inserting / deleting / updating
            (might be called many times before a single call to <c>ExecuteBatch()</c>
            </summary>
            <remarks>
            After setting parameters, call <c>AddToBatch()</c> - do not execute the statement
            explicitly.
            </remarks>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <param name="commandType">The <see cref="T:System.Data.CommandType"/> of the command.</param>
            <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql"/>.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
            <summary>
            Add an insert / delete / update to the current batch (might be called multiple times
            for a single <c>PrepareBatchStatement()</c>)
            </summary>
            <param name="expectation">Determines whether the number of rows affected by query is correct.</param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteBatch">
            <summary>
            Execute the batch
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseCommands">
            <summary>
            Close any query statements that were left lying around
            </summary>
            <remarks>
            Use this method instead of <c>Dispose</c> if the <see cref="T:NHibernate.Engine.IBatcher"/>
            can be used again.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteReader(System.Data.IDbCommand)">
            <summary>
            Gets an <see cref="T:System.Data.IDataReader"/> by calling ExecuteReader on the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to execute to get the <see cref="T:System.Data.IDataReader"/>.</param>
            <returns>The <see cref="T:System.Data.IDataReader"/> from the <see cref="T:System.Data.IDbCommand"/>.</returns>
            <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader"/>s it can have are followed.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteNonQuery(System.Data.IDbCommand)">
            <summary>
            Executes the <see cref="T:System.Data.IDbCommand"/>. 
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to execute.</param>
            <returns>The number of rows affected.</returns>
            <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader"/>s it can have are followed.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.AbortBatch(System.Exception)">
            <summary>
            Must be called when an exception occurs.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CancelLastQuery">
            <summary>
            Cancel the current query statement
            </summary>
        </member>
        <member name="P:NHibernate.Engine.IBatcher.HasOpenResources">
            <summary>
            Gets the value indicating whether there are any open resources
            managed by this batcher (IDbCommands or IDataReaders).
            </summary>
        </member>
        <member name="P:NHibernate.Engine.IBatcher.BatchSize">
            <summary>
            Gets or sets the size of the batch, this can change dynamically by
            calling the session's SetBatchSize.
            </summary>
            <value>The size of the batch.</value>
        </member>
        <member name="M:NHibernate.AdoNet.AbstractBatcher.#ctor(NHibernate.AdoNet.ConnectionManager,NHibernate.IInterceptor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AdoNet.AbstractBatcher"/> class.
            </summary>
            <param name="connectionManager">The <see cref="P:NHibernate.AdoNet.AbstractBatcher.ConnectionManager"/> owning this batcher.</param>
            <param name="interceptor"></param>
        </member>
        <member name="M:NHibernate.AdoNet.AbstractBatcher.Prepare(System.Data.IDbCommand)">
            <summary>
            Prepares the <see cref="T:System.Data.IDbCommand"/> for execution in the database.
            </summary>
            <remarks>
            This takes care of hooking the <see cref="T:System.Data.IDbCommand"/> up to an <see cref="T:System.Data.IDbConnection"/>
            and <see cref="T:System.Data.IDbTransaction"/> if one exists.  It will call <c>Prepare</c> if the Driver
            supports preparing commands.
            </remarks>
        </member>
        <member name="M:NHibernate.AdoNet.AbstractBatcher.CheckReaders">
            <summary>
            Ensures that the Driver's rules for Multiple Open DataReaders are being followed.
            </summary>
        </member>
        <member name="M:NHibernate.AdoNet.AbstractBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
            <summary>
            Adds the expected row count into the batch.
            </summary>
            <param name="expectation">The number of rows expected to be affected by the query.</param>
            <remarks>
            If Batching is not supported, then this is when the Command should be executed.  If Batching
            is supported then it should hold of on executing the batch until explicitly told to.
            </remarks>
        </member>
        <member name="F:NHibernate.AdoNet.AbstractBatcher._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.AdoNet.AbstractBatcher.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.AdoNet.AbstractBatcher.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.AdoNet.AbstractBatcher.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this BatcherImpl is being Disposed of or Finalized.</param>
            <remarks>
            If this BatcherImpl is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this BatcherImpl back to life.
            </remarks>
        </member>
        <member name="P:NHibernate.AdoNet.AbstractBatcher.CurrentCommand">
            <summary>
            Gets the current <see cref="T:System.Data.IDbCommand"/> that is contained for this Batch
            </summary>
            <value>The current <see cref="T:System.Data.IDbCommand"/>.</value>
        </member>
        <member name="P:NHibernate.AdoNet.AbstractBatcher.BatchSize">
            <summary>
            Gets or sets the size of the batch, this can change dynamically by
            calling the session's SetBatchSize.
            </summary>
            <value>The size of the batch.</value>
        </member>
        <member name="P:NHibernate.AdoNet.AbstractBatcher.Factory">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> the Batcher was
            created in.
            </summary>
            <value>
            The <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> the Batcher was
            created in.
            </value>
        </member>
        <member name="P:NHibernate.AdoNet.AbstractBatcher.ConnectionManager">
            <summary>
            Gets the <see cref="P:NHibernate.AdoNet.AbstractBatcher.ConnectionManager"/> for this batcher.
            </summary>
        </member>
        <member name="T:NHibernate.AdoNet.ColumnNameCache">
            <summary> Implementation of ColumnNameCache. Thread safe. </summary>
        </member>
        <member name="T:NHibernate.AdoNet.ConnectionManager">
            <summary>
            Manages the database connection and transaction for an <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            This class corresponds to ConnectionManager and JDBCContext in Hibernate,
            combined.
            </remarks>
        </member>
        <member name="P:NHibernate.AdoNet.ConnectionManager.Batcher">
            <summary> The batcher managed by this ConnectionManager. </summary>
        </member>
        <member name="P:NHibernate.AdoNet.IExpectation.ExpectedRowCount">
            <summary>
            Expected row count. Valid only for batchable expectations.
            </summary>
        </member>
        <member name="T:NHibernate.AdoNet.IBatcherFactory">
            <summary> Factory for <see cref="T:NHibernate.Engine.IBatcher"/> instances.</summary>
        </member>
        <member name="T:NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider">
            <summary>
            Provide the class of <see cref="T:NHibernate.AdoNet.IBatcherFactory"/> according to the configuration 
            and the capabilities of the driver.
            </summary>
            <remarks>
            By default, .Net doesn't have any batching capabilities, drivers that does have
            batching support.
            The BatcherFactory trough session-factory configuration section.
            This interface was added in NHibernate for backdraw compatibility to have the ability
            to specify a default <see cref="T:NHibernate.AdoNet.IBatcherFactory"/> for a specific <see cref="T:NHibernate.Driver.IDriver"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.AdoNet.NonBatchingBatcher">
            <summary>
            An implementation of the <see cref="T:NHibernate.Engine.IBatcher"/> 
            interface that does no batching.
            </summary>
        </member>
        <member name="M:NHibernate.AdoNet.NonBatchingBatcher.#ctor(NHibernate.AdoNet.ConnectionManager,NHibernate.IInterceptor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AdoNet.NonBatchingBatcher"/> class.
            </summary>
            <param name="connectionManager">The <see cref="T:NHibernate.AdoNet.ConnectionManager"/> for this batcher.</param>
            <param name="interceptor"></param>
        </member>
        <member name="M:NHibernate.AdoNet.NonBatchingBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
            <summary>
            Executes the current <see cref="T:System.Data.IDbCommand"/> and compares the row Count
            to the <c>expectedRowCount</c>.
            </summary>
            <param name="expectation">
            The expected number of rows affected by the query.  A value of less than <c>0</c>
            indicates that the number of rows to expect is unknown or should not be a factor.
            </param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when there is an expected number of rows to be affected and the
            actual number of rows is different.
            </exception>
        </member>
        <member name="M:NHibernate.AdoNet.NonBatchingBatcher.DoExecuteBatch(System.Data.IDbCommand)">
            <summary>
            This Batcher implementation does not support batching so this is a no-op call.  The
            actual execution of the <see cref="T:System.Data.IDbCommand"/> is run in the <c>AddToBatch</c> 
            method.
            </summary>
            <param name="ps"></param>
        </member>
        <member name="T:NHibernate.AdoNet.NonBatchingBatcherFactory">
            <summary> 
            A BatcherFactory implementation which constructs Batcher instances
            that do not perform batch operations. 
            </summary>
        </member>
        <member name="T:NHibernate.AdoNet.OracleDataClientBatchingBatcher">
            <summary>
            Summary description for OracleDataClientBatchingBatcher.
            By Tomer Avissar
            </summary>
        </member>
        <member name="T:NHibernate.AdoNet.ResultSetWrapper">
            <summary> 
            A ResultSet delegate, responsible for locally caching the columnName-to-columnIndex
            resolution that has been found to be inefficient in a few vendor's drivers (i.e., Oracle
            and Postgres). 
            </summary>
            <seealso cref="M:System.Data.IDataRecord.GetOrdinal(System.String)"/>
        </member>
        <member name="T:NHibernate.AdoNet.SqlClientSqlCommandSet">
            <summary>
            Expose the batch functionality in ADO.Net 2.0
            Microsoft in its wisdom decided to make my life hard and mark it internal.
            Through the use of Reflection and some delegates magic, I opened up the functionality.
            
            Observable performance benefits are 50%+ when used, so it is really worth it.
            </summary>
        </member>
        <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.Append(System.Data.SqlClient.SqlCommand)">
            <summary>
            Append a command to the batch
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.AssertHasParameters(System.Data.SqlClient.SqlCommand)">
            <summary>
            This is required because SqlClient.SqlCommandSet will throw if 
            the command has no parameters.
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.ExecuteNonQuery">
            <summary>
            Executes the batch
            </summary>
            <returns>
            This seems to be returning the total number of affected rows in all queries
            </returns>
        </member>
        <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NHibernate.AdoNet.SqlClientSqlCommandSet.BatchCommand">
            <summary>
            Return the batch command to be executed
            </summary>
        </member>
        <member name="P:NHibernate.AdoNet.SqlClientSqlCommandSet.CountOfCommands">
            <summary>
            The number of commands batched in this instance
            </summary>
        </member>
        <member name="T:NHibernate.HibernateException">
            <summary>
            Any exception that occurs in the O-R persistence layer.
            </summary>
            <remarks>
            Exceptions that occur in the database layer are left as native exceptions.
            </remarks>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class 
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl">
            <summary>
            CodeDOM-based bytecode provider.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.IBytecodeProvider.GetReflectionOptimizer(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
            <summary>
            Retrieve the <see cref="T:NHibernate.Bytecode.IReflectionOptimizer"/> delegate for this provider
            capable of generating reflection optimization components.
            </summary>
            <param name="clazz">The class to be reflected upon.</param>
            <param name="getters">All property getters to be accessed via reflection.</param>
            <param name="setters">All property setters to be accessed via reflection.</param>
            <returns>The reflection optimization delegate.</returns>
        </member>
        <member name="P:NHibernate.Bytecode.IBytecodeProvider.ProxyFactoryFactory">
            <summary> 
            The specific factory for this provider capable of
            generating run-time proxies for lazy-loading purposes.
             </summary>
        </member>
        <member name="P:NHibernate.Bytecode.IBytecodeProvider.ObjectsFactory">
            <summary>
            NHibernate's object instaciator.
            </summary>
            <remarks>
            For entities <see cref="T:NHibernate.Bytecode.IReflectionOptimizer"/> and its implementations.
            </remarks>
        </member>
        <member name="P:NHibernate.Bytecode.IBytecodeProvider.CollectionTypeFactory">
            <summary>
            Instanciator of NHibernate's collections default types.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.#ctor(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
            <summary>
            ctor
            </summary>
            <param name="mappedClass">The target class</param>
            <param name="setters">Array of setters</param>
            <param name="getters">Array of getters</param>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.InitCompiler">
            <summary>
            Set up the compiler options
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.AddAssembly(System.String)">
            <summary>
            Add an assembly to the list of ReferencedAssemblies
            required to build the class
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.Build(System.String)">
            <summary>
            Build the generated code
            </summary>
            <param name="code">Generated code</param>
            <returns>An instance of the generated class</returns>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.IsPublic(System.String)">
            <summary>
            Check if the property is public
            </summary>
            <remarks>
            <para>If IsPublic==true I can directly set the property</para>
            <para>If IsPublic==false I need to use the setter/getter</para>
            </remarks>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.GenerateCode">
            <summary>
            Generate the required code
            </summary>
            <returns>C# code</returns>
        </member>
        <member name="T:NHibernate.Bytecode.IAccessOptimizer">
            <summary>
            Represents optimized entity property access.
            </summary>
        </member>
        <member name="T:NHibernate.Bytecode.Lightweight.BytecodeProviderImpl">
            <summary>
            Factory that generate object based on IReflectionOptimizer needed to replace the use
            of reflection.
            </summary>
            <remarks>
            Used in <see cref="T:NHibernate.Persister.Entity.AbstractEntityPersister"/> and
            <see cref="T:NHibernate.Type.ComponentType"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.BytecodeProviderImpl.GetReflectionOptimizer(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
            <summary>
            Generate the IReflectionOptimizer object
            </summary>
            <param name="mappedClass">The target class</param>
            <param name="setters">Array of setters</param>
            <param name="getters">Array of getters</param>
            <returns><see langword="null" /> if the generation fails</returns>
        </member>
        <member name="T:NHibernate.Bytecode.IReflectionOptimizer">
            <summary>
            Represents reflection optimization for a particular class.
            </summary>
        </member>
        <member name="T:NHibernate.Bytecode.IInstantiationOptimizer">
            <summary>
            Represents optimized entity instantiation.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.IInstantiationOptimizer.CreateInstance">
            <summary>
            Perform instantiation of an instance of the underlying class.
            </summary>
            <returns>The new instance.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.#ctor(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
            <summary>
            Class constructor.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.CreateCreateInstanceMethod(System.Type)">
            <summary>
            Generates a dynamic method which creates a new instance of <paramref name="type" />
            when invoked.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.GenerateGetPropertyValuesMethod(NHibernate.Properties.IGetter[])">
            <summary>
            Generates a dynamic method on the given type.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.GenerateSetPropertyValuesMethod(NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
            <summary>
            Generates a dynamic method on the given type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Bytecode.IObjectsFactory">
            <summary>
            Interface for instanciate all NHibernate objects.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.IObjectsFactory.CreateInstance(System.Type)">
            <summary>
            Creates an instance of the specified type.
            </summary>
            <param name="type">The type of object to create.</param>
            <returns>A reference to the created object.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.IObjectsFactory.CreateInstance(System.Type,System.Boolean)">
            <summary>
            Creates an instance of the specified type.
            </summary>
            <param name="type">The type of object to create.</param>
            <param name="nonPublic">true if a public or nonpublic default constructor can match; false if only a public default constructor can match.</param>
            <returns>A reference to the created object.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.IObjectsFactory.CreateInstance(System.Type,System.Object[])">
            <summary>
            Creates an instance of the specified type using the constructor 
            that best matches the specified parameters.
            </summary>
            <param name="type">The type of object to create.</param>
            <param name="ctorArgs">An array of constructor arguments.</param>
            <returns>A reference to the created object.</returns>
        </member>
        <member name="T:NHibernate.Bytecode.IProxyFactoryFactory">
            <summary> 
            An interface for factories of <see cref="T:NHibernate.Proxy.IProxyFactory">proxy factory</see> instances.
            </summary>
            <remarks>
            Used to abstract from the tupizer.
            </remarks>
        </member>
        <member name="M:NHibernate.Bytecode.IProxyFactoryFactory.BuildProxyFactory">
            <summary> 
            Build a proxy factory specifically for handling runtime
            lazy loading. 
            </summary>
            <returns> The lazy-load proxy factory. </returns>
        </member>
        <member name="M:NHibernate.Bytecode.EmitUtil.EmitFastInt(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Emits an <c>ldc.i4</c> opcode using the fastest available opcode choice.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.EmitUtil.PreparePropertyForSet(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Emits IL to unbox a value type and if null, create a new instance of the value type.
            </summary>
            <remarks>
            This does not work if the value type doesn't have a default constructor - we delegate
            that to the ISetter.
            </remarks>
        </member>
        <member name="M:NHibernate.Bytecode.EmitUtil.DefineDelegateType(System.String,System.Reflection.Emit.ModuleBuilder,System.Type,System.Type[])">
            <summary>
            Defines a new delegate type.
            </summary>
        </member>
        <member name="T:NHibernate.Bytecode.ICollectionTypeFactory">
            <summary>
            Type factory for collections types.
            </summary>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Array(System.String,System.String,System.Boolean,System.Type)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Array"/>.
            </summary>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">The <see cref="T:System.Type"/> to use to create the array.</param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <returns>
            An <see cref="T:NHibernate.Type.ArrayType"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Bag``1(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IList`1"/> with bag semantics.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">
            The name of the property in the owner object containing the collection ID, 
            or <see langword="null"/> if it is the primary key.
            </param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <returns>
            A <see cref="T:NHibernate.Type.GenericBagType`1"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.List``1(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IList`1"/> with list 
            semantics.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">
            The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.
            </param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <returns>
            A <see cref="T:NHibernate.Type.GenericListType`1"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.IdBag``1(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IList`1"/> with identifier
            bag semantics.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.
            </param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <returns>
            A <see cref="T:NHibernate.Type.GenericIdentifierBagType`1"/> for the specified role.
            </returns>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Set``1(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <returns>A <see cref="T:NHibernate.Type.GenericSetType`1"/> for the specified role.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.SortedSet``1(System.String,System.String,System.Boolean,System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for a sorted <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the set.</param>
            <returns>A <see cref="T:NHibernate.Type.GenericSetType`1"/> for the specified role.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.OrderedSet``1(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an ordered <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">
            The name of the property in the owner object containing the collection ID, 
            or <see langword="null"/> if it is the primary key.
            </param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <returns>A <see cref="T:NHibernate.Type.GenericSetType`1"/> for the specified role.</returns>
        </member>
        <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Map``2(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType"/> for an 
            <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="role">The role the collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.
            </param>
            <param name="embedded">Is embedded in XML (not supported yet)</param>
            <returns>
            A <see cref="T:NHibernate.Type.GenericMapType`2"/> for the specified role.
            </returns>
        </member>
        <member name="T:NHibernate.Bytecode.NullBytecodeProvider">
            <summary>
            A <see cref="T:NHibernate.Bytecode.IBytecodeProvider"/> implementation that returns
            <see langword="null"/>, disabling reflection optimization.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.Access.ISoftLock">
            <summary>
            Marker interface, denoting a client-visible "soft lock" on a cached item.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.Entry.CacheEntry">
            <summary>
            A cached instance of a persistent class
            </summary>
        </member>
        <member name="T:NHibernate.Cache.CachedItem">
            <summary>
            An item of cached data, timestamped with the time it was cached, when it was locked,
            when it was unlocked
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ReadWriteCache">
            <summary>
            Caches data that is sometimes updated while maintaining the semantics of
            "read committed" isolation level. If the database is set to "repeatable
            read", this concurrency strategy <em>almost</em> maintains the semantics.
            Repeatable read isolation is compromised in the case of concurrent writes.
            This is an "asynchronous" concurrency strategy.
            </summary>
            <remarks>
            If this strategy is used in a cluster, the underlying cache implementation
            must support distributed hard locks (which are held only momentarily). This
            strategy also assumes that the underlying cache implementation does not do
            asynchronous replication and that state has been fully replicated as soon
            as the lock is released.
            <seealso cref="T:NHibernate.Cache.NonstrictReadWriteCache"/> for a faster algorithm
            <seealso cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>
            </remarks>
        </member>
        <member name="T:NHibernate.Cache.ICacheConcurrencyStrategy">
            <summary>
            Implementors manage transactional access to cached data.
            </summary>
            <remarks>
            <para>
            Transactions pass in a timestamp indicating transaction start time.
            </para>
            <para>
            When used to cache entities and collections the key is the identifier of the
            entity/collection and the value should be set to the <see cref="T:NHibernate.Cache.Entry.CacheEntry"/> 
            for an entity and the results of <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)"/>
            for a collection.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Get(NHibernate.Cache.CacheKey,System.Int64)">
            <summary>
            Attempt to retrieve an object from the Cache
            </summary>
            <param name="key">The key (id) of the object to get out of the Cache.</param>
            <param name="txTimestamp">A timestamp prior to the transaction start time</param>
            <returns>The cached object or <see langword="null"/></returns>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
            <summary>
            Attempt to cache an object, after loading from the database
            </summary>
            <param name="key">The key (id) of the object to put in the Cache.</param>
            <param name="value">The value</param>
            <param name="txTimestamp">A timestamp prior to the transaction start time</param>
            <param name="version">the version number of the object we are putting</param>
            <param name="versionComparer">a Comparer to be used to compare version numbers</param>
            <param name="minimalPut">indicates that the cache should avoid a put if the item is already cached</param>
            <returns><see langword="true"/> if the object was successfully cached</returns>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            We are going to attempt to update/delete the keyed object
            </summary>
            <param name="key">The key</param>
            <param name="version"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Evict(NHibernate.Cache.CacheKey)">
            <summary>
            Called after an item has become stale (before the transaction completes).
            </summary>
            <param name="key"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Update(NHibernate.Cache.CacheKey,System.Object,System.Object,System.Object)">
            <summary>
            Called after an item has been updated (before the transaction completes),
            instead of calling Evict().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="currentVersion"></param>
            <param name="previousVersion"></param>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Insert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Called after an item has been inserted (before the transaction completes), instead of calling Evict().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="currentVersion"></param>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.Access.ISoftLock)">
            <summary>
            Called when we have finished the attempted update/delete (which may or
            may not have been successful), after transaction completion.
            </summary>
            <param name="key">The key</param>
            <param name="lock">The soft lock</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.Access.ISoftLock)">
            <summary>
            Called after an item has been updated (after the transaction completes),
            instead of calling Release().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <param name="lock"></param>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Called after an item has been inserted (after the transaction completes), instead of calling release().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Remove(NHibernate.Cache.CacheKey)">
            <summary>
            Evict an item from the cache immediately (without regard for transaction isolation).
            </summary>
            <param name="key"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Clear">
            <summary>
            Evict all items from the cache immediately.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Destroy">
            <summary>
            Clean up all resources.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.Cache">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Cache.ICache"/> for this strategy to use.
            </summary>
            <value>The <see cref="T:NHibernate.Cache.ICache"/> for this strategy to use.</value>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.NextLockId">
            <summary>
            Generate an id for a new lock. Uniqueness per cache instance is very
            desirable but not absolutely critical. Must be called from one of the
            synchronized methods of this class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Get(NHibernate.Cache.CacheKey,System.Int64)">
            <summary>
            Do not return an item whose timestamp is later than the current
            transaction timestamp. (Otherwise we might compromise repeatable
            read unnecessarily.) Do not return an item which is soft-locked.
            Always go straight to the database instead.
            </summary>
            <remarks>
            Note that since reading an item from that cache does not actually
            go to the database, it is possible to see a kind of phantom read
            due to the underlying row being updated after we have read it
            from the cache. This would not be possible in a lock-based
            implementation of repeatable read isolation. It is also possible
            to overwrite changes made and committed by another transaction
            after the current transaction read the item from the cache. This
            problem would be caught by the update-time version-checking, if 
            the data is versioned or timestamped.
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Stop any other transactions reading or writing this item to/from
            the cache. Send them straight to the database instead. (The lock
            does time out eventually.) This implementation tracks concurrent
            locks by transactions which simultaneously attempt to write to an
            item.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
            <summary>
            Do not add an item to the cache unless the current transaction
            timestamp is later than the timestamp at which the item was
            invalidated. (Otherwise, a stale item might be re-added if the
            database is operating in repeatable read isolation mode.)
            </summary>
            <returns>Whether the item was actually put into the cache</returns>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.DecrementLock(System.Object,NHibernate.Cache.CacheLock)">
            <summary>
            decrement a lock and put it back in the cache
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.Access.ISoftLock)">
            <summary>
            Re-cache the updated state, if and only if there there are
            no other concurrent soft locks. Release our lock.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.IsUnlockable(NHibernate.Cache.Access.ISoftLock,NHibernate.Cache.ReadWriteCache.ILockable)">
            <summary>
            Is the client's lock commensurate with the item in the cache?
            If it is not, we know that the cache expired the original
            lock.
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ReadWriteCache.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.Lock(System.Int64,System.Int32)">
            <summary>
            Lock the item
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.IsGettable(System.Int64)">
            <summary>
            Is this item visible to the timestamped transaction?
            </summary>
            <param name="txTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Don't overwrite already cached items
            </summary>
            <param name="txTimestamp"></param>
            <param name="newVersion"></param>
            <param name="comparator"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.FreshTimestamp">
            <summary>
            The timestamp on the cached data
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.Value">
            <summary>
            The actual cached data
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.IsLock">
            <summary>
            Not a lock!
            </summary>
        </member>
        <member name="T:NHibernate.Cache.CacheException">
            <summary>
            Represents any exception from an <see cref="T:NHibernate.Cache.ICache"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Cache.CacheFactory">
            <summary>
            Factory class for creating an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>.
            </summary>
        </member>
        <member name="F:NHibernate.Cache.CacheFactory.Transactional">
            <remarks>
            No providers implement transactional caching currently,
            it was ported from Hibernate just for the sake of completeness.
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.CacheFactory.CreateCache(System.String,System.String,System.Boolean,NHibernate.Cfg.Settings,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Creates an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> from the parameters.
            </summary>
            <param name="usage">The name of the strategy that <see cref="T:NHibernate.Cache.ICacheProvider"/> should use for the class.</param>
            <param name="name">The name of the class the strategy is being created for.</param>
            <param name="mutable"><see langword="true"/> if the object being stored in the cache is mutable.</param>
            <param name="settings">Used to retrieve the global cache region prefix.</param>
            <param name="properties">Properties the cache provider can use to configure the cache.</param>
            <returns>An <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> to use for this object in the <see cref="T:NHibernate.Cache.ICache"/>.</returns>
        </member>
        <member name="T:NHibernate.Cache.CacheKey">
            <summary>
            Allows multiple entity classes / collection roles to be 
            stored in the same cache region. Also allows for composite 
            keys which do not properly implement equals()/hashCode().
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheKey.#ctor(System.Object,NHibernate.Type.IType,System.String,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> 
            Construct a new key for a collection or entity instance.
            Note that an entity name should always be the root entity 
            name, not a subclass entity name. 
            </summary>
            <param name="id">The identifier associated with the cached data </param>
            <param name="type">The Hibernate type mapping </param>
            <param name="entityOrRoleName">The entity or collection-role name. </param>
            <param name="entityMode">The entiyt mode of the originating session </param>
            <param name="factory">The session factory for which we are caching </param>
        </member>
        <member name="T:NHibernate.Cache.CacheLock">
            <summary>
            A soft lock which supports concurrent locking,
            timestamped with the time it was released
            </summary>
            <remarks>
            This class was named Lock in H2.1
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.Lock(System.Int64,System.Int32)">
            <summary>
            Increment the lock, setting the
            new lock timeout
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.Unlock(System.Int64)">
            <summary>
            Decrement the lock, setting the unlock
            timestamp if now unlocked
            </summary>
            <param name="currentTimestamp"></param>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Can the timestamped transaction re-cache this
            locked item now?
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.IsGettable(System.Int64)">
            <summary>
            locks are not returned to the client!
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CacheLock.WasLockedConcurrently">
            <summary>
            Was this lock held concurrently by multiple
            transactions?
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CacheLock.IsLock">
            <summary>
            Yes, this is a lock
            </summary>
        </member>
        <member name="T:NHibernate.Cache.FakeCache">
            <summary>
            Used by <see cref="T:NHibernate.Cache.NoCacheProvider"/>
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICache">
            <summary>
            Implementors define a caching algorithm.
            </summary>
            <remarks>
            <threadsafety instance="true"/>
            <para>
            All implementations <em>must</em> be threadsafe.
            </para>
            <para>
            The key is the identifier of the object that is being cached and the 
            value is a <see cref="T:NHibernate.Cache.CachedItem"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ICache.Get(System.Object)">
            <summary>
            Get the object from the Cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICache.Put(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.ICache.Remove(System.Object)">
            <summary>
            Remove an item from the Cache.
            </summary>
            <param name="key">The Key of the Item in the Cache to remove.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Clear">
            <summary>
            Clear the Cache
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Destroy">
            <summary>
            Clean up.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Lock(System.Object)">
            <summary>
            If this is a clustered cache, lock the item
            </summary>
            <param name="key">The Key of the Item in the Cache to lock.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Unlock(System.Object)">
            <summary>
            If this is a clustered cache, unlock the item
            </summary>
            <param name="key">The Key of the Item in the Cache to unlock.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.NextTimestamp">
            <summary>
            Generate a timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cache.ICache.Timeout">
            <summary>
            Get a reasonable "lock timeout"
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ICache.RegionName">
            <summary>
            Gets the name of the cache region
            </summary>
        </member>
        <member name="T:NHibernate.Cache.HashtableCache">
            <summary>
            A simple <see cref="T:System.Collections.Hashtable"/>-based cache
            </summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Get(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Put(System.Object,System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Remove(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Destroy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Lock(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Unlock(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.NextTimestamp">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cache.HashtableCache.Timeout">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cache.HashtableCacheProvider">
            <summary>
            Cache Provider plugin for NHibernate that is configured by using
            <c>cache.provider_class="NHibernate.Cache.HashtableCacheProvider"</c>
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICacheProvider">
            <summary>
            Support for pluggable caches
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.BuildCache(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Configure the cache
            </summary>
            <param name="regionName">the name of the cache region</param>
            <param name="properties">configuration settings</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.NextTimestamp">
            <summary>
            generate a timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.Start(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Callback to perform any necessary initialization of the underlying cache implementation
            during ISessionFactory construction.
            </summary>
            <param name="properties">current configuration settings</param>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.Stop">
            <summary>
            Callback to perform any necessary cleanup of the underlying cache implementation
            during <see cref="M:NHibernate.ISessionFactory.Close"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.IOptimisticCacheSource">
            <summary> 
            Contract for sources of optimistically lockable data sent to the second level cache.
            </summary>
            <remarks>
            Note currently <see cref="T:NHibernate.Persister.Entity.IEntityPersister">EntityPersisters</see> are
            the only viable source.
            </remarks>
        </member>
        <member name="P:NHibernate.Cache.IOptimisticCacheSource.IsVersioned">
            <summary> 
            Does this source represent versioned (i.e., and thus optimistically lockable) data? 
            </summary>
            <returns> True if this source represents versioned data; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Cache.IOptimisticCacheSource.VersionComparator">
            <summary> Get the comparator used to compare two different version values together. </summary>
            <returns> An appropriate comparator. </returns>
        </member>
        <member name="T:NHibernate.Cache.IQueryCache">
            <summary>
            Defines the contract for caches capable of storing query results.  These
            caches should only concern themselves with storing the matching result ids.
            The transactional semantics are necessarily less strict than the semantics
            of an item cache.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.IQueryCacheFactory">
            <summary>
            Defines a factory for query cache instances.  These factories are responsible for
            creating individual QueryCache instances.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.NoCacheProvider">
            <summary>
            A cache provider placeholder used when caching is disabled.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.BuildCache(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Configure the cache
            </summary>
            <param name="regionName">the name of the cache region</param>
            <param name="properties">configuration settings</param>
            <exception cref="T:NHibernate.Cache.CacheException"/>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.NextTimestamp">
            <summary>
            Generate a timestamp
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.Start(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Callback to perform any necessary initialization of the underlying cache implementation during SessionFactory
            construction.
            </summary>
            <param name="properties">current configuration settings.</param>
        </member>
        <member name="M:NHibernate.Cache.NoCacheProvider.Stop">
            <summary>
            Callback to perform any necessary cleanup of the underlying cache implementation during SessionFactory.close().
            </summary>
        </member>
        <member name="T:NHibernate.Cache.NonstrictReadWriteCache">
            <summary>
            Caches data that is sometimes updated without ever locking the cache. 
            If concurrent access to an item is possible, this concurrency strategy 
            makes no guarantee that the item returned from the cache is the latest 
            version available in the database. Configure your cache timeout accordingly! 
            This is an "asynchronous" concurrency strategy.
            <seealso cref="T:NHibernate.Cache.ReadWriteCache"/> for a much stricter algorithm
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Get(NHibernate.Cache.CacheKey,System.Int64)">
            <summary>
            Get the most recent version, if available.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
            <summary>
            Add an item to the cache
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Evict(NHibernate.Cache.CacheKey)">
            <summary>
            Invalidate the item
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Update(NHibernate.Cache.CacheKey,System.Object,System.Object,System.Object)">
            <summary>
            Invalidate the item
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Insert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.Access.ISoftLock)">
            <summary>
            Invalidate the item (again, for safety).
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.Access.ISoftLock)">
            <summary>
            Invalidate the item (again, for safety).
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="P:NHibernate.Cache.NonstrictReadWriteCache.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.QueryKey.#ctor(NHibernate.Engine.ISessionFactoryImplementor,NHibernate.SqlCommand.SqlString,NHibernate.Engine.QueryParameters,System.Collections.Generic.ISet{NHibernate.Cache.FilterKey},NHibernate.Transform.CacheableResultTransformer)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.QueryKey"/> class.
            </summary>
            <param name="factory">the session factory for this query key, required to get the identifiers of entities that are used as values.</param>
            <param name="queryString">The query string.</param>
            <param name="queryParameters">The query parameters.</param>
            <param name="filters">The filters.</param>
            <param name="customTransformer">The result transformer; should be null if data is not transformed before being cached.</param>
        </member>
        <member name="T:NHibernate.Cache.ReadOnlyCache">
            <summary>
            Caches data that is never updated
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.Access.ISoftLock)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.Access.ISoftLock)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Evict(NHibernate.Cache.CacheKey)">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Insert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
            <summary>
            Do nothing.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Update(NHibernate.Cache.CacheKey,System.Object,System.Object,System.Object)">
            <summary>
            Unsupported!
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ReadOnlyCache.RegionName">
            <summary>
            Gets the cache region name.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.StandardQueryCache">
            <summary>
            The standard implementation of the Hibernate <see cref="T:NHibernate.Cache.IQueryCache"/>
            interface.  This implementation is very good at recognizing stale query
            results and re-running queries when it detects this condition, recaching
            the new results.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.StandardQueryCacheFactory">
            <summary>
            Standard Hibernate implementation of the IQueryCacheFactory interface.  Returns
            instances of <see cref="T:NHibernate.Cache.StandardQueryCache"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.Timestamper">
            <summary>
            Generates increasing identifiers (in a single application domain only).
            </summary>
            <remarks>
            Not valid across multiple application domains. Identifiers are not necessarily
            strictly increasing, but usually are.
            </remarks>
        </member>
        <member name="F:NHibernate.Cache.Timestamper.OneMs">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.Timestamper.Next">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cache.UpdateTimestampsCache">
            <summary>
            Tracks the timestamps of the most recent updates to particular tables. It is
            important that the cache timeout of the underlying cache implementation be set
            to a higher value than the timeouts of any of the query caches. In fact, we 
            recommend that the the underlying cache not be configured for expiry at all.
            Note, in particular, that an LRU cache expiry policy is never appropriate.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.UpdateTimestampsCache.Invalidate(System.Object[])">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper">
            <summary>
            Helper to parse hibernate-configuration XmlNode.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.CfgSectionName">
            <summary>
            The XML node name for hibernate configuration section in the App.config/Web.config and
            for the hibernate.cfg.xml .
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.CfgSchemaXMLNS">
            <summary>The XML Namespace for the nhibernate-configuration</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ByteCodeProviderExpression">
            <summary>XPath expression for bytecode-provider property.</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ReflectionOptimizerExpression">
            <summary>XPath expression for reflection-optimizer property.</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryExpression">
            <summary>XPath expression for session-factory whole node.</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryPropertiesExpression">
            <summary>XPath expression for session-factory.property nodes</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryMappingsExpression">
            <summary>XPath expression for session-factory.mapping nodes</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryClassesCacheExpression">
            <summary>XPath expression for session-factory.class-cache nodes</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryCollectionsCacheExpression">
            <summary>XPath expression for session-factory.collection-cache nodes</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryEventsExpression">
            <summary>XPath expression for session-factory.event nodes</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryListenersExpression">
            <summary>XPath expression for session-factory.listener nodes</summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ClassCacheIncludeConvertFrom(System.String)">
            <summary>
            Convert a string to <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude"/>.
            </summary>
            <param name="include">The string that represent <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude"/>.</param>
            <returns>
            The <paramref name="include"/> converted to <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude"/>.
            </returns>
            <exception cref="T:NHibernate.Cfg.HibernateConfigException">If the values is invalid.</exception>
            <remarks>
            See <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude"/> for allowed values.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ListenerTypeConvertFrom(System.String)">
            <summary>
            Convert a string to <see cref="T:NHibernate.Event.ListenerType"/>.
            </summary>
            <param name="listenerType">The string that represent <see cref="T:NHibernate.Event.ListenerType"/>.</param>
            <returns>
            The <paramref name="listenerType"/> converted to <see cref="T:NHibernate.Event.ListenerType"/>.
            </returns>
            <exception cref="T:NHibernate.Cfg.HibernateConfigException">If the values is invalid.</exception>
            <remarks>
            See <see cref="T:NHibernate.Event.ListenerType"/> for allowed values.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude">
            <summary>
            Values for class-cache include.
            </summary>
            <remarks>Not implemented in Cache.</remarks>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude.All">
            <summary>Xml value: all</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude.NonLazy">
            <summary>Xml value: non-lazy</summary>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration">
            <summary>
            Configuration parsed values for a class-cache XML node.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.EntityCacheUsage)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration"/> class.
            </summary>
            <param name="clazz">The class full name.</param>
            <param name="usage">Cache strategy.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="clazz"/> is null or empty.</exception>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.EntityCacheUsage,NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration"/> class.
            </summary>
            <param name="clazz">The class full name.</param>
            <param name="usage">Cache strategy.</param>
            <param name="include">Values for class-cache include.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="clazz"/> is null or empty.</exception>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.EntityCacheUsage,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration"/> class.
            </summary>
            <param name="clazz">The class full name.</param>
            <param name="usage">Cache strategy.</param>
            <param name="region">The cache region.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="clazz"/> is null or empty.</exception>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.EntityCacheUsage,NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration"/> class.
            </summary>
            <param name="clazz">The class full name.</param>
            <param name="usage">Cache strategy.</param>
            <param name="include">Values for class-cache include.</param>
            <param name="region">The cache region.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="clazz"/> is null or empty.</exception>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Class">
            <summary>
            The class full name.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Region">
            <summary>
            The cache region.
            </summary>
            <remarks>If null or empty the <see cref="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Class"/> is used during configuration.</remarks>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Usage">
            <summary>
            Cache strategy.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Include">
            <summary>
            class-cache include.
            </summary>
            <remarks>
            Not implemented in Cache.
            Default value <see cref="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude.All"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration">
            <summary>
            Configuration parsed values for a collection-cache XML node.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.#ctor(System.String,NHibernate.Cfg.EntityCacheUsage)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration"/> class.
            </summary>
            <param name="collection">The cache role.</param>
            <param name="usage">Cache strategy.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="collection"/> is null or empty.</exception>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.#ctor(System.String,NHibernate.Cfg.EntityCacheUsage,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration"/> class.
            </summary>
            <param name="collection">The cache role.</param>
            <param name="usage">Cache strategy.</param>
            <param name="region">The cache region.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="collection"/> is null or empty.</exception>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Collection">
            <summary>
            The role.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Region">
            <summary>
            The cache region.
            </summary>
            <remarks>If null or empty the <see cref="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Collection"/> is used during configuration.</remarks>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Usage">
            <summary>
            Cache strategy.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.EventConfiguration">
            <summary>
            Configuration parsed values for a event XML node.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.EventConfiguration.#ctor(NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration,NHibernate.Event.ListenerType)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.EventConfiguration"/> class.
            </summary>
            <param name="listener">The listener.</param>
            <param name="type">The type.</param>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.EventConfiguration.Type">
            <summary>
            The default type of listeners.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.EventConfiguration.Listeners">
            <summary>
            Listeners for this event.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType">
            <summary>
            Values for bytecode-provider system property.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Codedom">
            <summary>Xml value: codedom</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Lcg">
            <summary>Xml value: lcg</summary>
        </member>
        <member name="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Null">
            <summary>Xml value: null</summary>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration">
            <summary>
            Configuration parsed values for hibernate-configuration section.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.#ctor(System.Xml.XmlReader)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration"/> class.
            </summary>
            <param name="hbConfigurationReader">The XML reader to parse.</param>
            <remarks>
            The nhibernate-configuration.xsd is applied to the XML.
            </remarks>
            <exception cref="T:NHibernate.Cfg.HibernateConfigException">When nhibernate-configuration.xsd can't be applied.</exception>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.ByteCodeProviderType">
            <summary>
            Value for bytecode-provider system property.
            </summary>
            <remarks>Default value <see cref="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Lcg"/>.</remarks>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.UseReflectionOptimizer">
            <summary>
            Value for reflection-optimizer system property.
            </summary>
            <remarks>Default value true.</remarks>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.SessionFactory">
            <summary>
            The <see cref="T:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration"/> if the session-factory exists in hibernate-configuration;
            Otherwise null.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration">
            <summary>
            Configuration parsed values for a listener XML node
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration"/> class.
            </summary>
            <param name="clazz">The class full name.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="clazz"/> is null or empty.</exception>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.#ctor(System.String,NHibernate.Event.ListenerType)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration"/> class.
            </summary>
            <param name="clazz">The class full name.</param>
            <param name="type">The listener type.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="clazz"/> is null or empty.</exception>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.Class">
            <summary>
            The class full name.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.Type">
            <summary>
            The listener type.
            </summary>
            <remarks>Default value <see cref="F:NHibernate.Event.ListenerType.NotValidType"/> mean that the value is ignored.</remarks>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration">
            <summary>
            Configuration parsed values for a mapping XML node
            </summary>
            <remarks>
            There are 3 possible combinations of mapping attributes
            1 - resource and assembly:  NHibernate will read the mapping resource from the specified assembly
            2 - file only: NHibernate will read the mapping from the file.
            3 - assembly only: NHibernate will find all the resources ending in hbm.xml from the assembly.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration"/> class.
            </summary>
            <param name="file">Mapped file.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="file"/> is null or empty.</exception>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration"/> class.
            </summary>
            <param name="assembly">The assembly name.</param>
            <param name="resource">The mapped embedded resource.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="assembly"/> is null or empty.</exception>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration">
            <summary>
            Configuration parsed values for a session-factory XML node.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ISessionFactoryConfiguration.Name">
            <summary>
            The session factory name.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ISessionFactoryConfiguration.Properties">
            <summary>
            Session factory propeties bag.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ISessionFactoryConfiguration.Mappings">
            <summary>
            Session factory mapping configuration.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ISessionFactoryConfiguration.ClassesCache">
            <summary>
            Session factory class-cache configurations.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ISessionFactoryConfiguration.CollectionsCache">
            <summary>
            Session factory collection-cache configurations.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ISessionFactoryConfiguration.Events">
            <summary>
            Session factory event configurations.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.ISessionFactoryConfiguration.Listeners">
            <summary>
            Session factory listener configurations.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.SessionFactoryConfigurationBase.Name">
            <summary>
            The session factory name.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.SessionFactoryConfigurationBase.Properties">
            <summary>
            Session factory propeties bag.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.SessionFactoryConfigurationBase.Mappings">
            <summary>
            Session factory mapping configuration.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.SessionFactoryConfigurationBase.ClassesCache">
            <summary>
            Session factory class-cache configurations.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.SessionFactoryConfigurationBase.CollectionsCache">
            <summary>
            Session factory collection-cache configurations.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.SessionFactoryConfigurationBase.Events">
            <summary>
            Session factory event configurations.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.SessionFactoryConfigurationBase.Listeners">
            <summary>
            Session factory listener configurations.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration"/> class.
            </summary>
            <param name="name">The session factory name. Null or empty string are allowed.</param>
        </member>
        <member name="M:NHibernate.Cfg.Loquacious.IDbIntegrationConfiguration.Using``1">
            <summary>
            Define and configure the dialect to use.
            </summary>
            <typeparam name="TDialect">The dialect implementation inherited from <see cref="T:NHibernate.Dialect.Dialect"/>.</typeparam>
            <returns>The fluent configuration itself.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Loquacious.ICommandsConfiguration.WithMaximumDepthOfOuterJoinFetching(System.Byte)">
            <summary>
            Maximum depth of outer join fetching
            </summary>
            <remarks>
            0 (zero) disable the usage of OuterJoinFetching
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Named(System.String)">
            <summary>
            Set the SessionFactory mnemonic name.
            </summary>
            <param name="sessionFactoryName">The mnemonic name.</param>
            <returns>The fluent configuration itself.</returns>
            <remarks>
            The SessionFactory mnemonic name can be used as a surrogate key in a multi-DB application. 
            </remarks>
        </member>
        <member name="P:NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Integrate">
            <summary>
            DataBase integration configuration.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Loquacious.IFluentSessionFactoryConfiguration.Caching">
            <summary>
            Cache configuration.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.Loquacious.ITypeDefConfigurationProperties">
            <summary>
            Properties of TypeDef configuration.
            </summary>
            <seealso cref="M:NHibernate.Cfg.ConfigurationExtensions.TypeDefinition``1(NHibernate.Cfg.Configuration,System.Action{NHibernate.Cfg.Loquacious.ITypeDefConfigurationProperties})"/>
        </member>
        <member name="P:NHibernate.Cfg.Loquacious.ITypeDefConfigurationProperties.Alias">
            <summary>
            The key to use the type-definition inside not strongly typed mappings (XML mapping).
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Loquacious.ITypeDefConfigurationProperties.Properties">
            <summary>
            An <see cref="T:System.Object"/> which public properties are used as 
            type-definition pareneters or null where type-definition does not need parameters or you want use default values.
            </summary>
            <remarks>
            <example>
            As <paramref name="value"/> an anonimous object can be used:
            <code>
            configure.TypeDefinition&lt;TableHiLoGenerator&gt;(c=&gt;
                                                         	{
                                                         		c.Alias = "HighLow";
                                                         		c.Properties = new {max_lo = 99};
                                                         	});
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.EndsWithHbmXmlFilter">
            <summary>
            Responsible for checking that a resource name matches the default pattern of "*.hbm.xml". This is the
            default filter for <see cref="T:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.IAssemblyResourceFilter">
            <summary>
            Responsible for determining whether an embedded resource should be parsed for HBM XML data while
            iterating through an <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmAny">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.IColumnsMapping">
            <summary>
            Implemented by any mapping elemes supports simple and/or multicolumn mapping.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.metavalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.idtype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.metatype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.update">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.index">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmMeta">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmBase">
            <summary>A base class for HBM schema classes that provides helper methods.</summary>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMeta.attribute">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMeta.inherit">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMeta.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmMetaValue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMetaValue.value">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMetaValue.class">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmColumn">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.length">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.precision">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.scale">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.notnull">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.notnullSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.uniqueSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.uniquekey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.sqltype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.index">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.default">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmComment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComment.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmArray">
            <remarks/>
        </member>
        <member name="P:NHibernate.Cfg.MappingSchema.ICollectionPropertiesMapping.ElementRelationship">
            <summary>
            The relation of the element of the collection.
            </summary>
            <remarks>
            Can be one of: HbmCompositeElement, HbmElement, HbmManyToAny, HbmManyToMany, HbmOneToMany...
            according to the type of the collection.
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.Item1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqldeleteall">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.inverse">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.elementclass">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.batchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.collectiontype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.embedxml">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmSubselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubselect.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCache.usage">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCache.region">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCache.include">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCacheUsage">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.ReadOnly">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.ReadWrite">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.NonstrictReadWrite">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.Transactional">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCacheInclude">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheInclude.All">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheInclude.NonLazy">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmSynchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSynchronize.table">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmKey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.propertyref">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.foreignkey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.ondelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.notnull">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.notnullSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.update">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.updateSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.uniqueSpecified">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmOndelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOndelete.Cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOndelete.Noaction">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmIndex">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.length">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmListIndex">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmListIndex.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmListIndex.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmListIndex.base">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeElement">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.parent">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmParent">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmParent.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmParent.access">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmManyToOne">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.notnull">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.notnullSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.uniquekey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.index">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.update">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.foreignkey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.propertyref">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.notfound">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.embedxml">
            <remarks/>
        </member>
        <member name="P:NHibernate.Cfg.MappingSchema.HbmManyToOne.ColumnsAndFormulas">
            <summary>
            Columns and Formulas, in declared order
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmFormula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFormula.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy.Auto">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy.True">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy.False">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmFetchMode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFetchMode.Select">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFetchMode.Join">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmLaziness">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLaziness.False">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLaziness.Proxy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLaziness.NoProxy">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmNotFoundMode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNotFoundMode.Ignore">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNotFoundMode.Exception">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.parent">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmProperty">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.type1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.length">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.precision">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.scale">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.notnull">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.notnullSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.uniquekey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.index">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.update">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.updateSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.insertSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.generated">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmType">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmType.param">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmType.name">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmParam">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmParam.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmParam.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration.Never">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration.Insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration.Always">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmElement">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.type1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.length">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.precision">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.scale">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.notnull">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.unique">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmManyToAny">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.metavalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.idtype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.metatype">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmManyToMany">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.filter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.embedxml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.notfound">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.foreignkey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.orderby">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.propertyref">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmFilter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilter.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilter.condition">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilter.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmRestrictedLaziness">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmRestrictedLaziness.False">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmRestrictedLaziness.Proxy">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmOneToMany">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.notfound">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.embedxml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.entityname">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmLoader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLoader.queryref">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCustomSQL">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.callable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.callableSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.checkSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck.None">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck.Rowcount">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck.Param">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode.Select">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode.Join">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode.Subselect">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmBag">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqldeleteall">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.filter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.inverse">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.orderby">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.batchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.collectiontype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.embedxml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.generic">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.genericSpecified">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCollectionLazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionLazy.True">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionLazy.False">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionLazy.Extra">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmClass">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.tuplizer">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.discriminator">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.naturalid">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Item1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Items1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.filter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.resultset">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Items2">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.proxy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.schemaaction">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.discriminatorvalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.abstract">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.abstractSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.polymorphism">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.dynamicupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.dynamicinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.batchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.selectbeforeupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.rowid">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmTuplizer">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizer.entitymode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizer.entitymodeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizer.class">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode.Poco">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode.Xml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode.DynamicMap">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeId">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.mapped">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.unsavedvalue">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.foreignkey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.notfound">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmKeyProperty">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.type1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.length">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType.Undefined">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType.Any">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType.None">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmId">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.generator">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.type1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.length">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.unsavedvalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmId.generator1">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmGenerator">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmGenerator.param">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmGenerator.class">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmDiscriminator">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.notnull">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.length">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.force">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.insert">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmNaturalId">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNaturalId.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmNaturalId.mutable">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmComponent">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.tuplizer">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.parent">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.update">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmDynamicComponent">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.update">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmList">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.Item1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqldeleteall">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.filter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.inverse">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.orderby">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.batchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.collectiontype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.embedxml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.generic">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmList.genericSpecified">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmMap">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.Item1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqldeleteall">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.filter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.inverse">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.orderby">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.batchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.collectiontype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.embedxml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.generic">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.genericSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sort">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeIndex">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeIndex.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeIndex.class">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeMapKey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeMapKey.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeMapKey.class">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.idtype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.metatype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.column1">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.foreignkey">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmMapKey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.length">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.foreignkey">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmOneToOne">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.formula">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.formula1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.constrained">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.foreignkey">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.propertyref">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.embedxml">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.element">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqldeleteall">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.collectiontype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.embedxml">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin.True">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin.False">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin.Auto">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch.Join">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch.Select">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch.Subselect">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmSet">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqldeleteall">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.filter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.inverse">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.orderby">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.batchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.collectiontype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.embedxml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.generic">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.genericSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sort">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmIdbag">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.cache">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.collectionid">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.Item">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqldeleteall">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.filter">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.inverse">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.mutable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.cascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.orderby">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.where">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.batchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.outerjoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.outerjoinSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.fetchSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.collectiontype">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.embedxml">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.generic">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.genericSpecified">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCollectionId">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.generator">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.length">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmTimestamp">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.unsavedvalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.unsavedvalueSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.source">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.generated">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmTimestampUnsavedvalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampUnsavedvalue.Null">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampUnsavedvalue.Undefined">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmTimestampSource">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampSource.Vm">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampSource.Db">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmVersionGeneration">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersionGeneration.Never">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersionGeneration.Always">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmVersion">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.node">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.access">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.column1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.type">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.unsavedvalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.generated">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.insertSpecified">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmProperties">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.unique">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.insert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.update">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.optimisticlock">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmJoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.fetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.inverse">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.optional">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmJoinFetch">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinFetch.Join">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinFetch.Select">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.tuplizer">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.key">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.joinedsubclass1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.resultset">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.Items1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.proxy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.schemaaction">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.dynamicupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.dynamicinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.selectbeforeupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.extends">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.abstract">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.abstractSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmResultSet">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmResultSet.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmResultSet.name">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmLoadCollection">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.returnproperty">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.alias">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.role">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.lockmode">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnProperty">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnProperty.returncolumn">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnProperty.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnProperty.column">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnColumn">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnColumn.name">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmLockMode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.None">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.Read">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.Upgrade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.UpgradeNowait">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.Write">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmReturn">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.returndiscriminator">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.returnproperty">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.alias">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.lockmode">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnDiscriminator">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnDiscriminator.column">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnJoin">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.returnproperty">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.alias">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.property">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.lockmode">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnScalar">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnScalar.column">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnScalar.type">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmQuery">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.Text">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.flushmode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.flushmodeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cacheable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cacheregion">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.fetchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.fetchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.timeout">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cachemode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cachemodeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.readonly">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.readonlySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.comment">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmQueryParam">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQueryParam.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmQueryParam.type">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmFlushMode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFlushMode.Auto">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFlushMode.Never">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFlushMode.Always">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCacheMode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Get">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Ignore">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Normal">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Put">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Refresh">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmSqlQuery">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.Text">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.resultsetref">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.flushmode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.flushmodeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cacheable">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cacheregion">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.fetchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.fetchsizeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.timeout">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cachemode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cachemodeSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.readonly">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.readonlySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.callable">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmSubclass">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.tuplizer">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.join">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.subclass1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.resultset">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.Items1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.proxy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.discriminatorvalue">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.dynamicupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.dynamicinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.selectbeforeupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.extends">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.abstract">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.abstractSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmUnionSubclass">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.subselect">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.synchronize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.comment">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.tuplizer">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.unionsubclass1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.loader">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.sqlinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.sqlupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.sqldelete">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.resultset">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.Items1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.entityname">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.proxy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.table">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.subselect1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.dynamicupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.dynamicinsert">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.selectbeforeupdate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.extends">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.lazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.lazySpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.abstract">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.abstractSpecified">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.persister">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.check">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.batchsize">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.node">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmPolymorphismType">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPolymorphismType.Implicit">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmPolymorphismType.Explicit">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.None">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.Version">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.Dirty">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.All">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmCreate">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmCreate.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmDatabaseObject">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDatabaseObject.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDatabaseObject.dialectscope">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmDefinition">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDefinition.param">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDefinition.class">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmDrop">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDrop.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmDialectScope">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDialectScope.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmDialectScope.Text">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmFilterDef">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.Text">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.condition">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.usemanytoone">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmFilterParam">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterParam.name">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterParam.type">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmMapping">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.meta">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.typedef">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.import">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.Items">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.resultset">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.Items1">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.filterdef">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.databaseobject">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.schema">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.catalog">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.defaultcascade">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.defaultaccess">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.defaultlazy">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.autoimport">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.namespace">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.assembly">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmTypedef">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTypedef.param">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTypedef.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmTypedef.name">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.HbmImport">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmImport.class">
            <remarks/>
        </member>
        <member name="F:NHibernate.Cfg.MappingSchema.HbmImport.rename">
            <remarks/>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.IMappingDocumentParser">
            <summary>
            Responsible for converting a <see cref="T:System.IO.Stream"/> of HBM XML into an instance of
            <see cref="T:NHibernate.Cfg.MappingSchema.HbmMapping"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator">
            <summary>
            Responsible for building a list of <see cref="T:NHibernate.Cfg.MappingSchema.HbmMapping"/> objects from a range of acceptable
            sources.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator.#ctor">
            <summary>
            Calls the greedy constructor, passing it new instances of <see cref="T:NHibernate.Cfg.MappingSchema.MappingDocumentParser"/> and
            <see cref="T:NHibernate.Cfg.MappingSchema.EndsWithHbmXmlFilter"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator.Add(System.Reflection.Assembly,NHibernate.Cfg.MappingSchema.IAssemblyResourceFilter)">
            <summary>Adds any embedded resource streams which pass the <paramref name="filter"/>.</summary>
            <param name="assembly">An assembly containing embedded mapping documents.</param>
            <param name="filter">A custom filter.</param>
        </member>
        <member name="M:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator.Add(System.Reflection.Assembly)">
            <summary>Adds any embedded resource streams which pass the default filter.</summary>
            <param name="assembly">An assembly containing embedded mapping documents.</param>
        </member>
        <member name="T:NHibernate.Cfg.MappingSchema.MappingDocumentParser">
            <summary>
            Responsible for converting a <see cref="T:System.IO.Stream"/> of HBM XML into an instance of
            <see cref="T:NHibernate.Cfg.MappingSchema.HbmMapping"/>.
            </summary>
            <remarks>Uses an <see cref="T:System.Xml.Serialization.XmlSerializer"/> to deserialize HBM.</remarks>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.FullQualifiedClassName(System.String,NHibernate.Cfg.Mappings)">
            <summary>
            Converts a partial class name into a fully qualified one
            </summary>
            <param name="className"></param>
            <param name="mappings"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.FullClassName(System.String,NHibernate.Cfg.Mappings)">
            <summary>
            Converts a partial class name into a fully one
            </summary>
            <param name="className"></param>
            <param name="mappings"></param>
            <returns>The class FullName (without the assembly)</returns>
            <remarks>
            The FullName is equivalent to the default entity-name
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.ClassForFullNameChecked(System.String,System.String)">
            <summary>
            Attempts to find a type by its full name. Throws a <see cref="T:NHibernate.MappingException"/>
            using the provided <paramref name="errorMessage"/> in case of failure.
            </summary>
            <param name="fullName">name of the class to find</param>
            <param name="errorMessage">Error message to use for
            the <see cref="T:NHibernate.MappingException"/> in case of failure. Should contain
            the <c>{0}</c> formatting placeholder.</param>
            <returns>A <see cref="T:System.Type"/> instance.</returns>
            <exception cref="T:NHibernate.MappingException">
            Thrown when there is an error loading the class.
            </exception>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.ClassForNameChecked(System.String,NHibernate.Cfg.Mappings,System.String)">
            <summary>
            Similar to <see cref="M:NHibernate.Cfg.XmlHbmBinding.Binder.ClassForFullNameChecked(System.String,System.String)"/>, but handles short class names
            by calling <see cref="M:NHibernate.Cfg.XmlHbmBinding.Binder.FullQualifiedClassName(System.String,NHibernate.Cfg.Mappings)"/>.
            </summary>
            <param name="name"></param>
            <param name="mappings"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindCollection(NHibernate.Cfg.MappingSchema.ICollectionPropertiesMapping,NHibernate.Mapping.Collection,System.String,System.String,System.Type,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
            <remarks>
            Called for all collections. <paramref name="containingType" /> parameter
            was added in NH to allow for reflection related to generic types.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindArray(NHibernate.Cfg.MappingSchema.HbmArray,NHibernate.Mapping.Array,System.String,System.String,System.Type,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
            <remarks>
            Called for arrays and primitive arrays
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindMapSecondPass(NHibernate.Cfg.MappingSchema.HbmMap,NHibernate.Mapping.Map,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.PersistentClass},System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
            <summary>
            Called for Maps
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindCollectionSecondPass(NHibernate.Cfg.MappingSchema.ICollectionPropertiesMapping,NHibernate.Mapping.Collection,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.PersistentClass},System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
            <remarks>
            Called for all collections
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.XmlHbmBinding.ValuePropertyBinder.AddColumnsAndOrFormulas(NHibernate.Cfg.XmlHbmBinding.ColumnsBinder,System.Object[],System.Boolean)">
            <summary>
            Bind columns and formulas in the order in which they were mapped.
            </summary>
            <param name="binder"></param>
            <param name="columnsAndFormulas"></param>
            <param name="isNullable"></param>
        </member>
        <member name="T:NHibernate.Cfg.ClassExtractor">
            <summary>
            Extracts the names of classes mapped in a given file,
            and the names of the classes they extend.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ClassExtractor.GetClassEntries(NHibernate.Cfg.MappingSchema.HbmMapping)">
            <summary>
            Returns a collection of <see cref="T:NHibernate.Cfg.ClassExtractor.ClassEntry"/> containing
            information about all classes in this stream.
            </summary>
            <param name="document">A validated <see cref="T:System.Xml.XmlDocument"/> representing
            a mapping file.</param>
        </member>
        <member name="T:NHibernate.Cfg.ClassExtractor.ClassEntry">
            <summary>
            Holds information about mapped classes found in the <c>hbm.xml</c> files.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.Configuration">
            <summary>
            Allows the application to specify properties and mapping documents to be used when creating
            a <see cref="T:NHibernate.ISessionFactory"/>.
            </summary>
            <remarks>
            <para>
            Usually an application will create a single <see cref="T:NHibernate.Cfg.Configuration"/>, build a single instance
            of <see cref="T:NHibernate.ISessionFactory"/>, and then instantiate <see cref="T:NHibernate.ISession"/> objects in threads
            servicing client requests.
            </para>
            <para>
            The <see cref="T:NHibernate.Cfg.Configuration"/> is meant only as an initialization-time object. <see cref="T:NHibernate.ISessionFactory"/>
            is immutable and does not retain any association back to the <see cref="T:NHibernate.Cfg.Configuration"/>
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.Configuration.DefaultHibernateCfgFileName">
            <summary>Default name for hibernate configuration file.</summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Reset">
            <summary>
            Clear the internal state of the <see cref="T:NHibernate.Cfg.Configuration"/> object.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.#ctor">
            <summary>
            Create a new Configuration object.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetClassMapping(System.Type)">
            <summary>
            Get the mapping for a particular class
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetClassMapping(System.String)">
            <summary> Get the mapping for a particular entity </summary>
            <param name="entityName">An entity name. </param>
            <returns> the entity mapping information </returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetCollectionMapping(System.String)">
            <summary>
            Get the mapping for a particular collection role
            </summary>
            <param name="role">a collection role</param>
            <returns><see cref="T:NHibernate.Mapping.Collection"/></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddFile(System.String)">
            <summary>
            Read mappings from a particular XML file. This method is equivalent
            to <see cref="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)"/>.
            </summary>
            <param name="xmlFile"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)">
            <summary>
            Read mappings from a particular XML file.
            </summary>
            <param name="xmlFile">a path to a file</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXml(System.String,System.String)">
            <summary>
            Read mappings from a <see cref="T:System.String"/>. This method is equivalent to
            <see cref="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)"/>.
            </summary>
            <param name="xml">an XML string</param>
            <param name="name">The name to use in error reporting. May be <see langword="null"/>.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)">
            <summary>
            Read mappings from a <see cref="T:System.String"/>.
            </summary>
            <param name="xml">an XML string</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddUrl(System.String)">
            <summary>
            Read mappings from a URL.
            </summary>
            <param name="url">a URL</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddUrl(System.Uri)">
            <summary>
            Read mappings from a URL.
            </summary>
            <param name="url">a <see cref="T:System.Uri"/> to read the mappings from.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddDocument(System.Xml.XmlDocument,System.String)">
            <summary>
            Read mappings from an <see cref="T:System.Xml.XmlDocument"/>.
            </summary>
            <param name="doc">A loaded <see cref="T:System.Xml.XmlDocument"/> that contains the mappings.</param>
            <param name="name">The name of the document, for error reporting purposes.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddValidatedDocument(NHibernate.Cfg.NamedXmlDocument)">
            <summary>
            Takes the validated XmlDocument and has the Binder do its work of
            creating Mapping objects from the Mapping Xml.
            </summary>
            <param name="doc">The NamedXmlDocument that contains the <b>validated</b> mapping XML file.</param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddDeserializedMapping(NHibernate.Cfg.MappingSchema.HbmMapping,System.String)">
            <summary>
            Add mapping data using deserialized class.
            </summary>
            <param name="mappingDocument">Mapping metadata.</param>
            <param name="documentFileName">XML file's name where available; otherwise null.</param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.CreateMappings(NHibernate.Dialect.Dialect)">
            <summary>
            Create a new <see cref="T:NHibernate.Cfg.Mappings"/> to add classes and collection
            mappings to.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddInputStream(System.IO.Stream)">
            <summary>
            Read mappings from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="xmlInputStream">The stream containing XML</param>
            <returns>This Configuration object.</returns>
            <remarks>
            The <see cref="T:System.IO.Stream"/> passed in through the parameter <paramref name="xmlInputStream"/>
            is not <em>guaranteed</em> to be cleaned up by this method.  It is the caller's responsiblity to
            ensure that <paramref name="xmlInputStream"/> is properly handled when this method
            completes.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddInputStream(System.IO.Stream,System.String)">
            <summary>
            Read mappings from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="xmlInputStream">The stream containing XML</param>
            <param name="name">The name of the stream to use in error reporting. May be <see langword="null"/>.</param>
            <returns>This Configuration object.</returns>
            <remarks>
            The <see cref="T:System.IO.Stream"/> passed in through the parameter <paramref name="xmlInputStream"/>
            is not <em>guaranteed</em> to be cleaned up by this method.  It is the caller's responsiblity to
            ensure that <paramref name="xmlInputStream"/> is properly handled when this method
            completes.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddResource(System.String,System.Reflection.Assembly)">
            <summary>
            Adds the mappings in the resource of the assembly.
            </summary>
            <param name="path">The path to the resource file in the assembly.</param>
            <param name="assembly">The assembly that contains the resource file.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddResources(System.Collections.Generic.IEnumerable{System.String},System.Reflection.Assembly)">
            <summary>
            Adds the mappings from embedded resources of the assembly.
            </summary>
            <param name="paths">Paths to the resource files in the assembly.</param>
            <param name="assembly">The assembly that contains the resource files.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddClass(System.Type)">
            <summary>
            Read a mapping from an embedded resource, using a convention.
            </summary>
            <param name="persistentClass">The type to map.</param>
            <returns>This configuration object.</returns>
            <remarks>
            The convention is for class <c>Foo.Bar.Foo</c> to be mapped by
            the resource named <c>Foo.Bar.Foo.hbm.xml</c>, embedded in
            the class' assembly. If the mappings and classes are defined
            in different assemblies or don't follow the naming convention,
            this method cannot be used.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.String)">
            <summary>
            Adds all of the assembly's embedded resources whose names end with <c>.hbm.xml</c>.
            </summary>
            <param name="assemblyName">The name of the assembly to load.</param>
            <returns>This configuration object.</returns>
            <remarks>
            The assembly must be loadable using <see cref="M:System.Reflection.Assembly.Load(System.String)"/>. If this
            condition is not satisfied, load the assembly manually and call
            <see cref="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)"/> instead.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Adds all of the assembly's embedded resources whose names end with <c>.hbm.xml</c>.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddDirectory(System.IO.DirectoryInfo)">
            <summary>
            Read all mapping documents from a directory tree. Assume that any
            file named <c>*.hbm.xml</c> is a mapping document.
            </summary>
            <param name="dir">a directory</param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GenerateDropSchemaScript(NHibernate.Dialect.Dialect)">
            <summary>
            Generate DDL for dropping tables
            </summary>
            <seealso cref="T:NHibernate.Tool.hbm2ddl.SchemaExport"/>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GenerateSchemaCreationScript(NHibernate.Dialect.Dialect)">
            <summary>
            Generate DDL for creating tables
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.BuildMappings">
            <summary> 
            Call this to ensure the mappings are fully compiled/built. Usefull to ensure getting
            access to all information in the metamodel when calling e.g. getClassMappings().
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SecondPassCompile">
            <remarks>
            This method may be called many times!!
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.BuildSessionFactory">
            <summary>
            Instantiate a new <see cref="T:NHibernate.ISessionFactory"/>, using the properties and mappings in this
            configuration. The <see cref="T:NHibernate.ISessionFactory"/> will be immutable, so changes made to the
            configuration after building the <see cref="T:NHibernate.ISessionFactory"/> will not affect it.
            </summary>
            <returns>An <see cref="T:NHibernate.ISessionFactory"/> instance.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetDerivedProperties">
            <summary>
            Returns the set of properties computed from the default properties in the dialect combined with the other properties in the configuration.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetDefaultAssembly(System.String)">
            <summary>
            Set the default assembly to use for the mappings added to the configuration
            afterwards.
            </summary>
            <param name="newDefaultAssembly">The default assembly name.</param>
            <returns>This configuration instance.</returns>
            <remarks>
            This setting can be overridden for a mapping file by setting <c>default-assembly</c>
            attribute of <c>&lt;hibernate-mapping&gt;</c> element.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetDefaultNamespace(System.String)">
            <summary>
            Set the default namespace to use for the mappings added to the configuration
            afterwards.
            </summary>
            <param name="newDefaultNamespace">The default namespace.</param>
            <returns>This configuration instance.</returns>
            <remarks>
            This setting can be overridden for a mapping file by setting <c>default-namespace</c>
            attribute of <c>&lt;hibernate-mapping&gt;</c> element.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetInterceptor(NHibernate.IInterceptor)">
            <summary>
            Sets the default interceptor for use by all sessions.
            </summary>
            <param name="newInterceptor">The default interceptor.</param>
            <returns>This configuration instance.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Specify a completely new set of properties
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Adds an <see cref="T:System.Collections.IDictionary"/> of configuration properties.  The 
            Key is the name of the Property and the Value is the <see cref="T:System.String"/>
            value of the Property.
            </summary>
            <param name="additionalProperties">An <see cref="T:System.Collections.IDictionary"/> of configuration properties.</param>
            <returns>
            This <see cref="T:NHibernate.Cfg.Configuration"/> object.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetProperty(System.String,System.String)">
            <summary>
            Sets the value of the configuration property.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="value">The value of the property.</param>
            <returns>
            This configuration object.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetProperty(System.String)">
            <summary>
            Gets the value of the configuration property.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>The configured value of the property, or <see langword="null" /> if the property was not specified.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure">
            <summary>
            Configure NHibernate using the <c>&lt;hibernate-configuration&gt;</c> section
            from the application config file, if found, or the file <c>hibernate.cfg.xml</c> if the
            <c>&lt;hibernate-configuration&gt;</c> section not include the session-factory configuration.
            </summary>
            <returns>A configuration object initialized with the file.</returns>
            <remarks>
            To configure NHibernate explicitly using <c>hibernate.cfg.xml</c>, appling merge/override
            of the application configuration file, use this code:
            <code>
            	configuration.Configure("path/to/hibernate.cfg.xml");
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.String)">
            <summary>
            Configure NHibernate using the file specified.
            </summary>
            <param name="fileName">The location of the XML file to use to configure NHibernate.</param>
            <returns>A Configuration object initialized with the file.</returns>
            <remarks>
            Calling Configure(string) will override/merge the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Reflection.Assembly,System.String)">
            <summary>
            Configure NHibernate using a resource contained in an Assembly.
            </summary>
            <param name="assembly">The <see cref="T:System.Reflection.Assembly"/> that contains the resource.</param>
            <param name="resourceName">The name of the manifest resource being requested.</param>
            <returns>A Configuration object initialized from the manifest resource.</returns>
            <remarks>
            Calling Configure(Assembly, string) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Xml.XmlReader)">
            <summary>
            Configure NHibernate using the specified XmlReader.
            </summary>
            <param name="textReader">The <see cref="T:System.Xml.XmlReader"/> that contains the Xml to configure NHibernate.</param>
            <returns>A Configuration object initialized with the file.</returns>
            <remarks>
            Calling Configure(XmlReader) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetCacheConcurrencyStrategy(System.String,System.String)">
            <summary>
            Set up a cache for an entity class
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetCollectionCacheConcurrencyStrategy(System.String,System.String)">
            <summary>
            Set up a cache for a collection role
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.BuildSettings">
            <summary>
            Create an object-oriented view of the configuration properties
            </summary>
            <returns>A <see cref="T:NHibernate.Cfg.Settings"/> object initialized from the settings properties.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetNamingStrategy(NHibernate.Cfg.INamingStrategy)">
            <summary>
            Set a custom naming strategy
            </summary>
            <param name="newNamingStrategy">the NamingStrategy to set</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.LoadMappingDocument(System.Xml.XmlReader,System.String)">
            <summary>
            Load and validate the mappings in the <see cref="T:System.Xml.XmlReader"/> against
            the nhibernate-mapping-2.2 schema, without adding them to the configuration.
            </summary>
            <remarks>
            This method is made public to be usable from the unit tests. It is not intended
            to be called by end users.
            </remarks>
            <param name="hbmReader">The XmlReader that contains the mapping.</param>
            <param name="name">The name of the document, for error reporting purposes.</param>
            <returns>NamedXmlDocument containing the validated XmlDocument built from the XmlReader.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlReader(System.Xml.XmlReader)">
            <summary>
            Adds the Mappings in the <see cref="T:System.Xml.XmlReader"/> after validating it
            against the nhibernate-mapping-2.2 schema.
            </summary>
            <param name="hbmReader">The XmlReader that contains the mapping.</param>
            <returns>This Configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlReader(System.Xml.XmlReader,System.String)">
            <summary>
            Adds the Mappings in the <see cref="T:System.Xml.XmlReader"/> after validating it
            against the nhibernate-mapping-2.2 schema.
            </summary>
            <param name="hbmReader">The XmlReader that contains the mapping.</param>
            <param name="name">The name of the document to use for error reporting. May be <see langword="null"/>.</param>
            <returns>This Configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetListeners(NHibernate.Event.ListenerType,System.String[])">
            <summary>
            Set or clear listener for a given <see cref="T:NHibernate.Event.ListenerType"/>.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Event.ListenerType"/>.</param>
            <param name="listenerClasses">The array of AssemblyQualifiedName of each listener for <paramref name="type"/>.</param>
            <remarks>
            <paramref name="listenerClasses"/> must implements the interface related with <paramref name="type"/>.
            All listeners of the given <see cref="T:NHibernate.Event.ListenerType"/> will be cleared if the <paramref name="listenerClasses"/> 
            is null or empty.
            </remarks>
            <exception cref="T:NHibernate.MappingException">
            when an element of <paramref name="listenerClasses"/> have an invalid value or cant be instantiated.
            </exception>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetListener(NHibernate.Event.ListenerType,System.Object)">
            <summary>
            Set or clear listener for a given <see cref="T:NHibernate.Event.ListenerType"/>.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Event.ListenerType"/>.</param>
            <param name="listener">The listener for <paramref name="type"/> or null to clear.</param>
            <remarks><paramref name="listener"/> must implements the interface related with <paramref name="type"/>.</remarks>
            <seealso cref="N:NHibernate.Event"/>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetListeners(NHibernate.Event.ListenerType,System.Object[])">
            <summary>
            Set or clear listeners for a given <see cref="T:NHibernate.Event.ListenerType"/>.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Event.ListenerType"/>.</param>
            <param name="listeners">The listener for <paramref name="type"/> or null to clear.</param>
            <remarks>Listeners of <paramref name="listeners"/> must implements one of the interface of event listenesr.</remarks>
            <seealso cref="N:NHibernate.Event"/>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AppendListeners(NHibernate.Event.ListenerType,System.Object[])">
            <summary>
            Append the listeners to the end of the currently configured
            listeners
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GenerateSchemaUpdateScript(NHibernate.Dialect.Dialect,NHibernate.Tool.hbm2ddl.DatabaseMetadata)">
            <summary>
             Generate DDL for altering tables
            </summary>
             <seealso cref="T:NHibernate.Tool.hbm2ddl.SchemaUpdate"/>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.ClassMappings">
            <summary>
            The class mappings 
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.CollectionMappings">
            <summary>
            The collection mappings
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.TableMappings">
            <summary>
            The table mappings
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamedQueries">
            <summary>
            The named queries
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.EntityNotFoundDelegate">
            <summary> 
            Retrieve the user-supplied delegate to handle non-existent entity scenarios.
            </summary>
            <remarks>
            Specify a user-supplied delegate to be used to handle scenarios where an entity could not be
            located by specified id.  This is mainly intended for EJB3 implementations to be able to
            control how proxy initialization errors should be handled...
            </remarks>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Interceptor">
            <summary>
            Gets or sets the <see cref="T:NHibernate.IInterceptor"/> to use.
            </summary>
            <value>The <see cref="T:NHibernate.IInterceptor"/> to use.</value>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Properties">
            <summary>
            Gets or sets the <see cref="T:System.Collections.IDictionary"/> that contains the configuration
            properties and their values.
            </summary>
            <value>
            The <see cref="T:System.Collections.IDictionary"/> that contains the configuration
            properties and their values.
            </value>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Imports">
            <summary>
            Get the query language imports (entityName/className -> AssemblyQualifiedName)
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamedSQLQueries">
            <summary>
            The named SQL queries
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamingStrategy">
            <summary>
            Naming strategy for tables and columns
            </summary>
        </member>
        <member name="T:NHibernate.Engine.IMapping">
            <summary>
            Defines operations common to "compiled" mappings (ie. <c>SessionFactory</c>) and
            "uncompiled" mappings (ie <c>Configuration</c> that are used by implementors of <c>IType</c>
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ConfigurationExtensions.TypeDefinition``1(NHibernate.Cfg.Configuration,System.Action{NHibernate.Cfg.Loquacious.ITypeDefConfigurationProperties})">
             <summary>
             Add a type-definition for mappings.
             </summary>
             <typeparam name="TDef">The peristent type.</typeparam>
             <param name="configuration">The <see cref="T:NHibernate.Cfg.Configuration"/> where add the type-definition.</param>
             <param name="typeDefConfiguration">The custom configuration action.</param>
             <returns>The <see cref="T:NHibernate.Cfg.Configuration"/>.</returns>
             <remarks>
             <para>
             <list type="bullet">
             <listheader>
             <description>Depending on where you will use the type-definition in the mapping the
              <typeparamref name="TDef"/> can be :
             </description>
            </listheader>
            <item>
                <term><see cref="T:NHibernate.UserTypes.IUserType"/></term>
            </item>
            <item>
                <term><see cref="T:NHibernate.UserTypes.IUserCollectionType"/></term>
            </item>
            <item>
                <term><see cref="T:NHibernate.UserTypes.IUserVersionType"/></term>
            </item>
            <item>
                <term><see cref="T:NHibernate.Id.IPersistentIdentifierGenerator"/> </term>
            </item>
            </list>
             </para>
             </remarks>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSectionHandler">
            <summary>
            Summary description for ConfigurationSectionHandler.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.DefaultNamingStrategy">
            <summary>
            The default <cref name="INamingStrategy"/>
            </summary>
            <remarks>See <cref name="ImprovedNamingStrategy"/> for a better alternative</remarks>
        </member>
        <member name="T:NHibernate.Cfg.INamingStrategy">
            <summary>
            A set of rules for determining the physical column and table names given the information in the mapping
            document. May be used to implement project-scoped naming standards for database objects.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return a table name for an entity class
            </summary>
            <param name="className">the fully-qualified class name</param>
            <returns>a table name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return a column name for a property path expression 
            </summary>
            <param name="propertyName">a property path</param>
            <returns>a column name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.TableName(System.String)">
            <summary>
            Alter the table name given in the mapping document
            </summary>
            <param name="tableName">a table name</param>
            <returns>a table name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.ColumnName(System.String)">
            <summary>
            Alter the column name given in the mapping document
            </summary>
            <param name="columnName">a column name</param>
            <returns>a column name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return a table name for a collection
            </summary>
            <param name="className">the fully-qualified name of the owning entity class</param>
            <param name="propertyName">a property path</param>
            <returns>a table name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.LogicalColumnName(System.String,System.String)">
            <summary> 
            Return the logical column name used to refer to a column in the metadata
            (like index, unique constraints etc)
            A full bijection is required between logicalNames and physical ones
            logicalName have to be case insersitively unique for a given table 
            </summary>
            <param name="columnName">given column name if any </param>
            <param name="propertyName">property name of this column </param>
        </member>
        <member name="F:NHibernate.Cfg.DefaultNamingStrategy.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return the unqualified class name
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return the unqualified property name
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.TableName(System.String)">
            <summary>
            Return the argument
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ColumnName(System.String)">
            <summary>
            Return the argument
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return the unqualified property name
            </summary>
            <param name="className"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cfg.EntityCacheUsage">
            <summary>
            Values for class-cache and collection-cache strategy.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.EntityCacheUsage.Readonly">
            <summary>Xml value: read-only</summary>
        </member>
        <member name="F:NHibernate.Cfg.EntityCacheUsage.ReadWrite">
            <summary>Xml value: read-write</summary>
        </member>
        <member name="F:NHibernate.Cfg.EntityCacheUsage.NonStrictReadWrite">
            <summary>Xml value: nonstrict-read-write</summary>
        </member>
        <member name="F:NHibernate.Cfg.EntityCacheUsage.Transactional">
            <summary>Xml value: transactional</summary>
        </member>
        <member name="T:NHibernate.Cfg.EntityCacheUsageParser">
            <summary>
            Helper to parse <see cref="T:NHibernate.Cfg.EntityCacheUsage"/> to and from XML string value.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.EntityCacheUsageParser.ToString(NHibernate.Cfg.EntityCacheUsage)">
            <summary>
            Convert a <see cref="T:NHibernate.Cfg.EntityCacheUsage"/> in its xml expected value.
            </summary>
            <param name="value">The <see cref="T:NHibernate.Cfg.EntityCacheUsage"/> to convert.</param>
            <returns>The <see cref="T:NHibernate.Cfg.EntityCacheUsage"/>.</returns>
        </member>
        <member name="M:NHibernate.Cfg.EntityCacheUsageParser.Parse(System.String)">
            <summary>
            Convert a string to <see cref="T:NHibernate.Cfg.EntityCacheUsage"/>.
            </summary>
            <param name="value">The string that represent <see cref="T:NHibernate.Cfg.EntityCacheUsage"/>.</param>
            <returns>
            The <paramref name="value"/> converted to <see cref="T:NHibernate.Cfg.EntityCacheUsage"/>.
            </returns>
            <exception cref="T:NHibernate.Cfg.HibernateConfigException">If the values is invalid.</exception>
            <remarks>
            See <see cref="T:NHibernate.Cfg.EntityCacheUsage"/> for allowed values.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.Environment">
            <summary>
            Provides access to configuration information.
            </summary>
            <remarks>
            NHibernate has two property scopes:
            <list>
            	<item><description>
            	 Factory-level properties may be passed to the <see cref="T:NHibernate.ISessionFactory"/> when it is
            	 instantiated. Each instance might have different property values. If no properties are
            	 specified, the factory gets them from Environment
            	</description></item>
            	<item><description>
            	 System-level properties are shared by all factory instances and are always determined
            	 by the <see cref="T:NHibernate.Cfg.Environment"/> properties
            	</description></item>
            </list>
            In NHibernate, <c>&lt;hibernate-configuration&gt;</c> section in the application configuration file
            corresponds to Java system-level properties; <c>&lt;session-factory&gt;</c>
            section is the session-factory-level configuration. 
            
            It is possible to use the application configuration file (App.config) together with the NHibernate 
            configuration file (hibernate.cfg.xml) at the same time.
            Properties in hibernate.cfg.xml override/merge properties in application configuration file where same
            property is found. For others configuration a merge is applied.
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.Environment.ConnectionStringName">
            <summary>
            Used to find the .Net 2.0 named connection string
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.DefaultSchema">
            <summary> A default database schema (owner) name to use for unqualified tablenames</summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.DefaultCatalog">
            <summary> A default database catalog name to use for unqualified tablenames</summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.DefaultEntityMode">
            <summary>The EntityMode in which set the Session opened from the SessionFactory.</summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.PreferPooledValuesLo">
            <summary>
            When using an enhanced id generator and pooled optimizers (<see cref="T:NHibernate.Id.Enhanced.IOptimizer"/>),
            prefer interpreting the database value as the lower (lo) boundary. The default is to interpret it as the high boundary.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.FormatSql">
            <summary> Enable formatting of SQL logged to the console</summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.QueryStartupChecking">
            <summary> Should named queries be checked during startup (the default is enabled). </summary>
            <remarks>Mainly intended for test environments.</remarks>
        </member>
        <member name="F:NHibernate.Cfg.Environment.GenerateStatistics">
            <summary> Enable statistics collection</summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.OrderInserts">
            <summary> Enable ordering of insert statements for the purpose of more effecient batching.</summary>
        </member>
        <member name="F:NHibernate.Cfg.Environment.InterceptorsBeforeTransactionCompletionIgnoreExceptions">
            <summary>
            If this setting is set to false, exceptions in IInterceptor.BeforeTransactionCompletion bubble to the caller of ITransaction.Commit and abort the commit.
            If this setting is set to true, exceptions in IInterceptor.BeforeTransactionCompletion are ignored and the commit is performed.
            The default setting is false.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Environment.VerifyProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Issue warnings to user when any obsolete property names are used.
            </summary>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cfg.Environment.Version">
            <summary>
            NHibernate version (informational).
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Environment.Properties">
            <summary>
            Gets a copy of the configuration found in <c>&lt;hibernate-configuration&gt;</c> section
            of app.config/web.config.
            </summary>
            <remarks>
            This is the replacement for hibernate.properties
            </remarks>
        </member>
        <member name="P:NHibernate.Cfg.Environment.BytecodeProvider">
            <summary>
            The bytecode provider to use.
            </summary>
            <remarks>
            This property is read from the <c>&lt;nhibernate&gt;</c> section
            of the application configuration file by default. Since it is not
            always convenient to configure NHibernate through the application
            configuration file, it is also possible to set the property value
            manually. This should only be done before a configuration object
            is created, otherwise the change may not take effect.
            </remarks>
        </member>
        <member name="P:NHibernate.Cfg.Environment.UseReflectionOptimizer">
            <summary>
            Whether to enable the use of reflection optimizer
            </summary>
            <remarks>
            This property is read from the <c>&lt;nhibernate&gt;</c> section
            of the application configuration file by default. Since it is not
            always convenient to configure NHibernate through the application
            configuration file, it is also possible to set the property value
            manually. This should only be done before a configuration object
            is created, otherwise the change may not take effect.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.ExtendsQueueEntry">
            <summary> 
            Represents a mapping queued for delayed processing to await
            processing of an extends entity upon which it depends. 
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.HibernateConfigException">
            <summary>
            An exception that occurs at configuration time, rather than runtime, as a result of
            something screwy in the hibernate.cfg.xml.
            </summary>
        </member>
        <member name="T:NHibernate.MappingException">
            <summary>
            An exception that usually occurs at configuration time, rather than runtime, as a result of
            something screwy in the O-R mappings
            </summary>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException"/> class.
            </summary>
            <remarks>Default message is used.</remarks>
        </member>
        <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Cfg.ImprovedNamingStrategy">
            <summary>
            Summary description for ImprovedNamingStrategy.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.ImprovedNamingStrategy.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return the unqualified class name, mixed case converted to underscores
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return the full property path with underscore separators, mixed case converted to underscores
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.TableName(System.String)">
            <summary>
            Convert mixed case to underscores
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ColumnName(System.String)">
            <summary>
            Convert mixed case to underscores
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return the full property path prefixed by the unqualified class name, with underscore separators, mixed case converted to underscores
            </summary>
            <param name="className"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cfg.Mappings">
            <summary>
            A collection of mappings from classes and collections to relational database tables.
            </summary>
            <remarks>Represents a single <c>&lt;hibernate-mapping&gt;</c> element.</remarks>
        </member>
        <member name="F:NHibernate.Cfg.Mappings.columnNameBindingPerTable">
            <summary> 
            Binding table between the logical column name and the name out of the naming strategy
            for each table.
            According that when the column name is not set, the property name is considered as such
            This means that while theoretically possible through the naming strategy contract, it is
            forbidden to have 2 real columns having the same logical name
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.Mappings.tableNameBinding">
            <summary> 
            Binding between logical table name and physical one (ie after the naming strategy has been applied)
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddClass(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddCollection(NHibernate.Mapping.Collection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddImport(System.String,System.String)">
            <summary>
            Adds an import to allow for the full class name <c>Namespace.Entity (AssemblyQualifiedName)</c> 
            to be referenced as <c>Entity</c> or some other name in HQL.
            </summary>
            <param name="className">The name of the type that is being renamed.</param>
            <param name="rename">The new name to use in HQL for the type.</param>
            <exception cref="T:NHibernate.MappingException">Thrown when the rename already identifies another type.</exception>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.NamingStrategy">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultNamespace">
            <summary>
            The default namespace for persistent classes
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultAssembly">
            <summary>
            The default assembly for persistent classes
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultCascade">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultAccess">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.IsAutoImport">
            <summary>
            Gets or sets a boolean indicating if the Fully Qualified Type name should
            automatically have an import added as the class name.
            </summary>
            <value><see langword="true" /> if the class name should be used as an import.</value>
            <remarks>
            Auto-import is used to shorten the string used to refer to types to just their
            unqualified name.  So if the type <c>MyAssembly.MyNamespace.MyClass, MyAssembly</c> has
            <c>auto-import="false"</c> then all use of it in HQL would need to be the fully qualified
            version <c>MyAssembly.MyNamespace.MyClass</c>. If <c>auto-import="true"</c>, the type could
            be referred to in HQL as just <c>MyClass</c>.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.MappingsQueue">
            <summary>
            Queues mapping files according to their dependency order.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.MappingsQueue.AddDocument(NHibernate.Cfg.NamedXmlDocument)">
            <summary>
            Adds the specified document to the queue.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.MappingsQueue.GetNextAvailableResource">
            <summary>
            Gets a <see cref="T:NHibernate.Cfg.NamedXmlDocument"/> that can now be processed (i.e.
            that doesn't depend on classes not yet processed).
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.MappingsQueue.CheckNoUnavailableEntries">
            <summary>
            Checks that no unprocessed documents remain in the queue.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.MappingsQueueEntry">
            <summary>
            Holds information about mapped classes found in an embedded resource
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.MappingsQueueEntry.RequiredClassNames">
            <summary>
            Gets the names of all entities outside this resource
            needed by the classes in this resource.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.MappingsQueueEntry.ContainedClassNames">
            <summary>
            Gets the names of all entities in this resource
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.Settings">
            <summary>
            Settings that affect the behavior of NHibernate at runtime.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.LinqToHqlGeneratorsRegistry">
            <summary>
            Get the registry to provide Hql-Generators for known properties/methods.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.SettingsFactory">
            <summary>
            Reads configuration properties and configures a <see cref="T:NHibernate.Cfg.Settings"/> instance. 
            </summary>
        </member>
        <member name="T:NHibernate.Classic.ILifecycle">
            <summary>
            Provides callbacks from the <see cref="T:NHibernate.ISession"/> to the persistent object. Persistent classes may
            implement this interface but they are not required to.
            </summary>
            <remarks>
            <para>
            <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/>, <see cref="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)"/>, and <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)"/> are intended to be used
            to cascade saves and deletions of dependent objects. This is an alternative to declaring cascaded
            operations in the mapping file.
            </para>
            <para>
            <see cref="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)"/> may be used to initialize transient properties of the object from its persistent
            state. It may <em>not</em> be used to load dependent objects since the <see cref="T:NHibernate.ISession"/> interface
            may not be invoked from inside this method.
            </para>
            <para>
            A further intended usage of <see cref="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)"/>, <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/>, and <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)"/>
            is to store a reference to the <see cref="T:NHibernate.ISession"/> for later use.
            </para>
            <para>
            If <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/>, <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)"/>, or <see cref="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)"/> return
            <see cref="F:NHibernate.Classic.LifecycleVeto.Veto"/>, the operation is silently vetoed. If a <see cref="T:NHibernate.CallbackException"/>
            is thrown, the operation is vetoed and the exception is passed back to the application.
            </para>
            <para>
            Note that <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)"/> is called after an identifier is assigned to the object, except when
            <c>identity</c> key generation is used.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)">
            <summary>
            Called when an entity is saved
            </summary>
            <param name="s">The session</param>
            <returns>If we should veto the save</returns>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)">
            <summary>
            Called when an entity is passed to <see cref="M:NHibernate.ISession.Update(System.Object)"/>.
            </summary>
            <param name="s">The session</param>
            <returns>A <see cref="T:NHibernate.Classic.LifecycleVeto"/> value indicating whether the operation
            should be vetoed or allowed to proceed.</returns>
            <remarks>
            This method is <em>not</em> called every time the object's state is
            persisted during a flush.
            </remarks>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)">
            <summary>
            Called when an entity is deleted
            </summary>
            <param name="s">The session</param>
            <returns>A <see cref="T:NHibernate.Classic.LifecycleVeto"/> value indicating whether the operation
            should be vetoed or allowed to proceed.</returns>
        </member>
        <member name="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)">
            <summary>
            Called after an entity is loaded. 
            </summary>
            <remarks>
            <note>It is illegal to access the <see cref="T:NHibernate.ISession"/> from inside this method.</note>. 
            However, the object may keep a reference to the session for later use
            </remarks>
            <param name="s">The session</param>
            <param name="id">The identifier</param>
        </member>
        <member name="F:NHibernate.Classic.LifecycleVeto.Veto">
            <summary>
            Veto the action
            </summary>
        </member>
        <member name="F:NHibernate.Classic.LifecycleVeto.NoVeto">
            <summary>
            Accept the action
            </summary>
        </member>
        <member name="T:NHibernate.Classic.IValidatable">
            <summary>
            Implemented by persistent classes with invariants that must be checked before inserting
            into or updating the database
            </summary>
        </member>
        <member name="M:NHibernate.Classic.IValidatable.Validate">
            <summary>
            Validate the state of the object before persisting it. If a violation occurs,
            throw a <see cref="T:NHibernate.Classic.ValidationFailure"/>. This method must not change the state of the object
            by side-effect.
            </summary>
        </member>
        <member name="T:NHibernate.Classic.ValidationFailure">
            <summary>
            Thrown from <see cref="M:NHibernate.Classic.IValidatable.Validate"/> when an invariant was violated. Some applications
            might subclass this exception in order to provide more information about the violation
            </summary>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericBag`1">
            <summary>
            An unordered, unkeyed collection that can contain the same element
            multiple times. The .NET collections API, has no <c>Bag</c>.
            Most developers seem to use <see cref="T:System.Collections.Generic.IList`1"/> to represent bag semantics,
            so NHibernate follows this practice.
            </summary>
            <typeparam name="T">The type of the element the bag should hold.</typeparam>
            <remarks>The underlying collection used is an <see cref="T:System.Collections.Generic.List`1"/></remarks>
        </member>
        <member name="T:NHibernate.Collection.AbstractPersistentCollection">
            <summary>
            Base class for implementing <see cref="T:NHibernate.Collection.IPersistentCollection"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Collection.IPersistentCollection">
            <summary>
            <para>
            Persistent collections are treated as value objects by NHibernate.
            ie. they have no independent existence beyond the object holding
            a reference to them. Unlike instances of entity classes, they are
            automatically deleted when unreferenced and automatically become
            persistent when held by a persistent object. Collections can be
            passed between different objects (change "roles") and this might
            cause their elements to move from one database table to another.
            </para>
            <para>
            NHibernate "wraps" a collection in an instance of
            <see cref="T:NHibernate.Collection.IPersistentCollection"/>. This mechanism is designed
            to support tracking of changes to the collection's persistent
            state and lazy instantiation of collection elements. The downside
            is that only certain abstract collection types are supported and
            any extra semantics are lost.
            </para>
            <para>
            Applications should <b>never</b> use classes in this namespace
            directly, unless extending the "framework" here.
            </para>
            <para>
            Changes to <b>structure</b> of the collection are recorded by the
            collection calling back to the session. Changes to mutable
            elements (ie. composite elements) are discovered by cloning their
            state when the collection is initialized and comparing at flush
            time.
            </para>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetValue">
            <summary>
            Return the user-visible collection (or array) instance
            </summary>
            <returns>
            By default, the NHibernate wrapper is an acceptable collection for
            the end user code to work with because it is interface compatible.
            An NHibernate PersistentList is an IList, an NHibernate PersistentMap is an IDictionary
            and those are the types user code is expecting.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.SetSnapshot(System.Object,System.String,System.Object)">
            <summary> After flushing, re-init snapshot state.</summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.PostAction">
            <summary>
            Clears out any Queued Additions.
            </summary>
            <remarks>
            After a Flush() the database is in synch with the in-memory
            contents of the Collection.  Since everything is in synch remove
            any Queued Additions.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.BeginRead">
            <summary>
            Called just before reading any rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called after reading all rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <remarks>
            This should be overridden by sub collections that use temporary collections
            to store values read from the db.
            </remarks>
            <returns>
            true if NOT has Queued operations
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.AfterInitialize(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called after initializing from cache
            </summary>
            <returns>
            true if NOT has Queued operations
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.UnsetSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Disassociate this collection from the given session.
            </summary>
            <param name="currentSession"></param>
            <returns>true if this was currently associated with the given session</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.SetCurrentSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Associate the collection with the given session.
            </summary>
            <param name="session"></param>
            <returns>false if the collection was already associated with the session</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Read the state of the collection from a disassembled cached value.
            </summary>
            <param name="persister"></param>
            <param name="disassembled"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.Entries(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Iterate all collection entries, during update of the database
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerable"/> that gives access to all entries
            in the collection.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)">
            <summary>
            Reads the row from the <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <remarks>
            This method should be prepared to handle duplicate elements caused by fetching multiple collections.
            </remarks>
            <param name="reader">The IDataReader that contains the value of the Identifier</param>
            <param name="role">The persister for this Collection.</param>
            <param name="descriptor">The descriptor providing result set column names</param>
            <param name="owner">The owner of this Collection.</param>
            <returns>The object that was contained in the row.</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetIdentifier(System.Object,System.Int32)">
            <summary>
            Get the identifier of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetIndex(System.Object,System.Int32,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Get the index of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetElement(System.Object)">
            <summary>
            Get the value of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetSnapshotElement(System.Object,System.Int32)">
            <summary>
            Get the snapshot value of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.BeforeInitialize(NHibernate.Persister.Collection.ICollectionPersister,System.Int32)">
            <summary>
            Called before any elements are read into the collection,
            allowing appropriate initializations to occur.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this persistent collection.</param>
            <param name="anticipatedSize">The anticipated size of the collection after initilization is complete.</param>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.EqualsSnapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Does the current state exactly match the snapshot?
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> to compare the elements of the Collection.</param>
            <returns>
            <see langword="true"/> if the wrapped collection is different than the snapshot
            of the collection or if one of the elements in the collection is
            dirty.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.IsSnapshotEmpty(System.Object)">
            <summary> Is the snapshot empty?</summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Disassemble the collection, ready for the cache
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>The contents of the persistent collection in a cacheable form.</returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the rows for this collection
            need to be recreated in the table.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            <see langword="false"/> by default since most collections can determine which rows need to be
            individually updated/inserted/deleted.  Currently only <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/>'s for <c>many-to-many</c>
            need to be recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetSnapshot(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Return a new snapshot of the current state of the collection
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.ForceInitialization">
            <summary>
            To be called internally by the session, forcing
            immediate initalization.
            </summary>
            <remarks>
            This method is similar to <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)"/>, except that different exceptions are thrown.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.EntryExists(System.Object,System.Int32)">
            <summary>
            Does an element exist at this entry in the collection?
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to insert this element?
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to update this element?
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetDeletes(NHibernate.Persister.Collection.ICollectionPersister,System.Boolean)">
            <summary>
            Get all the elements that need deleting
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.IsWrapper(System.Object)">
            <summary>
            Is this the wrapper for the given underlying collection instance?
            </summary>
            <param name="collection">The collection to see if this IPersistentCollection is wrapping.</param>
            <returns>
            <see langword="true" /> if the IPersistentCollection is wrappping the collection instance,
            <see langword="false" /> otherwise.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetQueuedOrphans(System.String)">
            <summary> Get the "queued" orphans</summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.ClearDirty">
            <summary>
            Clear the dirty flag, after flushing changes
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.Dirty">
            <summary>
            Mark the collection as dirty
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.PreInsert(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called before inserting rows, to ensure that any surrogate keys are fully generated
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.AfterRowInsert(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32,System.Object)">
            <summary>
            Called after inserting a row, to fetch the natively generated id
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IPersistentCollection.GetOrphans(System.Object,System.String)">
            <summary>
            Get all "orphaned" elements
            </summary>
            <param name="snapshot">The snapshot of the collection.</param>
            <param name="entityName">The persistent class whose objects
            the collection is expected to contain.</param>
            <returns>
            An <see cref="T:System.Collections.ICollection"/> that contains all of the elements
            that have been orphaned.
            </returns>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.Owner">
            <summary>
            The owning entity.
            </summary>
            <remarks>
            Note that the owner is only set during the flush
            cycle, and when a new collection wrapper is created
            while loading an entity.
            </remarks>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.Key">
            <summary> Get the current collection key value</summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.Role">
            <summary> Get the current role name</summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.IsUnreferenced">
            <summary> Is the collection unreferenced?</summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.IsDirty">
            <summary>
            Is the collection dirty? Note that this is only
            reliable during the flush cycle, after the
            collection elements are dirty checked against
            the snapshot.
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.StoredSnapshot">
            <summary> Get the snapshot cached by the collection instance </summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.Empty">
            <summary>
            Is the initialized collection empty?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.IsDirectlyAccessible">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the underlying collection is directly
            accessible through code.
            </summary>
            <value>
            <see langword="true"/> if we are not guaranteed that the NHibernate collection wrapper
            is being used.
            </value>
            <remarks>
            This is typically <see langword="false"/> whenever a transient object that contains a collection is being
            associated with an <see cref="T:NHibernate.ISession"/> through <see cref="M:NHibernate.ISession.Save(System.Object)"/> or <see cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)"/>.
            NHibernate can't guarantee that it will know about all operations that would cause NHibernate's collections
            to call <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Read"/> or <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Write"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.WasInitialized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.HasQueuedOperations">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.IPersistentCollection.QueuedAdditionIterator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.#ctor">
            <summary>
            Not called by Hibernate, but used by non-NET serialization, eg. SOAP libraries.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetValue">
            <summary>
            Return the user-visible collection (or array) instance
            </summary>
            <returns>
            By default, the NHibernate wrapper is an acceptable collection for
            the end user code to work with because it is interface compatible.
            An NHibernate PersistentList is an IList, an NHibernate PersistentMap is an IDictionary
            and those are the types user code is expecting.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Read">
            <summary>
            Called by any read-only method of the collection interface
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.ReadSize">
            <summary> Called by the <tt>Count</tt> property</summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Write">
            <summary>
            Called by any writer method of the collection interface
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.QueueOperation(NHibernate.Collection.AbstractPersistentCollection.IDelayedOperation)">
            <summary>
            Queue an addition, delete etc. if the persistent collection supports it
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.PerformQueuedOperations">
            <summary> 
            After reading all existing elements from the database,
            add the queued elements to the underlying collection.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.PostAction">
            <summary>
            Clears out any Queued operation.
            </summary>
            <remarks>
            After flushing, clear any "queued" additions, since the
            database state is now synchronized with the memory state.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.BeginRead">
            <summary>
            Called just before reading any rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called after reading all rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <remarks>
            This should be overridden by sub collections that use temporary collections
            to store values read from the db.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)">
            <summary>
            Initialize the collection, if possible, wrapping any exceptions
            in a runtime exception
            </summary>
            <param name="writing">currently obsolete</param>
            <exception cref="T:NHibernate.LazyInitializationException">if we cannot initialize</exception>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.SetInitialized">
            <summary>
            Mark the collection as initialized.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.UnsetSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Disassociate this collection from the given session.
            </summary>
            <param name="currentSession"></param>
            <returns>true if this was currently associated with the given session</returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.SetCurrentSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Associate the collection with the given session.
            </summary>
            <param name="session"></param>
            <returns>false if the collection was already associated with the session</returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the rows for this collection
            need to be recreated in the table.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            <see langword="false"/> by default since most collections can determine which rows need to be
            individually updated/inserted/deleted.  Currently only <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/>'s for <c>many-to-many</c>
            need to be recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.ForceInitialization">
            <summary>
            To be called internally by the session, forcing
            immediate initalization.
            </summary>
            <remarks>
            This method is similar to <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)"/>, except that different exceptions are thrown.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetSnapshot">
            <summary>
            Gets the Snapshot from the current session the collection is in.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.PreInsert(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Called before inserting rows, to ensure that any surrogate keys are fully generated
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.AfterRowInsert(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32,System.Object)">
            <summary>
            Called after inserting a row, to fetch the natively generated id
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetOrphans(System.Object,System.String)">
            <summary>
            Get all "orphaned" elements
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetOrphans(System.Collections.ICollection,System.Collections.ICollection,System.String,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Given a collection of entity instances that used to
            belong to the collection, and a collection of instances
            that currently belong, return a collection of orphans
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Disassemble the collection, ready for the cache
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.IsWrapper(System.Object)">
            <summary>
            Is this the wrapper for the given underlying collection instance?
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.EntryExists(System.Object,System.Int32)">
            <summary>
            Does an element exist at this entry in the collection?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetDeletes(NHibernate.Persister.Collection.ICollectionPersister,System.Boolean)">
            <summary>
            Get all the elements that need deleting
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Read the state of the collection from a disassembled cached value.
            </summary>
            <param name="persister"></param>
            <param name="disassembled"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to update this element?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)">
            <summary>
            Reads the row from the <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="reader">The IDataReader that contains the value of the Identifier</param>
            <param name="role">The persister for this Collection.</param>
            <param name="descriptor">The descriptor providing result set column names</param>
            <param name="owner">The owner of this Collection.</param>
            <returns>The object that was contained in the row.</returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to insert this element?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetIndex(System.Object,System.Int32,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Get the index of the given collection entry
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractPersistentCollection.BeforeInitialize(NHibernate.Persister.Collection.ICollectionPersister,System.Int32)">
            <summary>
            Called before any elements are read into the collection,
            allowing appropriate initializations to occur.
            </summary>
            <param name="persister">The underlying collection persister. </param>
            <param name="anticipatedSize">The anticipated size of the collection after initilization is complete. </param>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsConnectedToSession">
            <summary>
            Is the collection currently connected to an open session?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsOperationQueueEnabled">
            <summary>
            Is this collection in a state that would allow us to "queue" additions?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.PutQueueEnabled">
            <summary> Is this collection in a state that would allow us to
            "queue" puts? This is a special case, because of orphan
            delete.
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.ClearQueueEnabled">
            <summary> Is this collection in a state that would allow us to
            "queue" clear? This is a special case, because of orphan
            delete.
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsInverseCollection">
            <summary> Is this the "inverse" end of a bidirectional association?</summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.InverseCollectionNoOrphanDelete">
            <summary> 
            Is this the "inverse" end of a bidirectional association with
            no orphan delete enabled?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.InverseOneToManyOrNoOrphanDelete">
            <summary> 
            Is this the "inverse" end of a bidirectional one-to-many, or 
            of a collection with no orphan delete?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.Session">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.Empty">
            <summary>
            Is the initialized collection empty?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsDirectlyAccessible">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the underlying collection is directly
            accessible through code.
            </summary>
            <value>
            <see langword="true"/> if we are not guaranteed that the NHibernate collection wrapper
            is being used.
            </value>
            <remarks>
            This is typically <see langword="false"/> whenever a transient object that contains a collection is being
            associated with an <see cref="T:NHibernate.ISession"/> through <see cref="M:NHibernate.ISession.Save(System.Object)"/> or <see cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)"/>.
            NHibernate can't guarantee that it will know about all operations that would cause NHibernate's collections
            to call <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Read"/> or <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Write"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.WasInitialized">
            <summary> Is this instance initialized?</summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.HasQueuedOperations">
            <summary> Does this instance have any "queued" additions?</summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractPersistentCollection.QueuedAdditionIterator">
            <summary></summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NHibernate.Collection.Generic.PersistentGenericBag`1._gbag" -->
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentBag from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentBag.</param>
            <param name="disassembled">The disassembled PersistentBag.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this PersistentBag needs to be recreated
            in the database.
            </summary>
            <param name="persister"></param>
            <returns>
            <see langword="false"/> if this is a <c>one-to-many</c> Bag, <see langword="true"/> if this is not
            a <c>one-to-many</c> Bag.  Since a Bag is an unordered, unindexed collection 
            that permits duplicates it is not possible to determine what has changed in a
            <c>many-to-many</c> so it is just recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericBag`1.CountOccurrences(System.Object,System.Collections.IEnumerable,NHibernate.Type.IType,NHibernate.EntityMode)">
            <summary>
            Counts the number of times that the <paramref name="element"/> occurs
            in the <paramref name="list"/>.
            </summary>
            <param name="element">The element to find in the list.</param>
            <param name="list">The <see cref="T:System.Collections.IList"/> to search.</param>
            <param name="elementType">The <see cref="T:NHibernate.Type.IType"/> that can determine equality.</param>
            <param name="entityMode">The entity mode.</param>
            <returns>
            The number of occurrences of the element in the list.
            </returns>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentIdentifierBag`1">
            <summary>
            Implements "bag" semantics more efficiently than <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/> by adding
            a synthetic identifier column to the table.
            </summary>
            <remarks>
            <para>
            The identifier is unique for all rows in the table, allowing very efficient
            updates and deletes.  The value of the identifier is never exposed to the 
            application. 
            </para>
            <para>
            Identifier bags may not be used for a many-to-one association.  Furthermore,
            there is no reason to use <c>inverse="true"</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentIdentifierBag`1.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this Bag from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentIdentifierBag.</param>
            <param name="disassembled">The disassembled PersistentIdentifierBag.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericList`1">
            <summary>
            A persistent wrapper for an <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <typeparam name="T">The type of the element the list should hold.</typeparam>
            <remarks>The underlying collection used is a <see cref="T:System.Collections.Generic.List`1"/></remarks>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/>
            in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the list is in.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.Generic.IList{`0})">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/>
            that wraps an existing <see cref="T:System.Collections.IList"/> in the <paramref name="session"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the list is in.</param>
            <param name="list">The <see cref="T:System.Collections.IList"/> to wrap.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericList`1.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentGenericList from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentGenericList.</param>
            <param name="disassembled">The disassembled PersistentList.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericMap`2">
            <summary>
            A persistent wrapper for a <see cref="T:System.Collections.Generic.IDictionary`2"/>.  Underlying
            collection is a <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </summary>
            <typeparam name="TKey">The type of the keys in the IDictionary.</typeparam>
            <typeparam name="TValue">The type of the elements in the IDictionary.</typeparam>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericMap`2.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Construct an uninitialized PersistentGenericMap.
            </summary>
            <param name="session">The ISession the PersistentGenericMap should be a part of.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericMap`2.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Construct an initialized PersistentGenericMap based off the values from the existing IDictionary.
            </summary>
            <param name="session">The ISession the PersistentGenericMap should be a part of.</param>
            <param name="map">The IDictionary that contains the initial values.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericMap`2.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentGenericMap from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentGenericMap.</param>
            <param name="disassembled">The disassembled PersistentGenericMap.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="T:NHibernate.Collection.Generic.PersistentGenericSet`1">
            <summary>
            A persistent wrapper for an <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.Generic.PersistentGenericSet`1.WrappedSet">
            <summary>
            The <see cref="T:System.Collections.Generic.ISet`1"/> that NHibernate is wrapping.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.Generic.PersistentGenericSet`1._tempList">
            <summary>
            A temporary list that holds the objects while the PersistentSet is being
            populated from the database.  
            </summary>
            <remarks>
            This is necessary to ensure that the object being added to the PersistentSet doesn't
            have its' <c>GetHashCode()</c> and <c>Equals()</c> methods called during the load
            process.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Constructor matching super.
            Instantiates a lazy set (the underlying set is un-initialized).
            </summary>
            <param name="session">The session to which this set will belong. </param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.Generic.ISet{`0})">
            <summary> 
            Instantiates a non-lazy set (the underlying set is constructed
            from the incoming set reference).
            </summary>
            <param name="session">The session to which this set will belong. </param>
            <param name="original">The underlying set data. </param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this PersistentSet from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the PersistentSet.</param>
            <param name="disassembled">The disassembled PersistentSet.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.BeginRead">
            <summary>
            Set up the temporary List that will be used in the EndRead() 
            to fully create the set.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Generic.PersistentGenericSet`1.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Takes the contents stored in the temporary list created during <c>BeginRead()</c>
            that was populated during <c>ReadFrom()</c> and write it to the underlying 
            PersistentSet.
            </summary>
        </member>
        <member name="T:NHibernate.Collection.PersistentArrayHolder">
            <summary>
            A persistent wrapper for an array. lazy initialization is NOT supported
            </summary>
            <remarks> Use of Hibernate arrays is not really recommended. </remarks>
        </member>
        <member name="F:NHibernate.Collection.PersistentArrayHolder.tempList">
            <summary>
            A temporary list that holds the objects while the PersistentArrayHolder is being
            populated from the database.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.GetValue">
            <summary>
            Returns the user-visible portion of the NHibernate PersistentArrayHolder.
            </summary>
            <returns>
            The array that contains the data, not the NHibernate wrapper.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.BeginRead">
            <summary>
            Before <see cref="M:NHibernate.Collection.PersistentArrayHolder.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)"/> is called the PersistentArrayHolder needs to setup 
            a temporary list to hold the objects.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Takes the contents stored in the temporary list created during <see cref="M:NHibernate.Collection.PersistentArrayHolder.BeginRead"/>
            that was populated during <see cref="M:NHibernate.Collection.PersistentArrayHolder.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)"/> and write it to the underlying 
            array.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentArrayHolder.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this array holder from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the Array.</param>
            <param name="disassembled">The disassembled Array.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="P:NHibernate.Collection.PersistentArrayHolder.Array">
            <summary>
            Gets or sets the array.
            </summary>
            <value>The array.</value>
        </member>
        <member name="T:NHibernate.Connection.ConnectionProvider">
            <summary>
            The base class for the ConnectionProvider.
            </summary>
        </member>
        <member name="T:NHibernate.Connection.IConnectionProvider">
            <summary>
            A strategy for obtaining ADO.NET <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <remarks>
            The <c>IConnectionProvider</c> interface is not intended to be exposed to the application.
            Instead it is used internally by NHibernate to obtain <see cref="T:System.Data.IDbConnection"/>. 
            Implementors should provide a public default constructor.
            </remarks>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Initialize the connection provider from the given properties.
            </summary>
            <param name="settings">The connection provider settings</param>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Dispose of a used <see cref="T:System.Data.IDbConnection"/>
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.GetConnection">
            <summary>
            Get an open <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <returns>An open <see cref="T:System.Data.IDbConnection"/>.</returns>
        </member>
        <member name="P:NHibernate.Connection.IConnectionProvider.Driver">
            <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver"/> this ConnectionProvider should use to 
            communicate with the .NET Data Provider
            </summary>
            <value>
            The <see cref="T:NHibernate.Driver.IDriver"/> to communicate with the .NET Data Provider.
            </value>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Closes the <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Configures the ConnectionProvider with the Driver and the ConnectionString.
            </summary>
            <param name="settings">An <see cref="T:System.Collections.IDictionary"/> that contains the settings for this ConnectionProvider.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when a <see cref="F:NHibernate.Cfg.Environment.ConnectionString"/> could not be found 
            in the <c>settings</c> parameter or the Driver Class could not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.GetNamedConnectionString(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Get the .NET 2.0 named connection string 
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when a <see cref="F:NHibernate.Cfg.Environment.ConnectionStringName"/> was found 
            in the <c>settings</c> parameter but could not be found in the app.config
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.ConfigureDriver(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Configures the driver for the ConnectionProvider.
            </summary>
            <param name="settings">An <see cref="T:System.Collections.IDictionary"/> that contains the settings for the Driver.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <see cref="F:NHibernate.Cfg.Environment.ConnectionDriver"/> could not be 
            found in the <c>settings</c> parameter or there is a problem with creating
            the <see cref="T:NHibernate.Driver.IDriver"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.GetConnection">
            <summary>
            Get an open <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <returns>An open <see cref="T:System.Data.IDbConnection"/>.</returns>
        </member>
        <member name="F:NHibernate.Connection.ConnectionProvider._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this ConnectionProvider is being Disposed of or Finalized.</param>
            <remarks>
            <p>
            If this ConnectionProvider is being Finalized (<c>isDisposing==false</c>) then make 
            sure not to call any methods that could potentially bring this 
            ConnectionProvider back to life.
            </p>
            <p>
            If any subclasses manage resources that also need to be disposed of this method
            should be overridden, but don't forget to call it in the override.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Connection.ConnectionProvider.ConnectionString">
            <summary>
            Gets the <see cref="T:System.String"/> for the <see cref="T:System.Data.IDbConnection"/>
            to connect to the database.
            </summary>
            <value>
            The <see cref="T:System.String"/> for the <see cref="T:System.Data.IDbConnection"/>
            to connect to the database.
            </value>
        </member>
        <member name="P:NHibernate.Connection.ConnectionProvider.Driver">
            <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver"/> that can create the <see cref="T:System.Data.IDbConnection"/> object.
            </summary>
            <value>
            The <see cref="T:NHibernate.Driver.IDriver"/> that can create the <see cref="T:System.Data.IDbConnection"/>.
            </value>
        </member>
        <member name="T:NHibernate.Connection.ConnectionProviderFactory">
            <summary>
            Instanciates a connection provider given configuration properties.
            </summary>
        </member>
        <member name="T:NHibernate.Connection.DriverConnectionProvider">
            <summary>
            A ConnectionProvider that uses an IDriver to create connections.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Closes and Disposes of the <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.GetConnection">
            <summary>
            Gets a new open <see cref="T:System.Data.IDbConnection"/> through 
            the <see cref="T:NHibernate.Driver.IDriver"/>.
            </summary>
            <returns>
            An Open <see cref="T:System.Data.IDbConnection"/>.
            </returns>
            <exception cref="T:System.Exception">
            If there is any problem creating or opening the <see cref="T:System.Data.IDbConnection"/>.
            </exception>
        </member>
        <member name="T:NHibernate.Connection.UserSuppliedConnectionProvider">
            <summary>
            An implementation of the <c>IConnectionProvider</c> that simply throws an exception when
            a connection is requested.
            </summary>
            <remarks>
            This implementation indicates that the user is expected to supply an ADO.NET connection
            </remarks>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if this method is called
            because the user is responsible for closing <see cref="T:System.Data.IDbConnection"/>s.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for closing
            <see cref="T:System.Data.IDbConnection"/>s.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.GetConnection">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if this method is called
            because the user is responsible for creating <see cref="T:System.Data.IDbConnection"/>s.
            </summary>
            <returns>
            No value is returned because an <see cref="T:System.InvalidOperationException"/> is thrown.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for creating
            <see cref="T:System.Data.IDbConnection"/>s.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Configures the ConnectionProvider with only the Driver class.
            </summary>
            <param name="settings"></param>
            <remarks>
            All other settings of the Connection are the responsibility of the User since they configured
            NHibernate to use a Connection supplied by the User.
            </remarks>
        </member>
        <member name="T:NHibernate.Context.CallSessionContext">
            <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for each <see cref="T:System.Runtime.Remoting.Messaging.CallContext"/>.
            Not recommended for .NET 2.0 web applications.
            </summary>
        </member>
        <member name="T:NHibernate.Context.CurrentSessionContext">
            <summary>
            Extends the contract defined by <see cref="T:NHibernate.Context.ICurrentSessionContext"/>
            by providing methods to bind and unbind sessions to the current context.
            </summary>
            <remarks>
            The notion of a contextual session is managed by some external entity
            (generally some form of interceptor like the HttpModule).
            This external manager is responsible for scoping these contextual sessions
            appropriately binding/unbinding them here for exposure to the application
            through <see cref="M:NHibernate.ISessionFactory.GetCurrentSession"/> calls.
            </remarks>
        </member>
        <member name="T:NHibernate.Context.ICurrentSessionContext">
            <summary>
            Defines the contract for implementations which know how to
            scope the notion of a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>.
            </summary>
            <remarks>
            <para>
            Implementations should adhere to the following:
            <list type="bullet">
            <item><description>contain a constructor accepting a single argument of type
            <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/></description></item>
            <item><description>should be thread safe</description></item>
            <item><description>should be fully serializable</description></item>
            </list>
            </para>
            <para>
            Implementors should be aware that they are also fully responsible for
            cleanup of any generated current-sessions.
            </para>
            <para>
            Note that there will be exactly one instance of the configured
            ICurrentSessionContext implementation per <see cref="T:NHibernate.ISessionFactory"/>.
            </para>
            <para>
            It is recommended to inherit from the class <see cref="T:NHibernate.Context.CurrentSessionContext"/>
            whenever possible as it simplifies the implementation and provides
            single entry point with session binding support.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Context.ICurrentSessionContext.CurrentSession">
            <summary>
            Retrieve the current session according to the scoping defined
            by this implementation.
            </summary>
            <returns>The current session.</returns>
            <exception cref="T:NHibernate.HibernateException">Typically indicates an issue
            locating or creating the current session.</exception>
        </member>
        <member name="M:NHibernate.Context.CurrentSessionContext.CurrentSession">
            <summary>
            Retrieve the current session according to the scoping defined
            by this implementation.
            </summary>
            <returns>The current session.</returns>
            <exception cref="T:NHibernate.HibernateException">Indicates an issue
            locating the current session.</exception>
        </member>
        <member name="M:NHibernate.Context.CurrentSessionContext.Bind(NHibernate.ISession)">
            <summary>
            Binds the specified session to the current context.
            </summary>
        </member>
        <member name="M:NHibernate.Context.CurrentSessionContext.HasBind(NHibernate.ISessionFactory)">
            <summary>
            Returns whether there is a session bound to the current context.
            </summary>
        </member>
        <member name="M:NHibernate.Context.CurrentSessionContext.Unbind(NHibernate.ISessionFactory)">
            <summary>
            Unbinds and returns the current session.
            </summary>
        </member>
        <member name="P:NHibernate.Context.CurrentSessionContext.Session">
            <summary> Gets or sets the currently bound session. </summary>
        </member>
        <member name="M:NHibernate.Context.MapBasedSessionContext.GetMap">
            <summary>
            Get the dicitonary mapping session factory to its current session.
            </summary>
        </member>
        <member name="M:NHibernate.Context.MapBasedSessionContext.SetMap(System.Collections.IDictionary)">
            <summary>
            Set the map mapping session factory to its current session.
            </summary>
        </member>
        <member name="P:NHibernate.Context.MapBasedSessionContext.Session">
            <summary>
            Gets or sets the currently bound session.
            </summary>
        </member>
        <member name="M:NHibernate.Context.CallSessionContext.SetMap(System.Collections.IDictionary)">
            <summary>
            The key is the session factory and the value is the bound session.
            </summary>
        </member>
        <member name="M:NHibernate.Context.CallSessionContext.GetMap">
            <summary>
            The key is the session factory and the value is the bound session.
            </summary>
        </member>
        <member name="T:NHibernate.Context.ReflectiveHttpContext">
            <summary>
            This class allows access to the HttpContext without referring to HttpContext at compile time.
            The accessors are cached as delegates for performance.
            </summary>
        </member>
        <member name="T:NHibernate.Context.ThreadLocalSessionContext">
            <summary>
            A <see cref="T:NHibernate.Context.ICurrentSessionContext"/> impl which scopes the notion of current
            session by the current thread of execution. Threads do not give us a 
            nice hook to perform any type of cleanup making
            it questionable for this impl to actually generate Session instances.  In
            the interest of usability, it was decided to have this default impl
            actually generate a session upon first request and then clean it up
            after the <see cref="T:NHibernate.ITransaction"/> associated with that session
            is committed/rolled-back.  In order for ensuring that happens, the sessions
            generated here are unusable until after {@link Session#beginTransaction()}
            has been called. If <tt>Close()</tt> is called on a session managed by
            this class, it will be automatically unbound.
            <p/>
            Additionally, the static <see cref="M:NHibernate.Context.ThreadLocalSessionContext.Bind(NHibernate.ISession)"/> and <see cref="M:NHibernate.Context.ThreadLocalSessionContext.Unbind(NHibernate.ISessionFactory)"/> methods are
            provided to allow application code to explicitly control opening and
            closing of these sessions.  This, with some from of interception,
            is the preferred approach.  It also allows easy framework integration
            and one possible approach for implementing long-sessions.
            <p/>
            </summary>
        </member>
        <member name="M:NHibernate.Context.ThreadLocalSessionContext.Unbind(NHibernate.ISessionFactory)">
            <summary>
            Unassociate a previously bound session from the current thread of execution.
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Context.ThreadStaticSessionContext">
            <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for each thread using the [<see cref="T:System.ThreadStaticAttribute"/>].
            To avoid if there are two session factories in the same thread.
            </summary>
        </member>
        <member name="P:NHibernate.Context.ThreadStaticSessionContext.Session">
            <summary> Gets or sets the currently bound session. </summary>
        </member>
        <member name="T:NHibernate.Context.WcfOperationSessionContext">
            <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for the current OperationContext in WCF. Works only during the lifetime of a WCF operation.
            </summary>
        </member>
        <member name="T:NHibernate.Context.WebSessionContext">
            <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for each System.Web.HttpContext. Works only with web applications.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.#ctor(NHibernate.Impl.ExpressionProcessor.ProjectionInfo)">
            <summary>
            Constructed with property name
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsBetween(System.Object)">
            <summary>
            Apply a "between" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsIn(System.Collections.ICollection)">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsIn(System.Object[])">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsInG``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsInsensitiveLike(System.Object)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsInsensitiveLike(System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsLike(System.Object)">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsLike(System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsLike(System.String,NHibernate.Criterion.MatchMode,System.Nullable{System.Char})">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsEmpty">
            <summary>
            Apply an "is empty" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsNotEmpty">
            <summary>
            Apply a "not is empty" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsNull">
            <summary>
            Apply an "is null" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.LambdaRestrictionBuilder.IsNotNull">
            <summary>
            Apply an "not is null" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.#ctor(System.String,System.Object)">
            <summary>
            Constructed with property name
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.Eq``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add a property equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.EqAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add a property equal all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.Ge``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than or equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.GeAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than or equal all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.GeSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than or equal some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.Gt``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.GtAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.GtSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.In``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property in subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.Le``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than or equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.LeAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than or equal all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.LeSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than or equal some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.Lt``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.LtAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.LtSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.Ne``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property not equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.LambdaSubqueryBuilder.NotIn``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property not in subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.WithAlias(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Create an alias for the previous projection
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.Select(NHibernate.Criterion.IProjection)">
            <summary>
            Select an arbitrary projection
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectAvg(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A property average value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectAvg(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property average value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectCount(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectCount(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectCountDistinct(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A distinct property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectCountDistinct(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A distinct property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectGroup(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A grouping property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectGroup(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A grouping property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectMax(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A property maximum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectMax(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property maximum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectMin(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A property minimum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectMin(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property minimum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.Select(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A projected property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.Select(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A projected property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectSum(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            A property value sum
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverProjectionBuilder`1.SelectSum(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property value sum
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.#ctor(`0,NHibernate.Impl.ExpressionProcessor.ProjectionInfo)">
            <summary>
            Constructed with property name
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsBetween(System.Object)">
            <summary>
            Apply a "between" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsIn(System.Collections.ICollection)">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsIn(System.Object[])">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsInG``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsInsensitiveLike(System.Object)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsInsensitiveLike(System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsLike(System.Object)">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsLike(System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsLike(System.String,NHibernate.Criterion.MatchMode,System.Nullable{System.Char})">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsEmpty">
            <summary>
            Apply an "is empty" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsNotEmpty">
            <summary>
            Apply a "not is empty" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsNull">
            <summary>
            Apply an "is null" constraint to the named property
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Lambda.QueryOverRestrictionBuilderBase`3.IsNotNull">
            <summary>
            Apply an "not is null" constraint to the named property
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.WhereExists``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add an Exists subquery criterion
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.WhereNotExists``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add a NotExists subquery criterion
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.Where(System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Subquery expression in the format
            .Where(t =&gt; t.Property [==, !=, >, etc.] detachedQueryOver.As&lt;propertyType&gt;())
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.Where(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Subquery expression in the format
            .Where(() =&gt; alias.Property [==, !=, >, etc.] detachedQueryOver.As&lt;propertyType&gt;())
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.WhereAll(System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Subquery expression in the format
            .WhereAll(t =&gt; t.Property [==, !=, >, etc.] detachedQueryOver.As&lt;propertyType&gt;())
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.WhereAll(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Subquery expression in the format
            .WhereAll(() =&gt; alias.Property [==, !=, >, etc.] detachedQueryOver.As&lt;propertyType&gt;())
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.WhereSome(System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Subquery expression in the format
            .WhereSome(t =&gt; t.Property [==, !=, >, etc.] detachedQueryOver.As&lt;propertyType&gt;())
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryBuilderBase`4.WhereSome(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Subquery expression in the format
            .WhereSome(() =&gt; alias.Property [==, !=, >, etc.] detachedQueryOver.As&lt;propertyType&gt;())
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.Eq``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add a property equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.EqAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add a property equal all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.Ge``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than or equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.GeAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than or equal all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.GeSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than or equal some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.Gt``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.GtAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.GtSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property greater than some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.In``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property in subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.Le``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than or equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.LeAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than or equal all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.LeSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than or equal some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.Lt``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.LtAll``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than all subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.LtSome``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property less than some subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.Ne``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property not equal subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="M:NHibernate.Criterion.Lambda.QueryOverSubqueryPropertyBuilderBase`3.NotIn``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Create a property not in subquery criterion
            </summary>
            <param name="detachedCriteria">detached subquery</param>
        </member>
        <member name="T:NHibernate.Criterion.AbstractCriterion">
            <summary>
            Base class for <see cref="T:NHibernate.Criterion.ICriterion"/> implementations.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.ICriterion">
            <summary>
            An object-oriented representation of a query criterion that may be used as a constraint
            in a <see cref="T:NHibernate.ICriteria"/> query.
            </summary>
            <remarks>
            Built-in criterion types are provided by the <c>Expression</c> factory class.
            This interface might be implemented by application classes but, more commonly, application 
            criterion types would extend <c>AbstractCriterion</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.ICriterion.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Render a SqlString fragment for the expression.
            </summary>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Criterion.ICriterion.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
            <returns>An array of TypedValues for the Expression.</returns>
        </member>
        <member name="M:NHibernate.Criterion.ICriterion.GetProjections">
            <summary>
            Return all projections used in this criterion
            </summary>
            <returns>An array of IProjection used by the Expression.</returns>
        </member>
        <member name="M:NHibernate.Criterion.AbstractCriterion.ToString">
            <summary>
            Gets a string representation of the <see cref="T:NHibernate.Criterion.AbstractCriterion"/>.  
            </summary>
            <returns>
            A String that shows the contents of the <see cref="T:NHibernate.Criterion.AbstractCriterion"/>.
            </returns>
            <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what the <see cref="T:NHibernate.Criterion.AbstractCriterion"/>
            looks like.
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.AbstractCriterion.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Render a SqlString for the expression.
            </summary>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Criterion.AbstractCriterion.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
            <returns>An array of TypedValues for the Expression.</returns>
        </member>
        <member name="M:NHibernate.Criterion.AbstractCriterion.GetProjections">
            <summary>
            Return all projections used in this criterion
            </summary>
            <returns>An array of IProjection used by the Expression.</returns>
        </member>
        <member name="M:NHibernate.Criterion.AbstractCriterion.op_False(NHibernate.Criterion.AbstractCriterion)">
            <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.AbstractCriterion.op_True(NHibernate.Criterion.AbstractCriterion)">
            <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.AggregateProjection">
            <summary>
            An Aggregation
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.SimpleProjection">
            <summary>
            A single-column projection that may be aliased
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.IProjection.ToSqlString(NHibernate.ICriteria,System.Int32,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Render the SQL Fragment.
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="position">The position.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <param name="enabledFilters">The enabled filters.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.IProjection.ToGroupSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Render the SQL Fragment to be used in the Group By Clause.
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <param name="enabledFilters">The enabled filters.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.IProjection.GetTypes(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Return types for a particular user-visible alias
            </summary>
            <param name="criteria"></param>
            <param name="criteriaQuery"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.IProjection.GetTypes(System.String,NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="criteria"></param>
            <param name="criteriaQuery"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.IProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Gets the typed values for parameters in this projection
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.IProjection.GetColumnAliases(System.Int32,NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Get the SQL column aliases used by this projection for the columns it writes for inclusion into the
            <code>SELECT</code> clause <see cref="M:NHibernate.Criterion.IProjection.ToSqlString(NHibernate.ICriteria,System.Int32,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})"/>.  NHibernate always uses column aliases 
            to extract data from the <see cref="T:System.Data.IDataReader"/>, so it is important that these be implemented 
            correctly in order for NHibernate to be able to extract these values correctly.
            </summary>
            <param name="position">Just as in <see cref="M:NHibernate.Criterion.IProjection.ToSqlString(NHibernate.ICriteria,System.Int32,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})"/>, represents the number of columns rendered prior to this projection.</param>
            <param name="criteria">The local criteria to which this project is attached (for resolution).</param>
            <param name="criteriaQuery">The overall criteria query instance.</param>
            <returns>The columns aliases.</returns>
        </member>
        <member name="M:NHibernate.Criterion.IProjection.GetColumnAliases(System.String,System.Int32,NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Get the SQL column aliases used by this projection for the columns it writes for inclusion into the
            <code>SELECT</code> clause (<see cref="M:NHibernate.Criterion.IProjection.ToSqlString(NHibernate.ICriteria,System.Int32,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})"/>) for a particular criteria-level alias.
            </summary>
            <param name="alias">The criteria-level alias.</param>
            <param name="position">Just as in <see cref="M:NHibernate.Criterion.IProjection.ToSqlString(NHibernate.ICriteria,System.Int32,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})"/>, represents the number of columns rendered prior to this projection.</param>
            <param name="criteria">The local criteria to which this project is attached (for resolution).</param>
            <param name="criteriaQuery">The overall criteria query instance.</param>
            <returns>The columns aliases.</returns>
        </member>
        <member name="P:NHibernate.Criterion.IProjection.Aliases">
            <summary>
            Get the user-visible aliases for this projection (ie. the ones that will be passed to the ResultTransformer)
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.IProjection.IsGrouped">
            <summary>
            Does this projection specify grouping attributes?
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.IProjection.IsAggregate">
            <summary>
            Does this projection specify aggregate attributes?
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.SimpleProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Gets the typed values for parameters in this projection
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.AliasedProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Gets the typed values for parameters in this projection
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Criterion.AndExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.LogicalExpression"/> that combines two <see cref="T:NHibernate.Criterion.ICriterion"/>s 
            with an <c>and</c> between them.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.LogicalExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that combines two <see cref="T:NHibernate.Criterion.ICriterion"/>s 
            with a operator (either "<c>and</c>" or "<c>or</c>") between them.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.LogicalExpression.#ctor(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.LogicalExpression"/> class that
            combines two other <see cref="T:NHibernate.Criterion.ICriterion"/>s.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Criterion.ICriterion"/> to use in the Left Hand Side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Criterion.ICriterion"/> to use in the Right Hand Side.</param>
        </member>
        <member name="M:NHibernate.Criterion.LogicalExpression.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Combines the <see cref="T:NHibernate.Engine.TypedValue"/> for the Left Hand Side and the 
            Right Hand Side of the Expression into one array.
            </summary>
            <returns>An array of <see cref="T:NHibernate.Engine.TypedValue"/>s.</returns>
        </member>
        <member name="M:NHibernate.Criterion.LogicalExpression.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Converts the LogicalExpression to a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <returns>A well formed SqlString for the Where clause.</returns>
            <remarks>The SqlString will be enclosed by <c>(</c> and <c>)</c>.</remarks>
        </member>
        <member name="M:NHibernate.Criterion.LogicalExpression.ToString">
            <summary>
            Gets a string representation of the LogicalExpression.  
            </summary>
            <returns>
            The String contains the LeftHandSide.ToString() and the RightHandSide.ToString()
            joined by the Op.
            </returns>
            <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what Expressions
            are being combined.
            </remarks>
        </member>
        <member name="P:NHibernate.Criterion.LogicalExpression.LeftHandSide">
            <summary>
            Gets the <see cref="T:NHibernate.Criterion.ICriterion"/> that will be on the Left Hand Side of the Op.
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.LogicalExpression.RightHandSide">
            <summary>
            Gets the <see cref="T:NHibernate.Criterion.ICriterion"/> that will be on the Right Hand Side of the Op.
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.LogicalExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Criterion.Expression"/>s.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.AndExpression.#ctor(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.AndExpression"/> class
            that combines two <see cref="T:NHibernate.Criterion.ICriterion"/>.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Criterion.ICriterion"/> to use as the left hand side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Criterion.ICriterion"/> to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Criterion.AndExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Criterion.ICriterion"/>s.
            </summary>
            <value>The string "<c>and</c>"</value>
        </member>
        <member name="T:NHibernate.Criterion.BetweenExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents a "between" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.BetweenExpression.#ctor(NHibernate.Criterion.IProjection,System.Object,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.BetweenExpression"/> class.
            </summary>
            <param name="projection">The _projection.</param>
            <param name="lo">The _lo.</param>
            <param name="hi">The _hi.</param>
        </member>
        <member name="M:NHibernate.Criterion.BetweenExpression.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.BetweenExpression"/> class for
            the named Property.
            </summary>
            <param name="propertyName">The name of the Property of the Class.</param>
            <param name="lo">The low value for the BetweenExpression.</param>
            <param name="hi">The high value for the BetweenExpression.</param>
        </member>
        <member name="T:NHibernate.Criterion.CastProjection">
            <summary>
            Casting a value from one type to another, at the database
            level
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.Conjunction">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that Junctions together multiple 
            <see cref="T:NHibernate.Criterion.ICriterion"/>s with an <c>and</c>
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.Junction">
            <summary>
            A sequence of logical <see cref="T:NHibernate.Criterion.ICriterion"/>s combined by some associative
            logical operator.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Junction.Add(NHibernate.Criterion.ICriterion)">
            <summary>
            Adds an <see cref="T:NHibernate.Criterion.ICriterion"/> to the list of <see cref="T:NHibernate.Criterion.ICriterion"/>s
            to junction together.
            </summary>
            <param name="criterion">The <see cref="T:NHibernate.Criterion.ICriterion"/> to add.</param>
            <returns>
            This <see cref="T:NHibernate.Criterion.Junction"/> instance.
            </returns>
        </member>
        <member name="M:NHibernate.Criterion.Junction.Add``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Adds an <see cref="T:NHibernate.Criterion.ICriterion"/> to the list of <see cref="T:NHibernate.Criterion.ICriterion"/>s
            to junction together.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Junction.Add(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Adds an <see cref="T:NHibernate.Criterion.ICriterion"/> to the list of <see cref="T:NHibernate.Criterion.ICriterion"/>s
            to junction together.
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Junction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Criterion.ICriterion"/>s.
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Junction.EmptyExpression">
            <summary>
            The <see cref="T:NHibernate.SqlCommand.SqlString"/> corresponding to an instance with no added
            subcriteria.
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Conjunction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Criterion.ICriterion"/>s.
            </summary>
            <value>The string "<c> and </c>"</value>
        </member>
        <member name="T:NHibernate.Criterion.ConstantProjection">
            <summary>
            This is useful if we want to send a value to the database
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.CountProjection">
            <summary>
            A Count
            </summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.RootAlias">
            <summary> The alias that refers to the "root" entity of the criteria query.</summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.AliasToEntityMap">
            <summary> Each row of results is a <see cref="T:System.Collections.IDictionary"/> from alias to entity instance</summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.RootEntity">
            <summary> Each row of results is an instance of the root entity</summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.DistinctRootEntity">
            <summary> Each row of results is a distinct instance of the root entity</summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.Projection">
            <summary> This result transformer is selected implicitly by calling <see cref="M:NHibernate.ICriteria.SetProjection(NHibernate.Criterion.IProjection[])"/> </summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.InnerJoin">
            <summary> Specifies joining to an entity based on an inner join.</summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.FullJoin">
            <summary> Specifies joining to an entity based on a full join.</summary>
        </member>
        <member name="F:NHibernate.Criterion.CriteriaSpecification.LeftJoin">
            <summary> Specifies joining to an entity based on a left outer join.</summary>
        </member>
        <member name="T:NHibernate.Criterion.DetachedCriteria">
            <summary>
            Some applications need to create criteria queries in "detached
            mode", where the Hibernate session is not available. This class
            may be instantiated anywhere, and then a <c>ICriteria</c>
            may be obtained by passing a session to 
            <c>GetExecutableCriteria()</c>. All methods have the
            same semantics and behavior as the corresponding methods of the
            <c>ICriteria</c> interface.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.DetachedCriteria.GetExecutableCriteria(NHibernate.ISession)">
            <summary>
            Get an executable instance of <c>Criteria</c>,
            to actually run the query.</summary>
        </member>
        <member name="M:NHibernate.Criterion.DetachedCriteria.GetExecutableCriteria(NHibernate.IStatelessSession)">
            <summary>
            Get an executable instance of <c>Criteria</c>,
            to actually run the query.</summary>
        </member>
        <member name="M:NHibernate.Criterion.DetachedCriteria.GetRootEntityTypeIfAvailable">
            <summary>
            Gets the root entity type if available, throws otherwise
            </summary>
            <remarks>
            This is an NHibernate specific method, used by several dependent 
            frameworks for advance integration with NHibernate.
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.DetachedCriteria.ClearOrders">
            <summary>
            Clear all orders from criteria.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.Disjunction">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that Junctions together multiple 
            <see cref="T:NHibernate.Criterion.ICriterion"/>s with an <c>or</c>
            </summary>
        </member>
        <member name="P:NHibernate.Criterion.Disjunction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Criterion.ICriterion"/>s.
            </summary>
            <value>The string "<c> or </c>"</value>
        </member>
        <member name="M:NHibernate.Criterion.Distinct.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Gets the typed values for parameters in this projection
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Criterion.EqPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents an "equal" constraint 
            between two properties.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.PropertyExpression">
            <summary>
            Superclass for an <see cref="T:NHibernate.Criterion.ICriterion"/> that represents a
            constraint between two properties (with SQL binary operators).
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The projection.</param>
            <param name="rhsPropertyName">Name of the RHS property.</param>
        </member>
        <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression"/> class.
            </summary>
            <param name="lhsPropertyName">Name of the LHS property.</param>
            <param name="rhsPropertyName">Name of the RHS property.</param>
        </member>
        <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression"/> class.
            </summary>
            <param name="lhsPropertyName">Name of the LHS property.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.PropertyExpression.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Criterion.PropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the property expression.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> class.
            </summary>
            <param name="lhsPropertyName">Name of the LHS property.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The projection.</param>
            <param name="rhsPropertyName">Name of the RHS property.</param>
        </member>
        <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> class
            that compares two mapped properties using an "equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Criterion.EqPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.EqPropertyExpression"/>.
            </summary>
            <value>The string "<c> = </c>"</value>
        </member>
        <member name="T:NHibernate.Criterion.Example">
            <summary>
            Support for <c>Query By Example</c>.
            </summary>
            <example>
            <code>
            List results = session.CreateCriteria(typeof(Parent))
            .Add( Example.Create(parent).IgnoreCase() )
            .CreateCriteria("child")
            .Add( Example.Create( parent.Child ) )
            .List();
            </code>
            </example>
            <remarks>
            "Examples" may be mixed and matched with "Expressions" in the same <see cref="T:NHibernate.ICriteria"/>
            </remarks>
            <seealso cref="T:NHibernate.ICriteria"/>
        </member>
        <member name="M:NHibernate.Criterion.Example.SetEscapeCharacter(System.Nullable{System.Char})">
            <summary> Set escape character for "like" clause</summary>
        </member>
        <member name="M:NHibernate.Criterion.Example.SetPropertySelector(NHibernate.Criterion.Example.IPropertySelector)">
            <summary>
            Set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Criterion.Example"/>.
            </summary>
            <param name="selector">The <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> to determine which properties to include.</param>
            <returns>This <see cref="T:NHibernate.Criterion.Example"/> instance.</returns>
            <remarks>
            This should be used when a custom <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> has
            been implemented.  Otherwise use the methods <see cref="M:NHibernate.Criterion.Example.ExcludeNulls"/> 
            or <see cref="M:NHibernate.Criterion.Example.ExcludeNone"/> to set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/>
            to the <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/>s built into NHibernate.
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.Example.ExcludeZeroes">
            <summary>
            Set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Criterion.Example"/>
            to exclude zero-valued properties.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Example.ExcludeNone">
            <summary>
            Set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Criterion.Example"/>
            to exclude no properties.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Example.EnableLike(NHibernate.Criterion.MatchMode)">
            <summary>
            Use the "like" operator for all string-valued properties with
            the specified <see cref="T:NHibernate.Criterion.MatchMode"/>.
            </summary>
            <param name="matchMode">
            The <see cref="T:NHibernate.Criterion.MatchMode"/> to convert the string to the pattern
            for the <c>like</c> comparison.
            </param>
        </member>
        <member name="M:NHibernate.Criterion.Example.EnableLike">
            <summary>
            Use the "like" operator for all string-valued properties.
            </summary>
            <remarks>
            The default <see cref="T:NHibernate.Criterion.MatchMode"/> is <see cref="F:NHibernate.Criterion.MatchMode.Exact">MatchMode.Exact</see>.
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.Example.ExcludeProperty(System.String)">
            <summary>
            Exclude a particular named property
            </summary>
            <param name="name">The name of the property to exclude.</param>
        </member>
        <member name="M:NHibernate.Criterion.Example.Create(System.Object)">
            <summary>
            Create a new instance, which includes all non-null properties 
            by default
            </summary>
            <param name="entity"></param>
            <returns>A new instance of <see cref="T:NHibernate.Criterion.Example"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Example.#ctor(System.Object,NHibernate.Criterion.Example.IPropertySelector)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.Example"/> class for a particular
            entity.
            </summary>
            <param name="entity">The <see cref="T:System.Object"/> that the Example is being built from.</param>
            <param name="selector">The <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> the Example should use.</param>
        </member>
        <member name="M:NHibernate.Criterion.Example.IsPropertyIncluded(System.Object,System.String,NHibernate.Type.IType)">
            <summary>
            Determines if the property should be included in the Query.
            </summary>
            <param name="value">The value of the property.</param>
            <param name="name">The name of the property.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the property.</param>
            <returns>
            <see langword="true"/> if the Property should be included, <see langword="false"/> if
            the Property should not be a part of the Query.
            </returns>
        </member>
        <member name="M:NHibernate.Criterion.Example.AddPropertyTypedValue(System.Object,NHibernate.Type.IType,System.Collections.IList)">
            <summary>
            Adds a <see cref="T:NHibernate.Engine.TypedValue"/> based on the <c>value</c> 
            and <c>type</c> parameters to the <see cref="T:System.Collections.IList"/> in the
            <c>list</c> parameter.
            </summary>
            <param name="value">The value of the Property.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the Property.</param>
            <param name="list">The <see cref="T:System.Collections.IList"/> to add the <see cref="T:NHibernate.Engine.TypedValue"/> to.</param>
            <remarks>
            This method will add <see cref="T:NHibernate.Engine.TypedValue"/> objects to the <c>list</c> parameter.
            </remarks>
        </member>
        <member name="T:NHibernate.Criterion.Example.IPropertySelector">
            <summary>
            A strategy for choosing property values for inclusion in the query criteria
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Example.IPropertySelector.Include(System.Object,System.String,NHibernate.Type.IType)">
            <summary>
            Determine if the Property should be included.
            </summary>
            <param name="propertyValue">The value of the property that is being checked for inclusion.</param>
            <param name="propertyName">The name of the property that is being checked for inclusion.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the property.</param>
            <returns>
            <see langword="true"/> if the Property should be included in the Query, 
            <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="T:NHibernate.Criterion.Example.AllPropertySelector">
            <summary>
            Implementation of <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> that includes all
            properties regardless of value.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.Example.NotNullOrEmptyStringPropertySelector">
            <summary>
            Implementation of <see cref="T:NHibernate.Criterion.Example.IPropertySelector"/> that includes the
            properties that are not <see langword="null"/> and do not have an <see cref="F:System.String.Empty"/>
            returned by <c>propertyValue.ToString()</c>.
            </summary>
            <remarks>
            This selector is not present in H2.1. It may be useful if nullable types
            are used for some properties.
            </remarks>
        </member>
        <member name="T:NHibernate.Criterion.Expression">
            <summary> 
            This class is semi-deprecated. Use <see cref="T:NHibernate.Criterion.Restrictions"/>. 
            </summary>
            <seealso cref="T:NHibernate.Criterion.Restrictions"/>
        </member>
        <member name="T:NHibernate.Criterion.Restrictions">
            <summary> 
            The <see cref="N:NHibernate.Criterion"/> namespace may be used by applications as a framework for building
            new kinds of <see cref="T:NHibernate.Criterion.ICriterion"/>. 
            However, it is intended that most applications will
            simply use the built-in criterion types via the static factory methods of this class.
            </summary>
            <seealso cref="T:NHibernate.ICriteria"/>
            <seealso cref="T:NHibernate.Criterion.Projections"/>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IdEq(System.Object)">
            <summary>
            Apply an "equal" constraint to the identifier property
            </summary>
            <param name="value"></param>
            <returns>ICriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IdEq(NHibernate.Criterion.IProjection)">
            <summary>
            Apply an "equal" constraint from the projection to the identifier property
            </summary>
            <param name="projection">The projection.</param>
            <returns>ICriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Eq(System.String,System.Object)">
            <summary>
            Apply an "equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Eq(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            Apply an "equal" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Like(System.String,System.Object)">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Like(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            Apply a "like" constraint to the project
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Like(NHibernate.Criterion.IProjection,System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            Apply a "like" constraint to the project
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
            <param name="matchMode">The match mode.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.InsensitiveLike(System.String,System.Object)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>An <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.InsensitiveLike(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
            <returns>
            An <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Gt(System.String,System.Object)">
            <summary>
            Apply a "greater than" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Gt(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            Apply a "greater than" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Lt(System.String,System.Object)">
            <summary>
            Apply a "less than" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Lt(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            Apply a "less than" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Le(System.String,System.Object)">
            <summary>
            Apply a "less than or equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Le(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            Apply a "less than or equal" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Ge(System.String,System.Object)">
            <summary>
            Apply a "greater than or equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Ge(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            Apply a "greater than or equal" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Between(System.String,System.Object,System.Object)">
            <summary>
            Apply a "between" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="lo">The low value for the Property.</param>
            <param name="hi">The high value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Criterion.BetweenExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Between(NHibernate.Criterion.IProjection,System.Object,System.Object)">
            <summary>
            Apply a "between" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="lo">The low value for the Property.</param>
            <param name="hi">The high value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Criterion.BetweenExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.In(System.String,System.Object[])">
            <summary>
            Apply an "in" constraint to the named property 
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An array of values.</param>
            <returns>An <see cref="T:NHibernate.Criterion.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.In(NHibernate.Criterion.IProjection,System.Object[])">
            <summary>
            Apply an "in" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="values">An array of values.</param>
            <returns>An <see cref="T:NHibernate.Criterion.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.In(NHibernate.Criterion.IProjection,System.Collections.ICollection)">
            <summary>
            Apply an "in" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <param name="values">An ICollection of values.</param>
            <returns>An <see cref="T:NHibernate.Criterion.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.In(System.String,System.Collections.ICollection)">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An ICollection of values.</param>
            <returns>An <see cref="T:NHibernate.Criterion.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.InG``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Apply an "in" constraint to the named property. This is the generic equivalent
            of <see cref="M:NHibernate.Criterion.Restrictions.In(System.String,System.Collections.ICollection)"/>, renamed to avoid ambiguity.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            of values.</param>
            <returns>An <see cref="T:NHibernate.Criterion.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.InG``1(NHibernate.Criterion.IProjection,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Apply an "in" constraint to the projection. This is the generic equivalent
            of <see cref="M:NHibernate.Criterion.Restrictions.In(System.String,System.Collections.ICollection)"/>, renamed to avoid ambiguity.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="projection">The projection.</param>
            <param name="values">An <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            of values.</param>
            <returns>An <see cref="T:NHibernate.Criterion.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IsNull(System.String)">
            <summary>
            Apply an "is null" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Criterion.NullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IsNull(NHibernate.Criterion.IProjection)">
            <summary>
            Apply an "is null" constraint to the projection
            </summary>
            <param name="projection">The projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.NullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.EqProperty(System.String,System.String)">
            <summary>
            Apply an "equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.EqProperty(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Apply an "equal" constraint to projection and property
            </summary>
            <param name="projection">The projection.</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.EqProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Apply an "equal" constraint to lshProjection and rshProjection
            </summary>
            <param name="lshProjection">The LHS projection.</param>
            <param name="rshProjection">The RSH projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.EqProperty(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Apply an "equal" constraint to the property and rshProjection
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="rshProjection">The RSH projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(System.String,System.String)">
            <summary>
            Apply an "not equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Apply an "not equal" constraint to projection and property
            </summary>
            <param name="projection">The projection.</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Apply an "not equal" constraint to the projections
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Apply an "not equal" constraint to the projections
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="rhsProjection">The RHS projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GtProperty(System.String,System.String)">
            <summary>
            Apply a "greater than" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GtProperty(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Apply a "greater than" constraint to two properties
            </summary>
            <param name="projection">The projection.</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GtProperty(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "greater than" constraint to two properties
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="projection">The projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GtProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "greater than" constraint to two properties
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GeProperty(System.String,System.String)">
            <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GeProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GeProperty(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
            <param name="projection">The projection.</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.GeProperty(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="projection">The projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LtProperty(System.String,System.String)">
            <summary>
            Apply a "less than" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LtProperty(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Apply a "less than" constraint to two properties
            </summary>
            <param name="projection">The projection.</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LtProperty(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "less than" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="projection">The projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LtProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "less than" constraint to two properties
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LeProperty(System.String,System.String)">
            <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LeProperty(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
            <param name="projection">The projection.</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LeProperty(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="projection">The projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.LeProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IsNotNull(System.String)">
            <summary>
            Apply an "is not null" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Criterion.NotNullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IsNotNull(NHibernate.Criterion.IProjection)">
            <summary>
            Apply an "is not null" constraint to the named property
            </summary>
            <param name="projection">The projection.</param>
            <returns>A <see cref="T:NHibernate.Criterion.NotNullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IsNotEmpty(System.String)">
            <summary>
            Apply an "is not empty" constraint to the named property 
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Criterion.IsNotEmptyExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.IsEmpty(System.String)">
            <summary>
            Apply an "is not empty" constraint to the named property 
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Criterion.IsEmptyExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.And(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
            <summary>
            Return the conjunction of two expressions
            </summary>
            <param name="lhs">The Expression to use as the Left Hand Side.</param>
            <param name="rhs">The Expression to use as the Right Hand Side.</param>
            <returns>An <see cref="T:NHibernate.Criterion.AndExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Or(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
            <summary>
            Return the disjuction of two expressions
            </summary>
            <param name="lhs">The Expression to use as the Left Hand Side.</param>
            <param name="rhs">The Expression to use as the Right Hand Side.</param>
            <returns>An <see cref="T:NHibernate.Criterion.OrExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Not(NHibernate.Criterion.ICriterion)">
            <summary>
            Return the negation of an expression
            </summary>
            <param name="expression">The Expression to negate.</param>
            <returns>A <see cref="T:NHibernate.Criterion.NotExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Conjunction">
            <summary>
            Group expressions together in a single conjunction (A and B and C...)
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Disjunction">
            <summary>
            Group expressions together in a single disjunction (A or B or C...)
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.AllEq(System.Collections.IDictionary)">
            <summary>
            Apply an "equals" constraint to each property in the key set of a IDictionary
            </summary>
            <param name="propertyNameValues">a dictionary from property names to values</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Where``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Create an ICriterion for the supplied LambdaExpression
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="expression">lambda expression</param>
            <returns>return NHibernate.Criterion.ICriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.Where(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Create an ICriterion for the supplied LambdaExpression
            </summary>
            <param name="expression">lambda expression</param>
            <returns>return NHibernate.Criterion.ICriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.WhereNot``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Create an ICriterion for the negation of the supplied LambdaExpression
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="expression">lambda expression</param>
            <returns>return NHibernate.Criterion.ICriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.WhereNot(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Create an ICriterion for the negation of the supplied LambdaExpression
            </summary>
            <param name="expression">lambda expression</param>
            <returns>return NHibernate.Criterion.ICriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.On``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Build an ICriterion for the given property
            </summary>
            <param name="expression">lambda expression identifying property</param>
            <returns>returns LambdaRestrictionBuilder</returns>
        </member>
        <member name="M:NHibernate.Criterion.Restrictions.On(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Build an ICriterion for the given property
            </summary>
            <param name="expression">lambda expression identifying property</param>
            <returns>returns LambdaRestrictionBuilder</returns>
        </member>
        <member name="M:NHibernate.Criterion.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameters
            </summary>
            <param name="sql"></param>
            <param name="values"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object,NHibernate.Type.IType)">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameter
            </summary>
            <param name="sql"></param>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Expression.Sql(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameter
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Expression.Sql(NHibernate.SqlCommand.SqlString)">
            <summary>
            Apply a constraint expressed in SQL
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Expression.Sql(System.String)">
            <summary>
            Apply a constraint expressed in SQL
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Criterion.GePropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents an "greater than or equal" constraint
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression"/> class.
            </summary>
            <param name="lhsPropertyName">Name of the LHS property.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The projection.</param>
            <param name="rhsPropertyName">Name of the RHS property.</param>
        </member>
        <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression"/> class
            that compares two mapped properties using an "greater than or equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Criterion.GePropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LtPropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="M:NHibernate.Criterion.GroupedProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Gets the typed values for parameters in this projection
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Criterion.GtPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents an "greater than" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression"/> class.
            </summary>
            <param name="lhsPropertyName">Name of the LHS property.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The projection.</param>
            <param name="rhsPropertyName">Name of the RHS property.</param>
        </member>
        <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression"/> class
            that compares two mapped properties using an "greater than" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Criterion.GtPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LtPropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Criterion.ICriteriaQuery">
            <summary> 
            An instance of <see cref="T:NHibernate.Criterion.ICriteriaQuery"/> is passed to criterion, 
            order and projection instances when actually compiling and
            executing the query. This interface is not used by application
            code. 
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetColumn(NHibernate.ICriteria,System.String)">
            <summary>Get the name of the column mapped by a property path, ignoring projection alias</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetColumns(NHibernate.ICriteria,System.String)">
            <summary>Get the names of the columns mapped by a property path, ignoring projection aliases</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetType(NHibernate.ICriteria,System.String)">
            <summary>Get the type of a property path, ignoring projection aliases</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetColumnsUsingProjection(NHibernate.ICriteria,System.String)">
            <summary>Get the names of the columns mapped by a property path</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetTypeUsingProjection(NHibernate.ICriteria,System.String)">
            <summary>Get the type of a property path</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetTypedValue(NHibernate.ICriteria,System.String,System.Object)">
            <summary>Get the a typed value for the given property value.</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetEntityName(NHibernate.ICriteria)">
            <summary>Get the entity name of an entity</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetEntityName(NHibernate.ICriteria,System.String)">
            <summary> 
            Get the entity name of an entity, taking into account
            the qualifier of the property path
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetSQLAlias(NHibernate.ICriteria)">
            <summary>Get the root table alias of an entity</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetSQLAlias(NHibernate.ICriteria,System.String)">
            <summary> 
            Get the root table alias of an entity, taking into account
            the qualifier of the property path
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetPropertyName(System.String)">
            <summary>Get the property name, given a possibly qualified property name</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetIdentifierColumns(NHibernate.ICriteria)">
            <summary>Get the identifier column names of this entity</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.GetIdentifierType(NHibernate.ICriteria)">
            <summary>Get the identifier type of this entity</summary>
        </member>
        <member name="M:NHibernate.Criterion.ICriteriaQuery.NewQueryParameter(NHibernate.Engine.TypedValue)">
            <summary>
            Create a new query parameter to use in a <see cref="T:NHibernate.Criterion.ICriterion"/>
            </summary>
            <param name="parameter">The value and the <see cref="T:NHibernate.Type.IType"/> of the parameter.</param>
            <returns>A new instance of a query parameter to be added to a <see cref="T:NHibernate.SqlCommand.SqlString"/>.</returns>
        </member>
        <member name="T:NHibernate.Criterion.IdentifierEqExpression">
            <summary>
            An identifier constraint
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.InExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that constrains the property
            to a specified list of values.
            </summary>
            <remarks>
            InExpression - should only be used with a Single Value column - no multicolumn properties...
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.InExpression.#ctor(NHibernate.Criterion.IProjection,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.InExpression"/> class.
            </summary>
            <param name="projection">The projection.</param>
            <param name="values">The _values.</param>
        </member>
        <member name="M:NHibernate.Criterion.InExpression.GetElementType(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Determine the type of the elements in the IN clause.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.InsensitiveLikeExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents an "like" constraint
            that is <b>not</b> case sensitive.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.InsensitiveLikeExpression.#ctor(NHibernate.Criterion.IProjection,System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression"/> class.
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value.</param>
            <param name="matchMode">The match mode.</param>
        </member>
        <member name="M:NHibernate.Criterion.InsensitiveLikeExpression.#ctor(NHibernate.Criterion.IProjection,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression"/> class.
            </summary>
            <param name="projection">The projection.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NHibernate.Criterion.InsensitiveLikeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression"/> 
            class for a named Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="T:NHibernate.Criterion.IsEmptyExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents empty association constraint.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.IsNotEmptyExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents non-empty association constraint.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.LePropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents an "less than or equal" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression"/> class.
            </summary>
            <param name="lhsPropertyName">Name of the LHS property.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The projection.</param>
            <param name="rhsPropertyName">Name of the RHS property.</param>
        </member>
        <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression"/> class
            that compares two mapped properties using an "less than or equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Criterion.LePropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LePropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt;= </c>"</value>
        </member>
        <member name="T:NHibernate.Criterion.LikeExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents an "like" constraint.
            </summary>
            <remarks>
            The case sensitivity depends on the database settings for string
            comparisons.  Use <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression"/> if the
            string comparison should not be case sensitive.
            </remarks>
        </member>
        <member name="T:NHibernate.Criterion.LtPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents an "less than" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> class.
            </summary>
            <param name="lhsPropertyName">Name of the LHS property.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The LHS projection.</param>
            <param name="rhsProjection">The RHS projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> class.
            </summary>
            <param name="lhsProjection">The projection.</param>
            <param name="rhsPropertyName">Name of the RHS property.</param>
        </member>
        <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression"/> class
            that compares two mapped properties using an "less than" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Criterion.LtPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LtPropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Criterion.MatchMode">
            <summary>
            Represents an strategy for matching strings using "like".
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.#ctor(System.Int32,System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode"/> class.
            </summary>
            <param name="intCode">The code that identifies the match mode.</param>
            <param name="name">The friendly name of the match mode.</param>
            <remarks>
            The parameter <c>intCode</c> is used as the key of <see cref="T:System.Collections.IDictionary"/>
            to store instances and to ensure only instance of a particular <see cref="T:NHibernate.Criterion.MatchMode"/>
            is created.
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.ToString">
            <summary>
            The string representation of the <see cref="T:NHibernate.Criterion.MatchMode"/>.
            </summary>
            <returns>The friendly name used to describe the <see cref="T:NHibernate.Criterion.MatchMode"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.ToMatchString(System.String)">
            <summary>
            Convert the pattern, by appending/prepending "%"
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>
            A <see cref="T:System.String"/> that contains a "%" in the appropriate place
            for the Match Strategy.
            </returns>
        </member>
        <member name="F:NHibernate.Criterion.MatchMode.Exact">
            <summary>
            Match the entire string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Criterion.MatchMode.Start">
            <summary>
            Match the start of the string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Criterion.MatchMode.End">
            <summary>
            Match the end of the string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Criterion.MatchMode.Anywhere">
            <summary>
            Match the pattern anywhere in the string
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.MatchMode.ExactMatchMode">
            <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode"/> that matches the entire string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.ExactMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.ExactMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.ExactMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Exact MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> exactly the same as it was passed in.</returns>
        </member>
        <member name="T:NHibernate.Criterion.MatchMode.StartMatchMode">
            <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode"/> that matches the start of the string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.StartMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.StartMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.StartMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Start MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the end.</returns>
        </member>
        <member name="T:NHibernate.Criterion.MatchMode.EndMatchMode">
            <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode"/> that matches the end of the string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.EndMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.EndMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.EndMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the End MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning.</returns>
        </member>
        <member name="T:NHibernate.Criterion.MatchMode.AnywhereMatchMode">
            <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode"/> that exactly matches the string
            by appending "<c>%</c>" to the beginning and end.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.AnywhereMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.AnywhereMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.MatchMode.AnywhereMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Exact MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning and the end.</returns>
        </member>
        <member name="T:NHibernate.Criterion.NotExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that negates another <see cref="T:NHibernate.Criterion.ICriterion"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.NotExpression.#ctor(NHibernate.Criterion.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.NotExpression"/> class for an
            <see cref="T:NHibernate.Criterion.ICriterion"/>
            </summary>
            <param name="criterion">The <see cref="T:NHibernate.Criterion.ICriterion"/> to negate.</param>
        </member>
        <member name="T:NHibernate.Criterion.NotNullExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents "not null" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.NotNullExpression.#ctor(NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.NotNullExpression"/> class.
            </summary>
            <param name="projection">The projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.NotNullExpression.#ctor(System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.NotNullExpression"/> class for a named
            Property that should not be null.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
        </member>
        <member name="T:NHibernate.Criterion.NullExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that represents "null" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.NullExpression.#ctor(NHibernate.Criterion.IProjection)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.NullExpression"/> class.
            </summary>
            <param name="projection">The projection.</param>
        </member>
        <member name="M:NHibernate.Criterion.NullExpression.#ctor(System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.NotNullExpression"/> class for a named
            Property that should be null.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
        </member>
        <member name="M:NHibernate.Criterion.NullExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Criterion.Order">
            <summary>
            Represents an order imposed upon a <see cref="T:NHibernate.ICriteria"/>
            result set.
            </summary>
            <remarks>
            Should Order implement ICriteriaQuery?
            </remarks>
        </member>
        <member name="M:NHibernate.Criterion.Order.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Render the SQL fragment
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Order.Asc(System.String)">
            <summary>
            Ascending order
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Order.Asc(NHibernate.Criterion.IProjection)">
            <summary>
            Ascending order
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Order.Desc(NHibernate.Criterion.IProjection)">
            <summary>
            Descending order
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Order.Desc(System.String)">
            <summary>
            Descending order
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Criterion.OrExpression">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that combines two <see cref="T:NHibernate.Criterion.ICriterion"/>s with an 
            <c>"or"</c> between them.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.OrExpression.#ctor(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.OrExpression"/> class for 
            two <see cref="T:NHibernate.Criterion.ICriterion"/>s.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Criterion.ICriterion"/> to use as the left hand side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Criterion.ICriterion"/> to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Criterion.OrExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Criterion.Expression"/>s.
            </summary>
            <value>Returns "<c>or</c>"</value>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionList.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Gets the typed values for parameters in this projection
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Criterion.Projections">
            <summary>
            The <tt>criterion</tt> package may be used by applications as a framework for building
            new kinds of <tt>Projection</tt>. However, it is intended that most applications will
            simply use the built-in projection types via the static factory methods of this class.<br/>
            <br/>
            The factory methods that take an alias allow the projected value to be referred to by 
            criterion and order instances.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Distinct(NHibernate.Criterion.IProjection)">
            <summary>
            Create a distinct projection from a projection
            </summary>
            <param name="proj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.ProjectionList">
            <summary>
            Create a new projection list
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.RowCount">
            <summary>
            The query row count, ie. <tt>count(*)</tt>
            </summary>
            <returns>The RowCount projection mapped to an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.RowCountInt64">
            <summary>
            The query row count, ie. <tt>count(*)</tt>
            </summary>
            <returns>The RowCount projection mapped to an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Count(NHibernate.Criterion.IProjection)">
            <summary>
            A property value count
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Count(System.String)">
            <summary>
            A property value count
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.CountDistinct(System.String)">
            <summary>
            A distinct property value count
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Max(System.String)">
            <summary>
            A property maximum value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Max(NHibernate.Criterion.IProjection)">
            <summary>
            A projection maximum value
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Min(System.String)">
            <summary>
            A property minimum value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Min(NHibernate.Criterion.IProjection)">
            <summary>
            A projection minimum value
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Avg(System.String)">
            <summary>
            A property average value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Avg(NHibernate.Criterion.IProjection)">
            <summary>
            A property average value
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Sum(System.String)">
            <summary>
            A property value sum
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Sum(NHibernate.Criterion.IProjection)">
            <summary>
            A property value sum
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.SqlProjection(System.String,System.String[],NHibernate.Type.IType[])">
            <summary>
            A SQL projection, a typed select clause fragment
            </summary>
            <param name="sql"></param>
            <param name="columnAliases"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.SqlGroupProjection(System.String,System.String,System.String[],NHibernate.Type.IType[])">
            <summary>
            A grouping SQL projection, specifying both select clause and group by clause fragments
            </summary>
            <param name="sql"></param>
            <param name="groupBy"></param>
            <param name="columnAliases"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.GroupProperty(System.String)">
            <summary>
            A grouping property value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.GroupProperty(NHibernate.Criterion.IProjection)">
            <summary>
            A grouping projection value
            </summary>
            <param name="projection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Property(System.String)">
            <summary>
            A projected property value
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Id">
            <summary>
            A projected identifier value
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Alias(NHibernate.Criterion.IProjection,System.String)">
            <summary>
            Assign an alias to a projection, by wrapping it
            </summary>
            <param name="projection"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Cast(NHibernate.Type.IType,NHibernate.Criterion.IProjection)">
            <summary>
            Casts the projection result to the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="projection">The projection.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Constant(System.Object)">
            <summary>
            Return a constant value
            </summary>
            <param name="obj">The obj.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Constant(System.Object,NHibernate.Type.IType)">
            <summary>
            Return a constant value
            </summary>
            <param name="obj">The obj.</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.SqlFunction(System.String,NHibernate.Type.IType,NHibernate.Criterion.IProjection[])">
            <summary>
            Calls the named <see cref="T:NHibernate.Dialect.Function.ISQLFunction"/>
            </summary>
            <param name="functionName">Name of the function.</param>
            <param name="type">The type.</param>
            <param name="projections">The projections.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.SqlFunction(NHibernate.Dialect.Function.ISQLFunction,NHibernate.Type.IType,NHibernate.Criterion.IProjection[])">
            <summary>
            Calls the specified <see cref="T:NHibernate.Dialect.Function.ISQLFunction"/>
            </summary>
            <param name="function">the function.</param>
            <param name="type">The type.</param>
            <param name="projections">The projections.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Conditional(NHibernate.Criterion.ICriterion,NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
            <summary>
            Conditionally return the true or false part, dependention on the criterion
            </summary>
            <param name="criterion">The criterion.</param>
            <param name="whenTrue">The when true.</param>
            <param name="whenFalse">The when false.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Avg``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A property average value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Avg(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property average value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Count``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Count(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.CountDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A distinct property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.CountDistinct(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A distinct property value count
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Group``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A grouping property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Group(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A grouping property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Max``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A property maximum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Max(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property maximum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Min``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A property minimum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Min(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property minimum value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Property``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A projected property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Property(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A projected property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Sum``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            A property value sum
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Sum(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            A property value sum
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Projections.Concat(System.String[])">
            <summary>
            Project SQL function concat()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.WithAlias(NHibernate.Criterion.IProjection,System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Create an alias for a projection
            </summary>
            <param name="projection">the projection instance</param>
            <param name="alias">LambdaExpression returning an alias</param>
            <returns>return NHibernate.Criterion.IProjection</returns>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.YearPart(System.DateTime)">
            <summary>
            Project SQL function year()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.DayPart(System.DateTime)">
            <summary>
            Project SQL function day()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.MonthPart(System.DateTime)">
            <summary>
            Project SQL function month()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.HourPart(System.DateTime)">
            <summary>
            Project SQL function hour()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.MinutePart(System.DateTime)">
            <summary>
            Project SQL function minute()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.SecondPart(System.DateTime)">
            <summary>
            Project SQL function second()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.DatePart(System.DateTime)">
            <summary>
            Project SQL function date()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Sqrt(System.Double)">
            <summary>
            Project SQL function sqrt()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Sqrt(System.Int32)">
            <summary>
            Project SQL function sqrt()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Sqrt(System.Int64)">
            <summary>
            Project SQL function sqrt()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Sqrt(System.Decimal)">
            <summary>
            Project SQL function sqrt()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Sqrt(System.Byte)">
            <summary>
            Project SQL function sqrt()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Lower(System.String)">
            <summary>
            Project SQL function lower()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Upper(System.String)">
            <summary>
            Project SQL function upper()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Abs(System.Int32)">
            <summary>
            Project SQL function abs()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Abs(System.Int64)">
            <summary>
            Project SQL function abs()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Abs(System.Double)">
            <summary>
            Project SQL function abs()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.TrimStr(System.String)">
            <summary>
            Project SQL function trim()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.StrLength(System.String)">
            <summary>
            Project SQL function length()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.BitLength(System.String)">
            <summary>
            Project SQL function bit_length()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Substr(System.String,System.Int32,System.Int32)">
            <summary>
            Project SQL function substring()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.CharIndex(System.String,System.String,System.Int32)">
            <summary>
            Project SQL function locate()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Coalesce``1(``0,``0)">
            <summary>
            Project SQL function coalesce()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Coalesce``1(System.Nullable{``0},``0)">
            <summary>
            Project SQL function coalesce()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.ProjectionsExtensions.Mod(System.Int32,System.Int32)">
            <summary>
            Project SQL function mod()
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.Property">
            <summary>
            A factory for property-specific  AbstractCriterion  and projection instances
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.PropertyProjection">
            <summary>
            A property value, or grouped property value
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Property.GetProperty(System.String)">
            <summary>
            Get a component attribute of this property
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.PropertySubqueryExpression">
            <summary>
            A comparison between a property value in the outer query and the
             result of a subquery
            </summary>
        </member>
        <member name="T:NHibernate.IQueryOver`1">
            <summary>
            QueryOver&lt;TRoot&gt; is an API for retrieving entities by composing
            <see cref="T:NHibernate.Criterion.Expression"/> objects expressed using Lambda expression syntax.
            </summary>
            <remarks>
            <code>
            IList&lt;Cat&gt; cats = session.QueryOver&lt;Cat&gt;()
            	.Where( c =&gt; c.Name == "Tigger" )
            	.And( c =&gt; c.Weight &gt; minWeight ) )
            	.List();
            </code>
            </remarks>
        </member>
        <member name="P:NHibernate.IQueryOver.UnderlyingCriteria">
            <summary>
            Access the underlying ICriteria
            </summary>
        </member>
        <member name="P:NHibernate.IQueryOver.RootCriteria">
            <summary>
            Access the root underlying ICriteria
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.List">
            <summary>
            Get the results of the root type and fill the <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <returns>The list filled with the results.</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`1.List``1">
            <summary>
            Get the results of the root type and fill the <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <returns>The list filled with the results.</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`1.ToRowCountQuery">
            <summary>
            Clones the QueryOver, removes orders and paging, and projects the row-count
            for the query
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.ToRowCountInt64Query">
            <summary>
            Clones the QueryOver, removes orders and paging, and projects the row-count (Int64)
            for the query
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.RowCount">
            <summary>
            Short for ToRowCountQuery().SingleOrDefault&lt;int&gt;()
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.RowCountInt64">
            <summary>
            Short for ToRowCountInt64Query().SingleOrDefault&lt;long&gt;()
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.SingleOrDefault">
            <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
            <returns>the single result or <see langword="null"/></returns>
            <exception cref="T:NHibernate.HibernateException">
            If there is more than one matching result
            </exception>
        </member>
        <member name="M:NHibernate.IQueryOver`1.SingleOrDefault``1">
            <summary>
            Override type of <see cref="M:NHibernate.IQueryOver`1.SingleOrDefault"/>.
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.Future">
            <summary>
            Get a enumerable that when enumerated will execute
            a batch of queries in a single database roundtrip
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.Future``1">
            <summary>
            Get a enumerable that when enumerated will execute
            a batch of queries in a single database roundtrip
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.FutureValue">
            <summary>
            Get an IFutureValue instance, whose value can be retrieved through
            its Value property. The query is not executed until the Value property
            is retrieved, which will execute other Future queries as well in a
            single roundtrip
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.FutureValue``1">
            <summary>
            Get an IFutureValue instance, whose value can be retrieved through
            its Value property. The query is not executed until the Value property
            is retrieved, which will execute other Future queries as well in a
            single roundtrip
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.Clone">
            <summary>
            Creates an exact clone of the IQueryOver
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.ClearOrders">
            <summary>
            Clear all orders from the query.
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.Skip(System.Int32)">
            <summary>
            Set the first result to be retrieved
            </summary>
            <param name="firstResult"></param>
        </member>
        <member name="M:NHibernate.IQueryOver`1.Take(System.Int32)">
            <summary>
            Set a limit upon the number of objects to be retrieved
            </summary>
            <param name="maxResults"></param>
        </member>
        <member name="M:NHibernate.IQueryOver`1.Cacheable">
            <summary>
            Enable caching of this query result set
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`1.CacheMode(NHibernate.CacheMode)">
            <summary> Override the cache mode for this particular query. </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.IQueryOver`1.CacheRegion(System.String)">
            <summary>
            Set the name of the cache region.
            </summary>
            <param name="cacheRegion">the name of a query cache region, or <see langword="null" />
            for the default query cache</param>
        </member>
        <member name="M:NHibernate.IQueryOver`1.ReadOnly">
            <summary>
            Set the read-only mode for entities (and proxies) loaded by this QueryOver.
            (see <see cref="M:NHibernate.ICriteria.SetReadOnly(System.Boolean)"/>).
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.QueryOver`1.GetExecutableQueryOver(NHibernate.ISession)">
            <summary>
            Get an executable instance of <c>IQueryOver&lt;TRoot&gt;</c>,
            to actually run the query.</summary>
        </member>
        <member name="M:NHibernate.Criterion.QueryOver`1.GetExecutableQueryOver(NHibernate.IStatelessSession)">
            <summary>
            Get an executable instance of <c>IQueryOver&lt;TRoot&gt;</c>,
            to actually run the query.</summary>
        </member>
        <member name="M:NHibernate.Criterion.QueryOver`1.ToRowCountQuery">
            <summary>
            Clones the QueryOver, clears the orders and paging, and projects the RowCount
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.QueryOver`1.ToRowCountInt64Query">
            <summary>
            Clones the QueryOver, clears the orders and paging, and projects the RowCount (Int64)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Criterion.QueryOver`1.Clone">
            <summary>
            Creates an exact clone of the QueryOver
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.QueryOver`1.As``1">
            <summary>
            Method to allow comparison of detached query in Lambda expression
            e.g., p =&gt; p.Name == myQuery.As&lt;string&gt;
            </summary>
            <typeparam name="S">type returned (projected) by query</typeparam>
            <returns>throws an exception if evaluated directly at runtime.</returns>
        </member>
        <member name="T:NHibernate.Criterion.QueryOver`2">
            <summary>
            Implementation of the <see cref="T:NHibernate.IQueryOver`2"/> interface
            </summary>
        </member>
        <member name="T:NHibernate.IQueryOver`2">
            <summary>
            QueryOver&lt;TRoot,TSubType&gt; is an API for retrieving entities by composing
            <see cref="T:NHibernate.Criterion.Expression"/> objects expressed using Lambda expression syntax.
            </summary>
            <remarks>
            <code>
            IList&lt;Cat&gt; cats = session.QueryOver&lt;Cat&gt;()
            	.Where( c =&gt; c.Name == "Tigger" )
            	.And( c =&gt; c.Weight &gt; minWeight ) )
            	.List();
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.IQueryOver`2.And(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Add criterion expressed as a lambda expression
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.And(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Add criterion expressed as a lambda expression
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.And(NHibernate.Criterion.ICriterion)">
            <summary>
            Add arbitrary ICriterion (e.g., to allow protected member access)
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.AndNot(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Add negation of criterion expressed as a lambda expression
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.AndNot(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Add negation of criterion expressed as a lambda expression
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.AndRestrictionOn(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Add restriction to a property
            </summary>
            <param name="expression">Lambda expression containing path to property</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.AndRestrictionOn(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Add restriction to a property
            </summary>
            <param name="expression">Lambda expression containing path to property</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Where(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Identical semantics to And() to allow more readable queries
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Where(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Identical semantics to And() to allow more readable queries
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Where(NHibernate.Criterion.ICriterion)">
            <summary>
            Add arbitrary ICriterion (e.g., to allow protected member access)
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.WhereNot(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Identical semantics to AndNot() to allow more readable queries
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.WhereNot(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Identical semantics to AndNot() to allow more readable queries
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.WhereRestrictionOn(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Identical semantics to AndRestrictionOn() to allow more readable queries
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.WhereRestrictionOn(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Identical semantics to AndRestrictionOn() to allow more readable queries
            </summary>
            <param name="expression">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Select(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Add projection expressed as a lambda expression
            </summary>
            <param name="projections">Lambda expressions</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Select(NHibernate.Criterion.IProjection[])">
            <summary>
            Add arbitrary IProjections to query
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.SelectList(System.Func{NHibernate.Criterion.Lambda.QueryOverProjectionBuilder{`0},NHibernate.Criterion.Lambda.QueryOverProjectionBuilder{`0}})">
            <summary>
            Create a list of projections using a projection builder
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.OrderBy(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Add order expressed as a lambda expression
            </summary>
            <param name="path">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.OrderBy(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Add order expressed as a lambda expression
            </summary>
            <param name="path">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.OrderBy(NHibernate.Criterion.IProjection)">
            <summary>
            Order by arbitrary IProjection (e.g., to allow protected member access)
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.OrderByAlias(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Add order for an aliased projection expressed as a lambda expression
            </summary>
            <param name="path">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.ThenBy(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Add order expressed as a lambda expression
            </summary>
            <param name="path">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.ThenBy(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Add order expressed as a lambda expression
            </summary>
            <param name="path">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.ThenBy(NHibernate.Criterion.IProjection)">
            <summary>
            Order by arbitrary IProjection (e.g., to allow protected member access)
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.ThenByAlias(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Add order for an aliased projection expressed as a lambda expression
            </summary>
            <param name="path">Lambda expression</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.TransformUsing(NHibernate.Transform.IResultTransformer)">
            <summary>
            Transform the results using the supplied IResultTransformer
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Fetch(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specify an association fetching strategy.  Currently, only
            one-to-many and one-to-one associations are supported.
            </summary>
            <param name="path">A lambda expression path (e.g., ChildList[0].Granchildren[0].Pets).</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Lock">
            <summary>
            Set the lock mode of the current entity
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.Lock(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Set the lock mode of the aliased entity
            </summary>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            </summary>
            <typeparam name="U">Type of sub-criteria</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinQueryOver``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Creates a new NHibernate.IQueryOver&lt;TRoot, U&gt;, "rooted" at the associated entity
            specifying a collection for the join.
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias(System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias(System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}},NHibernate.SqlCommand.JoinType)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>criteria instance</returns>
        </member>
        <member name="M:NHibernate.IQueryOver`2.JoinAlias``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}},System.Linq.Expressions.Expression{System.Func{``0}},NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <typeparam name="U">Type of sub-criteria (type of the collection)</typeparam>
            <param name="path">Lambda expression returning association path</param>
            <param name="alias">Lambda expression returning alias reference</param>
            <param name="joinType">Type of join</param>
            <param name="withClause">Additional criterion for the SQL on clause</param>
            <returns>criteria instance</returns>
        </member>
        <member name="P:NHibernate.IQueryOver`2.WithSubquery">
            <summary>
            Add a subquery expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsLike(System.String,System.String)">
            <summary>
            Apply a "like" restriction in a QueryOver expression
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsLike(System.String,System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            Apply a "like" restriction in a QueryOver expression
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsLike(System.String,System.String,NHibernate.Criterion.MatchMode,System.Nullable{System.Char})">
            <summary>
            Apply a "like" restriction in a QueryOver expression
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsInsensitiveLike(System.String,System.String)">
            <summary>
            Apply a "like" restriction in a QueryOver expression
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsInsensitiveLike(System.String,System.String,NHibernate.Criterion.MatchMode)">
            <summary>
            Apply a "like" restriction in a QueryOver expression
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsIn(System.Object,System.Object[])">
            <summary>
            Apply an "in" constraint to the named property 
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsIn(System.Object,System.Collections.ICollection)">
            <summary>
            Apply an "in" constraint to the named property 
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.RestrictionExtensions.IsBetween(System.Object,System.Object)">
            <summary>
            Apply a "between" constraint to the named property
            Note: throws an exception outside of a QueryOver expression
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.SelectSubqueryExpression">
            <summary>
            A comparison between a property value in the outer query and the
             result of a subquery
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.SimpleExpression">
            <summary>
            The base class for an <see cref="T:NHibernate.Criterion.ICriterion"/> that compares a single Property
            to a value.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.SimpleExpression.#ctor(System.String,System.Object,System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.SimpleExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <param name="op">The SQL operation.</param>
        </member>
        <member name="M:NHibernate.Criterion.SimpleExpression.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Converts the SimpleExpression to a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="P:NHibernate.Criterion.SimpleExpression.PropertyName">
            <summary>
            Gets the named Property for the Expression.
            </summary>
            <value>A string that is the name of the Property.</value>
        </member>
        <member name="P:NHibernate.Criterion.SimpleExpression.Value">
            <summary>
            Gets the Value for the Expression.
            </summary>
            <value>An object that is the value for the Expression.</value>
        </member>
        <member name="P:NHibernate.Criterion.SimpleExpression.Op">
            <summary>
            Get the Sql operator to use for the specific 
            subclass of <see cref="T:NHibernate.Criterion.SimpleExpression"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.SimpleSubqueryExpression">
            <summary>
            A comparison between a constant value and the the result of a subquery
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.SQLCriterion">
            <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion"/> that creates a SQLExpression.
            The string {alias} will be replaced by the alias of the root entity.
            </summary>
            <remarks>
            This allows for database specific Expressions at the cost of needing to 
            write a correct <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Criterion.SQLProjection">
            <summary>
            A SQL fragment. The string {alias} will be replaced by the alias of the root entity.
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.SQLProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
            <summary>
            Gets the typed values for parameters in this projection
            </summary>
            <param name="criteria">The criteria.</param>
            <param name="criteriaQuery">The criteria query.</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Criterion.Subqueries">
            <summary>
            Factory class for AbstractCriterion instances that represent 
            involving subqueries.
            <c>Expression</c>
            <c>Projection</c>
            <c>AbstractCriterion</c>
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereProperty``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Create a ICriterion for the specified property subquery expression
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="expression">lambda expression</param>
            <returns>returns LambdaSubqueryBuilder</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereProperty(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            Create a ICriterion for the specified property subquery expression
            </summary>
            <param name="expression">lambda expression</param>
            <returns>returns LambdaSubqueryBuilder</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereValue(System.Object)">
            <summary>
            Create a ICriterion for the specified value subquery expression
            </summary>
            <param name="value">value</param>
            <returns>returns LambdaSubqueryBuilder</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.Where``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Create ICriterion for subquery expression using lambda syntax
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="expression">lambda expression</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.Where(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Create ICriterion for (exact) subquery expression using lambda syntax
            </summary>
            <param name="expression">lambda expression</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereAll``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Create ICriterion for (all) subquery expression using lambda syntax
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="expression">lambda expression</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereAll(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Create ICriterion for (all) subquery expression using lambda syntax
            </summary>
            <param name="expression">lambda expression</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereSome``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Create ICriterion for (some) subquery expression using lambda syntax
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="expression">lambda expression</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereSome(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Create ICriterion for (some) subquery expression using lambda syntax
            </summary>
            <param name="expression">lambda expression</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereExists``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add an Exists subquery criterion
            </summary>
        </member>
        <member name="M:NHibernate.Criterion.Subqueries.WhereNotExists``1(NHibernate.Criterion.QueryOver{``0})">
            <summary>
            Add a NotExists subquery criterion
            </summary>
        </member>
        <member name="T:NHibernate.Criterion.SubqueryProjection">
            <summary>
            A property value, or grouped property value
            </summary>
        </member>
        <member name="T:NHibernate.DebugHelpers.DictionaryProxy">
            <summary>
            Used to show a better debug display for dictionaries
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.AnsiExtractFunction">
             <summary>
             
             </summary>
             <remarks>
             <![CDATA[
             <extract expression> ::=
            					EXTRACT <left paren> <extract field> FROM <extract source> <right paren>
             
            <extract field > ::=
            			<datetime field> | <time zone field >
             
             <datetime field> ::= 
            			YEAR |
            			MONTH |
            			DAY |
            			HOUR |
            			MINUTE |
            			SECOND
             
            <time zone field> ::= 
            			TIMEZONE_HOUR	| 
            			TIMEZONE_MINUTE
             ]]>
             </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Function.SQLFunctionTemplate">
            <summary>
            Represents HQL functions that can have different representations in different SQL dialects.
            E.g. in HQL we can define function <code>concat(?1, ?2)</code> to concatenate two strings 
            p1 and p2. Target SQL function will be dialect-specific, e.g. <code>(?1 || ?2)</code> for 
            Oracle, <code>concat(?1, ?2)</code> for MySql, <code>(?1 + ?2)</code> for MS SQL.
            Each dialect will define a template as a string (exactly like above) marking function 
            parameters with '?' followed by parameter's index (first index is 1).
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.ISQLFunction">
             <summary>
             Provides support routines for the HQL functions as used
             in the various SQL Dialects
            
             Provides an interface for supporting various HQL functions that are
             translated to SQL. The Dialect and its sub-classes use this interface to
             provide details required for processing of the function.
             </summary>
        </member>
        <member name="M:NHibernate.Dialect.Function.ISQLFunction.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
            <summary>
            The function return type
            </summary>
            <param name="columnType">The type of the first argument</param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Function.ISQLFunction.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Render the function call as SQL.
            </summary>
            <param name="args">List of arguments</param>
            <param name="factory"></param>
            <returns>SQL fragment for the fuction.</returns>
        </member>
        <member name="P:NHibernate.Dialect.Function.ISQLFunction.HasArguments">
            <summary>
            Does this function have any arguments?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Function.ISQLFunction.HasParenthesesIfNoArguments">
            <summary>
            If there are no arguments, are parens required?
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Function.SQLFunctionTemplate.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Applies the template to passed in arguments.
            </summary>
            <param name="args">args function arguments</param>
            <param name="factory">generated SQL function call</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Dialect.Function.AnsiSubstringFunction">
             <summary>
             ANSI-SQL substring  
             Documented in:
             ANSI X3.135-1992
             American National Standard for Information Systems - Database Language - SQL
             </summary>
             <remarks>
             Syntax:
            <![CDATA[
             <character substring function> ::=
             SUBSTRING <left paren> <character value expression> FROM < start position>
             [ FOR <string length> ] <right paren>
            ]]>
             </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Function.AnsiTrimEmulationFunction">
            <summary>
            A SQLFunction implementation that emulates the ANSI SQL trim function
            on dialects which do not support the full definition.  However, this function
            definition does assume the availability of ltrim, rtrim, and replace functions
            which it uses in various combinations to emulate the desired ANSI trim()
            functionality.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Function.AnsiTrimEmulationFunction.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
             <summary>
             
             </summary>
             <param name="args"></param>
             <param name="factory"></param>
             <returns></returns>
             <remarks>
             according to both the ANSI-SQL and EJB3 specs, trim can either take
             exactly one parameter or a variable number of parameters between 1 and 4.
             from the SQL spec:
             <![CDATA[
             <trim function> ::=
                  TRIM <left paren> <trim operands> <right paren>
            
             <trim operands> ::=
                  [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>
            
             <trim specification> ::=
                  LEADING
                  | TRAILING
                  | BOTH
             ]]>
             If only trim specification is omitted, BOTH is assumed;
             if trim character is omitted, space is assumed
             </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Function.ClassicAggregateFunction.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="acceptAsterisk">Whether the function accepts an asterisk (*) in place of arguments</param>
        </member>
        <member name="M:NHibernate.Dialect.Function.ClassicAggregateFunction.#ctor(System.String,System.Boolean,NHibernate.Type.IType)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="acceptAsterisk">True if accept asterisk like argument</param>
            <param name="typeValue">Return type for the fuction.</param>
        </member>
        <member name="T:NHibernate.Dialect.Function.CastFunction">
            <summary>
            ANSI-SQL style cast(foo as type) where the type is a NHibernate type
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.CharIndexFunction">
            <summary>
            Emulation of locate() on Sybase
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.ClassicAvgFunction">
            <summary>
            Classic AVG sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.ClassicCountFunction">
            <summary>
            Classic COUNT sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.ClassicSumFunction">
            <summary>
            Classic SUM sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.EmulatedLengthSubstringFunction">
            <summary>
            Provides a substring implementation of the form substring(expr, start, length)
            for SQL dialects where the length argument is mandatory. If this is called
            from HQL with only two arguments, this implementation will generate the length
            parameter as (len(expr) + 1 - start).
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.StandardSQLFunction">
            <summary>
            Provides a standard implementation that supports the majority of the HQL
            functions that are translated to SQL.
            </summary>
            <remarks>
            The Dialect and its sub-classes use this class to provide details required
            for processing of the associated function.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Function.StandardSQLFunction.#ctor(System.String)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
        </member>
        <member name="M:NHibernate.Dialect.Function.StandardSQLFunction.#ctor(System.String,NHibernate.Type.IType)">
            <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="typeValue">Return type for the fuction.</param>
        </member>
        <member name="M:NHibernate.Dialect.Function.EmulatedLengthSubstringFunction.#ctor">
            <summary>
            Initializes a new instance of the EmulatedLengthSubstringFunction class.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.NoArgSQLFunction">
            <summary>
            Summary description for NoArgSQLFunction.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.NvlFunction">
            <summary>
            Emulation of coalesce() on Oracle, using multiple nvl() calls
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.PositionSubstringFunction">
            <summary>
            Emulation of locate() on PostgreSQL
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Function.StandardSafeSQLFunction">
            <summary>
            Provides a standard implementation that supports the majority of the HQL
            functions that are translated to SQL.
            </summary>
            <remarks>
            The Dialect and its sub-classes use this class to provide details required
            for processing of the associated function.
            </remarks>	
        </member>
        <member name="M:NHibernate.Dialect.Function.StandardSafeSQLFunction.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the StandardSafeSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="allowedArgsCount">Exact number of arguments expected.</param>
        </member>
        <member name="M:NHibernate.Dialect.Function.StandardSafeSQLFunction.#ctor(System.String,NHibernate.Type.IType,System.Int32)">
            <summary>
            Initializes a new instance of the StandardSafeSQLFunction class.
            </summary>
            <param name="name">SQL function name.</param>
            <param name="typeValue">Return type for the fuction.</param>
            <param name="allowedArgsCount">Exact number of arguments expected.</param>
        </member>
        <member name="T:NHibernate.Dialect.Function.VarArgsSQLFunction">
            <summary>
            Support for slightly more general templating than StandardSQLFunction,
            with an unlimited number of arguments.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Lock.ILockingStrategy">
            <summary> 
            A strategy abstraction for how locks are obtained in the underlying database.
            </summary>
            <remarks>
            All locking provided implemenations assume the underlying database supports
            (and that the connection is in) at least read-committed transaction isolation.
            The most glaring exclusion to this is HSQLDB which only offers support for
            READ_UNCOMMITTED isolation.
            </remarks>
            <seealso cref="M:NHibernate.Dialect.Dialect.GetLockingStrategy(NHibernate.Persister.Entity.ILockable,NHibernate.LockMode)"/>
        </member>
        <member name="M:NHibernate.Dialect.Lock.ILockingStrategy.Lock(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Acquire an appropriate type of lock on the underlying data that will
            endure until the end of the current transaction.
            </summary>
            <param name="id">The id of the row to be locked </param>
            <param name="version">The current version (or null if not versioned) </param>
            <param name="obj">The object logically being locked (currently not used) </param>
            <param name="session">The session from which the lock request originated </param>
        </member>
        <member name="T:NHibernate.Dialect.Lock.SelectLockingStrategy">
            <summary> 
            A locking strategy where the locks are obtained through select statements.
             </summary>
            <seealso cref="M:NHibernate.Dialect.Dialect.GetForUpdateString(NHibernate.LockMode)"/>
            <seealso cref="M:NHibernate.Dialect.Dialect.AppendLockHint(NHibernate.LockMode,System.String)"/>
            <remarks>
            For non-read locks, this is achieved through the Dialect's specific
            SELECT ... FOR UPDATE syntax.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Lock.UpdateLockingStrategy">
            <summary> 
            A locking strategy where the locks are obtained through update statements.
            </summary>
            <remarks> This strategy is not valid for read style locks. </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Lock.UpdateLockingStrategy.#ctor(NHibernate.Persister.Entity.ILockable,NHibernate.LockMode)">
            <summary> 
            Construct a locking strategy based on SQL UPDATE statements.
            </summary>
            <param name="lockable">The metadata for the entity to be locked. </param>
            <param name="lockMode">Indictates the type of lock to be acquired. </param>
            <remarks>
            read-locks are not valid for this strategy.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Schema.AbstractDataBaseSchema">
            <summary>
            Common implementation of schema reader.
            </summary>
            <remarks>
            This implementation of <see cref="T:NHibernate.Dialect.Schema.IDataBaseSchema"/> is based on the new <see cref="T:System.Data.Common.DbConnection"/> of
            .NET 2.0.
            </remarks>
            <seealso cref="M:System.Data.Common.DbConnection.GetSchema"/>
        </member>
        <member name="T:NHibernate.Dialect.Schema.IDataBaseSchema">
            <summary>
            This class is specific of NHibernate and supply DatabaseMetaData of Java.
            In the .NET Framework, there is no direct equivalent.
            </summary>
            <remarks>
            Implementation is provide by a dialect.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTables(System.String,System.String,System.String,System.String[])">
            <summary>
            Gets a description of the tables available for the catalog
            </summary>
            <param name="catalog">A catalog, retrieves those without a catalog</param>
            <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
            <param name="tableNamePattern">A table name pattern</param>
            <param name="types">a list of table types to include</param>
            <returns>Each row</returns>
        </member>
        <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTableMetadata(System.Data.DataRow,System.Boolean)">
            <summary>
            Get the Table MetaData.
            </summary>
            <param name="rs">The <see cref="T:System.Data.DataRow"/> resultSet of <see cref="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTables(System.String,System.String,System.String,System.String[])"/>.</param>
            <param name="extras">Include FKs and indexes</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetColumns(System.String,System.String,System.String,System.String)">
            <summary>
            Gets a description of the table columns available
            </summary>
            <param name="catalog">A catalog, retrieves those without a catalog</param>
            <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
            <param name="tableNamePattern">A table name pattern</param>
            <param name="columnNamePattern">a columng name patterm</param>
            <returns>A description of the table columns available</returns>
        </member>
        <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetIndexInfo(System.String,System.String,System.String)">
            <summary>
            Get a description of the given table's indices and statistics.
            </summary>
            <param name="catalog">A catalog, retrieves those without a catalog</param>
            <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
            <param name="tableName">A table name pattern</param>
            <returns>A description of the table's indices available</returns>
            <remarks>The result is relative to the schema collections "Indexes".</remarks>
        </member>
        <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetIndexColumns(System.String,System.String,System.String,System.String)">
            <summary>
            Get a description of the given table's indices and statistics.
            </summary>
            <param name="catalog">A catalog, retrieves those without a catalog</param>
            <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
            <param name="tableName">A table name pattern</param>
            <param name="indexName">The name of the index</param>
            <returns>A description of the table's indices available</returns>
            <remarks>The result is relative to the schema collections "IndexColumns".</remarks>
        </member>
        <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetForeignKeys(System.String,System.String,System.String)">
            <summary>
            Gets a description of the foreign keys available
            </summary>
            <param name="catalog">A catalog, retrieves those without a catalog</param>
            <param name="schema">Schema name, retrieves those without the schema</param>
            <param name="table">A table name</param>
            <returns>A description of the foreign keys available</returns>
        </member>
        <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetReservedWords">
            <summary>
            Get all reserved words
            </summary>
            <returns>A set of reserved words</returns>
        </member>
        <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresMixedCaseQuotedIdentifiers">
            <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            quoted SQL identifiers as case-insensitive and stores them in mixed case.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresUpperCaseQuotedIdentifiers">
            <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            quoted SQL identifiers as case-insensitive and stores them in upper case.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresUpperCaseIdentifiers">
            <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            unquoted SQL identifiers as case-insensitive and stores them in upper case.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresLowerCaseQuotedIdentifiers">
            <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            quoted SQL identifiers as case-insensitive and stores them in lower case. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresLowerCaseIdentifiers">
            <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            unquoted SQL identifiers as case-insensitive and stores them in lower case, 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.ColumnNameForTableName">
            <summary>
            The name of the column that represent the TABLE_NAME in the <see cref="T:System.Data.DataTable"/>
            returned by <see cref="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTables(System.String,System.String,System.String,System.String[])"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Schema.SchemaHelper.GetValue(System.Data.DataRow,System.String[])">
            <summary>
            Get a value from the DataRow. Multiple alternative column names can be given.
            The names are tried in order, and the value from the first present column
            is returned.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Schema.SchemaHelper.GetString(System.Data.DataRow,System.String[])">
            <summary>
            Get a string value from the DataRow. Multiple alternative column names can be given.
            The names are tried in order, and the value from the first present column
            is returned.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.DB2400Dialect">
            <summary>
            An SQL dialect for DB2 on iSeries OS/400.
            </summary>
            <remarks>
            The DB2400Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.DB2400Driver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.DB2Dialect">
            <summary>
            An SQL dialect for DB2.
            </summary>
            <remarks>
            The DB2Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.DB2Driver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Dialect">
            <summary>
            Represents a dialect of SQL implemented by a particular RDBMS. Subclasses
            implement NHibernate compatibility with different systems.
            </summary>
            <remarks>
            Subclasses should provide a public default constructor that <c>Register()</c>
            a set of type mappings and default Hibernate properties.
            </remarks>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.PossibleQuoteChars">
            <summary> Characters used for quoting sql identifiers </summary>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.PossibleClosedQuoteChars">
            <summary> Characters used for closing quoted sql identifiers </summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.#ctor">
            <summary>
            The base constructor for Dialect.
            </summary>
            <remarks>
            Every subclass should override this and call Register() with every <see cref="T:System.Data.DbType"/> except
            <see cref="F:System.Data.DbType.Object"/>, <see cref="F:System.Data.DbType.SByte"/>, <see cref="F:System.Data.DbType.UInt16"/>, <see cref="F:System.Data.DbType.UInt32"/>, 
            <see cref="F:System.Data.DbType.UInt64"/>, <see cref="F:System.Data.DbType.VarNumeric"/>.
            
            <para>
            The Default properties for this Dialect should also be set - such as whether or not to use outer-joins
            and what the batch size should be.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDialect">
            <summary> Get an instance of the dialect specified by the current <see cref="T:NHibernate.Cfg.Environment"/> properties. </summary>
            <returns> The specified Dialect </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDialect(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Get <see cref="T:NHibernate.Dialect.Dialect"/> from a property bag (prop name <see cref="F:NHibernate.Cfg.Environment.Dialect"/>)
            </summary>
            <param name="props">The property bag.</param>
            <returns>An instance of <see cref="T:NHibernate.Dialect.Dialect"/>.</returns>
            <exception cref="T:System.ArgumentNullException">When <paramref name="props"/> is null.</exception>
            <exception cref="T:NHibernate.HibernateException">When the property bag don't contains de property <see cref="F:NHibernate.Cfg.Environment.Dialect"/>.</exception>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType)">
            <summary>
            Get the name of the database type associated with the given 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>,
            </summary>
            <param name="sqlType">The SqlType</param>
            <returns>The database type name used by ddl.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the name of the database type associated with the given
            <see cref="T:NHibernate.SqlTypes.SqlType"/>.
            </summary>
            <param name="sqlType">The SqlType </param>
            <param name="length">The datatype length </param>
            <param name="precision">The datatype precision </param>
            <param name="scale">The datatype scale </param>
            <returns>The database type name used by ddl.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLongestTypeName(System.Data.DbType)">
            <summary>
            Gets the name of the longest registered type for a particular DbType.
            </summary>
            <param name="dbType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetCastTypeName(NHibernate.SqlTypes.SqlType)">
            <summary> 
            Get the name of the database type appropriate for casting operations
            (via the CAST() SQL function) for the given <see cref="T:NHibernate.SqlTypes.SqlType"/> typecode.
            </summary>
            <param name="sqlType">The <see cref="T:NHibernate.SqlTypes.SqlType"/> typecode </param>
            <returns> The database type name </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.Int32,System.String)">
            <summary>
            Subclasses register a typename for the given type code and maximum
            column length. <c>$l</c> in the type name will be replaced by the column
            length (if appropriate)
            </summary>
            <param name="code">The typecode</param>
            <param name="capacity">Maximum length of database type</param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.String)">
            <summary>
            Subclasses register a typename for the given type code. <c>$l</c> in the 
            typename will be replaced by the column length (if appropriate).
            </summary>
            <param name="code">The typecode</param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetAddForeignKeyConstraintString(System.String,System.String[],System.String,System.String[],System.Boolean)">
            <summary> 
            The syntax used to add a foreign key constraint to a table.  If SupportsForeignKeyConstraintInAlterTable is false, the returned string will be added to the create table statement instead.  In this case, extra strings, like "add", that apply when using alter table should be omitted.
            </summary>
            <param name="constraintName">The FK constraint name. </param>
            <param name="foreignKey">The names of the columns comprising the FK </param>
            <param name="referencedTable">The table referenced by the FK </param>
            <param name="primaryKey">The explicit columns in the referencedTable referenced by this FK. </param>
            <param name="referencesPrimaryKey">
            if false, constraint should be explicit about which column names the constraint refers to 
            </param>
            <returns> the "add FK" fragment </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetAddPrimaryKeyConstraintString(System.String)">
            <summary>
            The syntax used to add a primary key constraint to a table
            </summary>
            <param name="constraintName"></param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLockingStrategy(NHibernate.Persister.Entity.ILockable,NHibernate.LockMode)">
            <summary> 
            Get a strategy instance which knows how to acquire a database-level lock
            of the specified mode for this dialect. 
            </summary>
            <param name="lockable">The persister for the entity to be locked. </param>
            <param name="lockMode">The type of lock to be acquired. </param>
            <returns> The appropriate locking strategy. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetForUpdateString(NHibernate.LockMode)">
            <summary> 
            Given a lock mode, determine the appropriate for update fragment to use. 
            </summary>
            <param name="lockMode">The lock mode to apply. </param>
            <returns> The appropriate for update fragment. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetForUpdateString(System.String)">
            <summary> 
            Get the <tt>FOR UPDATE OF column_list</tt> fragment appropriate for this
            dialect given the aliases of the columns to be write locked.
             </summary>
            <param name="aliases">The columns to be write locked. </param>
            <returns> The appropriate <tt>FOR UPDATE OF column_list</tt> clause string. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetForUpdateNowaitString(System.String)">
            <summary> 
            Get the <tt>FOR UPDATE OF column_list NOWAIT</tt> fragment appropriate
            for this dialect given the aliases of the columns to be write locked.
            </summary>
            <param name="aliases">The columns to be write locked. </param>
            <returns> The appropriate <tt>FOR UPDATE colunm_list NOWAIT</tt> clause string. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.ApplyLocksToSql(NHibernate.SqlCommand.SqlString,System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode},System.Collections.Generic.IDictionary{System.String,System.String[]})">
            <summary> 
            Modifies the given SQL by applying the appropriate updates for the specified
            lock modes and key columns.
            </summary>
            <param name="sql">the SQL string to modify </param>
            <param name="aliasedLockModes">a map of lock modes indexed by aliased table names. </param>
            <param name="keyColumnNames">a map of key columns indexed by aliased table names. </param>
            <returns> the modified SQL string. </returns>
            <remarks>
            The behavior here is that of an ANSI SQL <tt>SELECT FOR UPDATE</tt>.  This
            method is really intended to allow dialects which do not support
            <tt>SELECT FOR UPDATE</tt> to achieve this in their own fashion.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.AppendLockHint(NHibernate.LockMode,System.String)">
            <summary> 
            Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>,
            whereby a "lock hint" is appends to the table name in the from clause.
             </summary>
            <param name="lockMode">The lock mode to apply </param>
            <param name="tableName">The name of the table to which to apply the lock hint. </param>
            <returns> The table with any required lock hints. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropTableString(System.String)">
            <summary>
            Return SQL needed to drop the named table. May (and should) use
            some form of "if exists" clause, and cascade constraints.
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GenerateTemporaryTableName(System.String)">
            <summary> Generate a temporary table name given the bas table. </summary>
            <param name="baseTableName">The table name from which to base the temp table name. </param>
            <returns> The generated temp table name. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.PerformTemporaryTableDDLInIsolation">
            <summary> 
            Does the dialect require that temporary table DDL statements occur in
            isolation from other statements?  This would be the case if the creation
            would cause any current transaction to get committed implicitly.
             </summary>
            <returns> see the result matrix above. </returns>
            <remarks>
            JDBC defines a standard way to query for this information via the
            {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}
            method.  However, that does not distinguish between temporary table
            DDL and other forms of DDL; MySQL, for example, reports DDL causing a
            transaction commit via its driver, even though that is not the case for
            temporary table DDL.
            <p/>
            Possible return values and their meanings:<ul>
            <li>{@link Boolean#TRUE} - Unequivocally, perform the temporary table DDL in isolation.</li>
            <li>{@link Boolean#FALSE} - Unequivocally, do <b>not</b> perform the temporary table DDL in isolation.</li>
            <li><i>null</i> - defer to the JDBC driver response in regards to {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}</li>
            </ul>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.DropTemporaryTableAfterUse">
            <summary> Do we need to drop the temporary table after use? </summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterResultSetOutParameter(System.Data.Common.DbCommand,System.Int32)">
            <summary> 
            Registers an OUT parameter which will be returing a
            <see cref="T:System.Data.Common.DbDataReader"/>.  How this is accomplished varies greatly
            from DB to DB, hence its inclusion (along with {@link #getResultSet}) here.
             </summary>
            <param name="statement">The callable statement. </param>
            <param name="position">The bind position at which to register the OUT param. </param>
            <returns> The number of (contiguous) bind positions used. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetResultSet(System.Data.Common.DbCommand)">
            <summary> 
            Given a callable statement previously processed by <see cref="M:NHibernate.Dialect.Dialect.RegisterResultSetOutParameter(System.Data.Common.DbCommand,System.Int32)"/>,
            extract the <see cref="T:System.Data.Common.DbDataReader"/> from the OUT parameter. 
            </summary>
            <param name="statement">The callable statement. </param>
            <returns> The extracted result set. </returns>
            <throws>  SQLException Indicates problems extracting the result set. </throws>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropForeignKeyConstraintString(System.String)">
            <summary>
            The syntax used to drop a foreign key constraint from a table.
            </summary>
            <param name="constraintName">The name of the foreign key constraint to drop.</param>
            <returns>
            The SQL string to drop the foreign key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetIfNotExistsCreateConstraint(NHibernate.Mapping.Table,System.String)">
            <summary>
            The syntax that is used to check if a constraint does not exists before creating it
            </summary>
            <param name="table">The table.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetIfNotExistsCreateConstraintEnd(NHibernate.Mapping.Table,System.String)">
            <summary>
            The syntax that is used to close the if for a constraint exists check, used
            for dialects that requires begin/end for ifs
            </summary>
            <param name="table">The table.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetIfExistsDropConstraint(NHibernate.Mapping.Table,System.String)">
            <summary>
            The syntax that is used to check if a constraint exists before dropping it
            </summary>
            <param name="table">The table.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetIfExistsDropConstraintEnd(NHibernate.Mapping.Table,System.String)">
            <summary>
            The syntax that is used to close the if for a constraint exists check, used
            for dialects that requires begin/end for ifs
            </summary>
            <param name="table">The table.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropPrimaryKeyConstraintString(System.String)">
            <summary>
            The syntax used to drop a primary key constraint from a table.
            </summary>
            <param name="constraintName">The name of the primary key constraint to drop.</param>
            <returns>
            The SQL string to drop the primary key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropIndexConstraintString(System.String)">
            <summary>
            The syntax used to drop an index constraint from a table.
            </summary>
            <param name="constraintName">The name of the index constraint to drop.</param>
            <returns>
            The SQL string to drop the primary key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.AppendIdentitySelectToInsert(NHibernate.SqlCommand.SqlString)">
            <summary> 
            Provided we <see cref="P:NHibernate.Dialect.Dialect.SupportsInsertSelectIdentity"/>, then attch the
            "select identity" clause to the  insert statement.
            </summary>
            <param name="insertString">The insert command </param>
            <returns> 
            The insert command with any necessary identity select clause attached.
            Note, if <see cref="P:NHibernate.Dialect.Dialect.SupportsInsertSelectIdentity"/> == false then
            the insert-string should be returned without modification.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetIdentitySelectString(System.String,System.String,System.Data.DbType)">
            <summary> 
            Get the select command to use to retrieve the last generated IDENTITY
            value for a particular table 
            </summary>
            <param name="tableName">The table into which the insert was done </param>
            <param name="identityColumn">The PK column. </param>
            <param name="type">The <see cref="T:System.Data.DbType"/> type code. </param>
            <returns> The appropriate select command </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetIdentityColumnString(System.Data.DbType)">
            <summary> 
            The syntax used during DDL to define a column as being an IDENTITY of
            a particular type. 
            </summary>
            <param name="type">The <see cref="T:System.Data.DbType"/> type code. </param>
            <returns> The appropriate DDL fragment. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetSequenceNextValString(System.String)">
            <summary> 
            Generate the appropriate select statement to to retreive the next value
            of a sequence.
            </summary>
            <param name="sequenceName">the name of the sequence </param>
            <returns> String The "nextval" select string. </returns>
            <remarks>This should be a "stand alone" select statement.</remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropSequenceString(System.String)">
            <summary> 
            Typically dialects which support sequences can drop a sequence
            with a single command.  
            </summary>
            <param name="sequenceName">The name of the sequence </param>
            <returns> The sequence drop commands </returns>
            <remarks>
            This is convenience form of <see cref="M:NHibernate.Dialect.Dialect.GetDropSequenceStrings(System.String)"/>
            to help facilitate that.
            
            Dialects which support sequences and can drop a sequence in a
            single command need *only* override this method.  Dialects
            which support sequences but require multiple commands to drop
            a sequence should instead override <see cref="M:NHibernate.Dialect.Dialect.GetDropSequenceStrings(System.String)"/>. 
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropSequenceStrings(System.String)">
            <summary> 
            The multiline script used to drop a sequence. 
            </summary>
            <param name="sequenceName">The name of the sequence </param>
            <returns> The sequence drop commands </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetSelectSequenceNextValString(System.String)">
            <summary> 
            Generate the select expression fragment that will retrieve the next
            value of a sequence as part of another (typically DML) statement.
            </summary>
            <param name="sequenceName">the name of the sequence </param>
            <returns> The "nextval" fragment. </returns>
            <remarks>
            This differs from <see cref="M:NHibernate.Dialect.Dialect.GetSequenceNextValString(System.String)"/> in that this
            should return an expression usable within another statement.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String)">
            <summary> 
            Typically dialects which support sequences can create a sequence
            with a single command.
            </summary>
            <param name="sequenceName">The name of the sequence </param>
            <returns> The sequence creation command </returns>
            <remarks>
            This is convenience form of <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)"/> to help facilitate that.
            Dialects which support sequences and can create a sequence in a
            single command need *only* override this method.  Dialects
            which support sequences but require multiple commands to create
            a sequence should instead override <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)">
            <summary> 
            An optional multi-line form for databases which <see cref="P:NHibernate.Dialect.Dialect.SupportsPooledSequences"/>. 
            </summary>
            <param name="sequenceName">The name of the sequence </param>
            <param name="initialValue">The initial value to apply to 'create sequence' statement </param>
            <param name="incrementSize">The increment value to apply to 'create sequence' statement </param>
            <returns> The sequence creation commands </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String,System.Int32,System.Int32)">
            <summary> 
            Overloaded form of <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String)"/>, additionally
            taking the initial value and increment size to be applied to the sequence
            definition.
             </summary>
            <param name="sequenceName">The name of the sequence </param>
            <param name="initialValue">The initial value to apply to 'create sequence' statement </param>
            <param name="incrementSize">The increment value to apply to 'create sequence' statement </param>
            <returns> The sequence creation command </returns>
            <remarks>
            The default definition is to suffix <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String,System.Int32,System.Int32)"/>
            with the string: " start with {initialValue} increment by {incrementSize}" where
            {initialValue} and {incrementSize} are replacement placeholders.  Generally
            dialects should only need to override this method if different key phrases
            are used to apply the allocation information.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.CreateOuterJoinFragment">
            <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.JoinFragment"/> strategy responsible
            for handling this dialect's variations in how joins are handled. 
            </summary>
            <returns> This dialect's <see cref="T:NHibernate.SqlCommand.JoinFragment"/> strategy. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.CreateCaseFragment">
            <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.CaseFragment"/> strategy responsible
            for handling this dialect's variations in how CASE statements are
            handled. 
            </summary>
            <returns> This dialect's <see cref="T:NHibernate.SqlCommand.CaseFragment"/> strategy. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.ToBooleanValueString(System.Boolean)">
            <summary> The SQL literal value to which this database maps boolean values. </summary>
            <param name="value">The boolean value </param>
            <returns> The appropriate SQL literal. </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            Attempts to add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>.
            Expects any database-specific offset and limit adjustments to have already been performed (ex. UseMaxForLimit, OffsetStartsAtOne).
            </summary>
            <param name="queryString">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to base the limit query off.</param>
            <param name="offset">Offset of the first row to be returned by the query.  This may be represented as a parameter, a string literal, or a null value if no limit is requested.  This should have already been adjusted to account for OffsetStartsAtOne.</param>
            <param name="limit">Maximum number of rows to be returned by the query.  This may be represented as a parameter, a string literal, or a null value if no offset is requested.  This should have already been adjusted to account for UseMaxForLimit.</param>
            <returns>A new <see cref="T:NHibernate.SqlCommand.SqlString"/> that contains the <c>LIMIT</c> clause. Returns <c>null</c> 
            if <paramref name="queryString"/> represents a SQL statement to which a limit clause cannot be added, 
            for example when the query string is custom SQL invoking a stored procedure.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Nullable{System.Int32},System.Nullable{System.Int32},NHibernate.SqlCommand.Parameter,NHibernate.SqlCommand.Parameter)">
            <summary>
            Attempts to generate a string to limit the result set to a number of maximum results with a specified offset into the results.
            Expects any database-specific offset and limit adjustments to have already been performed (ex. UseMaxForLimit, OffsetStartsAtOne).
            Performs error checking based on the various dialect limit support options.  If both parameters and fixed valeus are
            specified, this will use the parameter option if possible.  Otherwise, it will fall back to a fixed string.
            </summary>
            <param name="queryString"></param>
            <param name="offset"></param>
            <param name="limit"></param>
            <param name="offsetParameter"></param>
            <param name="limitParameter"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLimitValue(System.Int32,System.Int32)">
            <summary>
            Some databases require that a limit statement contain the maximum row number
            instead of the number of rows to retrieve.  This method adjusts source
            limit and offset values to account for this.
            </summary>
            <param name="offset"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetOffsetValue(System.Int32)">
            <summary>
            Some databases use limit row offsets that start at one instead of zero.
            This method adjusts a desired offset using the OffsetStartsAtOne flag.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.IsQuoted(System.String)">
            <summary>
            Checks to see if the name has been quoted.
            </summary>
            <param name="name">The name to check if it is quoted</param>
            <returns>true if name is already quoted.</returns>
            <remarks>
            The default implementation is to compare the first character
            to Dialect.OpenQuote and the last char to Dialect.CloseQuote
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.Quote(System.String)">
            <summary>
            Quotes a name.
            </summary>
            <param name="name">The string that needs to be Quoted.</param>
            <returns>A QuotedName </returns>
            <remarks>
            <p>
            This method assumes that the name is not already Quoted.  So if the name passed
            in is <c>"name</c> then it will return <c>"""name"</c>.  It escapes the first char
            - the " with "" and encloses the escaped string with OpenQuote and CloseQuote. 
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForAliasName(System.String)">
            <summary>
            Quotes a name for being used as a aliasname
            </summary>
            <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)"/></remarks>
            <param name="aliasName">Name of the alias</param>
            <returns>A Quoted name in the format of OpenQuote + aliasName + CloseQuote</returns>
            <remarks>
            <p>
            If the aliasName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the aliasName that was passed in without going through any
            Quoting process.  So if aliasName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForColumnName(System.String)">
            <summary>
            Quotes a name for being used as a columnname
            </summary>
            <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)"/></remarks>
            <param name="columnName">Name of the column</param>
            <returns>A Quoted name in the format of OpenQuote + columnName + CloseQuote</returns>
            <remarks>
            <p>
            If the columnName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the columnName that was passed in without going through any
            Quoting process.  So if columnName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)">
            <summary>
            Quotes a name for being used as a tablename
            </summary>
            <param name="tableName">Name of the table</param>
            <returns>A Quoted name in the format of OpenQuote + tableName + CloseQuote</returns>
            <remarks>
            <p>
            If the tableName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the tableName that was passed in without going through any
            Quoting process.  So if tableName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForSchemaName(System.String)">
            <summary>
            Quotes a name for being used as a schemaname
            </summary>
            <param name="schemaName">Name of the schema</param>
            <returns>A Quoted name in the format of OpenQuote + schemaName + CloseQuote</returns>
            <remarks>
            <p>
            If the schemaName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the schemaName that was passed in without going through any
            Quoting process.  So if schemaName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String)">
            <summary>
            Unquotes and unescapes an already quoted name
            </summary>
            <param name="quoted">Quoted string</param>
            <returns>Unquoted string</returns>
            <remarks>
            <p>
            This method checks the string <c>quoted</c> to see if it is 
            quoted.  If the string <c>quoted</c> is already enclosed in the OpenQuote
            and CloseQuote then those chars are removed.
            </p>
            <p>
            After the OpenQuote and CloseQuote have been cleaned from the string <c>quoted</c>
            then any chars in the string <c>quoted</c> that have been escaped by doubling them
            up are changed back to a single version.
            </p>
            <p>
            The following quoted values return these results
            "quoted" = quoted
            "quote""d" = quote"d
            quote""d = quote"d 
            </p>
            <p>
            If this implementation is not sufficient for your Dialect then it needs to be overridden.
            MsSql2000Dialect is an example of where UnQuoting rules are different.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String[])">
            <summary>
            Unquotes an array of Quoted Names.
            </summary>
            <param name="quoted">strings to Unquote</param>
            <returns>an array of unquoted strings.</returns>
            <remarks>
            This use UnQuote(string) for each string in the quoted array so
            it should not need to be overridden - only UnQuote(string) needs
            to be overridden unless this implementation is not sufficient.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetSelectClauseNullString(NHibernate.SqlTypes.SqlType)">
            <summary> 
            Given a <see cref="T:System.Data.DbType"/> type code, determine an appropriate
            null value to use in a select clause.
            </summary>
            <param name="sqlType">The <see cref="T:System.Data.DbType"/> type code. </param>
            <returns> The appropriate select clause value fragment. </returns>
            <remarks>
            One thing to consider here is that certain databases might
            require proper casting for the nulls here since the select here
            will be part of a UNION/UNION ALL.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterHibernateType(System.Data.DbType,System.String)">
            <summary> 
            Registers a NHibernate <see cref="T:NHibernate.Type.IType"/> name for the given <see cref="T:System.Data.DbType"/> type code. 
            </summary>
            <param name="code">The <see cref="T:System.Data.DbType"/> typecode </param>
            <param name="name">The NHibernate <see cref="T:System.Data.DbType"/> name </param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.BuildSQLExceptionConverter">
            <summary> 
            Build an instance of the <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter"/> preferred by this dialect for
            converting <see cref="T:System.Data.Common.DbException"/> into NHibernate's ADOException hierarchy.  
            </summary>
            <returns> The Dialect's preferred <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter"/>. </returns>
            <remarks>
            The default Dialect implementation simply returns a converter based on X/Open SQLState codes.
            <para/>
            It is strongly recommended that specific Dialect implementations override this
            method, since interpretation of a SQL error is much more accurate when based on
            the ErrorCode rather than the SQLState. Unfortunately, the ErrorCode is a vendor-specific approach. 
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DropConstraints">
            <summary>
            Do we need to drop constraints before dropping tables in the dialect?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.QualifyIndexName">
            <summary>
            Do we need to qualify index names with the schema name?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsUnique">
            <summary>
            Does this dialect support the <c>UNIQUE</c> column syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsUniqueConstraintInCreateAlterTable">
            <summary> Does this dialect support adding Unique constraints via create and alter table ?</summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsForeignKeyConstraintInAlterTable">
            <summary>
            Does this dialect support adding foreign key constraints via alter table?  If not, it's assumed they can only be added through create table.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsBeforeTableName">
            <summary>
            Does the dialect support the syntax 'drop table if exists NAME'
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsAfterTableName">
            <summary>
            Does the dialect support the syntax 'drop table NAME if exists'
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsColumnCheck">
            <summary> Does this dialect support column-level check constraints? </summary>
            <returns> True if column-level CHECK constraints are supported; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsTableCheck">
            <summary> Does this dialect support table-level check constraints? </summary>
            <returns> True if table-level CHECK constraints are supported; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.ForUpdateString">
            <summary>
            Get the string to append to SELECT statements to acquire locks
            for this dialect.
            </summary>
            <value>The appropriate <c>FOR UPDATE</c> clause string.</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.ForUpdateOfColumns">
            <summary> Is <tt>FOR UPDATE OF</tt> syntax supported? </summary>
            <value> True if the database supports <tt>FOR UPDATE OF</tt> syntax; false otherwise. </value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsOuterJoinForUpdate">
            <summary> 
            Does this dialect support <tt>FOR UPDATE</tt> in conjunction with outer joined rows?
            </summary>
            <value> True if outer joined rows can be locked via <tt>FOR UPDATE</tt>. </value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.ForUpdateNowaitString">
            <summary>
            Retrieves the <c>FOR UPDATE NOWAIT</c> syntax specific to this dialect
            </summary>
            <value>The appropriate <c>FOR UPDATE NOWAIT</c> clause string.</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsTemporaryTables">
            <summary> Does this dialect support temporary tables? </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsCurrentTimestampSelection">
            <summary> Does this dialect support a way to retrieve the database's current timestamp value? </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.TimestampResolutionInTicks">
            <summary>
            Gives the best resolution that the database can use for storing
            date/time values, in ticks.
            </summary>
            <remarks>
            <para>
            For example, if the database can store values with 100-nanosecond
            precision, this property is equal to 1L. If the database can only
            store values with 1-millisecond precision, this property is equal
            to 10000L (number of ticks in a millisecond).
            </para>
            <para>
            Used in TimestampType.
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CascadeConstraintsString">
            <summary>
            Completely optional cascading drop clause
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DisableForeignKeyConstraintsString">
            <summary> Only needed if the Dialect does not have SupportsForeignKeyConstraintInAlterTable. </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.EnableForeignKeyConstraintsString">
            <summary> Only needed if the Dialect does not have SupportsForeignKeyConstraintInAlterTable. </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIdentityColumns">
            <summary>
            Does this dialect support identity column key generation?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsInsertSelectIdentity">
            <summary> 
            Does the dialect support some form of inserting and selecting
            the generated IDENTITY value all in the same statement.
             </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.HasDataTypeInIdentityColumn">
            <summary>
            Whether this dialect has an identity clause added to the data type or a
            completely separate identity data type.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentitySelectString">
            <summary> 
            Get the select command to use to retrieve the last generated IDENTITY value.
            </summary>
            <returns> The appropriate select command </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentityColumnString">
            <summary>
            The keyword used to specify an identity column, if native key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.GenerateTablePrimaryKeyConstraintForIdentityColumn">
            <summary>
            Set this to false if no table-level primary key constraint should be generated when an identity column has been specified for the table.
            This is used as a work-around for SQLite so it doesn't tell us we have "more than one primary key".
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentityInsertString">
            <summary>
            The keyword used to insert a generated value into an identity column (or null).
            Need if the dialect does not support inserts that specify no column values.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSequences">
            <summary>
            Does this dialect support sequences?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsPooledSequences">
            <summary> 
            Does this dialect support "pooled" sequences?
            </summary>
            <returns> True if such "pooled" sequences are supported; false otherwise. </returns>
            <remarks>
            A pooled sequence is one that has a configurable initial size and increment 
            size. It enables NHibernate to be allocated a pool/block/range of IDs,
            which can reduce the frequency of round trips to the database during ID
            generation.
            </remarks>
            <seealso cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)"> </seealso>
            <seealso cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String,System.Int32,System.Int32)"> </seealso>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.QuerySequencesString">
            <summary> Get the select command used retrieve the names of all sequences.</summary>
            <returns> The select command; or null if sequences are not supported. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentityStyleIdentifierGeneratorClass">
            <summary> 
            The class (which implements <see cref="T:NHibernate.Id.IIdentifierGenerator"/>)
            which acts as this dialects identity-style generation strategy.
            </summary>
            <returns> The native generator class. </returns>
            <remarks>
            Comes into play whenever the user specifies the "identity" generator.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.NativeIdentifierGeneratorClass">
            <summary> 
            The class (which implements <see cref="T:NHibernate.Id.IIdentifierGenerator"/>)
            which acts as this dialects native generation strategy.
            </summary>
            <returns> The native generator class. </returns>
            <remarks>
            Comes into play whenever the user specifies the native generator.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>False, unless overridden.</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.UseMaxForLimit">
            <summary> 
            Does the <tt>LIMIT</tt> clause take a "maximum" row number instead
            of a total number of returned rows?
            </summary>
            <returns> True if limit is relative from offset; false otherwise. </returns>
            <remarks>
            This is easiest understood via an example.  Consider you have a table
            with 20 rows, but you only want to retrieve rows number 11 through 20.
            Generally, a limit with offset would say that the offset = 11 and the
            limit = 10 (we only want 10 rows at a time); this is specifying the
            total number of returned rows.  Some dialects require that we instead
            specify offset = 11 and limit = 20, where 20 is the "last" row we want
            relative to offset (i.e. total number of rows = 20 - 11 = 9)
            So essentially, is limit relative from offset?  Or is limit absolute?
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.OffsetStartsAtOne">
            <summary>
            For limit clauses, indicates whether to use 0 or 1 as the offset that returns the first row.  Should be true if the first row is at offset 1.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.OpenQuote">
            <summary>
            The opening quote for a quoted identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CloseQuote">
            <summary>
            The closing quote for a quoted identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsUnionAll">
            <summary> 
            Does this dialect support UNION ALL, which is generally a faster variant of UNION? 
            True if UNION ALL is supported; false otherwise.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsEmptyInList">
            <summary> 
            Does this dialect support empty IN lists?
            For example, is [where XYZ in ()] a supported construct?
            </summary>
            <returns> True if empty in lists are supported; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.AreStringComparisonsCaseInsensitive">
            <summary> 
            Are string comparisons implicitly case insensitive.
            In other words, does [where 'XYZ' = 'xyz'] resolve to true? 
            </summary>
            <returns> True if comparisons are case insensitive. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsRowValueConstructorSyntax">
            <summary> 
            Is this dialect known to support what ANSI-SQL terms "row value
            constructor" syntax; sometimes called tuple syntax.
            <p/>
            Basically, does it support syntax like
            "... where (FIRST_NAME, LAST_NAME) = ('Steve', 'Ebersole') ...". 
            </summary>
            <returns> 
            True if this SQL dialect is known to support "row value
            constructor" syntax; false otherwise.
            </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsRowValueConstructorSyntaxInInList">
            <summary> 
            If the dialect supports {@link #supportsRowValueConstructorSyntax() row values},
            does it offer such support in IN lists as well?
            <p/>
            For example, "... where (FIRST_NAME, LAST_NAME) IN ( (?, ?), (?, ?) ) ..." 
            </summary>
            <returns> 
            True if this SQL dialect is known to support "row value
            constructor" syntax in the IN list; false otherwise.
            </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.UseInputStreamToInsertBlob">
            <summary> 
            Should LOBs (both BLOB and CLOB) be bound using stream operations (i.e.
            {@link java.sql.PreparedStatement#setBinaryStream}). 
            </summary>
            <returns> True if BLOBs and CLOBs should be bound using stream operations. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsParametersInInsertSelect">
            <summary> 
            Does this dialect support parameters within the select clause of
            INSERT ... SELECT ... statements? 
            </summary>
            <returns> True if this is supported; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor">
            <summary> 
            Does this dialect support asking the result set its positioning
            information on forward only cursors.  Specifically, in the case of
            scrolling fetches, Hibernate needs to use
            {@link java.sql.ResultSet#isAfterLast} and
            {@link java.sql.ResultSet#isBeforeFirst}.  Certain drivers do not
            allow access to these methods for forward only cursors.
            <p/>
            NOTE : this is highly driver dependent! 
            </summary>
            <returns> 
            True if methods like {@link java.sql.ResultSet#isAfterLast} and
            {@link java.sql.ResultSet#isBeforeFirst} are supported for forward
            only cursors; false otherwise.
            </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsCircularCascadeDeleteConstraints">
            <summary> 
            Does this dialect support definition of cascade delete constraints
            which can cause circular chains? 
            </summary>
            <returns> True if circular cascade delete constraints are supported; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSubselectAsInPredicateLHS">
            <summary> 
            Are subselects supported as the left-hand-side (LHS) of
            IN-predicates.
            <para/>
            In other words, is syntax like "... {subquery} IN (1, 2, 3) ..." supported? 
            </summary>
            <returns> True if subselects can appear as the LHS of an in-predicate;false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsExpectedLobUsagePattern">
            <summary> 
            Expected LOB usage pattern is such that I can perform an insert
            via prepared statement with a parameter binding for a LOB value
            without crazy casting to JDBC driver implementation-specific classes...
            <p/>
            Part of the trickiness here is the fact that this is largely
            driver dependent.  For example, Oracle (which is notoriously bad with
            LOB support in their drivers historically) actually does a pretty good
            job with LOB support as of the 10.2.x versions of their drivers... 
            </summary>
            <returns> 
            True if normal LOB usage patterns can be used with this driver;
            false if driver-specific hookiness needs to be applied.
            </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsLobValueChangePropogation">
            <summary> Does the dialect support propagating changes to LOB
            values back to the database?  Talking about mutating the
            internal value of the locator as opposed to supplying a new
            locator instance...
            <p/>
            For BLOBs, the internal value might be changed by:
            {@link java.sql.Blob#setBinaryStream},
            {@link java.sql.Blob#setBytes(long, byte[])},
            {@link java.sql.Blob#setBytes(long, byte[], int, int)},
            or {@link java.sql.Blob#truncate(long)}.
            <p/>
            For CLOBs, the internal value might be changed by:
            {@link java.sql.Clob#setAsciiStream(long)},
            {@link java.sql.Clob#setCharacterStream(long)},
            {@link java.sql.Clob#setString(long, String)},
            {@link java.sql.Clob#setString(long, String, int, int)},
            or {@link java.sql.Clob#truncate(long)}.
            <p/>
            NOTE : I do not know the correct answer currently for
            databases which (1) are not part of the cruise control process
            or (2) do not {@link #supportsExpectedLobUsagePattern}. 
            </summary>
            <returns> True if the changes are propagated back to the database; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsUnboundedLobLocatorMaterialization">
            <summary> 
            Is it supported to materialize a LOB locator outside the transaction in
            which it was created?
            <p/>
            Again, part of the trickiness here is the fact that this is largely
            driver dependent.
            <p/>
            NOTE: all database I have tested which {@link #supportsExpectedLobUsagePattern()}
            also support the ability to materialize a LOB outside the owning transaction... 
            </summary>
            <returns> True if unbounded materialization is supported; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSubqueryOnMutatingTable">
            <summary> 
            Does this dialect support referencing the table being mutated in
            a subquery.  The "table being mutated" is the table referenced in
            an UPDATE or a DELETE query.  And so can that table then be
            referenced in a subquery of said UPDATE/DELETE query.
            <p/>
            For example, would the following two syntaxes be supported:<ul>
            <li>delete from TABLE_A where ID not in ( select ID from TABLE_A )</li>
            <li>update TABLE_A set NON_ID = 'something' where ID in ( select ID from TABLE_A)</li>
            </ul>
             </summary>
            <returns> True if this dialect allows references the mutating table from a subquery. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsExistsInSelect">
            <summary> Does the dialect support an exists statement in the select clause? </summary>
            <returns> True if exists checks are allowed in the select clause; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DoesReadCommittedCauseWritersToBlockReaders">
            <summary> 
            For the underlying database, is READ_COMMITTED isolation implemented by
            forcing readers to wait for write locks to be released? 
            </summary>
            <returns> True if writers block readers to achieve READ_COMMITTED; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DoesRepeatableReadCauseReadersToBlockWriters">
            <summary> 
            For the underlying database, is REPEATABLE_READ isolation implemented by
            forcing writers to wait for read locks to be released? 
            </summary>
            <returns> True if readers block writers to achieve REPEATABLE_READ; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsBindAsCallableArgument">
            <summary> 
            Does this dialect support using a JDBC bind parameter as an argument
            to a function or procedure call? 
            </summary>
            <returns> True if the database supports accepting bind params as args; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSubSelects">
            <summary>
            Does this dialect support subselects?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DefaultProperties">
            <summary>
            Retrieve a set of default Hibernate properties for this database.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.Functions">
            <summary>
            Aggregate SQL functions as defined in general. This is
            a case-insensitive hashtable!
            </summary>
            <remarks>
            The results of this method should be integrated with the 
            specialization's data.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SelectGUIDString">
            <summary> 
            Get the command used to select a GUID from the underlying database.
            (Optional operation.)
             </summary>
            <returns> The appropriate command. </returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CreateTableString">
            <summary> Command used to create a table. </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CreateMultisetTableString">
            <summary> 
            Slight variation on <see cref="P:NHibernate.Dialect.Dialect.CreateTableString"/>.
            The command used to create a multiset table. 
            </summary>
            <remarks>
            Here, we have the command used to create a table when there is no primary key and
            duplicate rows are expected.
            <p/>
            Most databases do not care about the distinction; originally added for
            Teradata support which does care.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CreateTemporaryTableString">
            <summary> Command used to create a temporary table. </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CreateTemporaryTablePostfix">
            <summary> 
            Get any fragments needing to be postfixed to the command for
            temporary table creation. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IsCurrentTimestampSelectStringCallable">
            <summary> 
            Should the value returned by <see cref="P:NHibernate.Dialect.Dialect.CurrentTimestampSelectString"/>
            be treated as callable.  Typically this indicates that JDBC escape
            sytnax is being used...
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CurrentTimestampSelectString">
            <summary> 
            Retrieve the command used to retrieve the current timestammp from the database. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CurrentTimestampSQLFunctionName">
            <summary> 
            The name of the database-specific SQL function for retrieving the
            current timestamp. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.NoColumnsInsertString">
            <summary>
            The keyword used to insert a row without specifying any column values
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.LowercaseFunction">
            <summary>
            The name of the SQL function that transforms a string to lowercase
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.AddColumnString">
            <summary>
            The syntax used to add a column to a table. Note this is deprecated
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.NullColumnString">
            <summary>
            The keyword used to specify a nullable column
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.PrimaryKeyString">
            <summary>
            The keyword used to create a primary key constraint
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSqlBatches">
            <summary>
            Supports splitting batches using GO T-SQL command
            </summary>
            <remarks>
            Batches http://msdn.microsoft.com/en-us/library/ms175502.aspx
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Dialect.QuotedAndParenthesisStringTokenizer">
            <summary>
            This specialized string tokenizier will break a string to tokens, taking
            into account single quotes, parenthesis and commas and [ ]
            Notice that we aren't differenciating between [ ) and ( ] on purpose, it would complicate
            the code and it is not legal at any rate.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetSequenceNextValString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetCreateSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetDropSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.DropConstraints">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentitySelectString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentityInsertString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsSequences">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.UseMaxForLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.FirebirdDialect">
            <summary>
            Summary description for FirebirdDialect.
            </summary>
            <remarks>
            The FirebirdDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.FirebirdClientDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.GenericDialect">
            <summary>
            A generic SQL dialect which may or may not work on any actual databases
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.GenericDialect.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.GenericDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.InformixDialect">
            <summary>
            Summary description for InformixDialect.
            This dialect is intended to work with IDS version 7.31 
            However I can test only version 10.00 as I have only this version at work
            </summary>
            <remarks>
            The InformixDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>ConnectionDriver</term>
            		<description>NHibernate.Driver.OdbcDriver</description>
            		<term>PrepareSql</term>
            		<description>true</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.OdbcDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.GetForUpdateString(System.String)">
            <summary> 
            Get the <tt>FOR UPDATE OF column_list</tt> fragment appropriate for this
            dialect given the aliases of the columns to be write locked.
             </summary>
            <param name="aliases">The columns to be write locked. </param>
            <returns> The appropriate <tt>FOR UPDATE OF column_list</tt> clause string. </returns>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.PerformTemporaryTableDDLInIsolation">
            <summary> 
            Does the dialect require that temporary table DDL statements occur in
            isolation from other statements?  This would be the case if the creation
            would cause any current transaction to get committed implicitly.
             </summary>
            <returns> see the result matrix above. </returns>
            <remarks>
            JDBC defines a standard way to query for this information via the
            {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}
            method.  However, that does not distinguish between temporary table
            DDL and other forms of DDL; MySQL, for example, reports DDL causing a
            transaction commit via its driver, even though that is not the case for
            temporary table DDL.
            <p/>
            Possible return values and their meanings:<ul>
            <li>{@link Boolean#TRUE} - Unequivocally, perform the temporary table DDL in isolation.</li>
            <li>{@link Boolean#FALSE} - Unequivocally, do <b>not</b> perform the temporary table DDL in isolation.</li>
            <li><i>null</i> - defer to the JDBC driver response in regards to {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}</li>
            </ul>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.GetIdentitySelectString(System.String,System.String,System.Data.DbType)">
            <summary> 
            Get the select command to use to retrieve the last generated IDENTITY
            value for a particular table 
            </summary>
            <param name="tableName">The table into which the insert was done </param>
            <param name="identityColumn">The PK column. </param>
            <param name="type">The <see cref="T:System.Data.DbType"/> type code. </param>
            <returns> The appropriate select command </returns>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.GetIdentityColumnString(System.Data.DbType)">
            <summary> 
            The syntax used during DDL to define a column as being an IDENTITY of
            a particular type. 
            </summary>
            <param name="type">The <see cref="T:System.Data.DbType"/> type code. </param>
            <returns> The appropriate DDL fragment. </returns>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.CreateOuterJoinFragment">
            <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.JoinFragment"/> strategy responsible
            for handling this dialect's variations in how joins are handled. 
            </summary>
            <returns> This dialect's <see cref="T:NHibernate.SqlCommand.JoinFragment"/> strategy. </returns>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect.ToBooleanValueString(System.Boolean)">
            <summary> The SQL literal value to which this database maps boolean values. </summary>
            <param name="value">The boolean value </param>
            <returns> The appropriate SQL literal. </returns>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.IdentityInsertString">
            <summary>
            The keyword used to insert a generated value into an identity column (or null).
            Need if the dialect does not support inserts that specify no column values.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.CreateTemporaryTableString">
            <summary> Command used to create a temporary table. </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.CreateTemporaryTablePostfix">
            <summary> 
            Get any fragments needing to be postfixed to the command for
            temporary table creation. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.IsCurrentTimestampSelectStringCallable">
            <summary> 
            Should the value returned by <see cref="P:NHibernate.Dialect.InformixDialect.CurrentTimestampSelectString"/>
            be treated as callable.  Typically this indicates that JDBC escape
            sytnax is being used...
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.CurrentTimestampSelectString">
            <summary> 
            Retrieve the command used to retrieve the current timestammp from the database. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.CurrentTimestampSQLFunctionName">
            <summary> 
            The name of the database-specific SQL function for retrieving the
            current timestamp. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.ForUpdateOfColumns">
            <summary> Is <tt>FOR UPDATE OF</tt> syntax supported? </summary>
            <value> True if the database supports <tt>FOR UPDATE OF</tt> syntax; false otherwise. </value>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsOuterJoinForUpdate">
            <summary> 
            Does this dialect support <tt>FOR UPDATE</tt> in conjunction with outer joined rows?
            </summary>
            <value> True if outer joined rows can be locked via <tt>FOR UPDATE</tt>. </value>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsTemporaryTables">
            <summary> Does this dialect support temporary tables? </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsCurrentTimestampSelection">
            <summary> Does this dialect support a way to retrieve the database's current timestamp value? </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.HasDataTypeInIdentityColumn">
            <summary>
            Whether this dialect have an Identity clause added to the data type or a
            completely separate identity data type
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.IdentitySelectString">
            <summary>
            The syntax that returns the identity value of the last insert, if native
            key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.IdentityColumnString">
            <summary>
            The keyword used to specify an identity column, if native key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsSequences">
            <summary>
            Does this dialect support sequences?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>False, unless overridden.</value>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect.SupportsUnionAll">
            <summary> 
            Does this dialect support UNION ALL, which is generally a faster variant of UNION? 
            True if UNION ALL is supported; false otherwise.
            </summary>
        </member>
        <member name="T:NHibernate.Exceptions.TemplatedViolatedConstraintNameExtracter">
            <summary> 
            Knows how to extract a violated constraint name from an error message based on the
            fact that the constraint name is templated within the message.
            </summary>
        </member>
        <member name="T:NHibernate.Exceptions.IViolatedConstraintNameExtracter">
            <summary> 
            Defines a contract for implementations that can extract the name of a violated
            constraint from a SQLException that is the result of that constraint violation. 
            </summary>
        </member>
        <member name="M:NHibernate.Exceptions.IViolatedConstraintNameExtracter.ExtractConstraintName(System.Data.Common.DbException)">
            <summary> 
            Extract the name of the violated constraint from the given SQLException. 
            </summary>
            <param name="sqle">The exception that was the result of the constraint violation. </param>
            <returns> The extracted constraint name. </returns>
        </member>
        <member name="M:NHibernate.Exceptions.TemplatedViolatedConstraintNameExtracter.ExtractUsingTemplate(System.String,System.String,System.String)">
            <summary>
            Extracts the constraint name based on a template (i.e., <i>templateStart</i><b>constraintName</b><i>templateEnd</i>).
            </summary>
            <param name="templateStart">The pattern denoting the start of the constraint name within the message.</param>
            <param name="templateEnd">The pattern denoting the end of the constraint name within the message.</param>
            <param name="message">The templated error message containing the constraint name.</param>
            <returns>The found constraint name, or null.</returns>
        </member>
        <member name="M:NHibernate.Exceptions.TemplatedViolatedConstraintNameExtracter.ExtractConstraintName(System.Data.Common.DbException)">
            <summary> 
            Extract the name of the violated constraint from the given SQLException. 
            </summary>
            <param name="sqle">The exception that was the result of the constraint violation. </param>
            <returns> The extracted constraint name. </returns>
        </member>
        <member name="M:NHibernate.Dialect.IfxViolatedConstraintExtracter.ExtractConstraintName(System.Data.Common.DbException)">
            <summary> 
            Extract the name of the violated constraint from the given DbException.
            </summary>
            <param name="sqle">The exception that was the result of the constraint violation.</param> 
            <returns>The extracted constraint name.</returns> 
        </member>
        <member name="T:NHibernate.Dialect.InformixDialect0940">
            <summary>
            Summary description for InformixDialect.
            This dialect is intended to work with IDS version 9.40
            </summary>
            <remarks>
            The InformixDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>ConnectionDriver</term>
            		<description>NHibernate.Driver.OdbcDriver</description>
            		<term>PrepareSql</term>
            		<description>true</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.OdbcDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect0940.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect0940.GetSequenceNextValString(System.String)">
            <summary> 
            Generate the appropriate select statement to to retreive the next value
            of a sequence.
            </summary>
            <param name="sequenceName">the name of the sequence </param>
            <returns> String The "nextval" select string. </returns>
            <remarks>This should be a "stand alone" select statement.</remarks>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect0940.GetSelectSequenceNextValString(System.String)">
            <summary> 
            Generate the select expression fragment that will retrieve the next
            value of a sequence as part of another (typically DML) statement.
            </summary>
            <param name="sequenceName">the name of the sequence </param>
            <returns> The "nextval" fragment. </returns>
            <remarks>
            This differs from <see cref="M:NHibernate.Dialect.InformixDialect0940.GetSequenceNextValString(System.String)"/> in that this
            should return an expression usable within another statement.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect0940.CreateOuterJoinFragment">
            <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.JoinFragment"/> strategy responsible
            for handling this dialect's variations in how joins are handled. 
            </summary>
            <returns> This dialect's <see cref="T:NHibernate.SqlCommand.JoinFragment"/> strategy. </returns>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect0940.QuerySequencesString">
            <summary> Get the select command used retrieve the names of all sequences.</summary>
            <returns> The select command; or null if sequences are not supported. </returns>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsSequences">
            <summary>
            Does this dialect support sequences?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsPooledSequences">
            <summary> 
            Does this dialect support "pooled" sequences.  Not aware of a better
            name for this.  Essentially can we specify the initial and increment values? 
            </summary>
            <returns> True if such "pooled" sequences are supported; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>False, unless overridden.</value>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.InformixDialect1000">
            <summary>
            Summary description for InformixDialect.
            This dialect is intended to work with IDS version 10.00
            </summary>
            <remarks>
            The InformixDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>ConnectionDriver</term>
            		<description>NHibernate.Driver.OdbcDriver</description>
            		<term>PrepareSql</term>
            		<description>true</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.OdbcDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.InformixDialect1000.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect1000.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>False, unless overridden.</value>
        </member>
        <member name="P:NHibernate.Dialect.InformixDialect1000.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.IngresDialect">
            <summary>
            An SQL dialect for IngresSQL.
            </summary>
            <remarks>
            The IngresDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.IngresDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Ingres9Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            Attempts to add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>.
            Expects any database-specific offset and limit adjustments to have already been performed (ex. UseMaxForLimit, OffsetStartsAtOne).
            </summary>
            <param name="queryString">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to base the limit query off.</param>
            <param name="offset">Offset of the first row to be returned by the query.  This may be represented as a parameter, a string literal, or a null value if no limit is requested.  This should have already been adjusted to account for OffsetStartsAtOne.</param>
            <param name="limit">Maximum number of rows to be returned by the query.  This may be represented as a parameter, a string literal, or a null value if no offset is requested.  This should have already been adjusted to account for UseMaxForLimit.</param>
            <returns>
            A new <see cref="T:NHibernate.SqlCommand.SqlString"/> that contains the <c>LIMIT</c> clause. Returns <c>null</c>
            if <paramref name="queryString"/> represents a SQL statement to which a limit clause cannot be added,
            for example when the query string is custom SQL invoking a stored procedure.
            </returns>
        </member>
        <member name="P:NHibernate.Dialect.Ingres9Dialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>
            False, unless overridden.
            </value>
        </member>
        <member name="P:NHibernate.Dialect.Ingres9Dialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Ingres9Dialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="F:NHibernate.Dialect.InsertGeneratedIdentifierRetrievalMethod.OutputParameter">
            <summary>
            Use a parameter with ParameterDirection.Output
            </summary>
        </member>
        <member name="F:NHibernate.Dialect.InsertGeneratedIdentifierRetrievalMethod.ReturnValueParameter">
            <summary>
            Use a parameter with ParameterDirection.ReturnValue
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.MsSql2000Dialect">
            <summary>
            An SQL dialect compatible with Microsoft SQL Server 2000.
            </summary>
            <remarks>
            The MsSql2000Dialect defaults the following configuration properties:
            <list type="table">
            <listheader>
            	<term>Property</term>
            	<description>Default Value</description>
            </listheader>
            <item>
            	<term>connection.driver_class</term>
            	<description><see cref="T:NHibernate.Driver.SqlClientDriver"/></description>
            </item>
            <item>
            	<term>adonet.batch_size</term>
            	<description>10</description>
            </item>
            <item>
            	<term>query.substitutions</term>
            	<description>true 1, false 0, yes 'Y', no 'N'</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetDropTableString(System.String)">
            <summary>
            Generates the string to drop the table using SQL Server syntax.
            </summary>
            <param name="tableName">The name of the table to drop.</param>
            <returns>The SQL with the <paramref name="tableName" /> inserted.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.Quote(System.String)">
            <summary />
            <param name="name"></param>
            <returns></returns>
            <remarks>
            MsSql does not require the OpenQuote to be escaped as long as the first char
            is an OpenQuote.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>True, we'll use the SELECT TOP nn syntax.</value>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.UseMaxForLimit">
            <summary>
            Does the <c>LIMIT</c> clause take a "maximum" row number
            instead of a total number of returned rows?
            </summary>
            <returns>false, unless overridden</returns>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2005Dialect.SupportsLimit">
            <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionality.
            </summary>
            <value><c>true</c></value>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2005Dialect.SupportsLimitOffset">
            <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionality with an offset.
            </summary>
            <value><c>true</c></value>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2005Dialect.UseMaxForLimit">
            <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionality with an offset.
            </summary>
            <value><c>false</c></value>
        </member>
        <member name="T:NHibernate.Dialect.MsSql2005DialectQueryPager">
            <summary>
            Transforms a T-SQL SELECT statement into a statement that will - when executed - return a 'page' of results. The page is defined
            by a page size ('limit'), and/or a starting page number ('offset').
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2005DialectQueryPager.PageBy(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            Returns a TSQL SELECT statement that will - when executed - return a 'page' of results.
            </summary>
            <param name="offset"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Dialect.MsSql7Dialect">
            <summary>
            An SQL dialect compatible with Microsoft SQL Server 7.
            </summary>
            <remarks>
            There have been no test run with this because the NHibernate team does not
            have a machine with Sql 7 installed on it.  But there have been users using
            Ms Sql 7 with NHibernate.  As issues with Ms Sql 7 and NHibernate become known
            this Dialect will be updated.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.MsSql7Dialect.IdentitySelectString">
            <summary>
            Uses @@identity to get the Id value.
            </summary>
            <remarks>
            There is a well known problem with @@identity and triggers that insert into
            rows into other tables that also use an identity column.  The only way I know
            of to get around this problem is to upgrade your database server to Ms Sql 2000.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.MsSqlCeDialect">
            <summary>
            A dialect for SQL Server Everywhere (SQL Server CE).
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.MySQLDialect">
            <summary>
            A SQL dialect for MySQL
            </summary>
            <remarks>
            The MySQLDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.MySqlDataDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropForeignKeyConstraintString(System.String)">
            <summary>
            Create the SQL string to drop a foreign key constraint.
            </summary>
            <param name="constraintName">The name of the foreign key to drop.</param>
            <returns>The SQL string to drop the foreign key constraint.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropPrimaryKeyConstraintString(System.String)">
            <summary>
            Create the SQL string to drop a primary key constraint.
            </summary>
            <param name="constraintName">The name of the primary key to drop.</param>
            <returns>The SQL string to drop the primary key constraint.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropIndexConstraintString(System.String)">
            <summary>
            Create the SQL string to drop an index.
            </summary>
            <param name="constraintName">The name of the index to drop.</param>
            <returns>The SQL string to drop the index constraint.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.RegisterCastType(System.Data.DbType,System.String)">
            <summary>
            Subclasses register a typename for the given type code, to be used in CAST()
            statements.
            </summary>
            <param name="code">The typecode</param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.RegisterCastType(System.Data.DbType,System.Int32,System.String)">
            <summary>
            Subclasses register a typename for the given type code, to be used in CAST()
            statements.
            </summary>
            <param name="code">The typecode</param>
            <param name="capacity"></param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetCastTypeName(NHibernate.SqlTypes.SqlType)">
            <summary> 
            Get the name of the database type appropriate for casting operations
            (via the CAST() SQL function) for the given <see cref="T:NHibernate.SqlTypes.SqlType"/> typecode.
            </summary>
            <param name="sqlType">The <see cref="T:NHibernate.SqlTypes.SqlType"/> typecode </param>
            <returns> The database type name </returns>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.QualifyIndexName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.IdentitySelectString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.CloseQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.OpenQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.Oracle10gDialect">
            <summary> 
            A dialect specifically for use with Oracle 10g.
            </summary>
            <remarks>
            The main difference between this dialect and <see cref="T:NHibernate.Dialect.Oracle9iDialect"/>
            is the use of "ANSI join syntax" here...
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Oracle8iDialect">
            <summary>
            A dialect for Oracle 8i. 
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle8iDialect.CreateOuterJoinFragment">
            <summary> 
            Support for the oracle proprietary join syntax... 
            </summary>
            <returns> The orqacle join fragment </returns>
        </member>
        <member name="M:NHibernate.Dialect.Oracle8iDialect.CreateCaseFragment">
            <summary> 
            Map case support to the Oracle DECODE function.  Oracle did not
            add support for CASE until 9i. 
            </summary>
            <returns> The oracle CASE -> DECODE fragment </returns>
        </member>
        <member name="M:NHibernate.Dialect.Oracle8iDialect.GetBasicSelectClauseNullString(NHibernate.SqlTypes.SqlType)">
            <summary> 
            Allows access to the basic <see cref="M:NHibernate.Dialect.Dialect.GetSelectClauseNullString(NHibernate.SqlTypes.SqlType)"/>
            implementation... 
            </summary>
            <param name="sqlType">The <see cref="T:NHibernate.SqlTypes.SqlType"/> mapping type</param>
            <returns> The appropriate select cluse fragment </returns>
        </member>
        <member name="T:NHibernate.Dialect.OracleLiteDialect">
            <summary>
            It's a immature version, it just work.
            An SQL dialect for Oracle Lite
            </summary>
            <remarks>
            The OracleLiteDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.OracleLiteDataClientDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.OracleLiteDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.OracleLiteDialect.GetCreateSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQL81Dialect">
            <summary>
            An SQL dialect for PostgreSQL 8.1 and above.
            </summary>
            <remarks>
            <para>
            PostgreSQL 8.1 supports <c>FOR UPDATE ... NOWAIT</c> syntax.
            </para>
            <para>
            PostgreSQL supports Identity column using the "SERIAL" type.
            Serial type is a "virtual" type that will automatically:
            </para>
            <list type="bullet">
            <item><description>Create a sequence named tablename_colname_seq.</description></item>
            <item><description>Set the default value of this column to the next value of the 
            sequence. (using function <c>nextval('tablename_colname_seq')</c>)</description></item>
            <item><description>Add a "NOT NULL" constraint to this column.</description></item>
            <item><description>Set the sequence as "owned by" the table.</description></item>
            </list>
            <para>
            To insert the next value of the sequence into the serial column,
            exclude the column from the list of columns 
            in the INSERT statement or use the DEFAULT key word.
            </para>
            <para>
            If the table or the column is dropped, the sequence is dropped too.
            </para>
            </remarks>
            <seealso cref="T:NHibernate.Dialect.PostgreSQLDialect"/>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQLDialect">
            <summary>
            An SQL dialect for PostgreSQL.
            </summary>
            <remarks>
            The PostgreSQLDialect defaults the following configuration properties:
            <list type="table">
            <listheader>
            	<term>Property</term>
            	<description>Default Value</description>
            </listheader>
            <item>
            	<term>connection.driver_class</term>
            	<description><see cref="T:NHibernate.Driver.NpgsqlDriver"/></description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetSelectClauseNullString(NHibernate.SqlTypes.SqlType)">
            <summary>PostgreSQL requires to cast NULL values to correctly handle UNION/UNION ALL</summary>
            <remarks>
            See <see href="http://archives.postgresql.org/pgsql-bugs/2005-08/msg00239.php">
            PostgreSQL BUG #1847: Error in some kind of UNION query.</see>
            </remarks>
            <param name="sqlType">The <see cref="T:System.Data.DbType"/> type code.</param>
            <returns>null casted as <paramref name="sqlType"/>: "<c>null::sqltypename</c>"</returns>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.SupportsPooledSequences">
            <summary>
            Supported with SQL 2003 syntax since 7.4, released 2003-11-17. For older versions
            we need to override GetCreateSequenceString(string, int, int) and provide alternative
            syntax, but I don't think we need to bother for such ancient releases (considered EOL).
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.SupportsUnionAll">
            <summary>PostgreSQL supports UNION ALL clause</summary>
            <remarks>
            Reference: <see href="http://www.postgresql.org/docs/8.0/static/sql-select.html#SQL-UNION">
            PostgreSQL 8.0 UNION Clause documentation</see>
            </remarks>
            <value><see langword="true"/></value>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQL81Dialect.GetIdentityColumnString(System.Data.DbType)">
            <summary>
            PostgreSQL supports <c>serial</c> and <c>serial4</c> type for 4 bytes integer auto increment column.
            <c>bigserial</c> or <c>serial8</c> can be used for 8 bytes integer auto increment column.
            </summary>
            <returns><c>bigserial</c> if <paramref name="type"/> equal Int64,
            <c>serial</c> otherwise</returns>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.SupportsIdentityColumns">
            <summary>
            PostgreSQL supports Identity column using the "SERIAL" type.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.HasDataTypeInIdentityColumn">
            <summary>
            PostgreSQL doesn't have type in identity column.
            </summary>
            <remarks>
            To create an identity column it uses the SQL syntax
            <c>CREATE TABLE tablename (colname SERIAL);</c> or 
            <c>CREATE TABLE tablename (colname BIGSERIAL);</c>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.NoColumnsInsertString">
            <summary>
            The sql syntax to insert a row without specifying any column in PostgreSQL is
            <c>INSERT INTO table DEFAULT VALUES;</c>
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.IdentitySelectString">
            <summary>
            PostgreSQL 8.1 and above defined the fuction <c>lastval()</c> that returns the
            value of the last sequence that <c>nextval()</c> was used on in the current session.
            Call <c>lastval()</c> if <c>nextval()</c> has not yet been called in the current
            session throw an exception.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQL82Dialect">
            <summary>
            An SQL dialect for PostgreSQL 8.2 and above.
            </summary>
            <remarks>
            PostgreSQL 8.2 supports <c>DROP TABLE IF EXISTS tablename</c>
            and <c>DROP SEQUENCE IF EXISTS sequencename</c> syntax.
            See <see cref="T:NHibernate.Dialect.PostgreSQLDialect"/> for more information.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.SQLiteDialect">
            <summary>
            A SQL dialect for SQLite.
            </summary>
            <remarks>
            <p>
            Author: <a href="mailto:ib@stalker.ro"> Ioan Bizau </a>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.SQLiteDialect.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SQLiteDialect.DisableForeignKeyConstraintsString">
            <summary>
            SQLite does not currently support dropping foreign key constraints by alter statements.
            This means that tables cannot be dropped if there are any rows that depend on those.
            If there are cycles between tables, it would even be excessively difficult to delete
            the data in the right order first.  Because of this, we just turn off the foreign
            constraints before we drop the schema and hope that we're not going to break anything. :(
            We could theoretically check for data consistency afterwards, but we don't currently.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.SybaseASA9Dialect">
            <summary>
            An SQL dialect for Sybase Adaptive Server Anywhere 9.0
            </summary>
            <remarks>
            <p>
            This dialect probably will not work with schema-export.  If anyone out there
            can fill in the ctor with DbTypes to Strings that would be helpful.
            </p>
            The dialect defaults the following configuration properties:
            <list type="table">
            <listheader>
            	<term>Property</term>
            	<description>Default Value</description>
            </listheader>
            <item>
            	<term>connection.driver_class</term>
            	<description><see cref="T:NHibernate.Driver.SybaseAsaClientDriver"/></description>
            </item>
            <item>
            	<term>prepare_sql</term>
            	<description><see langword="false"/></description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.SybaseASA9Dialect.DropConstraints">
            <summary>
            ASA does not require to drop constraint before dropping tables, and DROP statement
            syntax used by Hibernate to drop constraint is not compatible with ASA, so disable it.
            Comments matchs SybaseAnywhereDialect from Hibernate-3.1 src
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.SybaseASE15Dialect">
            <summary>
            An SQL dialect targeting Sybase Adaptive Server Enterprise (ASE) 15 and higher.
            </summary>
            <remarks>
            The dialect defaults the following configuration properties:
            <list type="table">
            <listheader>
            	<term>Property</term>
            	<description>Default Value</description>
            </listheader>
            <item>
            	<term>connection.driver_class</term>
            	<description><see cref="T:NHibernate.Driver.SybaseAseClientDriver"/></description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.SybaseASE15Dialect.SupportsTemporaryTables">
            <summary>
            Sybase ASE 15 temporary tables are not supported
            </summary>
            <remarks>
            By default, temporary tables in Sybase ASE 15 can only be created outside a transaction.
            This is not supported by NHibernate. Temporary tables (and other DDL) statements can only
            be run in a transaction if the 'ddl in tran' database option on tempdb is set to 'true'.
            However, Sybase does not recommend this setting due to the performance impact arising from
            locking and contention on tempdb system tables.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.SybaseASE15Dialect.AreStringComparisonsCaseInsensitive">
            <summary>
            This is false only by default. The database can be configured to be
            case-insensitive.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.SybaseSQLAnywhere10Dialect">
             <summary>
             SQL Dialect for SQL Anywhere 10 - for the NHibernate 3.0.0 distribution
             Copyright (C) 2010 Glenn Paulley
             Contact: http://iablog.sybase.com/paulley
            
             This NHibernate dialect should be considered BETA software.
            
             This library is free software; you can redistribute it and/or
             modify it under the terms of the GNU Lesser General Public
             License as published by the Free Software Foundation; either
             version 2.1 of the License, or (at your option) any later version.
            
             This library is distributed in the hope that it will be useful,
             but WITHOUT ANY WARRANTY; without even the implied warranty of
             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
             Lesser General Public License for more details.
            
             You should have received a copy of the GNU Lesser General Public
             License along with this library; if not, write to the Free Software
             Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
             </summary>
             <remarks>
             The dialect defaults the following configuration properties:
             <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SybaseSQLAnywhereDriver"/></description>
            	</item>
            	<item>
            		<term>prepare_sql</term>
            		<description><see langword="false"/></description>
            	</item>
             </list>
             </remarks>
        </member>
        <member name="M:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.GetForUpdateString(NHibernate.LockMode)">
             <summary>
             SQL Anywhere 10 supports READ, WRITE, and INTENT row
             locks. INTENT locks are sufficient to ensure that other
             concurrent connections cannot modify a row (though other
             connections can still read that row). SQL Anywhere also
             supports 3 modes of snapshot isolation (multi-version
             concurrency control (MVCC).
            
             SQL Anywhere's <tt>FOR UPDATE</tt> clause supports
            	<tt>FOR UPDATE BY [ LOCK | VALUES ]</tt>
            	<tt>FOR UPDATE OF ( COLUMN LIST )</tt>
            
             though they cannot be specified at the same time. <tt>BY LOCK</tt> is
             the syntax that acquires INTENT locks.  <tt>FOR UPDATE BY VALUES</tt>
             forces the use of the KEYSET cursor, which returns a warning to
             the application when a row in the cursor has been subsequently
             modified by another connection, and an error if the row has
             been deleted.
            
             SQL Anywhere does not support the <tt>FOR UPDATE NOWAIT</tt> syntax of
             Oracle on a statement-by-statement basis.  However, the
             identical functionality is provided by setting the connection
             option <tt>BLOCKING</tt> to "OFF", or setting an appropriate timeout
             period through the connection option <tt>BLOCKING_TIMEOUT</tt>.
             </summary>
        </member>
        <member name="M:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.PerformTemporaryTableDDLInIsolation">
            <summary>
            SQL Anywhere 10 does not perform a COMMIT upon creation of
            a temporary table.  However, it does perform an implicit
            COMMIT when creating an index over a temporary table, or
            upon ALTERing the definition of temporary table.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.RegisterResultSetOutParameter(System.Data.Common.DbCommand,System.Int32)">
            <summary>
            SQL Anywhere does support OUT parameters with callable stored procedures.
             </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.IdentityColumnString">
            <summary>
            SQL Anywhere uses <tt>DEFAULT AUTOINCREMENT</tt> to identify an IDENTITY
            column in a <tt>CREATE TABLE</tt> statement.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.ForUpdateOfColumns">
             <summary>
             SQL Anywhere does support <tt>FOR UPDATE OF</tt> syntax. However,
             in SQL Anywhere one cannot specify both <tt>FOR UPDATE OF</tt> syntax
             and <tt>FOR UPDATE BY LOCK</tt> in the same statement. To achieve INTENT
             locking when using <tt>FOR UPDATE OF</tt> syntax one must use a table hint
             in the query's FROM clause, ie.
            
             SELECT * FROM FOO WITH( UPDLOCK ) FOR UPDATE OF ( column-list ).
            
             In this dialect, we avoid this issue by supporting only
             <tt>FOR UPDATE BY LOCK</tt>.
             </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.SupportsOuterJoinForUpdate">
            <summary>
            SQL Anywhere supports <tt>FOR UPDATE</tt> over cursors containing
            outer joins.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.ForUpdateString">
            <summary>
            Lock rows in the cursor explicitly using INTENT row locks.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.ForReadOnlyString">
            <summary>
            Enforce the condition that this query is read-only. This ensure that certain
            query rewrite optimizations, such as join elimination, can be used.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.ForUpdateByLockString">
            <summary>
            Lock rows in the cursor explicitly using INTENT row locks.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.ForUpdateNowaitString">
            <summary>
            SQL Anywhere does not support <tt>FOR UPDATE NOWAIT</tt>. However, the intent
            is to acquire pessimistic locks on the underlying rows; with NHibernate
            one can accomplish this through setting the BLOCKING connection option.
            Hence, with this API we lock rows in the cursor explicitly using INTENT row locks.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.DoesReadCommittedCauseWritersToBlockReaders">
            <summary>
            We assume that applications using this dialect are NOT using
            SQL Anywhere's snapshot isolation modes.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.DoesRepeatableReadCauseReadersToBlockWriters">
            <summary>
            We assume that applications using this dialect are NOT using
            SQL Anywhere's snapshot isolation modes.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.CloseQuote">
             <summary>
             SQL Anywhere supports both double quotes or '[' (Microsoft syntax) for
             quoted identifiers.
            
             Note that quoted identifiers are controlled through
             the QUOTED_IDENTIFIER connection option.
             </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.OpenQuote">
            <summary>
            SQL Anywhere supports both double quotes or '[' (Microsoft syntax) for
            quoted identifiers.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor">
            <summary>
            SQL Anywhere's implementation of KEYSET-DRIVEN cursors does not
            permit absolute postioning. With jConnect as the driver, this support
            will succeed because jConnect FETCHes the entire result set to the client
            first; it will fail with the iAnywhere JDBC driver. Because the server
            may decide to use a KEYSET cursor even if the cursor is declared as
            FORWARD ONLY, this support is disabled.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.AreStringComparisonsCaseInsensitive">
             <summary>
             By default, the SQL Anywhere dbinit utility creates a
             case-insensitive database for the CHAR collation.  This can
             be changed through the use of the -c command line switch on
             dbinit, and the setting may differ for the NCHAR collation
             for national character sets.  Whether or not a database
             supports case-sensitive comparisons can be determined via
             the DB_Extended_property() function, for example
            
             SELECT DB_EXTENDED_PROPERTY( 'Collation', 'CaseSensitivity');
             </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.SupportsCommentOn">
            <summary>
            SQL Anywhere supports <tt>COMMENT ON</tt> statements for a wide variety of
            database objects. When the COMMENT statement is executed an implicit
            <tt>COMMIT</tt> is performed. However, COMMENT syntax for <tt>CREATE TABLE</tt>, as
            expected by NHibernate (see Table.cs), is not supported.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.NoColumnsInsertString">
            <summary>
            SQL Anywhere currently supports only "VALUES (DEFAULT)", not
            the ANSI standard "DEFAULT VALUES". This latter syntax will be
            supported in the SQL Anywhere 11.0.1 release.  For the moment,
            "VALUES (DEFAULT)" works only for a single-column table.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.DropConstraints">
            <summary>
            SQL Anywhere does not require dropping a constraint before
            dropping a table, and the DROP statement syntax used by Hibernate
            to drop a constraint is not compatible with SQL Anywhere, so disable it.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.CreateTemporaryTableString">
            <summary>
            In SQL Anywhere, the syntax, DECLARE LOCAL TEMPORARY TABLE ...,
            can also be used, which creates a temporary table with procedure scope,
            which may be important for stored procedures.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere10Dialect.CreateTemporaryTablePostfix">
            <summary>
            Assume that temporary table rows should be preserved across COMMITs.
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.SybaseSQLAnywhere11Dialect">
             <summary>
             SQL Dialect for SQL Anywhere 11 - for the NHibernate 3.0.0 distribution
             Copyright (C) 2010 Glenn Paulley
             Contact: http://iablog.sybase.com/paulley
            
             This NHibernate dialect should be considered BETA software.
            
             This library is free software; you can redistribute it and/or
             modify it under the terms of the GNU Lesser General Public
             License as published by the Free Software Foundation; either
             version 2.1 of the License, or (at your option) any later version.
            
             This library is distributed in the hope that it will be useful,
             but WITHOUT ANY WARRANTY; without even the implied warranty of
             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
             Lesser General Public License for more details.
            
             You should have received a copy of the GNU Lesser General Public
             License along with this library; if not, write to the Free Software
             Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
             </summary>
             <remarks>
             The dialect defaults the following configuration properties:
             <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SybaseSQLAnywhereDriver"/></description>
            	</item>
            	<item>
            		<term>prepare_sql</term>
            		<description><see langword="false"/></description>
            	</item>
             </list>
             </remarks>
        </member>
        <member name="T:NHibernate.Dialect.SybaseSQLAnywhere12Dialect">
             <summary>
             SQL Dialect for SQL Anywhere 12 - for the NHibernate 3.2.0 distribution
             Copyright (C) 2011 Glenn Paulley
             Contact: http://iablog.sybase.com/paulley
            
             This NHibernate dialect for SQL Anywhere 12 is a contribution to the NHibernate
             open-source project. It is intended to be included in the NHibernate 
             distribution and is licensed under LGPL.
            
             This library is free software; you can redistribute it and/or
             modify it under the terms of the GNU Lesser General Public
             License as published by the Free Software Foundation; either
             version 2.1 of the License, or (at your option) any later version.
            
             This library is distributed in the hope that it will be useful,
             but WITHOUT ANY WARRANTY; without even the implied warranty of
             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
             Lesser General Public License for more details.
            
             You should have received a copy of the GNU Lesser General Public
             License along with this library; if not, write to the Free Software
             Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
             </summary>
             <remarks>
             The SybaseSQLAnywhere12Dialect uses the SybaseSQLAnywhere11Dialect as its 
             base class. SybaseSQLAnywhere12Dialect includes support for ISO SQL standard
             sequences, which are defined in the catalog table <tt>SYSSEQUENCE</tt>. 
             The dialect uses the SybaseSQLAnywhe11MetaData class for metadata API
             calls, which correctly supports reserved words defined by SQL Anywhere.
             
             The dialect defaults the following configuration properties:
             <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SybaseSQLAnywhereDotNet4Driver"/></description>
            	</item>
            	<item>
            		<term>prepare_sql</term>
            		<description><see langword="false"/></description>
            	</item>
             </list>
             </remarks>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere12Dialect.SupportsSequences">
            <summary> 
            SQL Anywhere supports <tt>SEQUENCES</tt> using a primarily SQL Standard 
            syntax. Sequence values can be queried using the <tt>.CURRVAL</tt> identifier, and the next
            value in a sequence can be retrieved using the <tt>.NEXTVAL</tt> identifier. Sequences
            are retained in the SYS.SYSSEQUENCE catalog table. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere12Dialect.SupportsPooledSequences">
            <summary>
            Pooled sequences does not refer to the CACHE parameter of the <tt>CREATE SEQUENCE</tt>
            statement, but merely if the DBMS supports sequences that can be incremented or decremented
            by values greater than 1. 
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseSQLAnywhere12Dialect.QuerySequencesString">
            <summary>Get the <tt>SELECT</tt> command used to retrieve the names of all sequences.</summary>
            <returns>The <tt>SELECT</tt> command; or NULL if sequences are not supported.</returns>
        </member>
        <member name="T:NHibernate.Dialect.TypeNames">
            <summary>
            This class maps a DbType to names.
            </summary>
            <remarks>
            Associations may be marked with a capacity. Calling the <c>Get()</c>
            method with a type and actual size n will return the associated
            name with smallest capacity >= n, if available and an unmarked
            default type otherwise.
            Eg, setting
            <code>
            	Names.Put(DbType,			"TEXT" );
            	Names.Put(DbType,	255,	"VARCHAR($l)" );
            	Names.Put(DbType,	65534,	"LONGVARCHAR($l)" );
            </code>
            will give you back the following:
            <code>
            	Names.Get(DbType)			// --> "TEXT" (default)
            	Names.Get(DbType,100)		// --> "VARCHAR(100)" (100 is in [0:255])
            	Names.Get(DbType,1000)	// --> "LONGVARCHAR(1000)" (100 is in [256:65534])
            	Names.Get(DbType,100000)	// --> "TEXT" (default)
            </code>
            On the other hand, simply putting
            <code>
            	Names.Put(DbType, "VARCHAR($l)" );
            </code>
            would result in
            <code>
            	Names.Get(DbType)			// --> "VARCHAR($l)" (will cause trouble)
            	Names.Get(DbType,100)		// --> "VARCHAR(100)" 
            	Names.Get(DbType,1000)	// --> "VARCHAR(1000)"
            	Names.Get(DbType,10000)	// --> "VARCHAR(10000)"
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType)">
            <summary>
            Get default type name for specified type
            </summary>
            <param name="typecode">the type key</param>
            <returns>the default type name associated with the specified key</returns>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the type name specified type and size
            </summary>
            <param name="typecode">the type key</param>
            <param name="size">the SQL length </param>
            <param name="scale">the SQL scale </param>
            <param name="precision">the SQL precision </param>
            <returns>
            The associated name with smallest capacity >= size if available and the
            default type name otherwise
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.GetLongest(System.Data.DbType)">
            <summary>
            For types with a simple length, this method returns the definition
            for the longest registered type.
            </summary>
            <param name="typecode"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.Int32,System.String)">
            <summary>
            Set a type name for specified type key and capacity
            </summary>
            <param name="typecode">the type key</param>
            <param name="capacity">the (maximum) type size/length</param>
            <param name="value">The associated name</param>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.String)">
            <summary>
            
            </summary>
            <param name="typecode"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Driver.BasicResultSetsCommand.ForEachSqlCommand(System.Action{NHibernate.SqlCommand.ISqlCommand,System.Int32})">
            <summary>
            Execute the given <paramref name="actionToDo"/> for each command of the resultset.
            </summary>
            <param name="actionToDo">The action to perform where the first parameter is the <see cref="T:NHibernate.SqlCommand.ISqlCommand"/> and the second parameter is the parameters offset of the <see cref="T:NHibernate.SqlCommand.ISqlCommand"/>.</param>
        </member>
        <member name="T:NHibernate.Driver.BatcherDataReaderWrapper">
            <summary>
            Datareader wrapper with the same life cycle of its command (through the batcher)
            </summary>
        </member>
        <member name="T:NHibernate.Driver.CsharpSqliteDriver">
            <summary>
            NHibernate driver for the Community CsharpSqlite data provider.
            <p>
            Author: <a href="mailto:nick_tountas@hotmail.com"> Nikolaos Tountas </a>
            </p>
            </summary>
            <remarks>
            <p>
            In order to use this Driver you must have the Community.CsharpSqlite.dll and Community.CsharpSqlite.SQLiteClient assemblies referenced.
            </p>
            <p>
            Please check <a href="http://code.google.com/p/csharp-sqlite/"> http://code.google.com/p/csharp-sqlite/ </a> for more information regarding csharp-sqlite.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.DriverBase">
            <summary>
            Base class for the implementation of IDriver
            </summary>
        </member>
        <member name="T:NHibernate.Driver.IDriver">
            <summary>
            A strategy for describing how NHibernate should interact with the different .NET Data
            Providers.
            </summary>
            <remarks>
            <para>
            The <c>IDriver</c> interface is not intended to be exposed to the application.
            Instead it is used internally by NHibernate to obtain connection objects, command objects, and
            to generate and prepare <see cref="T:System.Data.IDbCommand">IDbCommands</see>. Implementors should provide a
            public default constructor.
            </para>
            <para>
            This is the interface to implement, or you can inherit from <see cref="T:NHibernate.Driver.DriverBase"/> 
            if you have an ADO.NET data provider that NHibernate does not have built in support for.
            To use the driver, NHibernate property <c>connection.driver_class</c> should be
            set to the assembly-qualified name of the driver class.
            </para>
            <code>
            key="connection.driver_class"
            value="FullyQualifiedClassName, AssemblyName"
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.IDriver.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Configure the driver using <paramref name="settings"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.IDriver.CreateConnection">
            <summary>
            Creates an uninitialized IDbConnection object for the specific Driver
            </summary>
        </member>
        <member name="M:NHibernate.Driver.IDriver.GenerateCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
            <summary>
            Generates an IDbCommand from the SqlString according to the requirements of the DataProvider.
            </summary>
            <param name="type">The <see cref="T:System.Data.CommandType"/> of the command to generate.</param>
            <param name="sqlString">The SqlString that contains the SQL.</param>
            <param name="parameterTypes">The types of the parameters to generate for the command.</param>
            <returns>An IDbCommand with the CommandText and Parameters fully set.</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.PrepareCommand(System.Data.IDbCommand)">
            <summary>
            Prepare the <paramref name="command"/> by calling <see cref="M:System.Data.IDbCommand.Prepare"/>.
            May be a no-op if the driver does not support preparing commands, or for any other reason.
            </summary>
            <param name="command">The command.</param>
        </member>
        <member name="M:NHibernate.Driver.IDriver.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Generates an IDbDataParameter for the IDbCommand.  It does not add the IDbDataParameter to the IDbCommand's
            Parameter collection.
            </summary>
            <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
            <param name="name">The name to set for IDbDataParameter.Name</param>
            <param name="sqlType">The SqlType to set for IDbDataParameter.</param>
            <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.RemoveUnusedCommandParameters(System.Data.IDbCommand,NHibernate.SqlCommand.SqlString)">
            <summary>
            Remove 'extra' parameters from the IDbCommand
            </summary>
            <remarks>
            We sometimes create more parameters than necessary (see NH-2792 &amp; also comments in SqlStringFormatter.ISqlStringVisitor.Parameter)
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.IDriver.ExpandQueryParameters(System.Data.IDbCommand,NHibernate.SqlCommand.SqlString)">
            <summary>
            Expand the parameters of the cmd to have a single parameter for each parameter in the
            sql string
            </summary>
            <remarks>
            This is for databases that do not support named parameters.  So, instead of a single parameter
            for 'select ... from MyTable t where t.Col1 = @p0 and t.Col2 = @p0' we can issue
            'select ... from MyTable t where t.Col1 = ? and t.Col2 = ?'
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.IDriver.AdjustCommand(System.Data.IDbCommand)">
            <summary>
            Make any adjustments to each IDbCommand object before it is added to the batcher.
            </summary>
            <param name="command">The command.</param>
            <remarks>
            This method should be executed before add each single command to the batcher.
            If you have to adjust parameters values/type (when the command is full filled) this is a good place where do it.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.IDriver.SupportsMultipleOpenReaders">
            <summary>
            Does this Driver support having more than 1 open IDataReader with
            the same IDbConnection.
            </summary>
            <remarks>
            <para>
            A value of <see langword="false"/> indicates that an exception would be thrown if NHibernate
            attempted to have 2 IDataReaders open using the same IDbConnection.  NHibernate
            (since this version is a close to straight port of Hibernate) relies on the 
            ability to recursively open 2 IDataReaders.  If the Driver does not support it
            then NHibernate will read the values from the IDataReader into an <see cref="T:NHibernate.Driver.NDataReader"/>.
            </para>
            <para>
            A value of <see langword="true"/> will result in greater performance because an IDataReader can be used
            instead of the <see cref="T:NHibernate.Driver.NDataReader"/>.  So if the Driver supports it then make sure
            it is set to <see langword="true"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.FormatNameForSql(System.String)">
            <summary>
            Change the parameterName into the correct format IDbCommand.CommandText
            for the ConnectionProvider
            </summary>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbCommand.CommandText</returns>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.FormatNameForParameter(System.String)">
            <summary>
            Changes the parameterName into the correct format for an IDbParameter
            for the Driver.
            </summary>
            <remarks>
            For SqlServerConnectionProvider it will change <c>id</c> to <c>@id</c>
            </remarks>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbParameter.</returns>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Generates an IDbDataParameter for the IDbCommand.  It does not add the IDbDataParameter to the IDbCommand's
            Parameter collection.
            </summary>
            <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
            <param name="name">The name to set for IDbDataParameter.Name</param>
            <param name="sqlType">The SqlType to set for IDbDataParameter.</param>
            <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.OnBeforePrepare(System.Data.IDbCommand)">
            <summary>
            Override to make any adjustments to the IDbCommand object.  (e.g., Oracle custom OUT parameter)
            Parameters have been bound by this point, so their order can be adjusted too.
            This is analagous to the RegisterResultSetOutParameter() function in Hibernate.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.AdjustCommand(System.Data.IDbCommand)">
            <summary>
            Override to make any adjustments to each IDbCommand object before it added to the batcher.
            </summary>
            <param name="command">The command.</param>
            <remarks>
            This method is similar to the <see cref="M:NHibernate.Driver.DriverBase.OnBeforePrepare(System.Data.IDbCommand)"/> but, instead be called just before execute the command (that can be a batch)
            is executed before add each single command to the batcher and before <see cref="M:NHibernate.Driver.DriverBase.OnBeforePrepare(System.Data.IDbCommand)"/> .
            If you have to adjust parameters values/type (when the command is full filled) this is a good place where do it.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.UseNamedPrefixInSql">
            <summary>
            Does this Driver require the use of a Named Prefix in the SQL statement.  
            </summary>
            <remarks>
            For example, SqlClient requires <c>select * from simple where simple_id = @simple_id</c>
            If this is false, like with the OleDb provider, then it is assumed that  
            the <c>?</c> can be a placeholder for the parameter in the SQL statement.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.UseNamedPrefixInParameter">
            <summary>
            Does this Driver require the use of the Named Prefix when trying
            to reference the Parameter in the Command's Parameter collection.  
            </summary>
            <remarks>
            This is really only useful when the UseNamedPrefixInSql == true.  When this is true the
            code will look like:
            <code>IDbParameter param = cmd.Parameters["@paramName"]</code>
            if this is false the code will be 
            <code>IDbParameter param = cmd.Parameters["paramName"]</code>.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.NamedPrefix">
            <summary>
            The Named Prefix for parameters.  
            </summary>
            <remarks>
            Sql Server uses <c>"@"</c> and Oracle uses <c>":"</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.DriverBase.SupportsPreparingCommands">
            <summary>
            Does this Driver support IDbCommand.Prepare().
            </summary>
            <remarks>
            <para>
            A value of <see langword="false" /> indicates that an exception would be thrown or the 
            company that produces the Driver we are wrapping does not recommend using
            IDbCommand.Prepare().
            </para>
            <para>
            A value of <see langword="true" /> indicates that calling IDbCommand.Prepare() will function
            fine on this Driver.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.ReflectionBasedDriver.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.ReflectionBasedDriver"/> with
            type names that are loaded from the specified assembly.
            </summary>
            <param name="driverAssemblyName">Assembly to load the types from.</param>
            <param name="connectionTypeName">Connection type name.</param>
            <param name="commandTypeName">Command type name.</param>
        </member>
        <member name="M:NHibernate.Driver.ReflectionBasedDriver.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.ReflectionBasedDriver"/> with
            type names that are loaded from the specified assembly.
            </summary>
            <param name="providerInvariantName">The Invariant name of a provider.</param>
            <param name="driverAssemblyName">Assembly to load the types from.</param>
            <param name="connectionTypeName">Connection type name.</param>
            <param name="commandTypeName">Command type name.</param>
            <seealso cref="M:System.Data.Common.DbProviderFactories.GetFactory(System.String)"/>
        </member>
        <member name="M:NHibernate.Driver.CsharpSqliteDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.CsharpSqliteDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Community.CsharpSqlite.dll</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.DB2400Driver">
            <summary>
            A NHibernate Driver for using the IBM.Data.DB2.iSeries DataProvider.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.DB2400Driver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DB2Driver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.DB2.iSeries</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.DB2Driver">
            <summary>
            A NHibernate Driver for using the IBM.Data.DB2 DataProvider.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.DB2Driver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DB2Driver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.DB2</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.DotConnectMySqlDriver">
            <summary>
            Provides a database driver for dotConnect for MySQL by DevArt.
            </summary>
            <remarks>
            <para>
            In order to use this driver you must have the assembly <c>Devart.Data.MySql.dll</c> available for 
            NHibernate to load, including its dependencies (<c>Devart.Data.dll</c>).
            </para>
            <para>
            Please check the product's <see href="http://www.devart.com/dotconnect/mysql/">website</see>
            for any updates and/or documentation regarding dotConnect for MySQL.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.DotConnectMySqlDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DotConnectMySqlDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Devart.Data.MySql</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="P:NHibernate.Driver.DotConnectMySqlDriver.UseNamedPrefixInSql">
            <summary>
            Devart.Data.MySql uses named parameters in the sql.
            </summary>
            <value><see langword="true" /> - MySql uses <c>@</c> in the sql.</value>
        </member>
        <member name="P:NHibernate.Driver.DotConnectMySqlDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.DotConnectMySqlDriver.NamedPrefix">
            <summary>
            Devart.Data.MySql use the <c>@</c> to locate parameters in sql.
            </summary>
            <value><c>@</c> is used to locate parameters in sql.</value>
        </member>
        <member name="T:NHibernate.Driver.FirebirdClientDriver">
            <summary>
            A NHibernate Driver for using the Firebird data provider located in
            <c>FirebirdSql.Data.FirebirdClient</c> assembly.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.FirebirdClientDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.FirebirdClientDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>FirebirdSql.Data.Firebird</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.IfxDriver">
            <summary>
            A NHibernate Driver for using the Informix DataProvider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.IfxDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.IfxDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.Informix</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.IngresDriver">
            <summary>
            A NHibernate Driver for using the Ingres DataProvider
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.MySqlDataDriver">
            <summary>
            Provides a database driver for MySQL.
            </summary>
            <remarks>
            <para>
            In order to use this driver you must have the assembly <c>MySql.Data.dll</c> available for 
            NHibernate to load, including its dependencies (<c>ICSharpCode.SharpZipLib.dll</c> is required by
            the assembly <c>MySql.Data.dll</c> as of the time of this writing).
            </para>
            <para>
            Please check the product's <see href="http://www.mysql.com/products/connector/net/">website</see>
            for any updates and/or documentation regarding MySQL.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.MySqlDataDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.MySqlDataDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>MySql.Data</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInSql">
            <summary>
            MySql.Data uses named parameters in the sql.
            </summary>
            <value><see langword="true" /> - MySql uses <c>?</c> in the sql.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.NamedPrefix">
            <summary>
            MySql.Data use the <c>?</c> to locate parameters in sql.
            </summary>
            <value><c>?</c> is used to locate parameters in sql.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsMultipleOpenReaders">
            <summary>
            The MySql.Data driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsPreparingCommands">
            <summary>
            MySql.Data does not support preparing of commands.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
            <remarks>
            With the Gamma MySql.Data provider it is throwing an exception with the 
            message "Expected End of data packet" when a select command is prepared.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.NDataReader">
            <summary>
            Some Data Providers (ie - SqlClient) do not support Multiple Active Result Sets (MARS).
            NHibernate relies on being able to create MARS to read Components and entities inside
            of Collections.
            </summary>
            <remarks>
            This is a completely off-line DataReader - the underlying IDataReader that was used to create
            this has been closed and no connections to the Db exists.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Creates a NDataReader from a <see cref="T:System.Data.IDataReader"/>
            </summary>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to get the records from the Database.</param>
            <param name="isMidstream"><see langword="true"/> if we are loading the <see cref="T:System.Data.IDataReader"/> in the middle of reading it.</param>
            <remarks>
            NHibernate attempts to not have to read the contents of an <see cref="T:System.Data.IDataReader"/> into memory until it absolutely
            has to.  What that means is that it might have processed some records from the <see cref="T:System.Data.IDataReader"/> and will
            pick up the <see cref="T:System.Data.IDataReader"/> midstream so that the underlying <see cref="T:System.Data.IDataReader"/> can be closed 
            so a new one can be opened.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.ClearCache">
            <summary>
            Sets the values that can be cached back to null and sets the 
            index of the cached column to -1
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NextResult">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Read">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <remarks>
            There are not any unmanaged resources or any disposable managed 
            resources that this class is holding onto.  It is in here
            to comply with the <see cref="T:System.Data.IDataReader"/> interface.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt32(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetValue(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.IsDBNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferOffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetByte(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDecimal(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetValues(System.Object[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt64(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDouble(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetBoolean(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetGuid(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDateTime(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetFloat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetData(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferOffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetString(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetChar(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt16(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.RecordsAffected">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.IsClosed">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Depth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Item(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.FieldCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NDataReader.NResult">
            <summary>
            Stores a Result from a DataReader in memory.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Initializes a new instance of the NResult class.
            </summary>
            <param name="reader">The IDataReader to populate the Result with.</param>
            <param name="isMidstream">
            <see langword="true"/> if the <see cref="T:System.Data.IDataReader"/> is already positioned on the record
            to start reading from.
            </param>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldCount">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="colName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="colName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValues(System.Int32,System.Object[])">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.NResult.RowCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NHybridDataReader">
            <summary>
            An implementation of <see cref="T:System.Data.IDataReader"/> that will work with either an 
            <see cref="T:System.Data.IDataReader"/> returned by Execute or with an <see cref="T:System.Data.IDataReader"/>
            whose contents have been read into a <see cref="T:NHibernate.Driver.NDataReader"/>.
            </summary>
            <remarks>
            <para>
            This allows NHibernate to use the underlying <see cref="T:System.Data.IDataReader"/> for as long as
            possible without the need to read everything into the <see cref="T:NHibernate.Driver.NDataReader"/>.
            </para>
            <para>
            The consumer of the <see cref="T:System.Data.IDataReader"/> returned from <see cref="T:NHibernate.Engine.IBatcher"/> does
            not need to know the underlying reader and can use it the same even if it switches from an
            <see cref="T:System.Data.IDataReader"/> to <see cref="T:NHibernate.Driver.NDataReader"/> in the middle of its use.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NHybridDataReader"/> class.
            </summary>
            <param name="reader">The underlying IDataReader to use.</param>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Initializes a new instance of the NHybridDataReader class.
            </summary>
            <param name="reader">The underlying IDataReader to use.</param>
            <param name="inMemory"><see langword="true" /> if the contents of the IDataReader should be read into memory right away.</param>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.ReadIntoMemory">
            <summary>
            Reads all of the contents into memory because another <see cref="T:System.Data.IDataReader"/>
            needs to be opened.
            </summary>
            <remarks>
            This will result in a no op if the reader is closed or is already in memory.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.NextResult">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Read">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Driver.NHybridDataReader._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this NHybridDataReader is being Disposed of or Finalized.</param>
            <remarks>
            If this NHybridDataReader is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this NHybridDataReader back to life.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt32(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetValue(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.IsDBNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetByte(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDecimal(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetValues(System.Object[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt64(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDouble(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetBoolean(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetGuid(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDateTime(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetFloat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetData(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldoffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetString(System.Int32)">
            <summary>
             
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetChar(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt16(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.IsMidstream">
            <summary>
            Gets if the object is in the middle of reading a Result.
            </summary>
            <value><see langword="true"/> if NextResult and Read have been called on the <see cref="T:System.Data.IDataReader"/>.</value>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.RecordsAffected">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.IsClosed">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.Depth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.Item(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.System#Data#IDataRecord#Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.FieldCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NpgsqlDriver">
            <summary>
            The PostgreSQL data provider provides a database driver for PostgreSQL.
            <p>
            Author: <a href="mailto:oliver@weichhold.com">Oliver Weichhold</a>
            </p>
            </summary>
            <remarks>
            <p>
            In order to use this Driver you must have the Npgsql.dll Assembly available for 
            NHibernate to load it.
            </p>
            <p>
            Please check the products website 
            <a href="http://www.postgresql.org/">http://www.postgresql.org/</a>
            for any updates and or documentation.
            </p>
            <p>
            The homepage for the .NET DataProvider is: 
            <a href="http://pgfoundry.org/projects/npgsql">http://pgfoundry.org/projects/npgsql</a>. 
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NpgsqlDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NpgsqlDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Npgsql</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.OdbcDriver">
            <summary>
            A NHibernate Driver for using the Odbc DataProvider
            </summary>
            <remarks>
            Always look for a native .NET DataProvider before using the Odbc DataProvider.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.OleDbDriver">
            <summary>
            A NHibernate Driver for using the OleDb DataProvider
            </summary>
            <remarks>
            Always look for a native .NET DataProvider before using the OleDb DataProvider.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.SupportsMultipleOpenReaders">
            <summary>
            OLE DB provider does not support multiple open data readers
            </summary>
        </member>
        <member name="T:NHibernate.Driver.OracleClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle DataProvider.
            </summary>
        </member>
        <member name="T:NHibernate.Driver.OracleDataClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle.DataAccess DataProvider
            </summary>
            <remarks>
            Code was contributed by <a href="http://sourceforge.net/users/jemcalgary/">James Mills</a>
            on the NHibernate forums in this 
            <a href="http://sourceforge.net/forum/message.php?msg_id=2952662">post</a>.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.OracleDataClientDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.OracleDataClientDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Oracle.DataAccess</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Driver.OracleDataClientDriver.InitializeParameter(System.Data.IDbDataParameter,System.String,NHibernate.SqlTypes.SqlType)">
            <remarks>
            This adds logic to ensure that a DbType.Boolean parameter is not created since
            ODP.NET doesn't support it.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInSql">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.NamedPrefix">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.OracleLiteDataClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle.DataAccess.Lite DataProvider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.OracleLiteDataClientDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.OracleLiteDataClientDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Oracle.DataAccess.Lite_w32</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Driver.OracleLiteDataClientDriver.InitializeParameter(System.Data.IDbDataParameter,System.String,NHibernate.SqlTypes.SqlType)">
            <remarks>
            This adds logic to ensure that a DbType.Boolean parameter is not created since
            ODP.NET doesn't support it.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.OracleManagedDataClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle.ManagedDataAccess DataProvider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.OracleManagedDataClientDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.OracleDataClientDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Oracle.ManagedDataAccess</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Driver.OracleManagedDataClientDriver.InitializeParameter(System.Data.IDbDataParameter,System.String,NHibernate.SqlTypes.SqlType)">
            <remarks>
            This adds logic to ensure that a DbType.Boolean parameter is not created since
            ODP.NET doesn't support it.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.OracleManagedDataClientDriver.NamedPrefix">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleManagedDataClientDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleManagedDataClientDriver.UseNamedPrefixInSql">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.SqlClientDriver">
            <summary>
            A NHibernate Driver for using the SqlClient DataProvider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.CreateConnection">
            <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbConnection"/> object for
            the SqlClientDriver.
            </summary>
            <value>An unitialized <see cref="T:System.Data.SqlClient.SqlConnection"/> object.</value>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.CreateCommand">
            <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbCommand"/> object for
            the SqlClientDriver.
            </summary>
            <value>An unitialized <see cref="T:System.Data.SqlClient.SqlCommand"/> object.</value>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.IsText(System.Data.IDbDataParameter,NHibernate.SqlTypes.SqlType)">
            <summary>
            Interprets if a parameter is a Clob (for the purposes of setting its default size)
            </summary>
            <param name="dbParam">The parameter</param>
            <param name="sqlType">The <see cref="T:NHibernate.SqlTypes.SqlType"/> of the parameter</param>
            <returns>True, if the parameter should be interpreted as a Clob, otherwise False</returns>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.IsBlob(System.Data.IDbDataParameter,NHibernate.SqlTypes.SqlType)">
            <summary>
            Interprets if a parameter is a Blob (for the purposes of setting its default size)
            </summary>
            <param name="dbParam">The parameter</param>
            <param name="sqlType">The <see cref="T:NHibernate.SqlTypes.SqlType"/> of the parameter</param>
            <returns>True, if the parameter should be interpreted as a Blob, otherwise False</returns>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInSql">
            <summary>
            MsSql requires the use of a Named Prefix in the SQL statement.
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInParameter">
            <summary>
            MsSql requires the use of a Named Prefix in the Parameter.
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.NamedPrefix">
            <summary>
            The Named Prefix for parameters.
            </summary>
            <value>
            Sql Server uses <c>"@"</c>.
            </value>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.SupportsMultipleOpenReaders">
            <summary>
            The SqlClient driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
            <remarks>
            MS SQL Server 2000 (and 7) throws an exception when multiple IDataReaders are
            attempted to be opened.  When SQL Server 2005 comes out a new driver will be
            created for it because SQL Server 2005 is supposed to support it.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.SQLite20Driver">
            <summary>
            NHibernate driver for the System.Data.SQLite data provider for .NET 2.0.
            </summary>
            <remarks>
            <p>
            In order to use this driver you must have the System.Data.SQLite.dll assembly available
            for NHibernate to load. This assembly includes the SQLite.dll or SQLite3.dll libraries.
            </p>    
            <p>
            You can get the System.Data.SQLite.dll assembly from http://sourceforge.net/projects/sqlite-dotnet2.
            </p>
            <p>
            Please check <a href="http://www.sqlite.org/">http://www.sqlite.org/</a> for more information regarding SQLite.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.SQLite20Driver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.SQLite20Driver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>SQLite.NET</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.SqlServerCeDriver">
            <summary>
            A NHibernate driver for Microsoft SQL Server CE data provider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SqlServerCeDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SqlServerCeDriver"/> class.
            </summary>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.UseNamedPrefixInSql">
            <summary>
            MsSql requires the use of a Named Prefix in the SQL statement.  
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.UseNamedPrefixInParameter">
            <summary>
            MsSql requires the use of a Named Prefix in the Parameter.  
            </summary>
            <remarks>
            <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.NamedPrefix">
            <summary>
            The Named Prefix for parameters.  
            </summary>
            <value>
            Sql Server uses <c>"@"</c>.
            </value>
        </member>
        <member name="P:NHibernate.Driver.SqlServerCeDriver.SupportsMultipleOpenReaders">
            <summary>
            The SqlClient driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><see langword="false" /> - it is not supported.</value>
            <remarks>
            Ms Sql 2000 (and 7) throws an Exception when multiple DataReaders are 
            attempted to be Opened.  When Yukon comes out a new Driver will be 
            created for Yukon because it is supposed to support it.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.SybaseAsaClientDriver">
            <summary>
            The SybaseAsaClientDriver driver provides a database driver for Adaptive Server Anywhere 9.0.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SybaseAsaClientDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SybaseAsaClientDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the iAnywhere.Data.AsaClient assembly is not and can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.SybaseAseClientDriver">
            <summary>
            This provides a driver for Sybase ASE 15 using the ADO.NET driver.
            </summary>
            <remarks>
            You will need the following libraries available to your application:
            <ul>
            <li>Sybase.AdoNet2.AseClient.dll</li>
            <li>sybdrvado20.dll</li>
            </ul>
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.SybaseSQLAnywhereDotNet4Driver">
             <summary>
             SQL Dialect for SQL Anywhere 12 - for the NHibernate 3.2.0 distribution
             Copyright (C) 2011 Glenn Paulley
             Contact: http://iablog.sybase.com/paulley
            
             This NHibernate dialect for SQL Anywhere 12 is a contribution to the NHibernate
             open-source project. It is intended to be included in the NHibernate 
             distribution and is licensed under LGPL.
            
             This library is free software; you can redistribute it and/or
             modify it under the terms of the GNU Lesser General Public
             License as published by the Free Software Foundation; either
             version 2.1 of the License, or (at your option) any later version.
            
             This library is distributed in the hope that it will be useful,
             but WITHOUT ANY WARRANTY; without even the implied warranty of
             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
             Lesser General Public License for more details.
            
             You should have received a copy of the GNU Lesser General Public
             License along with this library; if not, write to the Free Software
             Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
             </summary>
             <remarks>
             The SybaseSQLAnywhereDotNet4Driver provides a .NET 4 database driver for 
             Sybase SQL Anywhere 12 using the versioned ADO.NET driver 
             iAnywhere.Data.SQLAnywhere.v4.0.
             </remarks>
        </member>
        <member name="M:NHibernate.Driver.SybaseSQLAnywhereDotNet4Driver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SybaseSQLAnywhereDotNet4Driver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the iAnywhere.Data.SQLAnywhere.v4.0 assembly is not and can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.SybaseSQLAnywhereDriver">
            <summary>
            The SybaseSQLAnywhereDriver Driver provides a database driver for Sybase SQL Anywhere 10 and above
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SybaseSQLAnywhereDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SybaseSQLAnywhereDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the iAnywhere.Data.SQLAnywhere assembly is not and can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Engine.Loading.CollectionLoadContext">
            <summary> 
            Represents state associated with the processing of a given <see cref="T:System.Data.IDataReader"/>
            in regards to loading collections.
            </summary>
            <remarks>
            Another implementation option to consider is to not expose <see cref="T:System.Data.IDataReader">ResultSets</see>
            directly (in the JDBC redesign) but to always "wrap" them and apply a [series of] context[s] to that wrapper.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.#ctor(NHibernate.Engine.Loading.LoadContexts,System.Data.IDataReader)">
            <summary> 
            Creates a collection load context for the given result set. 
            </summary>
            <param name="loadContexts">Callback to other collection load contexts. </param>
            <param name="resultSet">The result set this is "wrapping".</param>
        </member>
        <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.GetLoadingCollection(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary> 
            Retrieve the collection that is being loaded as part of processing this result set. 
            </summary>
            <param name="persister">The persister for the collection being requested. </param>
            <param name="key">The key of the collection being requested. </param>
            <returns> The loading collection (see discussion above). </returns>
            <remarks>
            Basically, there are two valid return values from this method:<ul>
            <li>an instance of {@link PersistentCollection} which indicates to
            continue loading the result set row data into that returned collection
            instance; this may be either an instance already associated and in the
            midst of being loaded, or a newly instantiated instance as a matching
            associated collection was not found.</li>
            <li><i>null</i> indicates to ignore the corresponding result set row
            data relating to the requested collection; this indicates that either
            the collection was found to already be associated with the persistence
            context in a fully loaded state, or it was found in a loading state
            associated with another result set processing context.</li>
            </ul>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.EndLoadingCollections(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary> 
            Finish the process of collection-loading for this bound result set.  Mainly this
            involves cleaning up resources and notifying the collections that loading is
            complete. 
            </summary>
            <param name="persister">The persister for which to complete loading. </param>
        </member>
        <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.AddCollectionToCache(NHibernate.Engine.Loading.LoadingCollectionEntry,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary> Add the collection to the second-level cache </summary>
            <param name="lce">The entry representing the collection to add </param>
            <param name="persister">The persister </param>
        </member>
        <member name="T:NHibernate.Engine.Loading.LoadContexts">
            <summary> 
            Maps <see cref="T:System.Data.IDataReader"/> to specific contextual data
            related to processing that <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <remarks>
            Implementation note: internally an <see cref="T:NHibernate.Util.IdentityMap"/> is used to maintain
            the mappings; <see cref="T:NHibernate.Util.IdentityMap"/> was chosen because I'd rather not be
            dependent upon potentially bad <see cref="T:System.Data.IDataReader"/> and <see cref="T:System.Data.IDataReader"/>
            implementations.
            Considering the JDBC-redesign work, would further like this contextual info
            not mapped separately, but available based on the result set being processed.
            This would also allow maintaining a single mapping as we could reliably get
            notification of the result-set closing...
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.#ctor(NHibernate.Engine.IPersistenceContext)">
            <summary> Creates and binds this to the given persistence context. </summary>
            <param name="persistenceContext">The persistence context to which this will be bound. </param>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.Cleanup(System.Data.IDataReader)">
            <summary> 
            Release internal state associated with the given result set.
             </summary>
            <param name="resultSet">The result set for which it is ok to release associated resources. </param>
            <remarks>
            This should be called when we are done with processing said result set,
            ideally as the result set is being closed.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.Cleanup">
            <summary> Release internal state associated with *all* result sets. </summary>
            <remarks>
            This is intended as a "failsafe" process to make sure we get everything
            cleaned up and released.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.GetCollectionLoadContext(System.Data.IDataReader)">
            <summary> 
            Get the {@link CollectionLoadContext} associated with the given
            {@link ResultSet}, creating one if needed. 
            </summary>
            <param name="resultSet">The result set for which to retrieve the context. </param>
            <returns> The processing context. </returns>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.LocateLoadingCollection(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary> 
            Attempt to locate the loading collection given the owner's key.  The lookup here
            occurs against all result-set contexts... 
            </summary>
            <param name="persister">The collection persister </param>
            <param name="ownerKey">The owner key </param>
            <returns> The loading collection, or null if not found. </returns>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.RegisterLoadingCollectionXRef(NHibernate.Engine.CollectionKey,NHibernate.Engine.Loading.LoadingCollectionEntry)">
            <summary> 
            Register a loading collection xref. 
            </summary>
            <param name="entryKey">The xref collection key </param>
            <param name="entry">The corresponding loading collection entry </param>
            <remarks>
            This xref map is used because sometimes a collection is in process of
            being loaded from one result set, but needs to be accessed from the
            context of another "nested" result set processing.
            Implementation note: package protected, as this is meant solely for use
            by {@link CollectionLoadContext} to be able to locate collections
            being loaded by other {@link CollectionLoadContext}s/{@link ResultSet}s.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.UnregisterLoadingCollectionXRef(NHibernate.Engine.CollectionKey)">
            <summary> 
            The inverse of {@link #registerLoadingCollectionXRef}.  Here, we are done
            processing the said collection entry, so we remove it from the
            load context.
            </summary>
            <param name="key">The key of the collection we are done processing. </param>
            <remarks>
            The idea here is that other loading collections can now reference said
            collection directly from the {@link PersistenceContext} because it
            has completed its load cycle.
            Implementation note: package protected, as this is meant solely for use
            by {@link CollectionLoadContext} to be able to locate collections
            being loaded by other {@link CollectionLoadContext}s/{@link ResultSet}s.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Loading.LoadContexts.LocateLoadingCollectionEntry(NHibernate.Engine.CollectionKey)">
            <summary> 
            Locate the LoadingCollectionEntry within *any* of the tracked
            <see cref="T:NHibernate.Engine.Loading.CollectionLoadContext"/>s.
            </summary>
            <param name="key">The collection key. </param>
            <returns> The located entry; or null. </returns>
            <remarks>
            Implementation note: package protected, as this is meant solely for use
            by <see cref="T:NHibernate.Engine.Loading.CollectionLoadContext"/> to be able to locate collections
            being loaded by other <see cref="T:NHibernate.Engine.Loading.CollectionLoadContext"/>s/ResultSets. 
            </remarks>
        </member>
        <member name="P:NHibernate.Engine.Loading.LoadContexts.PersistenceContext">
            <summary> 
            Retrieves the persistence context to which this is bound.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.Loading.LoadContexts.HasLoadingCollectionEntries">
            <summary> 
            Do we currently have any internal entries corresponding to loading
            collections?
            </summary>
            <returns> True if we currently hold state pertaining to loading collections; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Engine.Loading.LoadContexts.HasRegisteredLoadingCollectionEntries">
            <summary>
             Do we currently have any registered internal entries corresponding to loading
             collections?
             True if we currently hold state pertaining to a registered loading collections; false otherwise.
             </summary>
        </member>
        <member name="T:NHibernate.Engine.Loading.LoadingCollectionEntry">
            <summary> 
            Represents a collection currently being loaded. 
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.Sql.INativeSQLQueryReturn">
            <summary> Describes a return in a native SQL query. </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn">
            <summary> 
            Represents a return defined as part of a native sql query which
            names a collection role in the form {classname}.{collectionrole}; it
            is used in defining a custom sql query for loading an entity's
            collection in non-fetching scenarios (i.e., loading the collection
            itself as the "root" of the result). 
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn">
            <summary> 
            Represents the base information for a non-scalar return defined as part of
            a native sql query. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
            <summary> Constructs some form of non-scalar return descriptor </summary>
            <param name="alias">The result alias </param>
            <param name="propertyResults">Any user-supplied column->property mappings </param>
            <param name="lockMode">The lock mode to apply to the return. </param>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.Alias">
            <summary> Retrieve the defined result alias </summary>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.LockMode">
            <summary> Retrieve the lock-mode to apply to this return </summary>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.PropertyResultsMap">
            <summary> Retrieve the user-supplied column->property mappings. </summary>
        </member>
        <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.#ctor(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
            <summary> Construct a native-sql return representing a collection initializer </summary>
            <param name="alias">The result alias </param>
            <param name="ownerEntityName">
            The entity-name of the entity owning the collection to be initialized. 
            </param>
            <param name="ownerProperty">
            The property name (on the owner) which represents
            the collection to be initialized.
            </param>
            <param name="propertyResults">Any user-supplied column->property mappings </param>
            <param name="lockMode">The lock mode to apply to the collection. </param>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.OwnerEntityName">
            <summary> 
            The class owning the collection. 
            </summary>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.OwnerProperty">
            <summary> 
            The name of the property representing the collection from the <see cref="P:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.OwnerEntityName"/>. 
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn">
            <summary> 
            Represents a return defined as part of a native sql query which
            names a fetched role. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn.#ctor(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
            <summary> Construct a return descriptor representing some form of fetch. </summary>
            <param name="alias">The result alias </param>
            <param name="ownerAlias">The owner's result alias </param>
            <param name="ownerProperty">The owner's property representing the thing to be fetched </param>
            <param name="propertyResults">Any user-supplied column->property mappings </param>
            <param name="lockMode">The lock mode to apply </param>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn.OwnerAlias">
            <summary> The alias of the owner of this fetched association. </summary>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn.OwnerProperty">
            <summary> 
            Retrieve the property name (relative to the owner) which maps to
            the association to be fetched. 
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn">
            <summary> 
            Represents a return defined as part of a native sql query which
            names a "root" entity.  A root entity means it is explicitly a
            "column" in the result, as opposed to a fetched relationship or role. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn.#ctor(System.String,System.String,NHibernate.LockMode)">
            <summary> 
            Construct a return representing an entity returned at the root
            of the result.
             </summary>
            <param name="alias">The result alias </param>
            <param name="entityName">The entity name. </param>
            <param name="lockMode">The lock mode to apply </param>
        </member>
        <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
            <summary> 
            Construct a return representing an entity returned at the root
            of the result. 
            </summary>
            <param name="alias">The result alias </param>
            <param name="entityName">The entity name. </param>
            <param name="propertyResults">Any user-supplied column->property mappings </param>
            <param name="lockMode">The lock mode to apply </param>
        </member>
        <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn.ReturnEntityName">
            <summary> The name of the entity to be returned. </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryScalarReturn">
            <summary> Describes a scalar return in a native SQL query. </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.FilterQueryPlan">
            <summary> 
            Extends an HQLQueryPlan to maintain a reference to the collection-role name
            being filtered. 
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.HQLQueryPlan">
            <summary> Defines a query execution plan for an HQL query (or filter). </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.NamedParameterDescriptor">
            <summary> Descriptor regarding a named parameter. </summary>
        </member>
        <member name="P:NHibernate.Engine.Query.NamedParameterDescriptor.JpaStyle">
            <summary>
            Not supported yet (AST parse needed)
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.NativeSQLQueryPlan">
            <summary> Defines a query execution plan for a native-SQL query. </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.ParameterMetadata">
            <summary> Encapsulates metadata about parameters encountered within a query. </summary>
        </member>
        <member name="T:NHibernate.Engine.Query.ParameterParser">
            <summary>
            The single available method <see cref="M:NHibernate.Engine.Query.ParameterParser.Parse(System.String,NHibernate.Engine.Query.ParameterParser.IRecognizer)"/>
            is responsible for parsing a query string and recognizing tokens in
            relation to parameters (either named, ejb3-style, or ordinal) and
            providing callbacks about such recognitions.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Query.ParameterParser.Parse(System.String,NHibernate.Engine.Query.ParameterParser.IRecognizer)">
            <summary>
            Performs the actual parsing and tokenizing of the query string making appropriate
            callbacks to the given recognizer upon recognition of the various tokens.
            </summary>
            <remarks>
            Note that currently, this only knows how to deal with a single output
            parameter (for callable statements).  If we later add support for
            multiple output params, this, obviously, needs to change.
            </remarks>
            <param name="sqlString">The string to be parsed/tokenized.</param>
            <param name="recognizer">The thing which handles recognition events.</param>
            <exception cref="T:NHibernate.QueryException"/>
        </member>
        <member name="T:NHibernate.Engine.Query.ParamLocationRecognizer">
            <summary> 
            Implements a parameter parser recognizer specifically for the purpose
            of journaling parameter locations. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Query.ParamLocationRecognizer.ParseLocations(System.String)">
            <summary> 
            Convenience method for creating a param location recognizer and
            initiating the parse. 
            </summary>
            <param name="query">The query to be parsed for parameter locations. </param>
            <returns> The generated recognizer, with journaled location info. </returns>
        </member>
        <member name="P:NHibernate.Engine.Query.ParamLocationRecognizer.NamedParameterDescriptionMap">
            <summary> 
            The dictionary of named parameter locations.
            The dictionary is keyed by parameter name.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.Query.ParamLocationRecognizer.OrdinalParameterLocationList">
            <summary> 
            The list of ordinal parameter locations. 
            </summary>
            <remarks>
            The list elements are integers, representing the location for that given ordinal.
            Thus OrdinalParameterLocationList[n] represents the location for the nth parameter.
            </remarks>
        </member>
        <member name="T:NHibernate.Engine.Query.QueryPlanCache">
            <summary> Acts as a cache for compiled query plans, as well as query-parameter metadata. </summary>
        </member>
        <member name="T:NHibernate.Engine.Transaction.IIsolatedWork">
            <summary>
            Represents work that needs to be performed in a manner
            which isolates it from any current application unit of
            work transaction.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Transaction.IIsolatedWork.DoWork(System.Data.IDbConnection,System.Data.IDbTransaction)">
            <summary>
            Perform the actual work to be done.
            </summary>
            <param name="connection">The ADP connection to use.</param>
            <param name="transaction">The active transaction of the connection.</param>
        </member>
        <member name="T:NHibernate.Engine.Transaction.Isolater">
            <summary>
            Class which provides the isolation semantics required by
            an <see cref="T:NHibernate.Engine.Transaction.IIsolatedWork"/>.
            </summary>
            <remarks>
            <list type="bullet">
            <listheader>
                 <description>Processing comes in two flavors:</description>
             </listheader>
             <item>
                 <term><see cref="M:NHibernate.Engine.Transaction.Isolater.DoIsolatedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)"/> </term>
                 <description>makes sure the work to be done is performed in a separate, distinct transaction</description>
             </item>
             <item>
                 <term><see cref="M:NHibernate.Engine.Transaction.Isolater.DoNonTransactedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)"/> </term>
                 <description>makes sure the work to be done is performed outside the scope of any transaction</description>
             </item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.Transaction.Isolater.DoIsolatedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Ensures that all processing actually performed by the given work will
            occur on a separate transaction. 
            </summary>
            <param name="work">The work to be performed. </param>
            <param name="session">The session from which this request is originating. </param>
        </member>
        <member name="M:NHibernate.Engine.Transaction.Isolater.DoNonTransactedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Ensures that all processing actually performed by the given work will
            occur outside of a transaction. 
            </summary>
            <param name="work">The work to be performed. </param>
            <param name="session">The session from which this request is originating. </param>
        </member>
        <member name="T:NHibernate.Engine.ActionQueue">
            <summary> 
            Responsible for maintaining the queue of actions related to events.
            <para>
            The ActionQueue holds the DML operations queued as part of a session's
            transactional-write-behind semantics. DML operations are queued here
            until a flush forces them to be executed against the database. 
            </para>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ActionQueue.ExecuteInserts">
            <summary> 
            Perform all currently queued entity-insertion actions.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ActionQueue.ExecuteActions">
            <summary> 
            Perform all currently queued actions. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ActionQueue.PrepareActions">
            <summary>
            Prepares the internal action queues for execution.  
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ActionQueue.BeforeTransactionCompletion">
            <summary>
            Execute any registered <see cref="T:NHibernate.Action.BeforeTransactionCompletionProcessDelegate"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ActionQueue.AfterTransactionCompletion(System.Boolean)">
            <summary> 
            Performs cleanup of any held cache softlocks.
            </summary>
            <param name="success">Was the transaction successful.</param>
        </member>
        <member name="M:NHibernate.Engine.ActionQueue.AreTablesToBeUpdated(System.Collections.Generic.ISet{System.String})">
            <summary> 
            Check whether the given tables/query-spaces are to be executed against
            given the currently queued actions. 
            </summary>
            <param name="tables">The table/query-spaces to check. </param>
            <returns> True if we contain pending actions against any of the given tables; false otherwise.</returns>
        </member>
        <member name="P:NHibernate.Engine.ActionQueue.AreInsertionsOrDeletionsQueued">
            <summary> 
            Check whether any insertion or deletion actions are currently queued. 
            </summary>
            <returns> True if insertions or deletions are currently queued; false otherwise.</returns>
        </member>
        <member name="T:NHibernate.Engine.AssociationKey">
            <summary> 
            Identifies a named association belonging to a particular
            entity instance. Used to record the fact that an association
            is null during loading. 
            </summary>
        </member>
        <member name="F:NHibernate.Engine.BatchFetchQueue.batchLoadableEntityKeys">
            <summary>
            Defines a sequence of <see cref="T:NHibernate.Engine.EntityKey"/> elements that are currently
            eligible for batch fetching.
            </summary>
            <remarks>
            Even though this is a map, we only use the keys.  A map was chosen in
            order to utilize a <see cref="T:NHibernate.Util.LinkedHashMap`2"/> to maintain sequencing
            as well as uniqueness.
            </remarks>
        </member>
        <member name="F:NHibernate.Engine.BatchFetchQueue.subselectsByEntityKey">
            <summary>
            A map of <see cref="T:NHibernate.Engine.SubselectFetch">subselect-fetch descriptors</see>
            keyed by the <see cref="T:NHibernate.Engine.EntityKey"/> against which the descriptor is
            registered.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.BatchFetchQueue.context">
            <summary>
            The owning persistence context.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.#ctor(NHibernate.Engine.IPersistenceContext)">
            <summary>
            Constructs a queue for the given context.
            </summary>
            <param name="context">The owning persistence context.</param>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.Clear">
            <summary>
            Clears all entries from this fetch queue.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.GetSubselect(NHibernate.Engine.EntityKey)">
            <summary>
            Retrieve the fetch descriptor associated with the given entity key.
            </summary>
            <param name="key">The entity key for which to locate any defined subselect fetch.</param>
            <returns>The fetch descriptor; may return null if no subselect fetch queued for
            this entity key.</returns>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.AddSubselect(NHibernate.Engine.EntityKey,NHibernate.Engine.SubselectFetch)">
            <summary>
            Adds a subselect fetch decriptor for the given entity key.
            </summary>
            <param name="key">The entity for which to register the subselect fetch.</param>
            <param name="subquery">The fetch descriptor.</param>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.RemoveSubselect(NHibernate.Engine.EntityKey)">
            <summary>
            After evicting or deleting an entity, we don't need to
            know the query that was used to load it anymore (don't
            call this after loading the entity, since we might still
            need to load its collections)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.ClearSubselects">
            <summary>
            Clears all pending subselect fetches from the queue.
            </summary>
            <remarks>
            Called after flushing.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.AddBatchLoadableEntityKey(NHibernate.Engine.EntityKey)">
            <summary>
            If an EntityKey represents a batch loadable entity, add
            it to the queue.
            </summary>
            <remarks>
            Note that the contract here is such that any key passed in should
            previously have been been checked for existence within the
            <see cref="T:NHibernate.ISession"/>; failure to do so may cause the
            referenced entity to be included in a batch even though it is
            already associated with the <see cref="T:NHibernate.ISession"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.RemoveBatchLoadableEntityKey(NHibernate.Engine.EntityKey)">
            <summary>
            After evicting or deleting or loading an entity, we don't
            need to batch fetch it anymore, remove it from the queue
            if necessary
            </summary>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.GetCollectionBatch(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            Get a batch of uninitialized collection keys for a given role
            </summary>
            <param name="collectionPersister">The persister for the collection role.</param>
            <param name="id">A key that must be included in the batch fetch</param>
            <param name="batchSize">the maximum number of keys to return</param>
            <param name="entityMode">The entity mode.</param>
            <returns>an array of collection keys, of length batchSize (padded with nulls)</returns>
        </member>
        <member name="M:NHibernate.Engine.BatchFetchQueue.GetEntityBatch(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Int32)">
            <summary>
            Get a batch of unloaded identifiers for this class, using a slightly
            complex algorithm that tries to grab keys registered immediately after
            the given key.
            </summary>
            <param name="persister">The persister for the entities being loaded.</param>
            <param name="id">The identifier of the entity currently demanding load.</param>
            <param name="batchSize">The maximum number of keys to return</param>
            <returns>an array of identifiers, of length batchSize (possibly padded with nulls)</returns>
        </member>
        <member name="T:NHibernate.Engine.CascadePoint">
            <summary>
            The types of children to cascade to
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.AfterInsertBeforeDelete">
            <summary>
            A cascade point that occurs just after the insertion of the parent
            entity and just before deletion
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.BeforeInsertAfterDelete">
            <summary>
            A cascade point that occurs just before the insertion of the parent entity
            and just after deletion
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.AfterInsertBeforeDeleteViaCollection">
            <summary>
            A cascade point that occurs just after the insertion of the parent entity
            and just before deletion, inside a collection
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.AfterUpdate">
            <summary>
            A cascade point that occurs just after the update of the parent entity
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.BeforeFlush">
            <summary> A cascade point that occurs just before the session is flushed</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.AfterEvict">
            <summary>
            A cascade point that occurs just after eviction of the parent entity from the
            session cache
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.BeforeRefresh">
            <summary> 
            A cascade point that occurs just after locking a transient parent entity into the
            session cache
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.AfterLock">
            <summary>
            A cascade point that occurs just after locking a transient parent entity into the session cache
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.BeforeMerge">
            <summary>
            A cascade point that occurs just before merging from a transient parent entity into
            the object in the session cache
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Cascade">
            <summary> 
            Delegate responsible, in conjunction with the various
            <see cref="T:NHibernate.Engine.CascadingAction"/>, for implementing cascade processing. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascade.CascadeOn(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary> Cascade an action from the parent entity instance to all its children. </summary>
            <param name="persister">The parent's entity persister </param>
            <param name="parent">The parent reference. </param>
        </member>
        <member name="M:NHibernate.Engine.Cascade.CascadeOn(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
            <summary> 
            Cascade an action from the parent entity instance to all its children.  This
            form is typicaly called from within cascade actions. 
            </summary>
            <param name="persister">The parent's entity persister </param>
            <param name="parent">The parent reference. </param>
            <param name="anything">
            Typically some form of cascade-local cache
            which is specific to each CascadingAction type
            </param>
        </member>
        <member name="M:NHibernate.Engine.Cascade.CascadeProperty(System.Object,System.Object,NHibernate.Type.IType,NHibernate.Engine.CascadeStyle,System.Object,System.Boolean)">
            <summary> Cascade an action to the child or children</summary>
        </member>
        <member name="M:NHibernate.Engine.Cascade.CascadeCollection(System.Object,System.Object,NHibernate.Engine.CascadeStyle,System.Object,NHibernate.Type.CollectionType)">
            <summary> Cascade an action to a collection</summary>
        </member>
        <member name="M:NHibernate.Engine.Cascade.CascadeToOne(System.Object,System.Object,NHibernate.Type.IType,NHibernate.Engine.CascadeStyle,System.Object,System.Boolean)">
            <summary> Cascade an action to a to-one association or any type</summary>
        </member>
        <member name="M:NHibernate.Engine.Cascade.CascadeCollectionElements(System.Object,System.Object,NHibernate.Type.CollectionType,NHibernate.Engine.CascadeStyle,NHibernate.Type.IType,System.Object,System.Boolean)">
            <summary> Cascade to the collection elements</summary>
        </member>
        <member name="M:NHibernate.Engine.Cascade.DeleteOrphans(System.String,NHibernate.Collection.IPersistentCollection)">
            <summary> Delete any entities that were removed from the collection</summary>
        </member>
        <member name="T:NHibernate.Engine.CascadeStyle">
            <summary> A contract for defining the aspects of cascading various persistence actions. </summary>
            <seealso cref="T:NHibernate.Engine.CascadingAction"/>
        </member>
        <member name="M:NHibernate.Engine.CascadeStyle.#ctor">
            <summary> package-protected constructor</summary>
        </member>
        <member name="M:NHibernate.Engine.CascadeStyle.DoCascade(NHibernate.Engine.CascadingAction)">
            <summary> For this style, should the given action be cascaded? </summary>
            <param name="action">The action to be checked for cascade-ability. </param>
            <returns> True if the action should be cascaded under this style; false otherwise. </returns>
        </member>
        <member name="M:NHibernate.Engine.CascadeStyle.ReallyDoCascade(NHibernate.Engine.CascadingAction)">
            <summary> 
            Probably more aptly named something like doCascadeToCollectionElements(); 
            it is however used from both the collection and to-one logic branches...
            </summary>
            <param name="action">The action to be checked for cascade-ability. </param>
            <returns> True if the action should be really cascaded under this style; false otherwise. </returns>
            <remarks>
            For this style, should the given action really be cascaded?  The default
            implementation is simply to return {@link #doCascade}; for certain
            styles (currently only delete-orphan), however, we need to be able to
            control this separately.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.CascadeStyle.GetCascadeStyle(System.String)">
            <summary> Factory method for obtaining named cascade styles </summary>
            <param name="cascade">The named cascade style name. </param>
            <returns> The appropriate CascadeStyle </returns>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.AllDeleteOrphan">
            <summary> save / delete / update / evict / lock / replicate / merge / persist + delete orphans</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.All">
            <summary> save / delete / update / evict / lock / replicate / merge / persist</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Update">
            <summary> save / update</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Lock">
            <summary> lock</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Refresh">
            <summary> refresh</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Evict">
            <summary> evict</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Replicate">
            <summary> replicate</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Merge">
            <summary> merge</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Persist">
            <summary> create</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.Delete">
            <summary> delete</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.DeleteOrphan">
            <summary> delete + delete orphans</summary>
        </member>
        <member name="F:NHibernate.Engine.CascadeStyle.None">
            <summary> no cascades</summary>
        </member>
        <member name="P:NHibernate.Engine.CascadeStyle.HasOrphanDelete">
            <summary> Do we need to delete orphaned collection elements? </summary>
            <returns> True if this style need to account for orphan delete operations; false otherwise. </returns>
        </member>
        <member name="T:NHibernate.Engine.CascadingAction">
            <summary>
            A session action that may be cascaded from parent entity to its children
            </summary>
        </member>
        <member name="M:NHibernate.Engine.CascadingAction.Cascade(NHibernate.Event.IEventSource,System.Object,System.String,System.Object,System.Boolean)">
            <summary> Cascade the action to the child object. </summary>
            <param name="session">The session within which the cascade is occurring. </param>
            <param name="child">The child to which cascading should be performed. </param>
            <param name="entityName">The child's entity name </param>
            <param name="anything">Typically some form of cascade-local cache which is specific to each CascadingAction type </param>
            <param name="isCascadeDeleteEnabled">Are cascading deletes enabled. </param>
        </member>
        <member name="M:NHibernate.Engine.CascadingAction.GetCascadableChildrenIterator(NHibernate.Event.IEventSource,NHibernate.Type.CollectionType,System.Object)">
            <summary> 
            Given a collection, get an iterator of the children upon which the
            current cascading action should be visited. 
            </summary>
            <param name="session">The session within which the cascade is occurring. </param>
            <param name="collectionType">The mapping type of the collection. </param>
            <param name="collection">The collection instance. </param>
            <returns> The children iterator. </returns>
        </member>
        <member name="M:NHibernate.Engine.CascadingAction.NoCascade(NHibernate.Event.IEventSource,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Int32)">
            <summary> 
            Called (in the case of <see cref="P:NHibernate.Engine.CascadingAction.RequiresNoCascadeChecking"/> returning true) to validate
            that no cascade on the given property is considered a valid semantic. 
            </summary>
            <param name="session">The session within which the cascade is occurring. </param>
            <param name="child">The property value </param>
            <param name="parent">The property value owner </param>
            <param name="persister">The entity persister for the owner </param>
            <param name="propertyIndex">The index of the property within the owner. </param>
        </member>
        <member name="M:NHibernate.Engine.CascadingAction.GetAllElementsIterator(NHibernate.Event.IEventSource,NHibernate.Type.CollectionType,System.Object)">
            <summary> 
            Given a collection, get an iterator of all its children, loading them
            from the database if necessary. 
            </summary>
            <param name="session">The session within which the cascade is occurring. </param>
            <param name="collectionType">The mapping type of the collection. </param>
            <param name="collection">The collection instance. </param>
            <returns> The children iterator. </returns>
        </member>
        <member name="M:NHibernate.Engine.CascadingAction.GetLoadedElementsIterator(NHibernate.Engine.ISessionImplementor,NHibernate.Type.CollectionType,System.Object)">
            <summary> 
            Iterate just the elements of the collection that are already there. Don't load
            any new elements from the database.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.Delete">
            <seealso cref="M:NHibernate.ISession.Delete(System.Object)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.Lock">
            <seealso cref="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.Refresh">
            <seealso cref="M:NHibernate.ISession.Refresh(System.Object)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.Evict">
            <seealso cref="M:NHibernate.ISession.Evict(System.Object)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.SaveUpdate">
            <seealso cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.Merge">
            <seealso cref="M:NHibernate.ISession.Merge(System.Object)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.Persist">
            <seealso cref="M:NHibernate.ISession.Persist(System.Object)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.PersistOnFlush">
            <summary> Execute persist during flush time </summary>
            <seealso cref="M:NHibernate.ISession.Persist(System.Object)"/>
        </member>
        <member name="F:NHibernate.Engine.CascadingAction.Replicate">
            <seealso cref="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)"/>
        </member>
        <member name="P:NHibernate.Engine.CascadingAction.DeleteOrphans">
            <summary> Does this action potentially extrapolate to orphan deletes? </summary>
            <returns> True if this action can lead to deletions of orphans. </returns>
        </member>
        <member name="P:NHibernate.Engine.CascadingAction.RequiresNoCascadeChecking">
            <summary> Does the specified cascading action require verification of no cascade validity? </summary>
            <returns> True if this action requires no-cascade verification; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Engine.CascadingAction.PerformOnLazyProperty">
            <summary> Should this action be performed (or noCascade consulted) in the case of lazy properties.</summary>
        </member>
        <member name="T:NHibernate.Engine.CollectionEntry">
            <summary>
            We need an entry to tell us all about the current state
            of a collection with respect to its persistent state
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.snapshot">
            <summary>session-start/post-flush persistent state</summary>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.role">
            <summary>allow the snapshot to be serialized</summary>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.loadedPersister">
            <summary>
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> when the Collection was loaded.
            </summary>
            <remarks>
            This can be <see langword="null"/> if the Collection was not loaded by NHibernate and 
            was passed in along with a transient object.
            </remarks>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.loadedKey">
            <summary>
            The identifier of the Entity that is the owner of this Collection 
            during the load or post flush.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.reached">
            <summary>
            Indicates that the Collection can still be reached by an Entity
            that exist in the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            It is also used to ensure that the Collection is not shared between
            two Entities.  
            </remarks>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.processed">
            <summary>
            Indicates that the Collection has been processed and is ready
            to have its state synchronized with the database.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.doupdate">
            <summary>
            Indicates that a Collection needs to be updated.
            </summary>
            <remarks>
            A Collection needs to be updated whenever the contents of the Collection
            have been changed. 
            </remarks>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.doremove">
            <summary>
            Indicates that a Collection has old elements that need to be removed.
            </summary>
            <remarks>
            A Collection needs to have removals performed whenever its role changes or
            the key changes and it has a loadedPersister - ie - it was loaded by NHibernate.
            </remarks>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.dorecreate">
            <summary>
            Indicates that a Collection needs to be recreated.
            </summary>
            <remarks>
            A Collection needs to be recreated whenever its role changes
            or the owner changes.
            </remarks>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.ignore">
            <summary>
            If we instantiate a collection during the <see cref="M:NHibernate.ISession.Flush"/>
            process, we must ignore it for the rest of the flush.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CollectionEntry.currentPersister">
            <summary>
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is currently responsible
            for the Collection.
            </summary>
            <remarks>
            This is set when NHibernate is updating a reachable or an
            unreachable collection.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.#ctor(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Engine.CollectionEntry"/>.
            </summary>
            <remarks> 
            For newly wrapped collections, or dereferenced collection wrappers
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean)">
            <summary> For collections just loaded from the database</summary>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Engine.CollectionEntry"/> for initialized detached collections.
            </summary>
            <remarks>
             For initialized detached collections
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.Dirty(NHibernate.Collection.IPersistentCollection)">
            <summary> 
            Determine if the collection is "really" dirty, by checking dirtiness
            of the collection elements, if necessary
            </summary>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.PreFlush(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Prepares this CollectionEntry for the Flush process.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection"/> that this CollectionEntry will be responsible for flushing.</param>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.PostInitialize(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Updates the CollectionEntry to reflect that the <see cref="T:NHibernate.Collection.IPersistentCollection"/>
            has been initialized.
            </summary>
            <param name="collection">The initialized <see cref="T:NHibernate.Collection.AbstractPersistentCollection"/> that this Entry is for.</param>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.PostFlush(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Updates the CollectionEntry to reflect that it is has been successfully flushed to the database.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection"/> that was flushed.</param>
            <remarks>
            Called after a <em>successful</em> flush.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.CollectionEntry.SetLoadedPersister(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Sets the information in this CollectionEntry that is specific to the
            <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/>.
            </summary>
            <param name="persister">
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> that is 
            responsible for the Collection.
            </param>
        </member>
        <member name="P:NHibernate.Engine.CollectionEntry.Key">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.CollectionEntry.Role">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.CollectionEntry.Snapshot">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Engine.CollectionKey">
            <summary> 
            Uniquely identifies a collection instance in a particular session. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Collections.ProcessUnreachableCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Record the fact that this collection was dereferenced 
            </summary>
            <param name="coll">The collection to be updated by unreachability. </param>
            <param name="session">The session.</param>
        </member>
        <member name="M:NHibernate.Engine.Collections.ProcessReachableCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Type.CollectionType,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Initialize the role of the collection. 
            </summary>
            <param name="collection">The collection to be updated by reachibility. </param>
            <param name="type">The type of the collection. </param>
            <param name="entity">The owner of the collection. </param>
            <param name="session">The session.</param>
        </member>
        <member name="T:NHibernate.Engine.EntityEntry">
            <summary>
            We need an entry to tell us all about the current state
            of an object with respect to its persistent state
            </summary>
        </member>
        <member name="M:NHibernate.Engine.EntityEntry.#ctor(NHibernate.Engine.Status,System.Object[],System.Object,System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,NHibernate.EntityMode,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of EntityEntry.
            </summary>
            <param name="status">The current <see cref="P:NHibernate.Engine.EntityEntry.Status"/> of the Entity.</param>
            <param name="loadedState">The snapshot of the Entity's state when it was loaded.</param>
            <param name="rowId"></param>
            <param name="id">The identifier of the Entity in the database.</param>
            <param name="version">The version of the Entity.</param>
            <param name="lockMode">The <see cref="P:NHibernate.Engine.EntityEntry.LockMode"/> for the Entity.</param>
            <param name="existsInDatabase">A boolean indicating if the Entity exists in the database.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for this Entity.</param>
            <param name="entityMode"></param>
            <param name="disableVersionIncrement"></param>
            <param name="lazyPropertiesAreUnfetched"></param>
        </member>
        <member name="M:NHibernate.Engine.EntityEntry.PostInsert">
            <summary>
            After actually inserting a row, record the fact that the instance exists on the
            database (needed for identity-column key generation)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.EntityEntry.PostUpdate(System.Object,System.Object[],System.Object)">
            <summary>
            After actually updating the database, update the snapshot information,
            and escalate the lock mode.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.EntityEntry.PostDelete">
            <summary>
            After actually deleting a row, record the fact that the instance no longer
            exists in the database
            </summary>
        </member>
        <member name="M:NHibernate.Engine.EntityEntry.IsModifiableEntity">
            <summary>
            Can the entity be modified?
            The entity is modifiable if all of the following are true:
            - the entity class is mutable
            - the entity is not read-only
            - if the current status is Status.Deleted, then the entity was not read-only when it was deleted
            </summary>
            <returns>true, if the entity is modifiable; false, otherwise</returns>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.LockMode">
            <summary>
            Gets or sets the current <see cref="P:NHibernate.Engine.EntityEntry.LockMode"/> of the Entity.
            </summary>
            <value>The <see cref="P:NHibernate.Engine.EntityEntry.LockMode"/> of the Entity.</value>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.Status">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Engine.EntityEntry.Status"/> of this Entity with respect to its
            persistence in the database.
            </summary>
            <value>The <see cref="P:NHibernate.Engine.EntityEntry.Status"/> of this Entity.</value>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.Id">
            <summary>
            Gets or sets the identifier of the Entity in the database.
            </summary>
            <value>The identifier of the Entity in the database if one has been assigned.</value>
            <remarks>This might be <see langword="null"/> when the <see cref="P:NHibernate.Engine.EntityEntry.Status"/> is
            <see cref="F:NHibernate.Engine.Status.Saving"/> and the database generates the id.</remarks>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.LoadedState">
            <summary>
            Gets or sets the snapshot of the Entity when it was loaded from the database.
            </summary>
            <value>The snapshot of the Entity.</value>
            <remarks>
            There will only be a value when the Entity was loaded in the current Session.
            </remarks>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.DeletedState">
            <summary>
            Gets or sets the snapshot of the Entity when it was marked as being ready for deletion.
            </summary>
            <value>The snapshot of the Entity.</value>
            <remarks>This will be <see langword="null" /> if the Entity is not being deleted.</remarks>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.ExistsInDatabase">
            <summary>
            Gets or sets a <see cref="T:System.Boolean"/> indicating if this Entity exists in the database.
            </summary>
            <value><see langword="true"/> if it is already in the database.</value>
            <remarks>
            It can also be <see langword="true"/> if it does not exists in the database yet and the
            <see cref="P:NHibernate.Persister.Entity.IEntityPersister.IsIdentifierAssignedByInsert"/> is <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.Version">
            <summary>
            Gets or sets the version of the Entity.
            </summary>
            <value>The version of the Entity.</value>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.Persister">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for this Entity.
            </summary>
            <value>The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for this Entity.</value>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.EntityName">
            <summary>
            Gets the Fully Qualified Name of the class this Entity is an instance of.
            </summary>
            <value>The Fully Qualified Name of the class this Entity is an instance of.</value>
        </member>
        <member name="P:NHibernate.Engine.EntityEntry.EntityKey">
            <summary>
            Get the EntityKey based on this EntityEntry.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.EntityKey">
            <summary>
            A globally unique identifier of an instance, consisting of the user-visible identifier
            and the identifier space (eg. tablename)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.EntityKey.#ctor(System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.EntityMode)">
            <summary> Construct a unique identifier for an entity class instance</summary>
        </member>
        <member name="M:NHibernate.Engine.EntityKey.#ctor(System.Object,System.String,System.String,NHibernate.Type.IType,System.Boolean,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.EntityMode)">
            <summary> Used to reconstruct an EntityKey during deserialization. </summary>
            <param name="identifier">The identifier value </param>
            <param name="rootEntityName">The root entity name </param>
            <param name="entityName">The specific entity name </param>
            <param name="identifierType">The type of the identifier value </param>
            <param name="batchLoadable">Whether represented entity is eligible for batch loading </param>
            <param name="factory">The session factory </param>
            <param name="entityMode">The entity's entity mode </param>
        </member>
        <member name="M:NHibernate.Engine.EntityKey.SetSessionFactory(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            To use in deserialization callback
            </summary>
            <param name="sessionFactory"></param>
        </member>
        <member name="T:NHibernate.Engine.EntityUniqueKey">
            <summary> 
            Used to uniquely key an entity instance in relation to a particular session
            by some unique property reference, as opposed to identifier.
            Uniqueing information consists of the entity-name, the referenced
            property name, and the referenced property value. 
            </summary>
            <seealso cref="T:NHibernate.Engine.EntityKey"/>
        </member>
        <member name="T:NHibernate.Engine.FilterDefinition">
            <summary>
            A FilterDefinition defines the global attributes of a dynamic filter.  This
            information includes its name as well as its defined parameters (name and type).
            </summary>
        </member>
        <member name="M:NHibernate.Engine.FilterDefinition.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.Type.IType},System.Boolean)">
            <summary>
            Set the named parameter's value list for this filter.
            </summary>
            <param name="name">The name of the filter for which this configuration is in effect.</param>
            <param name="defaultCondition">The default filter condition.</param>
            <param name="parameterTypes">A dictionary storing the NHibernate <see cref="T:NHibernate.Type.IType"/> type
            of each parameter under its name.</param>
            <param name="useManyToOne">if set to <c>true</c> used in many to one rel</param>
        </member>
        <member name="M:NHibernate.Engine.FilterDefinition.GetParameterType(System.String)">
            <summary>
            Retreive the type of the named parameter defined for this filter.
            </summary>
            <param name="parameterName">The name of the filter parameter for which to return the type.</param>
            <returns>The type of the named parameter.</returns>
        </member>
        <member name="P:NHibernate.Engine.FilterDefinition.UseInManyToOne">
            <summary>
            Gets a value indicating whether to use this filter-def in manytoone refs.
            </summary>
            <value><c>true</c> if [use in many to one]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NHibernate.Engine.FilterDefinition.FilterName">
            <summary>
            Get the name of the filter this configuration defines.
            </summary>
            <returns>The filter name for this configuration.</returns>
        </member>
        <member name="P:NHibernate.Engine.FilterDefinition.ParameterNames">
            <summary>
            Get a set of the parameters defined by this configuration.
            </summary>
            <returns>The parameters named by this configuration.</returns>
        </member>
        <member name="T:NHibernate.Engine.ForeignKeys">
            <summary> Algorithms related to foreign key constraint transparency </summary>
        </member>
        <member name="M:NHibernate.Engine.ForeignKeys.IsNotTransient(System.String,System.Object,System.Nullable{System.Boolean},NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Is this instance persistent or detached?
            </summary>
            <remarks>
            If <paramref name="assumed"/> is non-null, don't hit the database to make the 
            determination, instead assume that value; the client code must be 
            prepared to "recover" in the case that this assumed result is incorrect.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.ForeignKeys.IsTransient(System.String,System.Object,System.Nullable{System.Boolean},NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Is this instance, which we know is not persistent, actually transient? 
            If <tt>assumed</tt> is non-null, don't hit the database to make the 
            determination, instead assume that value; the client code must be 
            prepared to "recover" in the case that this assumed result is incorrect.
            </summary>
            <remarks>
            If <paramref name="assumed"/> is non-null, don't hit the database to make the 
            determination, instead assume that value; the client code must be 
            prepared to "recover" in the case that this assumed result is incorrect.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.ForeignKeys.GetEntityIdentifierIfNotUnsaved(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Return the identifier of the persistent or transient object, or throw
            an exception if the instance is "unsaved"
            </summary>
            <remarks>
            Used by OneToOneType and ManyToOneType to determine what id value should 
            be used for an object that may or may not be associated with the session. 
            This does a "best guess" using any/all info available to use (not just the 
            EntityEntry).
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.ForeignKeys.Nullifier.NullifyTransientReferences(System.Object[],NHibernate.Type.IType[])">
            <summary> 
            Nullify all references to entities that have not yet 
            been inserted in the database, where the foreign key
            points toward that entity
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ForeignKeys.Nullifier.NullifyTransientReferences(System.Object,NHibernate.Type.IType)">
            <summary> 
            Return null if the argument is an "unsaved" entity (ie. 
            one with no existing database row), or the input argument 
            otherwise. This is how Hibernate avoids foreign key constraint
            violations.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ForeignKeys.Nullifier.IsNullifiable(System.String,System.Object)">
            <summary> 
            Determine if the object already exists in the database, using a "best guess"
            </summary>
        </member>
        <member name="T:NHibernate.Engine.IdentifierValue">
            <summary>
            A strategy for determining if an identifier value is an identifier of a new 
            transient instance or a previously persistent transient instance. The strategy
            is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IdentifierValue.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.IdentifierValue.#ctor(System.Object)">
            <summary>
            Assume the transient instance is newly instantiated if its identifier is null or
            equal to <c>Value</c>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Engine.IdentifierValue.IsUnsaved(System.Object)">
            <summary>
            Does the given identifier belong to a new instance
            </summary>
        </member>
        <member name="F:NHibernate.Engine.IdentifierValue.SaveAny">
            <summary>
            Always assume the transient instance is newly instantiated
            </summary>
        </member>
        <member name="F:NHibernate.Engine.IdentifierValue.SaveNone">
            <summary>
            Never assume that transient instance is newly instantiated
            </summary>
        </member>
        <member name="F:NHibernate.Engine.IdentifierValue.SaveNull">
            <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.IdentifierValue.Undefined">
            <summary> Assume nothing.</summary>
        </member>
        <member name="T:NHibernate.Engine.IPersistenceContext">
            <summary>
            Holds the state of the persistence context, including the
            first-level cache, entries, snapshots, proxies, etc.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddUnownedCollection(NHibernate.Engine.CollectionKey,NHibernate.Collection.IPersistentCollection)">
            <summary> Add a collection which has no owner loaded</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.UseUnownedCollection(NHibernate.Engine.CollectionKey)">
            <summary>
            Get and remove a collection whose owner is not yet loaded,
            when its owner is being loaded
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.Clear">
            <summary> Clear the state of the persistence context</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.SetEntryStatus(NHibernate.Engine.EntityEntry,NHibernate.Engine.Status)">
            <summary> Set the status of an entry</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AfterTransactionCompletion">
            <summary> Called after transactions end</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Get the current state of the entity as known to the underlying
            database, or null if there is no corresponding row
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetCachedDatabaseSnapshot(NHibernate.Engine.EntityKey)">
            <summary>
            Retrieve the cached database snapshot for the requested entity key.
            </summary>
            <param name="key">The entity key for which to retrieve the cached snapshot </param>
            <returns> The cached snapshot </returns>
            <remarks>
            <list type="bullet">
            <listheader><description>This differs from <see cref="M:NHibernate.Engine.IPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)"/> is two important respects:</description></listheader>
            <item><description>no snapshot is obtained from the database if not already cached</description></item>
            <item><description>an entry of NO_ROW here is interpreted as an exception</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetNaturalIdSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Get the values of the natural id fields as known to the underlying
            database, or null if the entity has no natural id or there is no
            corresponding row.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddEntity(NHibernate.Engine.EntityKey,System.Object)">
            <summary> Add a canonical mapping from entity key to entity instance</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetEntity(NHibernate.Engine.EntityKey)">
            <summary>
            Get the entity instance associated with the given <tt>EntityKey</tt>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.ContainsEntity(NHibernate.Engine.EntityKey)">
            <summary> Is there an entity with the given key in the persistence context</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.RemoveEntity(NHibernate.Engine.EntityKey)">
            <summary>
            Remove an entity from the session cache, also clear
            up other state associated with the entity, all except
            for the <tt>EntityEntry</tt>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetEntity(NHibernate.Engine.EntityUniqueKey)">
            <summary> Get an entity cached by unique key</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddEntity(NHibernate.Engine.EntityUniqueKey,System.Object)">
            <summary> Add an entity to the cache by unique key</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetEntry(System.Object)">
            <summary>
            Retrieve the EntityEntry representation of the given entity.
            </summary>
            <param name="entity">The entity for which to locate the EntityEntry. </param>
            <returns> The EntityEntry for the given entity. </returns>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.RemoveEntry(System.Object)">
            <summary> Remove an entity entry from the session cache</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.IsEntryFor(System.Object)">
            <summary> Is there an EntityEntry for this instance?</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionEntry(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the collection entry for a persistent collection</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddEntity(System.Object,NHibernate.Engine.Status,System.Object[],NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
            <summary> Adds an entity to the internal caches.</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddEntry(System.Object,NHibernate.Engine.Status,System.Object[],System.Object,System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
            <summary>
            Generates an appropriate EntityEntry instance and adds it
            to the event source's internal caches.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.ContainsCollection(NHibernate.Collection.IPersistentCollection)">
            <summary> Is the given collection associated with this persistence context?</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.ContainsProxy(NHibernate.Proxy.INHibernateProxy)">
            <summary> Is the given proxy associated with this persistence context?</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.ReassociateIfUninitializedProxy(System.Object)">
            <summary>
            Takes the given object and, if it represents a proxy, reassociates it with this event source.
            </summary>
            <param name="value">The possible proxy to be reassociated. </param>
            <returns> Whether the passed value represented an actual proxy which got initialized. </returns>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.ReassociateProxy(System.Object,System.Object)">
            <summary>
            If a deleted entity instance is re-saved, and it has a proxy, we need to
            reset the identifier of the proxy
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.Unproxy(System.Object)">
            <summary>
            Get the entity instance underlying the given proxy, throwing
            an exception if the proxy is uninitialized. If the given object
            is not a proxy, simply return the argument.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.UnproxyAndReassociate(System.Object)">
            <summary>
            Possibly unproxy the given reference and reassociate it with the current session.
            </summary>
            <param name="maybeProxy">The reference to be unproxied if it currently represents a proxy. </param>
            <returns> The unproxied instance. </returns>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.CheckUniqueness(NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            Attempts to check whether the given key represents an entity already loaded within the
            current session.
            </summary>
            <param name="obj">The entity reference against which to perform the uniqueness check.</param>
            <param name="key">The entity key.</param>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.NarrowProxy(NHibernate.Proxy.INHibernateProxy,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            If the existing proxy is insufficiently "narrow" (derived), instantiate a new proxy
            and overwrite the registration of the old one. This breaks == and occurs only for
            "class" proxies rather than "interface" proxies. Also init the proxy to point to
            the given target implementation if necessary.
            </summary>
            <param name="proxy">The proxy instance to be narrowed. </param>
            <param name="persister">The persister for the proxied entity. </param>
            <param name="key">The internal cache key for the proxied entity. </param>
            <param name="obj">(optional) the actual proxied entity instance. </param>
            <returns> An appropriately narrowed instance. </returns>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.ProxyFor(NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            third argument (the entity associated with the key) if no proxy exists. Init
            the proxy to the target implementation, if necessary.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.ProxyFor(System.Object)">
            <summary>
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            argument (the entity associated with the key) if no proxy exists.
            (slower than the form above)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionOwner(System.Object,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary> Get the entity that owns this persistent collection</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetLoadedCollectionOwnerOrNull(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the entity that owned this persistent collection when it was loaded </summary>
            <param name="collection">The persistent collection </param>
            <returns>
            The owner if its entity ID is available from the collection's loaded key
            and the owner entity is in the persistence context; otherwise, returns null
            </returns>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetLoadedCollectionOwnerIdOrNull(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the ID for the entity that owned this persistent collection when it was loaded </summary>
            <param name="collection">The persistent collection </param>
            <returns> the owner ID if available from the collection's loaded key; otherwise, returns null </returns>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddUninitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
            <summary> add a collection we just loaded up (still needs initializing)</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddUninitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary> add a detached uninitialized collection</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddNewCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary>
            Add a new collection (ie. a newly created one, just instantiated by the
            application, with no database state or snapshot)
            </summary>
            <param name="collection">The collection to be associated with the persistence context </param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddInitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary>
            add an (initialized) collection that was created by another session and passed
            into update() (ie. one with a snapshot and existing state on the database)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddInitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
            <summary> add a collection we just pulled out of the cache (does not need initializing)</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetCollection(NHibernate.Engine.CollectionKey)">
            <summary> Get the collection instance associated with the <tt>CollectionKey</tt></summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddNonLazyCollection(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Register a collection for non-lazy loading at the end of the two-phase load
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.InitializeNonLazyCollections">
            <summary>
            Force initialization of all non-lazy collections encountered during
            the current two-phase load (actually, this is a no-op, unless this
            is the "outermost" load)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionHolder(System.Object)">
            <summary> Get the <tt>PersistentCollection</tt> object for an array</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddCollectionHolder(NHibernate.Collection.IPersistentCollection)">
            <summary> Register a <tt>PersistentCollection</tt> object for an array.
            Associates a holder with an array - MUST be called after loading
            array, since the array instance is not created until endLoad().
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.RemoveCollectionHolder(System.Object)">
            <summary>
            Remove the mapping of collection to holder during eviction of the owning entity
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetSnapshot(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the snapshot of the pre-flush collection state</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionEntryOrNull(System.Object)">
            <summary>
            Get the collection entry for a collection passed to filter,
            which might be a collection wrapper, an array, or an unwrapped
            collection. Return null if there is no entry.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetProxy(NHibernate.Engine.EntityKey)">
            <summary> Get an existing proxy by key</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddProxy(NHibernate.Engine.EntityKey,NHibernate.Proxy.INHibernateProxy)">
            <summary> Add a proxy to the session cache</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.RemoveProxy(NHibernate.Engine.EntityKey)">
            <summary> Remove a proxy from the session cache</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.IncrementCascadeLevel">
            <summary> Called before cascading</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.DecrementCascadeLevel">
            <summary> Called after cascading</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.BeforeLoad">
            <summary> Call this before beginning a two-phase load</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AfterLoad">
            <summary> Call this after finishing a two-phase load</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetOwnerId(System.String,System.String,System.Object,System.Collections.IDictionary)">
            <summary>
            Search the persistence context for an owner for the child object,
            given a collection role
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.GetIndexInOwner(System.String,System.String,System.Object,System.Collections.IDictionary)">
            <summary>
            Search the persistence context for an index of the child object, given a collection role
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddNullProperty(NHibernate.Engine.EntityKey,System.String)">
            <summary>
            Record the fact that the association belonging to the keyed entity is null.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.IsPropertyNull(NHibernate.Engine.EntityKey,System.String)">
            <summary> Is the association property belonging to the keyed entity null?</summary>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.SetReadOnly(System.Object,System.Boolean)">
            <summary>
            Change the read-only status of an entity (or proxy).
            </summary>
            <remarks>
            <para>
            Read-only entities can be modified, but changes are not persisted. They are not dirty-checked 
            and snapshots of persistent state are not maintained. 
            </para>
            <para>
            Immutable entities cannot be made read-only.
            </para>
            <para>
            To set the <em>default</em> read-only setting for entities and proxies that are loaded 
            into the persistence context, see <see cref="P:NHibernate.Engine.IPersistenceContext.DefaultReadOnly"/>.
            </para>
            </remarks>
            <param name="entityOrProxy">An entity (or <see cref="T:NHibernate.Proxy.INHibernateProxy"/>).</param>
            <param name="readOnly">If <c>true</c>, the entity or proxy is made read-only; if <c>false</c>, it is made modifiable.</param>
            <seealso cref="P:NHibernate.Engine.IPersistenceContext.DefaultReadOnly"/>
            <seealso cref="M:NHibernate.Engine.IPersistenceContext.IsReadOnly(System.Object)"/>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.IsReadOnly(System.Object)">
            <summary>
            Is the specified entity (or proxy) read-only?
            </summary>
            <param name="entityOrProxy">An entity (or <see cref="T:NHibernate.Proxy.INHibernateProxy"/>)</param>
            <returns>
            <c>true</c> if the entity or proxy is read-only, otherwise <c>false</c>.
            </returns>
            <seealso cref="P:NHibernate.Engine.IPersistenceContext.DefaultReadOnly"/>
            <seealso cref="M:NHibernate.Engine.IPersistenceContext.SetReadOnly(System.Object,System.Boolean)"/>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.AddChildParent(System.Object,System.Object)">
            <summary>
            Add child/parent relation to cache for cascading operations
            </summary>
            <param name="child">The child.</param>
            <param name="parent">The parent.</param>
        </member>
        <member name="M:NHibernate.Engine.IPersistenceContext.RemoveChildParent(System.Object)">
            <summary>
            Remove child/parent relation from cache
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.Session">
            <summary>
            Get the session to which this persistence context is bound.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.LoadContexts">
            <summary>
            Retrieve this persistence context's managed load context.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.BatchFetchQueue">
            <summary>
            Get the <tt>BatchFetchQueue</tt>, instantiating one if necessary.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.NullifiableEntityKeys">
            <summary> Retrieve the set of EntityKeys representing nullifiable references</summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.EntitiesByKey">
            <summary> Get the mapping from key value to entity instance</summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.EntityEntries">
            <summary> Get the mapping from entity instance to entity entry</summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.CollectionEntries">
            <summary> Get the mapping from collection instance to collection entry</summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.CollectionsByKey">
            <summary> Get the mapping from collection key to collection instance</summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.CascadeLevel">
            <summary> How deep are we cascaded?</summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.Flushing">
            <summary>Is a flush cycle currently in process?</summary>
            <remarks>Called before and after the flushcycle</remarks>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.DefaultReadOnly">
            <summary>
            The read-only status for entities (and proxies) loaded into this persistence context.
            </summary>
            <remarks>
            <para>
            When a proxy is initialized, the loaded entity will have the same read-only
            setting as the uninitialized proxy has, regardless of the persistence context's
            current setting.
            </para>
            <para>
            To change the read-only setting for a particular entity or proxy that is already
            in the current persistence context, use <see cref="M:NHibernate.Engine.IPersistenceContext.SetReadOnly(System.Object,System.Boolean)"/>.
            </para>
            </remarks>
            <seealso cref="M:NHibernate.Engine.IPersistenceContext.IsReadOnly(System.Object)"/>
            <seealso cref="M:NHibernate.Engine.IPersistenceContext.SetReadOnly(System.Object,System.Boolean)"/>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.HasNonReadOnlyEntities">
            <summary>False if we know for certain that all the entities are read-only</summary>
        </member>
        <member name="P:NHibernate.Engine.IPersistenceContext.IsLoadFinished">
            <summary>Is in a two-phase load? </summary>
        </member>
        <member name="T:NHibernate.Engine.ISessionFactoryImplementor">
            <summary>
            Defines the internal contract between the <c>ISessionFactory</c> and other parts of NHibernate
            such as implementors of <c>IType</c>.
            </summary>
        </member>
        <member name="T:NHibernate.ISessionFactory">
            <summary>
            Creates <c>ISession</c>s.
            </summary>
            <remarks>
            <para>
            Usually an application has a single <c>SessionFactory</c>. Threads servicing client requests
            obtain <c>ISession</c>s from the factory. Implementors must be threadsafe.
            </para>
            <para>
            <c>ISessionFactory</c>s are immutable. The behaviour of a <c>SessionFactory</c>
            is controlled by properties supplied at configuration time.
            These properties are defined on <c>Environment</c>
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection)">
            <summary>
            Open a <c>ISession</c> on the given connection
            </summary>
            <param name="conn">A connection provided by the application</param>
            <returns>A session</returns>
            <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(NHibernate.IInterceptor)">
            <summary>
            Create database connection and open a <c>ISession</c> on it, specifying an interceptor
            </summary>
            <param name="sessionLocalInterceptor">A session-scoped interceptor</param>
            <returns>A session</returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection,NHibernate.IInterceptor)">
            <summary>
            Open a <c>ISession</c> on the given connection, specifying an interceptor
            </summary>
            <param name="conn">A connection provided by the application</param>
            <param name="sessionLocalInterceptor">A session-scoped interceptor</param>
            <returns>A session</returns>
            <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession">
            <summary>
            Create a database connection and open a <c>ISession</c> on it
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetClassMetadata(System.Type)">
            <summary>
            Get the <see cref="T:NHibernate.Metadata.IClassMetadata"/> associated with the given entity class
            </summary>
            <param name="persistentClass">the given entity type.</param>
            <returns>The class metadata or <see langword="null"/> if not found.</returns>
            <seealso cref="T:NHibernate.Metadata.IClassMetadata"/>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetClassMetadata(System.String)">
            <summary> Get the <see cref="T:NHibernate.Metadata.IClassMetadata"/> associated with the given entity name </summary>
            <param name="entityName">the given entity name.</param>
            <returns>The class metadata or <see langword="null"/> if not found.</returns>
            <seealso cref="T:NHibernate.Metadata.IClassMetadata"/>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetCollectionMetadata(System.String)">
            <summary>
            Get the <c>CollectionMetadata</c> associated with the named collection role
            </summary>
            <param name="roleName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetAllClassMetadata">
            <summary> 
            Get all <see cref="T:NHibernate.Metadata.IClassMetadata"/> as a <see cref="T:System.Collections.IDictionary"/> from entityname <see langword="string"/>
            to metadata object
            </summary>
            <returns> A dictionary from <see langword="string"/> an entity name to <see cref="T:NHibernate.Metadata.IClassMetadata"/> </returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetAllCollectionMetadata">
            <summary>
            Get all <c>CollectionMetadata</c> as a <c>IDictionary</c> from role name
            to metadata object
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.Close">
            <summary>
            Destroy this <c>SessionFactory</c> and release all resources 
            connection pools, etc). It is the responsibility of the application
            to ensure that there are no open <c>Session</c>s before calling
            <c>close()</c>. 
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.Evict(System.Type)">
            <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="persistentClass"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.Evict(System.Type,System.Object)">
            <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="persistentClass"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictEntity(System.String)">
            <summary> 
            Evict all entries from the second-level cache. This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy. Use with care.
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictEntity(System.String,System.Object)">
            <summary> 
            Evict an entry from the second-level  cache. This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy. Use with care.
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String)">
            <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String,System.Object)">
            <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictQueries">
            <summary>
            Evict any query result sets cached in the default query cache region.
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictQueries(System.String)">
            <summary>
            Evict any query result sets cached in the named query cache region.
            </summary>
            <param name="cacheRegion"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenStatelessSession">
            <summary> Get a new stateless session.</summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenStatelessSession(System.Data.IDbConnection)">
            <summary> Get a new stateless session for the given ADO.NET connection.</summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetFilterDefinition(System.String)">
            <summary>
            Obtain the definition of a filter by name.
            </summary>
            <param name="filterName">The name of the filter for which to obtain the definition.</param>
            <return>The filter definition.</return>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetCurrentSession">
            <summary>
            Obtains the current session.
            </summary>
            <remarks>
            <para>
            The definition of what exactly "current" means is controlled by the <see cref="T:NHibernate.Context.ICurrentSessionContext"/>
            implementation configured for use.
            </para>
            </remarks>
            <returns>The current session.</returns>
            <exception cref="T:NHibernate.HibernateException">Indicates an issue locating a suitable current session.</exception>
        </member>
        <member name="P:NHibernate.ISessionFactory.Statistics">
            <summary> Get the statistics for this session factory</summary>
        </member>
        <member name="P:NHibernate.ISessionFactory.IsClosed">
            <summary> Was this <see cref="T:NHibernate.ISessionFactory"/> already closed?</summary>
        </member>
        <member name="P:NHibernate.ISessionFactory.DefinedFilterNames">
            <summary>
            Obtain a set of the names of all filters defined on this SessionFactory.
            </summary>
            <return>The set of filter names.</return>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetEntityPersister(System.String)">
            <summary>
            Get the persister for the named entity
            </summary>
            <param name="entityName">The name of the entity that is persisted.</param>
            <returns>The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the entity.</returns>
            <exception cref="T:NHibernate.MappingException">If no <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> can be found.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetCollectionPersister(System.String)">
            <summary>
            Get the persister object for a collection role
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetReturnTypes(System.String)">
            <summary>
            Get the return types of a query
            </summary>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetReturnAliases(System.String)">
            <summary> Get the return aliases of a query</summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImplementors(System.String)">
            <summary>
            Get the names of all persistent classes that implement/extend the given interface/class
            </summary>
            <param name="entityOrClassName">The entity-name, the class name or full name, the imported class name.</param>
            <returns>All implementors class names.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImportedClassName(System.String)">
            <summary>
            Get a class name, using query language imports
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetQueryCache(System.String)">
            <summary>
            Get a particular named query cache, or the default cache
            </summary>
            <param name="regionName">the name of the cache region, or null for the default
            query cache</param>
            <returns>the existing cache, or a newly created cache if none by that
            region name</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetNamedQuery(System.String)">
            <summary>
            Gets the <c>hql</c> query identified by the <c>name</c>.
            </summary>
            <param name="queryName">The name of that identifies the query.</param>
            <returns>
            A <c>hql</c> query or <see langword="null" /> if the named
            query does not exist.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetIdentifierGenerator(System.String)">
            <summary>
            Get the identifier generator for the hierarchy
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetSecondLevelCacheRegion(System.String)">
            <summary> Get a named second-level cache region</summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.OpenSession(System.Data.IDbConnection,System.Boolean,System.Boolean,NHibernate.ConnectionReleaseMode)">
            <summary>
            Open a session conforming to the given parameters. Used mainly
            for current session processing.
            </summary>
            <param name="connection">The external ado.net connection to use, if one (i.e., optional).</param>
            <param name="flushBeforeCompletionEnabled">
            Should the session be auto-flushed 
            prior to transaction completion?
            </param>
            <param name="autoCloseSessionEnabled">
            Should the session be auto-closed after
            transaction completion?
            </param>
            <param name="connectionReleaseMode">The release mode for managed jdbc connections.</param>
            <returns>An appropriate session.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetCollectionRolesByEntityParticipant(System.String)">
            <summary> 
            Retrieves a set of all the collection roles in which the given entity
            is a participant, as either an index or an element.
            </summary>
            <param name="entityName">The entity name for which to get the collection roles.</param>
            <returns> 
            Set of all the collection roles in which the given entityName participates.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.TryGetEntityPersister(System.String)">
            <summary>
            Get the persister for the named entity
            </summary>
            <param name="entityName">The name of the entity that is persisted.</param>
            <returns>
            The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the entity or <see langword="null"/> is the name was not found.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.TryGetGuessEntityName(System.Type)">
            <summary>
            Get the entity-name for a given mapped class.
            </summary>
            <param name="implementor">the mapped class</param>
            <returns>the enntity name where available or null</returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.Dialect">
            <summary>
            Get the SQL <see cref="T:NHibernate.Dialect.Dialect"/>.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.ConnectionProvider">
            <summary>
            Get the <see cref="T:NHibernate.Connection.IConnectionProvider"/> used.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.UpdateTimestampsCache">
            <summary> The cache of table update timestamps</summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.StatisticsImplementor">
            <summary> Statistics SPI</summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.SQLExceptionConverter">
            <summary> Retrieves the SQLExceptionConverter in effect for this SessionFactory. </summary>
            <returns> The SQLExceptionConverter for this SessionFactory. </returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.QueryCache">
            <summary>
            Get the default query cache
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.CurrentSessionContext">
            <summary>
            Gets the ICurrentSessionContext instance attached to this session factory.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ISessionImplementor">
            <summary>
            Defines the internal contract between the <c>Session</c> and other parts of NHibernate
            such as implementors of <c>Type</c> or <c>ClassPersister</c>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Initialize">
            <summary>
            Initialize the session after its construction was complete
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InitializeCollection(NHibernate.Collection.IPersistentCollection,System.Boolean)">
            <summary>
            Initialize the collection (if not already initialized)
            </summary>
            <param name="collection"></param>
            <param name="writing"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InternalLoad(System.String,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Load an instance without checking if it was deleted. If it does not exist and isn't nullable, throw an exception.
            This method may create a new proxy or return an existing proxy.
            </summary>
            <param name="entityName">The entityName (or class full name) to load.</param>
            <param name="id">The identifier of the object in the database.</param>
            <param name="isNullable">Allow null instance</param>
            <param name="eager">When enabled, the object is eagerly fetched.</param>
            <returns>
            A proxy of the object or an instance of the object if the <c>persistentClass</c> does not have a proxy.
            </returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">No object could be found with that <c>id</c>.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ImmediateLoad(System.String,System.Object)">
            <summary>
            Load an instance immediately. Do not return a proxy.
            </summary>
            <param name="entityName"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a <c>List()</c> query
            </summary>
            <param name="query"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.IQueryExpression,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a <c>List()</c> expression query
            </summary>
            <param name="queryExpression"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.CreateQuery(NHibernate.IQueryExpression)">
            <summary>
            Create a new instance of <c>Query</c> for the given query expression
            <param name="queryExpression">A hibernate query expression</param>
            <returns>The query</returns>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List``1(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(System.String,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List``1(NHibernate.IQueryExpression,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.IQueryExpression,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List``1(NHibernate.Impl.CriteriaImpl)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Impl.CriteriaImpl)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute an <c>Iterate()</c> query
            </summary>
            <param name="query"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable(NHibernate.IQueryExpression,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute an <c>Iterate()</c> query
            </summary>
            <param name="query"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable``1(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.Enumerable(System.String,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable``1(NHibernate.IQueryExpression,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.Enumerable(NHibernate.IQueryExpression,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ListFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a filter
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ListFilter``1(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a filter (strongly-typed version).
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Collection from a filter
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter``1(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityPersister(System.String,System.Object)">
            <summary> Get the <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for any instance</summary>
            <param name="entityName">optional entity name </param>
            <param name="obj">the entity instance </param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AfterTransactionBegin(NHibernate.ITransaction)">
            <summary>
            Notify the session that an NHibernate transaction has begun.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.BeforeTransactionCompletion(NHibernate.ITransaction)">
            <summary>
            Notify the session that the transaction is about to complete
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AfterTransactionCompletion(System.Boolean,NHibernate.ITransaction)">
            <summary>
            Notify the session that the transaction completed, so we no longer own the old locks.
            (Also we should release cache softlocks). May be called multiple times during the transaction
            completion process.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetContextEntityIdentifier(System.Object)">
            <summary>
            Return the identifier of the persistent object, or null if transient
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Instantiate(System.String,System.Object)">
            <summary>
            Instantiate the entity class, initializing with the given identifier
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute an SQL Query
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.List``1(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ListCustomQuery(NHibernate.Loader.Custom.ICustomQuery,NHibernate.Engine.QueryParameters,System.Collections.IList)">
            <summary> Execute an SQL Query</summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetFilterParameterValue(System.String)">
            <summary>
            Retrieve the currently set value for a filter parameter.
            </summary>
            <param name="filterParameterName">The filter parameter name in the format 
            {FILTER_NAME.PARAMETER_NAME}.</param>
            <returns>The filter parameter value.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetFilterParameterType(System.String)">
            <summary>
            Retrieve the type for a given filter parameter.
            </summary>
            <param name="filterParameterName">The filter parameter name in the format 
            {FILTER_NAME.PARAMETER_NAME}.</param>
            <returns>The filter parameter type.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityUsingInterceptor(NHibernate.Engine.EntityKey)">
            <summary> 
            Get the entity instance associated with the given <tt>Key</tt>,
            calling the Interceptor if necessary
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.BestGuessEntityName(System.Object)">
            <summary> The best guess entity name for an entity not in an association</summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GuessEntityName(System.Object)">
            <summary> The guessed entity name for an entity not in an association</summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ExecuteNativeUpdate(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
            <summary> Execute a native SQL update or delete query</summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ExecuteUpdate(System.String,NHibernate.Engine.QueryParameters)">
            <summary> Execute a HQL update or delete query</summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ExecuteUpdate(NHibernate.IQueryExpression,NHibernate.Engine.QueryParameters)">
            <summary> Execute a HQL update or delete query</summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Timestamp">
            <summary>
            System time before the start of the transaction
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Factory">
            <summary>
            Get the creating SessionFactoryImplementor
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Batcher">
            <summary>
            Get the prepared statement <c>Batcher</c> for this session
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.EnabledFilters">
            <summary>
            Return the currently enabled filters.  The filter map is keyed by filter
            name, with values corresponding to the <see cref="T:NHibernate.Impl.FilterImpl"/>
            instance.
            </summary>
            <returns>The currently enabled filters.</returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Listeners">
            <summary> Retrieves the configured event listeners from this event source. </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.PersistenceContext">
            <summary> Get the persistence context for this session</summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.IsOpen">
            <summary>
            Is the <c>ISession</c> still open?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.IsConnected">
            <summary>
            Is the <c>ISession</c> currently connected?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.IsClosed">
            <summary> Determine whether the session is closed.  Provided separately from
            {@link #isOpen()} as this method does not attempt any JTA synch
            registration, where as {@link #isOpen()} does; which makes this one
            nicer to use for most internal purposes. 
            </summary>
            <returns> True if the session is closed; false otherwise.
            </returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.TransactionInProgress">
            <summary> 
            Does this <tt>Session</tt> have an active Hibernate transaction
            or is there a JTA transaction in progress?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.EntityMode">
            <summary> Retrieve the entity mode in effect for this session. </summary>
        </member>
        <member name="M:NHibernate.Engine.JoinHelper.GetRHSColumnNames(NHibernate.Type.IAssociationType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Get the columns of the associated table which are to 
            be used in the join
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ILhsAssociationTypeSqlInfo.GetAliasedColumnNames(NHibernate.Type.IAssociationType,System.Int32)">
            <summary>
            Get the aliased columns of the owning entity which are to 
            be used in the join
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ILhsAssociationTypeSqlInfo.GetColumnNames(NHibernate.Type.IAssociationType,System.Int32)">
            <summary>
            Get the columns of the owning entity which are to 
            be used in the join
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Nullability">
            <summary> 
            Implements the algorithm for validating property values
            for illegal null values
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Nullability.CheckNullability(System.Object[],NHibernate.Persister.Entity.IEntityPersister,System.Boolean)">
            <summary> 
            Check nullability of the class persister properties
            </summary>
            <param name="values">entity properties </param>
            <param name="persister">class persister </param>
            <param name="isUpdate">wether it is intended to be updated or saved </param>
        </member>
        <member name="M:NHibernate.Engine.Nullability.CheckSubElementsNullability(NHibernate.Type.IType,System.Object)">
            <summary> 
            Check sub elements-nullability. Returns property path that break
            nullability or null if none 
            </summary>
            <param name="propertyType">type to check </param>
            <param name="value">value to check </param>
            <returns> property path </returns>
        </member>
        <member name="M:NHibernate.Engine.Nullability.CheckComponentNullability(System.Object,NHibernate.Type.IAbstractComponentType)">
            <summary> 
            Check component nullability. Returns property path that break
            nullability or null if none 
            </summary>
            <param name="value">component properties </param>
            <param name="compType">component not-nullable type </param>
            <returns> property path </returns>
        </member>
        <member name="M:NHibernate.Engine.Nullability.BuildPropertyPath(System.String,System.String)">
            <summary> 
            Return a well formed property path.
            Basicaly, it will return parent.child 
            </summary>
            <param name="parent">parent in path </param>
            <param name="child">child in path </param>
            <returns> parent-child path</returns>
        </member>
        <member name="T:NHibernate.Engine.QueryParameters">
            <summary>
            Container for data that is used during the NHibernate query/load process.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.ValidateParameters">
            <summary>
            Ensure the Types and Values are the same length.
            </summary>
            <exception cref="T:NHibernate.QueryException">
            If the Lengths of <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes"/> and
            <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterValues"/> are not equal.
            </exception>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes">
            <summary>
            Gets or sets an array of <see cref="T:NHibernate.Type.IType"/> objects that is stored at the index
            of the Parameter.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterValues">
            <summary>
            Gets or sets an array of <see cref="T:System.Object"/> objects that is stored at the index
            of the Parameter.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.RowSelection">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Engine.QueryParameters.RowSelection"/> for the Query.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.LockModes">
            <summary>
            Gets or sets an <see cref="T:System.Collections.IDictionary"/> that contains the alias name of the
            object from hql as the key and the <see cref="T:NHibernate.LockMode"/> as the value.
            </summary>
            <value>An <see cref="T:System.Collections.IDictionary"/> of lock modes.</value>
        </member>
        <member name="T:NHibernate.Engine.RowSelection">
            <summary>
            Information to determine how to run an IDbCommand and what
            records to return from the IDataReader.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.RowSelection.NoValue">
            <summary>
            Indicates that the no value has been set on the Property.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.FirstRow">
            <summary>
            Gets or Sets the Index of the First Row to Select
            </summary>
            <value>The Index of the First Rows to Select</value>
            <remarks>Defaults to 0 unless specifically set.</remarks>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.MaxRows">
            <summary>
            Gets or Sets the Maximum Number of Rows to Select
            </summary>
            <value>The Maximum Number of Rows to Select</value>
            <remarks>Defaults to NoValue unless specifically set.</remarks>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.Timeout">
            <summary>
            Gets or Sets the Timeout of the Query
            </summary>
            <value>The Query Timeout</value>
            <remarks>Defaults to NoValue unless specifically set.</remarks>
        </member>
        <member name="T:NHibernate.Engine.StatefulPersistenceContext">
            <summary>
            A <see cref="T:NHibernate.Engine.IPersistenceContext"/> represents the state of persistent "stuff" which
            NHibernate is tracking.  This includes persistent entities, collections,
            as well as proxies generated.
            </summary>
            <remarks>
            There is meant to be a one-to-one correspondence between a SessionImpl and
            a PersistentContext.  The SessionImpl uses the PersistentContext to track
            the current state of its context.  Event-listeners then use the
            PersistentContext to drive their processing.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary> Constructs a PersistentContext, bound to the given session. </summary>
            <param name="session">The session "owning" this context. </param>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddUnownedCollection(NHibernate.Engine.CollectionKey,NHibernate.Collection.IPersistentCollection)">
            <summary> Add a collection which has no owner loaded</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.UseUnownedCollection(NHibernate.Engine.CollectionKey)">
            <summary>
            Get and remove a collection whose owner is not yet loaded,
            when its owner is being loaded
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.Clear">
            <summary> Clear the state of the persistence context</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.SetEntryStatus(NHibernate.Engine.EntityEntry,NHibernate.Engine.Status)">
            <summary> Set the status of an entry</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AfterTransactionCompletion">
            <summary> Called after transactions end</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Get the current state of the entity as known to the underlying
            database, or null if there is no corresponding row
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCachedDatabaseSnapshot(NHibernate.Engine.EntityKey)">
            <summary>
            Retrieve the cached database snapshot for the requested entity key.
            </summary>
            <param name="key">The entity key for which to retrieve the cached snapshot </param>
            <returns> The cached snapshot </returns>
            <remarks>
            <list type="bullet">
            <listheader><description>This differs from <see cref="M:NHibernate.Engine.StatefulPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)"/> is two important respects:</description></listheader>
            <item><description>no snapshot is obtained from the database if not already cached</description></item>
            <item><description>an entry of NO_ROW here is interpreted as an exception</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetNaturalIdSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Get the values of the natural id fields as known to the underlying
            database, or null if the entity has no natural id or there is no
            corresponding row.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntity(NHibernate.Engine.EntityKey,System.Object)">
            <summary> Add a canonical mapping from entity key to entity instance</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetEntity(NHibernate.Engine.EntityKey)">
            <summary>
            Get the entity instance associated with the given <tt>EntityKey</tt>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ContainsEntity(NHibernate.Engine.EntityKey)">
            <summary> Is there an entity with the given key in the persistence context</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveEntity(NHibernate.Engine.EntityKey)">
            <summary>
            Remove an entity from the session cache, also clear
            up other state associated with the entity, all except
            for the <tt>EntityEntry</tt>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetEntity(NHibernate.Engine.EntityUniqueKey)">
            <summary> Get an entity cached by unique key</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntity(NHibernate.Engine.EntityUniqueKey,System.Object)">
            <summary> Add an entity to the cache by unique key</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetEntry(System.Object)">
            <summary>
            Retrieve the EntityEntry representation of the given entity.
            </summary>
            <param name="entity">The entity for which to locate the EntityEntry. </param>
            <returns> The EntityEntry for the given entity. </returns>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveEntry(System.Object)">
            <summary> Remove an entity entry from the session cache</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.IsEntryFor(System.Object)">
            <summary> Is there an EntityEntry for this instance?</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionEntry(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the collection entry for a persistent collection</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntity(System.Object,NHibernate.Engine.Status,System.Object[],NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
            <summary> Adds an entity to the internal caches.</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntry(System.Object,NHibernate.Engine.Status,System.Object[],System.Object,System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
            <summary>
            Generates an appropriate EntityEntry instance and adds it
            to the event source's internal caches.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ContainsCollection(NHibernate.Collection.IPersistentCollection)">
            <summary> Is the given collection associated with this persistence context?</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ContainsProxy(NHibernate.Proxy.INHibernateProxy)">
            <summary> Is the given proxy associated with this persistence context?</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ReassociateIfUninitializedProxy(System.Object)">
            <summary>
            Takes the given object and, if it represents a proxy, reassociates it with this event source.
            </summary>
            <param name="value">The possible proxy to be reassociated. </param>
            <returns> Whether the passed value represented an actual proxy which got initialized. </returns>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ReassociateProxy(System.Object,System.Object)">
            <summary>
            If a deleted entity instance is re-saved, and it has a proxy, we need to
            reset the identifier of the proxy
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ReassociateProxy(NHibernate.Proxy.ILazyInitializer,NHibernate.Proxy.INHibernateProxy)">
            <summary>
            Associate a proxy that was instantiated by another session with this session
            </summary>
            <param name="li">The proxy initializer. </param>
            <param name="proxy">The proxy to reassociate. </param>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.Unproxy(System.Object)">
            <summary>
            Get the entity instance underlying the given proxy, throwing
            an exception if the proxy is uninitialized. If the given object
            is not a proxy, simply return the argument.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.UnproxyAndReassociate(System.Object)">
            <summary>
            Possibly unproxy the given reference and reassociate it with the current session.
            </summary>
            <param name="maybeProxy">The reference to be unproxied if it currently represents a proxy. </param>
            <returns> The unproxied instance. </returns>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.CheckUniqueness(NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            Attempts to check whether the given key represents an entity already loaded within the
            current session.
            </summary>
            <param name="obj">The entity reference against which to perform the uniqueness check.</param>
            <param name="key">The entity key.</param>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.NarrowProxy(NHibernate.Proxy.INHibernateProxy,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            If the existing proxy is insufficiently "narrow" (derived), instantiate a new proxy
            and overwrite the registration of the old one. This breaks == and occurs only for
            "class" proxies rather than "interface" proxies. Also init the proxy to point to
            the given target implementation if necessary.
            </summary>
            <param name="proxy">The proxy instance to be narrowed. </param>
            <param name="persister">The persister for the proxied entity. </param>
            <param name="key">The internal cache key for the proxied entity. </param>
            <param name="obj">(optional) the actual proxied entity instance. </param>
            <returns> An appropriately narrowed instance. </returns>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ProxyFor(NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
            <summary>
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            third argument (the entity associated with the key) if no proxy exists. Init
            the proxy to the target implementation, if necessary.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.ProxyFor(System.Object)">
            <summary>
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            argument (the entity associated with the key) if no proxy exists.
            (slower than the form above)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionOwner(System.Object,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary> Get the entity that owns this persistent collection</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetLoadedCollectionOwnerOrNull(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the entity that owned this persistent collection when it was loaded </summary>
            <param name="collection">The persistent collection </param>
            <returns>
            The owner, if its entity ID is available from the collection's loaded key
            and the owner entity is in the persistence context; otherwise, returns null
            </returns>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetLoadedCollectionOwnerIdOrNull(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the ID for the entity that owned this persistent collection when it was loaded </summary>
            <param name="collection">The persistent collection </param>
            <returns> the owner ID if available from the collection's loaded key; otherwise, returns null </returns>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetLoadedCollectionOwnerIdOrNull(NHibernate.Engine.CollectionEntry)">
            <summary> Get the ID for the entity that owned this persistent collection when it was loaded </summary>
            <param name="ce">The collection entry </param>
            <returns> the owner ID if available from the collection's loaded key; otherwise, returns null </returns>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddUninitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
            <summary> add a collection we just loaded up (still needs initializing)</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddUninitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary> add a detached uninitialized collection</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddNewCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary>
            Add a new collection (ie. a newly created one, just instantiated by the
            application, with no database state or snapshot)
            </summary>
            <param name="collection">The collection to be associated with the persistence context </param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.CollectionEntry,System.Object)">
            <summary> Add an collection to the cache, with a given collection entry. </summary>
            <param name="coll">The collection for which we are adding an entry.</param>
            <param name="entry">The entry representing the collection. </param>
            <param name="key">The key of the collection's entry. </param>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary> Add a collection to the cache, creating a new collection entry for it </summary>
            <param name="collection">The collection for which we are adding an entry. </param>
            <param name="persister">The collection persister </param>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddInitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
            <summary>
            add an (initialized) collection that was created by another session and passed
            into update() (ie. one with a snapshot and existing state on the database)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddInitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
            <summary> add a collection we just pulled out of the cache (does not need initializing)</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollection(NHibernate.Engine.CollectionKey)">
            <summary> Get the collection instance associated with the <tt>CollectionKey</tt></summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddNonLazyCollection(NHibernate.Collection.IPersistentCollection)">
            <summary>
            Register a collection for non-lazy loading at the end of the two-phase load
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.InitializeNonLazyCollections">
            <summary>
            Force initialization of all non-lazy collections encountered during
            the current two-phase load (actually, this is a no-op, unless this
            is the "outermost" load)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionHolder(System.Object)">
            <summary> Get the <tt>PersistentCollection</tt> object for an array</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddCollectionHolder(NHibernate.Collection.IPersistentCollection)">
            <summary> Register a <tt>PersistentCollection</tt> object for an array.
            Associates a holder with an array - MUST be called after loading
            array, since the array instance is not created until endLoad().
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveCollectionHolder(System.Object)">
            <summary>
            Remove the mapping of collection to holder during eviction of the owning entity
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetSnapshot(NHibernate.Collection.IPersistentCollection)">
            <summary> Get the snapshot of the pre-flush collection state</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionEntryOrNull(System.Object)">
            <summary>
            Get the collection entry for a collection passed to filter,
            which might be a collection wrapper, an array, or an unwrapped
            collection. Return null if there is no entry.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetProxy(NHibernate.Engine.EntityKey)">
            <summary> Get an existing proxy by key</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddProxy(NHibernate.Engine.EntityKey,NHibernate.Proxy.INHibernateProxy)">
            <summary> Add a proxy to the session cache</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveProxy(NHibernate.Engine.EntityKey)">
            <summary> Remove a proxy from the session cache</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.IncrementCascadeLevel">
            <summary> Called before cascading</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.DecrementCascadeLevel">
            <summary> Called after cascading</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.BeforeLoad">
            <summary> Call this before begining a two-phase load</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AfterLoad">
            <summary> Call this after finishing a two-phase load</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetOwnerId(System.String,System.String,System.Object,System.Collections.IDictionary)">
            <summary>
            Search the persistence context for an owner for the child object,
            given a collection role
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetIndexInOwner(System.String,System.String,System.Object,System.Collections.IDictionary)">
            <summary>
            Search the persistence context for an index of the child object, given a collection role
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddNullProperty(NHibernate.Engine.EntityKey,System.String)">
            <summary>
            Record the fact that the association belonging to the keyed entity is null.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.IsPropertyNull(NHibernate.Engine.EntityKey,System.String)">
            <summary> Is the association property belonging to the keyed entity null?</summary>
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.SetReadOnly(System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Engine.StatefulPersistenceContext.IsReadOnly(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.Session">
            <summary>
            Get the session to which this persistence context is bound.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.LoadContexts">
            <summary>
            Retrieve this persistence context's managed load context.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.BatchFetchQueue">
            <summary>
            Get the <tt>BatchFetchQueue</tt>, instantiating one if necessary.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.NullifiableEntityKeys">
            <summary> Retrieve the set of EntityKeys representing nullifiable references</summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.EntitiesByKey">
            <summary> Get the mapping from key value to entity instance</summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.EntityEntries">
            <summary> Get the mapping from entity instance to entity entry</summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.CollectionEntries">
            <summary> Get the mapping from collection instance to collection entry</summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.CollectionsByKey">
            <summary> Get the mapping from collection key to collection instance</summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.CascadeLevel">
            <summary> How deep are we cascaded?</summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.Flushing">
            <summary>Is a flush cycle currently in process?</summary>
            <remarks>Called before and after the flushcycle</remarks>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.HasNonReadOnlyEntities">
            <summary>False if we know for certain that all the entities are read-only</summary>
        </member>
        <member name="P:NHibernate.Engine.StatefulPersistenceContext.DefaultReadOnly">
            <inheritdoc />
        </member>
        <member name="T:NHibernate.Engine.Status">
            <summary>
            Represents the status of an entity with respect to 
            this session. These statuses are for internal 
            book-keeping only and are not intended to represent 
            any notion that is visible to the <b>application</b>. 
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Status.Loaded">
            <summary>
            The Entity is snapshotted in the Session with the same state as the database
            (called Managed in H3).
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Status.Deleted">
            <summary>
            The Entity is in the Session and has been marked for deletion but not
            deleted from the database yet.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Status.Gone">
            <summary>
            The Entity has been deleted from database.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Status.Loading">
            <summary>
            The Entity is in the process of being loaded.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Status.Saving">
            <summary>
            The Entity is in the process of being saved.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Status.ReadOnly">
            <summary>
            The entity is read-only.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.TransactionHelper">
            <summary>
            Allows work to be done outside the current transaction, by suspending it,
            and performing work in a new transaction
            </summary>
        </member>
        <member name="M:NHibernate.Engine.TransactionHelper.DoWorkInCurrentTransaction(NHibernate.Engine.ISessionImplementor,System.Data.IDbConnection,System.Data.IDbTransaction)">
            <summary> The work to be done</summary>
        </member>
        <member name="M:NHibernate.Engine.TransactionHelper.DoWorkInNewTransaction(NHibernate.Engine.ISessionImplementor)">
            <summary> Suspend the current transaction and perform work in a new transaction</summary>
        </member>
        <member name="T:NHibernate.Engine.TwoPhaseLoad">
            <summary>
            Functionality relating to Hibernate's two-phase loading process,
            that may be reused by persisters that do not use the Loader
            framework
            </summary>
        </member>
        <member name="M:NHibernate.Engine.TwoPhaseLoad.PostHydrate(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object[],System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Engine.ISessionImplementor)">
             <summary>
             Register the "hydrated" state of an entity instance, after the first step of 2-phase loading.
            
             Add the "hydrated state" (an array) of an uninitialized entity to the session. We don't try
             to resolve any associations yet, because there might be other entities waiting to be
             read from the JDBC result set we are currently processing
             </summary>
        </member>
        <member name="M:NHibernate.Engine.TwoPhaseLoad.InitializeEntity(System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor,NHibernate.Event.PreLoadEvent,NHibernate.Event.PostLoadEvent)">
            <summary>
            Perform the second step of 2-phase load. Fully initialize the entity instance.
            After processing a JDBC result set, we "resolve" all the associations
            between the entities which were instantiated and had their state
            "hydrated" into an array
            </summary>
        </member>
        <member name="M:NHibernate.Engine.TwoPhaseLoad.AddUninitializedEntity(NHibernate.Engine.EntityKey,System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.LockMode,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Add an uninitialized instance of an entity class, as a placeholder to ensure object
            identity. Must be called before <tt>postHydrate()</tt>.
            Create a "temporary" entry for a newly instantiated entity. The entity is uninitialized,
            but we need the mapping from id to instance in order to guarantee uniqueness.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.TypedValue">
            <summary> An ordered pair of a value and its Hibernate type. </summary>
        </member>
        <member name="M:NHibernate.Engine.UnsavedValueFactory.GetUnsavedIdentifierValue(System.String,NHibernate.Properties.IGetter,NHibernate.Type.IType,System.Reflection.ConstructorInfo)">
            <summary>
            Return an IdentifierValue for the specified unsaved-value. If none is specified,
            guess the unsaved value by instantiating a test instance of the class and
            reading it's id property, or if that is not possible, using the java default
            value for the type
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ValueInclusion">
            <summary>
            An enum of the different ways a value might be "included".
            </summary>
            <remarks>
            This is really an expanded true/false notion with Partial being the
            expansion. Partial deals with components in the cases where
            parts of the referenced component might define inclusion, but the
            component overall does not.
            </remarks>
        </member>
        <member name="T:NHibernate.Engine.Versioning">
            <summary>
            Utility methods for managing versions and timestamps
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Versioning.Increment(System.Object,NHibernate.Type.IVersionType,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Increment the given version number
            </summary>
            <param name="version">The value of the current version.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <param name="session">The current <see cref="T:NHibernate.ISession"/>.</param>
            <returns>Returns the next value for the version.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.Seed(NHibernate.Type.IVersionType,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create an initial version number
            </summary>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <param name="session">The current <see cref="T:NHibernate.ISession"/>.</param>
            <returns>A seed value to initialize the versioned property with.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SeedVersion(System.Object[],System.Int32,NHibernate.Type.IVersionType,System.Nullable{System.Boolean},NHibernate.Engine.ISessionImplementor)">
            <summary>
            Seed the given instance state snapshot with an initial version number
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <param name="force">Force the version to initialize</param>
            <param name="session">The current session, if any.</param>
            <returns><see langword="true"/> if the version property needs to be seeded with an initial value.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SetVersion(System.Object[],System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Set the version number of the given instance state snapshot
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="version">The value the version should be set to in the <c>fields</c> parameter.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
        </member>
        <member name="M:NHibernate.Engine.Versioning.GetVersion(System.Object[],NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Get the version number of the given instance state snapshot
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
            <returns>
            The value of the version contained in the <c>fields</c> parameter or null if the
            Entity is not versioned.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.IsVersionIncrementRequired(System.Int32[],System.Boolean,System.Boolean[])">
            <summary> Do we need to increment the version number, given the dirty properties? </summary>
            <param name="dirtyProperties">The array of property indexes which were deemed dirty </param>
            <param name="hasDirtyCollections">Were any collections found to be dirty (structurally changed) </param>
            <param name="propertyVersionability">An array indicating versionability of each property. </param>
            <returns> True if a version increment is required; false otherwise. </returns>
        </member>
        <member name="T:NHibernate.Engine.VersionValue">
            <summary>
            A strategy for determining if a version value is an version of
            a new transient instance or a previously persistent transient instance.
            The strategy is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.VersionValue.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.VersionValue.#ctor(System.Object)">
            <summary>
            Assume the transient instance is newly instantiated if its version is null or
            equal to <c>Value</c>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Engine.VersionValue.IsUnsaved(System.Object)">
            <summary>
            Does the given identifier belong to a new instance
            </summary>
        </member>
        <member name="F:NHibernate.Engine.VersionValue.VersionSaveNull">
            <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise assume it is a detached instance.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.VersionValue.VersionUndefined">
            <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise defer to the identifier unsaved-value.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.VersionValue.VersionNegative">
            <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.AbstractFlushingEventListener">
            <summary>
            A convenience base class for listeners whose functionality results in flushing.
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractFlushingEventListener.FlushEverythingToExecutions(NHibernate.Event.FlushEvent)">
            <summary> 
            Coordinates the processing necessary to get things ready for executions
            as db calls by preparing the session caches and moving the appropriate
            entities and collections to their respective execution queues. 
            </summary>
            <param name="event">The flush event.</param>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractFlushingEventListener.PerformExecutions(NHibernate.Event.IEventSource)">
            <summary> 
            Execute all SQL and second-level cache updates, in a
            special order so that foreign-key constraints cannot
            be violated:
            <list type="bullet">
            <item> <description>Inserts, in the order they were performed</description> </item>
            <item> <description>Updates</description> </item>
            <item> <description>Deletion of collection elements</description> </item>
            <item> <description>Insertion of collection elements</description> </item>
            <item> <description>Deletes, in the order they were performed</description> </item>
            </list>
            </summary>
            <param name="session">The session being flushed</param>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractFlushingEventListener.PostFlush(NHibernate.Engine.ISessionImplementor)">
            <summary> 
            1. Recreate the collection key -> collection map
            2. rebuild the collection entries
            3. call Interceptor.postFlush()
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.AbstractLockUpgradeEventListener">
            <summary> 
            A convenience base class for listeners that respond to requests to perform a
            pessimistic lock upgrade on an entity. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.AbstractReassociateEventListener">
            <summary>
            A convenience base class for listeners that respond to requests to reassociate an entity
            to a session ( such as through lock() or update() ).
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractReassociateEventListener.Reassociate(NHibernate.Event.AbstractEvent,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Associates a given entity (either transient or associated with another session) to the given session.
            </summary>
            <param name="event">The event triggering the re-association </param>
            <param name="entity">The entity to be associated </param>
            <param name="id">The id of the entity. </param>
            <param name="persister">The entity's persister instance. </param>
            <returns> An EntityEntry representing the entity within this session. </returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractLockUpgradeEventListener.UpgradeLock(System.Object,NHibernate.Engine.EntityEntry,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Performs a pessimistic lock upgrade on a given entity, if needed. 
            </summary>
            <param name="entity">The entity for which to upgrade the lock.</param>
            <param name="entry">The entity's EntityEntry instance.</param>
            <param name="requestedLockMode">The lock mode being requested for locking. </param>
            <param name="source">The session which is the source of the event being processed.</param>
        </member>
        <member name="T:NHibernate.Event.Default.AbstractSaveEventListener">
            <summary> 
            A convenience bas class for listeners responding to save events. 
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.SaveWithRequestedId(System.Object,System.Object,System.String,System.Object,NHibernate.Event.IEventSource)">
            <summary> 
            Prepares the save call using the given requested id. 
            </summary>
            <param name="entity">The entity to be saved. </param>
            <param name="requestedId">The id to which to associate the entity. </param>
            <param name="entityName">The name of the entity being saved. </param>
            <param name="anything">Generally cascade-specific information. </param>
            <param name="source">The session which is the source of this save event. </param>
            <returns> The id used to save the entity. </returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.SaveWithGeneratedId(System.Object,System.String,System.Object,NHibernate.Event.IEventSource,System.Boolean)">
            <summary> 
            Prepares the save call using a newly generated id. 
            </summary>
            <param name="entity">The entity to be saved </param>
            <param name="entityName">The entity-name for the entity to be saved </param>
            <param name="anything">Generally cascade-specific information. </param>
            <param name="source">The session which is the source of this save event. </param>
            <param name="requiresImmediateIdAccess">
            does the event context require
            access to the identifier immediately after execution of this method (if
            not, post-insert style id generators may be postponed if we are outside
            a transaction). 
            </param>
            <returns> 
            The id used to save the entity; may be null depending on the
            type of id generator used and the requiresImmediateIdAccess value
            </returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.PerformSave(System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Object,NHibernate.Event.IEventSource,System.Boolean)">
            <summary> 
            Prepares the save call by checking the session caches for a pre-existing
            entity and performing any lifecycle callbacks. 
            </summary>
            <param name="entity">The entity to be saved. </param>
            <param name="id">The id by which to save the entity. </param>
            <param name="persister">The entity's persister instance. </param>
            <param name="useIdentityColumn">Is an identity column being used? </param>
            <param name="anything">Generally cascade-specific information. </param>
            <param name="source">The session from which the event originated. </param>
            <param name="requiresImmediateIdAccess">
            does the event context require
            access to the identifier immediately after execution of this method (if
            not, post-insert style id generators may be postponed if we are outside
            a transaction). 
            </param>
            <returns> 
            The id used to save the entity; may be null depending on the
            type of id generator used and the requiresImmediateIdAccess value
            </returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.PerformSaveOrReplicate(System.Object,NHibernate.Engine.EntityKey,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Object,NHibernate.Event.IEventSource,System.Boolean)">
            <summary> 
            Performs all the actual work needed to save an entity (well to get the save moved to
            the execution queue). 
            </summary>
            <param name="entity">The entity to be saved </param>
            <param name="key">The id to be used for saving the entity (or null, in the case of identity columns) </param>
            <param name="persister">The entity's persister instance. </param>
            <param name="useIdentityColumn">Should an identity column be used for id generation? </param>
            <param name="anything">Generally cascade-specific information. </param>
            <param name="source">The session which is the source of the current event. </param>
            <param name="requiresImmediateIdAccess">
            Is access to the identifier required immediately
            after the completion of the save?  persist(), for example, does not require this... 
            </param>
            <returns> 
            The id used to save the entity; may be null depending on the
            type of id generator used and the requiresImmediateIdAccess value
            </returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.SubstituteValuesIfNecessary(System.Object,System.Object,System.Object[],NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Perform any property value substitution that is necessary
            (interceptor callback, version initialization...) 
            </summary>
            <param name="entity">The entity </param>
            <param name="id">The entity identifier </param>
            <param name="values">The snapshot entity state </param>
            <param name="persister">The entity persister </param>
            <param name="source">The originating session </param>
            <returns> 
            True if the snapshot state changed such that
            reinjection of the values into the entity is required.
            </returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.CascadeBeforeSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
            <summary> Handles the calls needed to perform pre-save cascades for the given entity. </summary>
            <param name="source">The session from which the save event originated.</param>
            <param name="persister">The entity's persister instance. </param>
            <param name="entity">The entity to be saved. </param>
            <param name="anything">Generally cascade-specific data </param>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.CascadeAfterSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
            <summary> Handles to calls needed to perform post-save cascades. </summary>
            <param name="source">The session from which the event originated. </param>
            <param name="persister">The entity's persister instance. </param>
            <param name="entity">The entity being saved. </param>
            <param name="anything">Generally cascade-specific data </param>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.GetEntityState(System.Object,System.String,NHibernate.Engine.EntityEntry,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Determine whether the entity is persistent, detached, or transient 
            </summary>
            <param name="entity">The entity to check </param>
            <param name="entityName">The name of the entity </param>
            <param name="entry">The entity's entry in the persistence context </param>
            <param name="source">The originating session. </param>
            <returns> The state. </returns>
        </member>
        <member name="P:NHibernate.Event.Default.AbstractSaveEventListener.VersionIncrementDisabled">
            <summary> 
            After the save, will te version number be incremented
            if the instance is modified? 
            </summary>
            <returns> True if the version will be incremented on an entity change after save; false otherwise. </returns>
        </member>
        <member name="T:NHibernate.Event.Default.AbstractVisitor">
            <summary> 
            Abstract superclass of algorithms that walk a tree of property values of an entity, and
            perform specific functionality for collections, components and associated entities. 
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessValues(System.Object[],NHibernate.Type.IType[])">
            <summary> Dispatch each property value to ProcessValue(). </summary>
            <param name="values"> </param>
            <param name="types"> </param>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessValue(System.Object,NHibernate.Type.IType)">
            <summary> 
            Visit a property value. Dispatch to the correct handler for the property type.
            </summary>
            <param name="value"> </param>
            <param name="type"> </param>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessComponent(System.Object,NHibernate.Type.IAbstractComponentType)">
            <summary>
            Visit a component. Dispatch each property to <see cref="M:NHibernate.Event.Default.AbstractVisitor.ProcessValues(System.Object[],NHibernate.Type.IType[])"/>
            </summary>
            <param name="component"></param>
            <param name="componentType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessEntity(System.Object,NHibernate.Type.EntityType)">
            <summary>
             Visit a many-to-one or one-to-one associated entity. Default superclass implementation is a no-op.
            </summary>
            <param name="value"></param>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessCollection(System.Object,NHibernate.Type.CollectionType)">
            <summary>
            Visit a collection. Default superclass implementation is a no-op.
            </summary>
            <param name="value"></param>
            <param name="collectionType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Event.Default.AbstractVisitor.Process(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Walk the tree starting from the given entity.
            </summary>
            <param name="obj"></param>
            <param name="persister"></param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultAutoFlushEventListener">
            <summary>
            Defines the default flush event listeners used by hibernate for
            flushing session state in response to generated auto-flush events.
            </summary>
        </member>
        <member name="T:NHibernate.Event.IAutoFlushEventListener">
            <summary> Defines the contract for handling of session auto-flush events. </summary>
        </member>
        <member name="M:NHibernate.Event.IAutoFlushEventListener.OnAutoFlush(NHibernate.Event.AutoFlushEvent)">
            <summary>
            Handle the given auto-flush event.
            </summary>
            <param name="event">The auto-flush event to be handled.</param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultAutoFlushEventListener.OnAutoFlush(NHibernate.Event.AutoFlushEvent)">
            <summary>
            Handle the given auto-flush event.
            </summary>
            <param name="event">The auto-flush event to be handled.</param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultDeleteEventListener">
            <summary> 
            Defines the default delete event listener used by hibernate for deleting entities
            from the datastore in response to generated delete events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IDeleteEventListener">
            <summary> Defines the contract for handling of deletion events generated from a session. </summary>
        </member>
        <member name="M:NHibernate.Event.IDeleteEventListener.OnDelete(NHibernate.Event.DeleteEvent)">
            <summary>Handle the given delete event. </summary>
            <param name="event">The delete event to be handled. </param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.OnDelete(NHibernate.Event.DeleteEvent)">
            <summary>Handle the given delete event. </summary>
            <param name="event">The delete event to be handled. </param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.PerformDetachedEntityDeletionCheck(NHibernate.Event.DeleteEvent)">
            <summary> Called when we have recognized an attempt to delete a detached entity. </summary>
            <param name="event">The event. </param>
            <remarks>
            This is perfectly valid in Hibernate usage; JPA, however, forbids this.
            Thus, this is a hook for HEM to affect this behavior.
            </remarks>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.DeleteTransientEntity(NHibernate.Event.IEventSource,System.Object,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Collections.Generic.ISet{System.Object})">
            <summary> 
            We encountered a delete request on a transient instance.
            <p/>
            This is a deviation from historical Hibernate (pre-3.2) behavior to
            align with the JPA spec, which states that transient entities can be
            passed to remove operation in which case cascades still need to be
            performed.
             </summary>
            <param name="session">The session which is the source of the event </param>
            <param name="entity">The entity being delete processed </param>
            <param name="cascadeDeleteEnabled">Is cascading of deletes enabled</param>
            <param name="persister">The entity persister </param>
            <param name="transientEntities">
            A cache of already visited transient entities (to avoid infinite recursion).
            </param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.DeleteEntity(NHibernate.Event.IEventSource,System.Object,NHibernate.Engine.EntityEntry,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Collections.Generic.ISet{System.Object})">
            <summary> 
            Perform the entity deletion.  Well, as with most operations, does not
            really perform it; just schedules an action/execution with the
            <see cref="T:NHibernate.Engine.ActionQueue"/> for execution during flush. 
            </summary>
            <param name="session">The originating session </param>
            <param name="entity">The entity to delete </param>
            <param name="entityEntry">The entity's entry in the <see cref="T:NHibernate.ISession"/> </param>
            <param name="isCascadeDeleteEnabled">Is delete cascading enabled? </param>
            <param name="persister">The entity persister. </param>
            <param name="transientEntities">A cache of already deleted entities. </param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultDirtyCheckEventListener">
            <summary> 
            Defines the default dirty-check event listener used by hibernate for
            checking the session for dirtiness in response to generated dirty-check events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IDirtyCheckEventListener">
            <summary> Defines the contract for handling of session dirty-check events.</summary>
        </member>
        <member name="M:NHibernate.Event.IDirtyCheckEventListener.OnDirtyCheck(NHibernate.Event.DirtyCheckEvent)">
            <summary>Handle the given dirty-check event. </summary>
            <param name="event">The dirty-check event to be handled. </param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultEvictEventListener">
            <summary> 
            Defines the default evict event listener used by hibernate for evicting entities
            in response to generated flush events.  In particular, this implementation will
            remove any hard references to the entity that are held by the infrastructure
            (references held by application or other persistent instances are okay) 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IEvictEventListener">
            <summary> Defines the contract for handling of evict events generated from a session. </summary>
        </member>
        <member name="M:NHibernate.Event.IEvictEventListener.OnEvict(NHibernate.Event.EvictEvent)">
            <summary> Handle the given evict event. </summary>
            <param name="event">The evict event to be handled.</param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultFlushEntityEventListener">
            <summary>
            An event that occurs for each entity instance at flush time
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.OnFlushEntity(NHibernate.Event.FlushEntityEvent)">
            <summary>
            Flushes a single entity's state to the database, by scheduling an update action, if necessary
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.CheckId(System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.EntityMode)">
            <summary>
            make sure user didn't mangle the id
            </summary>
            <param name="obj">The obj.</param>
            <param name="persister">The persister.</param>
            <param name="id">The id.</param>
            <param name="entityMode">The entity mode.</param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.IsUpdateNecessary(NHibernate.Event.FlushEntityEvent)">
            <summary>
            Performs all necessary checking to determine if an entity needs an SQL update
            to synchronize its state to the database. Modifies the event by side-effect!
            Note: this method is quite slow, avoid calling if possible!
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.DirtyCheck(NHibernate.Event.FlushEntityEvent)">
            <summary> Perform a dirty check, and attach the results to the event</summary>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultFlushEventListener">
            <summary> 
            Defines the default flush event listeners used by hibernate for 
            flushing session state in response to generated flush events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IFlushEventListener">
            <summary> Defines the contract for handling of session flush events. </summary>
        </member>
        <member name="M:NHibernate.Event.IFlushEventListener.OnFlush(NHibernate.Event.FlushEvent)">
            <summary>Handle the given flush event. </summary>
            <param name="event">The flush event to be handled.</param>
        </member>
        <member name="T:NHibernate.Event.IInitializeCollectionEventListener">
            <summary> 
            Defines the contract for handling of collection initialization events 
            generated by a session. 
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultInitializeCollectionEventListener.OnInitializeCollection(NHibernate.Event.InitializeCollectionEvent)">
            <summary> called by a collection that wants to initialize itself</summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultInitializeCollectionEventListener.InitializeCollectionFromCache(System.Object,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ISessionImplementor)">
            <summary> Try to initialize a collection from the cache</summary>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultLoadEventListener">
            <summary>
            Defines the default load event listeners used by NHibernate for loading entities
            in response to generated load events.
            </summary>
        </member>
        <member name="T:NHibernate.Event.ILoadEventListener">
            <summary>
            Defines the contract for handling of load events generated from a session. 
            </summary>
        </member>
        <member name="M:NHibernate.Event.ILoadEventListener.OnLoad(NHibernate.Event.LoadEvent,NHibernate.Event.LoadType)">
            <summary> 
            Handle the given load event. 
            </summary>
            <param name="event">The load event to be handled. </param>
            <param name="loadType"></param>
            <returns> The result (i.e., the loaded entity). </returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.Load(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
            <summary> Perfoms the load of an entity. </summary>
            <returns> The loaded entity. </returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.ProxyOrLoad(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
            <summary>
            Based on configured options, will either return a pre-existing proxy,
            generate a new proxy, or perform an actual load.
            </summary>
            <returns> The result of the proxy/load operation.</returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.ReturnNarrowedProxy(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType,NHibernate.Engine.IPersistenceContext,System.Object)">
            <summary>
            Given that there is a pre-existing proxy.
            Initialize it if necessary; narrow if necessary.
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.CreateProxyIfNecessary(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType,NHibernate.Engine.IPersistenceContext)">
            <summary>
            Given that there is no pre-existing proxy.
            Check if the entity is already loaded. If it is, return the entity,
            otherwise create and return a proxy.
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LockAndLoad(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType,NHibernate.Engine.ISessionImplementor)">
            <summary>
            If the class to be loaded has been configured with a cache, then lock
            given id in that cache and then perform the load.
            </summary>
            <returns> The loaded entity </returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.DoLoad(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
            <summary>
            Coordinates the efforts to load a given entity.  First, an attempt is
            made to load the entity from the session-level cache.  If not found there,
            an attempt is made to locate it in second-level cache.  Lastly, an
            attempt is made to load it directly from the datasource.
            </summary>
            <param name="event">The load event </param>
            <param name="persister">The persister for the entity being requested for load </param>
            <param name="keyToLoad">The EntityKey representing the entity to be loaded. </param>
            <param name="options">The load options. </param>
            <returns> The loaded entity, or null. </returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LoadFromDatasource(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
            <summary>
            Performs the process of loading an entity from the configured underlying datasource.
            </summary>
            <param name="event">The load event </param>
            <param name="persister">The persister for the entity being requested for load </param>
            <param name="keyToLoad">The EntityKey representing the entity to be loaded. </param>
            <param name="options">The load options. </param>
            <returns> The object loaded from the datasource, or null if not found. </returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LoadFromSessionCache(NHibernate.Event.LoadEvent,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
            <summary>
            Attempts to locate the entity in the session-level cache.
            </summary>
            <param name="event">The load event </param>
            <param name="keyToLoad">The EntityKey representing the entity to be loaded. </param>
            <param name="options">The load options. </param>
            <returns> The entity from the session-level cache, or null. </returns>
            <remarks>
            If allowed to return nulls, then if the entity happens to be found in
            the session cache, we check the entity type for proper handling
            of entity hierarchies.
            If checkDeleted was set to true, then if the entity is found in the
            session-level cache, it's current status within the session cache
            is checked to see if it has previously been scheduled for deletion.
            </remarks>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LoadFromSecondLevelCache(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Event.LoadType)">
            <summary> Attempts to load the entity from the second-level cache. </summary>
            <param name="event">The load event </param>
            <param name="persister">The persister for the entity being requested for load </param>
            <param name="options">The load options. </param>
            <returns> The entity from the second-level cache, or null. </returns>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultLockEventListener">
            <summary> 
            Defines the default lock event listeners used by hibernate to lock entities
            in response to generated lock events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.ILockEventListener">
            <summary>
            Defines the contract for handling of lock events generated from a session.
            </summary>
        </member>
        <member name="M:NHibernate.Event.ILockEventListener.OnLock(NHibernate.Event.LockEvent)">
            <summary>Handle the given lock event. </summary>
            <param name="event">The lock event to be handled. </param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultLockEventListener.OnLock(NHibernate.Event.LockEvent)">
            <summary>Handle the given lock event. </summary>
            <param name="event">The lock event to be handled.</param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultMergeEventListener">
            <summary>
            Defines the default event listener for handling of merge events generated from a session.
            </summary>
        </member>
        <member name="T:NHibernate.Event.IMergeEventListener">
            <summary>
            Defines the contract for handling of merge events generated from a session.
            </summary>
        </member>
        <member name="M:NHibernate.Event.IMergeEventListener.OnMerge(NHibernate.Event.MergeEvent)">
            <summary> Handle the given merge event. </summary>
            <param name="event">The merge event to be handled. </param>
        </member>
        <member name="M:NHibernate.Event.IMergeEventListener.OnMerge(NHibernate.Event.MergeEvent,System.Collections.IDictionary)">
            <summary> Handle the given merge event. </summary>
            <param name="event">The merge event to be handled. </param>
            <param name="copiedAlready"></param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.CascadeOnMerge(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Collections.IDictionary)">
            <summary>
            Perform any cascades needed as part of this copy event.
            </summary>
            <param name="source">The merge event being processed. </param>
            <param name="persister">The persister of the entity being copied. </param>
            <param name="entity">The entity being copied. </param>
            <param name="copyCache">A cache of already copied instance. </param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.GetTransientCopyCache(NHibernate.Event.MergeEvent,NHibernate.Event.Default.EventCache)">
            <summary>
            Determine which merged entities in the copyCache are transient.
            </summary>
            <param name="event"></param>
            <param name="copyCache"></param>
            <returns></returns>
            <remarks>Should this method be on the EventCache class?</remarks>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.RetryMergeTransientEntities(NHibernate.Event.MergeEvent,System.Collections.IDictionary,NHibernate.Event.Default.EventCache)">
            <summary>
            Retry merging transient entities
            </summary>
            <param name="event"></param>
            <param name="transientCopyCache"></param>
            <param name="copyCache"></param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.CascadeAfterSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
            <summary> Cascade behavior is redefined by this subclass, disable superclass behavior</summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.CascadeBeforeSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
            <summary> Cascade behavior is redefined by this subclass, disable superclass behavior</summary>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultPersistEventListener">
            <summary> 
            Defines the default create event listener used by hibernate for creating
            transient entities in response to generated create events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IPersistEventListener">
            <summary>
            Defines the contract for handling of create events generated from a session.
            </summary>
        </member>
        <member name="M:NHibernate.Event.IPersistEventListener.OnPersist(NHibernate.Event.PersistEvent)">
            <summary> Handle the given create event.</summary>
            <param name="event">The create event to be handled.</param>
        </member>
        <member name="M:NHibernate.Event.IPersistEventListener.OnPersist(NHibernate.Event.PersistEvent,System.Collections.IDictionary)">
            <summary> Handle the given create event. </summary>
            <param name="event">The create event to be handled.</param>
            <param name="createdAlready"></param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultPersistEventListener.EntityIsTransient(NHibernate.Event.PersistEvent,System.Collections.IDictionary)">
            <summary> Handle the given create event. </summary>
            <param name="event">The save event to be handled. </param>
            <param name="createCache"></param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultPersistOnFlushEventListener">
            <summary>  When persist is used as the cascade action, persistOnFlush should be used</summary>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultPostLoadEventListener">
            <summary> Call <see cref="T:NHibernate.Classic.ILifecycle"/> interface if necessary </summary>
        </member>
        <member name="T:NHibernate.Event.IPostLoadEventListener">
            <summary>
            Occurs after an an entity instance is fully loaded.
            </summary>
        </member>
        <member name="M:NHibernate.Event.IPostLoadEventListener.OnPostLoad(NHibernate.Event.PostLoadEvent)">
            <summary>
            
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultPreLoadEventListener">
            <summary> 
            Called before injecting property values into a newly 
            loaded entity instance. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IPreLoadEventListener">
            <summary> 
            Called before injecting property values into a newly loaded entity instance.
            </summary>
        </member>
        <member name="M:NHibernate.Event.IPreLoadEventListener.OnPreLoad(NHibernate.Event.PreLoadEvent)">
            <summary>
            
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultRefreshEventListener">
            <summary> 
            Defines the default refresh event listener used by hibernate for refreshing entities
            in response to generated refresh events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IRefreshEventListener">
            <summary>
            Defines the contract for handling of refresh events generated from a session.
            </summary>
        </member>
        <member name="M:NHibernate.Event.IRefreshEventListener.OnRefresh(NHibernate.Event.RefreshEvent)">
            <summary> Handle the given refresh event. </summary>
            <param name="event">The refresh event to be handled.</param>
        </member>
        <member name="M:NHibernate.Event.IRefreshEventListener.OnRefresh(NHibernate.Event.RefreshEvent,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="event"></param>
            <param name="refreshedAlready"></param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultReplicateEventListener">
            <summary> 
            Defines the default replicate event listener used by Hibernate to replicate
            entities in response to generated replicate events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IReplicateEventListener">
            <summary>
            Defines the contract for handling of replicate events generated from a session.
            </summary>
        </member>
        <member name="M:NHibernate.Event.IReplicateEventListener.OnReplicate(NHibernate.Event.ReplicateEvent)">
            <summary>Handle the given replicate event. </summary>
            <param name="event">The replicate event to be handled.</param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultSaveEventListener">
            <summary> An event handler for save() events</summary>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener">
            <summary> 
            Defines the default listener used by Hibernate for handling save-update events. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.ISaveOrUpdateEventListener">
            <summary>
            Defines the contract for handling of update events generated from a session.
            </summary>
        </member>
        <member name="M:NHibernate.Event.ISaveOrUpdateEventListener.OnSaveOrUpdate(NHibernate.Event.SaveOrUpdateEvent)">
            <summary> Handle the given update event. </summary>
            <param name="event">The update event to be handled.</param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.EntityIsTransient(NHibernate.Event.SaveOrUpdateEvent)">
            <summary> 
            The given save-update event named a transient entity.
            Here, we will perform the save processing. 
            </summary>
            <param name="event">The save event to be handled. </param>
            <returns> The entity's identifier after saving. </returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.SaveWithGeneratedOrRequestedId(NHibernate.Event.SaveOrUpdateEvent)">
            <summary> 
            Save the transient instance, assigning the right identifier 
            </summary>
            <param name="event">The initiating event. </param>
            <returns> The entity's identifier value after saving.</returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.EntityIsDetached(NHibernate.Event.SaveOrUpdateEvent)">
            <summary> 
            The given save-update event named a detached entity.
            Here, we will perform the update processing. 
            </summary>
            <param name="event">The update event to be handled. </param>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.GetUpdateId(System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.EntityMode)">
            <summary> Determine the id to use for updating. </summary>
            <param name="entity">The entity. </param>
            <param name="persister">The entity persister </param>
            <param name="requestedId">The requested identifier </param>
            <param name="entityMode">The entity mode. </param>
            <returns> The id. </returns>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.CascadeOnUpdate(NHibernate.Event.SaveOrUpdateEvent,NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary> 
            Handles the calls needed to perform cascades as part of an update request
            for the given entity. 
            </summary>
            <param name="event">The event currently being processed. </param>
            <param name="persister">The defined persister for the entity being updated. </param>
            <param name="entity">The entity being updated. </param>
        </member>
        <member name="T:NHibernate.Event.Default.DefaultUpdateEventListener">
            <summary> An event handler for update() events</summary>
        </member>
        <member name="M:NHibernate.Event.Default.DefaultUpdateEventListener.GetUpdateId(System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.EntityMode)">
            <summary> 
            If the user specified an id, assign it to the instance and use that, 
            otherwise use the id already assigned to the instance
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.DirtyCollectionSearchVisitor">
            <summary>
            A Visitor that determines if a dirty collection was found.
            </summary>
            <remarks>
            <list type="number">
            	<listheader>
            		<description>Reason for dirty collection</description>
            	</listheader>
            	<item>
            		<description>
            		If it is a new application-instantiated collection, return true (does not occur anymore!)
            		</description>
            	</item>
            	<item>
            		<description>
            		If it is a component, recurse.
            		</description>
            	</item>
            	<item>
            		<description>
            		If it is a wrapped collection, ask the collection entry.
            		</description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="P:NHibernate.Event.Default.DirtyCollectionSearchVisitor.WasDirtyCollectionFound">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if a dirty collection was found.
            </summary>
            <value><see langword="true"/> if a dirty collection was found.</value>
        </member>
        <member name="M:NHibernate.Event.Default.EventCache.Add(System.Object,System.Object,System.Boolean)">
            <summary>
            Associates the specified entity with the specified copy in this EventCache;
            </summary>
            <param name="entity"></param>
            <param name="copy"></param>
            <param name="isOperatedOn">indicates if the operation is performed on the entity</param>
        </member>
        <member name="M:NHibernate.Event.Default.EventCache.InvertMap">
            <summary>
            Returns copy-entity mappings
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Event.Default.EventCache.IsOperatedOn(System.Object)">
            <summary>
            Returns true if the listener is performing the operation on the specified entity.
            </summary>
            <param name="entity">Must be non-null and this EventCache must contain a mapping for this entity</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Event.Default.EventCache.SetOperatedOn(System.Object,System.Boolean)">
            <summary>
            Set flag to indicate if the listener is performing the operation on the specified entity.
            </summary>
            <param name="entity"></param>
            <param name="isOperatedOn"></param>
        </member>
        <member name="P:NHibernate.Event.Default.EventCache.Count">
            <summary>
            Returns the number of entity-copy mappings in this EventCache
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.EvictVisitor">
            <summary> 
            Evict any collections referenced by the object from the session cache.
            This will NOT pick up any collections that were dereferenced, so they
            will be deleted (suboptimal but not exactly incorrect). 
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.FlushVisitor">
            <summary> 
            Process collections reachable from an entity. 
            This visitor assumes that wrap was already performed for the entity.
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.OnLockVisitor">
            <summary> 
            When a transient entity is passed to lock(), we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. throw an exception for each "new" collection 
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.ReattachVisitor">
            <summary>
            Abstract superclass of visitors that reattach collections
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.ProxyVisitor">
            <summary>
            Reassociates uninitialized proxies with the session
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.ProxyVisitor.ProcessEntity(System.Object,NHibernate.Type.EntityType)">
            <summary>
             Visit a many-to-one or one-to-one associated entity. Default superclass implementation is a no-op.
            </summary>
            <param name="value"></param>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Event.Default.ProxyVisitor.IsOwnerUnchanged(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary> 
            Has the owner of the collection changed since the collection was snapshotted and detached?
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.ProxyVisitor.ReattachCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Type.CollectionType)">
            <summary> 
            Reattach a detached (disassociated) initialized or uninitialized
            collection wrapper, using a snapshot carried with the collection wrapper
            </summary>
        </member>
        <member name="M:NHibernate.Event.Default.ReattachVisitor.RemoveCollection(NHibernate.Persister.Collection.ICollectionPersister,System.Object,NHibernate.Event.IEventSource)">
            <summary> 
            Schedules a collection for deletion. 
            </summary>
            <param name="role">The persister representing the collection to be removed. </param>
            <param name="collectionKey">The collection key (differs from owner-id in the case of property-refs). </param>
            <param name="source">The session from which the request originated. </param>
        </member>
        <member name="M:NHibernate.Event.Default.ReattachVisitor.ExtractCollectionKeyFromOwner(NHibernate.Persister.Collection.ICollectionPersister)">
            <summary> 
            This version is slightly different in that here we need to assume that
            the owner is not yet associated with the session, and thus we cannot
            rely on the owner's EntityEntry snapshot... 
            </summary>
            <param name="role">The persister for the collection role being processed. </param>
            <returns> </returns>
        </member>
        <member name="T:NHibernate.Event.Default.OnReplicateVisitor">
            <summary> 
            When an entity is passed to replicate(), and there is an existing row, we must
            inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. execute a collection removal (SQL DELETE) for each null collection property or "new" collection 
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.OnUpdateVisitor">
            <summary> 
            When an entity is passed to update(), we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. execute a collection removal (SQL DELETE) for each null collection property or "new" collection 
            </summary>
        </member>
        <member name="T:NHibernate.Event.Default.WrapVisitor">
            <summary> 
            Wrap collections in a Hibernate collection wrapper.
            </summary>
        </member>
        <member name="T:NHibernate.Event.AbstractCollectionEvent">
            <summary> Defines a base class for events involving collections. </summary>
        </member>
        <member name="T:NHibernate.Event.AbstractEvent">
            <summary> 
            Defines a base class for Session generated events.
            </summary>
        </member>
        <member name="P:NHibernate.Event.IDatabaseEventArgs.Session">
            <summary> 
            Returns the session event source for this event.  
            This is the underlying session from which this event was generated.
            </summary>
        </member>
        <member name="M:NHibernate.Event.AbstractEvent.#ctor(NHibernate.Event.IEventSource)">
            <summary> 
            Constructs an event from the given event session.
            </summary>
            <param name="source">The session event source. </param>
        </member>
        <member name="P:NHibernate.Event.AbstractEvent.Session">
            <summary> 
            Returns the session event source for this event.  
            This is the underlying session from which this event was generated.
            </summary>
        </member>
        <member name="M:NHibernate.Event.AbstractCollectionEvent.#ctor(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,NHibernate.Event.IEventSource,System.Object,System.Object)">
            <summary> Constructs an AbstractCollectionEvent object. </summary>
            <param name="collectionPersister">The collection persister.</param>
            <param name="collection">The collection </param>
            <param name="source">The Session source </param>
            <param name="affectedOwner">The owner that is affected by this event; can be null if unavailable </param>
            <param name="affectedOwnerId">
            The ID for the owner that is affected by this event; can be null if unavailable
            that is affected by this event; can be null if unavailable
            </param>
        </member>
        <member name="M:NHibernate.Event.AbstractCollectionEvent.GetAffectedOwnerEntityName">
            <summary> Get the entity name for the collection owner entity that is affected by this event. </summary>
            <returns> 
            The entity name; if the owner is not in the PersistenceContext, the
            returned value may be a superclass name, instead of the actual class name
            </returns>
        </member>
        <member name="P:NHibernate.Event.AbstractCollectionEvent.AffectedOwnerOrNull">
            <summary> The collection owner entity that is affected by this event. </summary>
            <value> 
            Returns null if the entity is not in the persistence context
            (e.g., because the collection from a detached entity was moved to a new owner)
            </value>
        </member>
        <member name="P:NHibernate.Event.AbstractCollectionEvent.AffectedOwnerIdOrNull">
            <summary> Get the ID for the collection owner entity that is affected by this event. </summary>
            <value>
            Returns null if the ID cannot be obtained
            from the collection's loaded key (e.g., a property-ref is used for the
            collection and does not include the entity's ID)
            </value>
        </member>
        <member name="T:NHibernate.Event.AbstractPostDatabaseOperationEvent">
            <summary> 
            Represents an operation we performed against the database. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.IPostDatabaseOperationEventArgs">
            <summary> 
            Represents an operation we performed against the database. 
            </summary>
        </member>
        <member name="P:NHibernate.Event.IPostDatabaseOperationEventArgs.Entity">
            <summary> The entity involved in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.IPostDatabaseOperationEventArgs.Id">
            <summary> The id to be used in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.IPostDatabaseOperationEventArgs.Persister">
            <summary> 
            The persister for the <see cref="P:NHibernate.Event.IPostDatabaseOperationEventArgs.Entity"/>. 
            </summary>
        </member>
        <member name="M:NHibernate.Event.AbstractPostDatabaseOperationEvent.#ctor(NHibernate.Event.IEventSource,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary> Constructs an event containing the pertinent information. </summary>
            <param name="source">The session from which the event originated. </param>
            <param name="entity">The entity to be invloved in the database operation. </param>
            <param name="id">The entity id to be invloved in the database operation. </param>
            <param name="persister">The entity's persister. </param>
        </member>
        <member name="P:NHibernate.Event.AbstractPostDatabaseOperationEvent.Entity">
            <summary> The entity involved in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.AbstractPostDatabaseOperationEvent.Id">
            <summary> The id to be used in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.AbstractPostDatabaseOperationEvent.Persister">
            <summary> 
            The persister for the <see cref="P:NHibernate.Event.AbstractPostDatabaseOperationEvent.Entity"/>. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.AbstractPreDatabaseOperationEvent">
            <summary> 
            Represents an operation we are about to perform against the database. 
            </summary>
        </member>
        <member name="P:NHibernate.Event.IPreDatabaseOperationEventArgs.Entity">
            <summary> The entity involved in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.IPreDatabaseOperationEventArgs.Id">
            <summary> The id to be used in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.IPreDatabaseOperationEventArgs.Persister">
            <summary> 
            The persister for the <see cref="P:NHibernate.Event.IPreDatabaseOperationEventArgs.Entity"/>. 
            </summary>
        </member>
        <member name="M:NHibernate.Event.AbstractPreDatabaseOperationEvent.#ctor(NHibernate.Event.IEventSource,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary> Constructs an event containing the pertinent information. </summary>
            <param name="source">The session from which the event originated. </param>
            <param name="entity">The entity to be invloved in the database operation. </param>
            <param name="id">The entity id to be invloved in the database operation. </param>
            <param name="persister">The entity's persister. </param>
        </member>
        <member name="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Entity">
            <summary> The entity involved in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Id">
            <summary> The id to be used in the database operation. </summary>
        </member>
        <member name="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Persister">
            <summary> 
            The persister for the <see cref="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Entity"/>. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.AutoFlushEvent">
            <summary>Defines an event class for the auto-flushing of a session. </summary>
        </member>
        <member name="T:NHibernate.Event.FlushEvent">
            <summary> Defines an event class for the flushing of a session. </summary>
        </member>
        <member name="T:NHibernate.Event.DeleteEvent">
            <summary>Defines an event class for the deletion of an entity. </summary>
        </member>
        <member name="M:NHibernate.Event.DeleteEvent.#ctor(System.Object,NHibernate.Event.IEventSource)">
            <summary> Constructs a new DeleteEvent instance. </summary>
            <param name="entity">The entity to be deleted.</param>
            <param name="source">The session from which the delete event was generated.
            </param>
        </member>
        <member name="P:NHibernate.Event.DeleteEvent.Entity">
            <summary>
            Returns the encapsulated entity to be deleed.
            </summary>
        </member>
        <member name="T:NHibernate.Event.DirtyCheckEvent">
            <summary>Defines an event class for the dirty-checking of a session. </summary>
        </member>
        <member name="T:NHibernate.Event.EventListeners">
            <summary> 
            A convience holder for all defined session event listeners.
            </summary>
        </member>
        <member name="M:NHibernate.Event.EventListeners.InitializeListeners(NHibernate.Cfg.Configuration)">
            <summary> 
            Call <see cref="M:NHibernate.Event.IInitializable.Initialize(NHibernate.Cfg.Configuration)"/> on any listeners that implement 
            <see cref="T:NHibernate.Event.IInitializable"/>.
            </summary>
            <seealso cref="T:NHibernate.Event.IInitializable"/>
        </member>
        <member name="T:NHibernate.Event.EvictEvent">
            <summary>  Defines an event class for the evicting of an entity. </summary>
        </member>
        <member name="T:NHibernate.Event.IDestructible">
            <summary> 
            Contract for listeners which require notification of SessionFactory closing,
            presumably to destroy internal state.
            </summary>
        </member>
        <member name="M:NHibernate.Event.IDestructible.Cleanup">
            <summary>
            Notification of <see cref="T:NHibernate.ISessionFactory"/> shutdown.
            </summary>
        </member>
        <member name="T:NHibernate.ISession">
            <summary>
            The main runtime interface between a .NET application and NHibernate. This is the central
            API class abstracting the notion of a persistence service.
            </summary>
            <remarks>
            <para>
            The lifecycle of a <c>ISession</c> is bounded by the beginning and end of a logical
            transaction. (Long transactions might span several database transactions.)
            </para>
            <para>
            The main function of the <c>ISession</c> is to offer create, find, update, and delete operations
            for instances of mapped entity classes. Instances may exist in one of two states:
            <list type="bullet">
            <item>transient: not associated with any <c>ISession</c></item>
            <item>persistent: associated with a <c>ISession</c></item>
            </list>
            </para>
            <para>
            Transient instances may be made persistent by calling <c>Save()</c>, <c>Insert()</c>,
            or <c>Update()</c>. Persistent instances may be made transient by calling <c>Delete()</c>.
            Any instance returned by a <c>List()</c>, <c>Enumerable()</c>, <c>Load()</c>, or <c>Create()</c>
            method is persistent.
            </para>
            <para>
            <c>Save()</c> results in an SQL <c>INSERT</c>, <c>Delete()</c>
            in an SQL <c>DELETE</c> and <c>Update()</c> in an SQL <c>UPDATE</c>. Changes to
            <em>persistent</em> instances are detected at flush time and also result in an SQL
            <c>UPDATE</c>.
            </para>
            <para>
            It is not intended that implementors be threadsafe. Instead each thread/transaction should obtain
            its own instance from an <c>ISessionFactory</c>.
            </para>
            <para>
            A <c>ISession</c> instance is serializable if its persistent classes are serializable
            </para>
            <para>
            A typical transaction should use the following idiom:
            <code>
            	using (ISession session = factory.OpenSession())
            	using (ITransaction tx = session.BeginTransaction())
            	{
            		try
            		{
            			// do some work
            			...
            			tx.Commit();
            		}
            		catch (Exception e)
            		{
            			if (tx != null) tx.Rollback();
            			throw;
            		}
            	}
            </code>
            </para>
            <para>
            If the <c>ISession</c> throws an exception, the transaction must be rolled back and the session
            discarded. The internal state of the <c>ISession</c> might not be consistent with the database
            after the exception occurs.
            </para>
            <seealso cref="T:NHibernate.ISessionFactory"/>
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Flush">
            <summary>
            Force the <c>ISession</c> to flush.
            </summary>
            <remarks>
            Must be called at the end of a unit of work, before commiting the transaction and closing
            the session (<c>Transaction.Commit()</c> calls this method). <i>Flushing</i> is the process
            of synchronising the underlying persistent store with persistable state held in memory.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Disconnect">
            <summary>
            Disconnect the <c>ISession</c> from the current ADO.NET connection.
            </summary>
            <remarks>
            If the connection was obtained by Hibernate, close it or return it to the connection
            pool. Otherwise return it to the application. This is used by applications which require
            long transactions.
            </remarks>
            <returns>The connection provided by the application or <see langword="null" /></returns>
        </member>
        <member name="M:NHibernate.ISession.Reconnect">
            <summary>
            Obtain a new ADO.NET connection.
            </summary>
            <remarks>
            This is used by applications which require long transactions
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Reconnect(System.Data.IDbConnection)">
            <summary>
            Reconnect to the given ADO.NET connection.
            </summary>
            <remarks>This is used by applications which require long transactions</remarks>
            <param name="connection">An ADO.NET connection</param>
        </member>
        <member name="M:NHibernate.ISession.Close">
            <summary>
            End the <c>ISession</c> by disconnecting from the ADO.NET connection and cleaning up.
            </summary>
            <remarks>
            It is not strictly necessary to <c>Close()</c> the <c>ISession</c> but you must
            at least <c>Disconnect()</c> it.
            </remarks>
            <returns>The connection provided by the application or <see langword="null" /></returns>
        </member>
        <member name="M:NHibernate.ISession.CancelQuery">
            <summary>
            Cancel execution of the current query.
            </summary>
            <remarks>
            May be called from one thread to stop execution of a query in another thread.
            Use with care!
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.IsDirty">
            <summary>
            Does this <c>ISession</c> contain any changes which must be
            synchronized with the database? Would any SQL be executed if
            we flushed this session?
            </summary>
        </member>
        <member name="M:NHibernate.ISession.IsReadOnly(System.Object)">
            <summary>
            Is the specified entity (or proxy) read-only?
            </summary>
            <remarks>
            Facade for <see cref="M:NHibernate.Engine.IPersistenceContext.IsReadOnly(System.Object)"/>.
            </remarks>
            <param name="entityOrProxy">An entity (or <see cref="T:NHibernate.Proxy.INHibernateProxy"/>)</param>
            <returns>
            <c>true</c> if the entity (or proxy) is read-only, otherwise <c>false</c>.
            </returns>
            <seealso cref="P:NHibernate.ISession.DefaultReadOnly"/>
            <seealso cref="M:NHibernate.ISession.SetReadOnly(System.Object,System.Boolean)"/>
        </member>
        <member name="M:NHibernate.ISession.SetReadOnly(System.Object,System.Boolean)">
            <summary>
            Change the read-only status of an entity (or proxy).
            </summary>
            <remarks>
            <para>
            Read-only entities can be modified, but changes are not persisted. They are not dirty-checked 
            and snapshots of persistent state are not maintained. 
            </para>
            <para>
            Immutable entities cannot be made read-only.
            </para>
            <para>
            To set the <em>default</em> read-only setting for entities and proxies that are loaded 
            into the session, see <see cref="P:NHibernate.ISession.DefaultReadOnly"/>.
            </para>
            <para>
            This method a facade for <see cref="M:NHibernate.Engine.IPersistenceContext.SetReadOnly(System.Object,System.Boolean)"/>.
            </para>
            </remarks>
            <param name="entityOrProxy">An entity (or <see cref="T:NHibernate.Proxy.INHibernateProxy"/>).</param>
            <param name="readOnly">If <c>true</c>, the entity or proxy is made read-only; if <c>false</c>, it is made modifiable.</param>
            <seealso cref="P:NHibernate.ISession.DefaultReadOnly"/>
            <seealso cref="M:NHibernate.ISession.IsReadOnly(System.Object)"/>
        </member>
        <member name="M:NHibernate.ISession.GetIdentifier(System.Object)">
            <summary>
            Return the identifier of an entity instance cached by the <c>ISession</c>
            </summary>
            <remarks>
            Throws an exception if the instance is transient or associated with a different
            <c>ISession</c>
            </remarks>
            <param name="obj">a persistent instance</param>
            <returns>the identifier</returns>
        </member>
        <member name="M:NHibernate.ISession.Contains(System.Object)">
            <summary>
            Is this instance associated with this Session?
            </summary>
            <param name="obj">an instance of a persistent class</param>
            <returns>true if the given instance is associated with this Session</returns>
        </member>
        <member name="M:NHibernate.ISession.Evict(System.Object)">
            <summary>
            Remove this instance from the session cache.
            </summary>
            <remarks>
            Changes to the instance will not be synchronized with the database.
            This operation cascades to associated instances if the association is mapped
            with <c>cascade="all"</c> or <c>cascade="all-delete-orphan"</c>.
            </remarks>
            <param name="obj">a persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode.
            </summary>
            <param name="theType">A persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <param name="lockMode">The lock level</param>
            <returns>the persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.Load(System.String,System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode, assuming the instance exists.
            </summary>
            <param name="entityName">The entity-name of a persistent class</param>
            <param name="id">a valid identifier of an existing persistent instance of the class </param>
            <param name="lockMode">the lock level </param>
            <returns> the persistent instance or proxy </returns>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Type,System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            assuming that the instance exists.
            </summary>
            <remarks>
            You should not use this method to determine if an instance exists (use a query or
            <see cref="M:NHibernate.ISession.Get(System.Type,System.Object)"/> instead). Use this only to retrieve an instance
            that you assume exists, where non-existence would be an actual error.
            </remarks>
            <param name="theType">A persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <returns>The persistent instance or proxy</returns>
        </member>
        <member name="M:NHibernate.ISession.Load``1(System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode.
            </summary>
            <typeparam name="T">A persistent class</typeparam>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <param name="lockMode">The lock level</param>
            <returns>the persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.Load``1(System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            assuming that the instance exists.
            </summary>
            <remarks>
            You should not use this method to determine if an instance exists (use a query or
            <see cref="M:NHibernate.ISession.Get``1(System.Object)"/> instead). Use this only to retrieve an instance that you
            assume exists, where non-existence would be an actual error.
            </remarks>
            <typeparam name="T">A persistent class</typeparam>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <returns>The persistent instance or proxy</returns>
        </member>
        <member name="M:NHibernate.ISession.Load(System.String,System.Object)">
            <summary>
            Return the persistent instance of the given <paramref name="entityName"/> with the given identifier,
            assuming that the instance exists.
            </summary>
            <param name="entityName">The entity-name of a persistent class</param>
            <param name="id">a valid identifier of an existing persistent instance of the class </param>
            <returns> The persistent instance or proxy </returns>
            <remarks>
            You should not use this method to determine if an instance exists (use <see cref="M:NHibernate.ISession.Get(System.String,System.Object)"/>
            instead). Use this only to retrieve an instance that you assume exists, where non-existence
            would be an actual error.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Object,System.Object)">
            <summary>
            Read the persistent state associated with the given identifier into the given transient
            instance.
            </summary>
            <param name="obj">An "empty" instance of the persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
        </member>
        <member name="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)">
            <summary>
            Persist all reachable transient objects, reusing the current identifier
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
            <param name="obj">a detached instance of a persistent class</param>
            <param name="replicationMode"></param>
        </member>
        <member name="M:NHibernate.ISession.Replicate(System.String,System.Object,NHibernate.ReplicationMode)">
            <summary>
            Persist the state of the given detached instance, reusing the current
            identifier value.  This operation cascades to associated instances if
            the association is mapped with <tt>cascade="replicate"</tt>.
            </summary>
            <param name="entityName"></param>
            <param name="obj">a detached instance of a persistent class </param>
            <param name="replicationMode"></param>
        </member>
        <member name="M:NHibernate.ISession.Save(System.Object)">
            <summary>
            Persist the given transient instance, first assigning a generated identifier.
            </summary>
            <remarks>
            Save will use the current value of the identifier property if the <c>Assigned</c>
            generator is used.
            </remarks>
            <param name="obj">A transient instance of a persistent class</param>
            <returns>The generated identifier</returns>
        </member>
        <member name="M:NHibernate.ISession.Save(System.Object,System.Object)">
            <summary>
            Persist the given transient instance, using the given identifier.
            </summary>
            <param name="obj">A transient instance of a persistent class</param>
            <param name="id">An unused valid identifier</param>
        </member>
        <member name="M:NHibernate.ISession.Save(System.String,System.Object)">
            <summary>
            Persist the given transient instance, first assigning a generated identifier. (Or
            using the current value of the identifier property if the <tt>assigned</tt>
            generator is used.)
            </summary>
            <param name="entityName">The Entity name.</param>
            <param name="obj">a transient instance of a persistent class </param>
            <returns> the generated identifier </returns>
            <remarks>
            This operation cascades to associated instances if the
            association is mapped with <tt>cascade="save-update"</tt>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Save(System.String,System.Object,System.Object)">
            <summary>
            Persist the given transient instance, using the given identifier.
            </summary>
            <param name="entityName">The Entity name.</param>
            <param name="obj">a transient instance of a persistent class </param>
            <param name="id">An unused valid identifier</param>
            <remarks>
            This operation cascades to associated instances if the
            association is mapped with <tt>cascade="save-update"</tt>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdate(System.Object)">
            <summary>
            Either <c>Save()</c> or <c>Update()</c> the given instance, depending upon the value of
            its identifier property.
            </summary>
            <remarks>
            By default the instance is always saved. This behaviour may be adjusted by specifying
            an <c>unsaved-value</c> attribute of the identifier property mapping
            </remarks>
            <param name="obj">A transient instance containing new or updated state</param>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdate(System.String,System.Object)">
            <summary>
            Either <see cref="M:NHibernate.ISession.Save(System.String,System.Object)"/> or <see cref="M:NHibernate.ISession.Update(System.String,System.Object)"/>
            the given instance, depending upon resolution of the unsaved-value checks
            (see the manual for discussion of unsaved-value checking).
            </summary>
            <param name="entityName">The name of the entity </param>
            <param name="obj">a transient or detached instance containing new or updated state </param>
            <seealso cref="M:NHibernate.ISession.Save(System.String,System.Object)"/>
            <seealso cref="M:NHibernate.ISession.Update(System.String,System.Object)"/>
            <remarks>
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="save-update"</tt>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdate(System.String,System.Object,System.Object)">
            <summary>
            Either <c>Save()</c> or <c>Update()</c> the given instance, depending upon the value of
            its identifier property.
            </summary>
            <remarks>
            By default the instance is always saved. This behaviour may be adjusted by specifying
            an <c>unsaved-value</c> attribute of the identifier property mapping
            </remarks>
            <param name="entityName">The name of the entity</param>      
            <param name="obj">A transient instance containing new or updated state</param>
            <param name="id">Identifier of persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Update(System.Object)">
            <summary>
            Update the persistent instance with the identifier of the given transient instance.
            </summary>
            <remarks>
            If there is a persistent instance with the same identifier, an exception is thrown. If
            the given transient instance has a <see langword="null" /> identifier, an exception will be thrown.
            </remarks>
            <param name="obj">A transient instance containing updated state</param>
        </member>
        <member name="M:NHibernate.ISession.Update(System.Object,System.Object)">
            <summary>
            Update the persistent state associated with the given identifier.
            </summary>
            <remarks>
            An exception is thrown if there is a persistent instance with the same identifier
            in the current session.
            </remarks>
            <param name="obj">A transient instance containing updated state</param>
            <param name="id">Identifier of persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Update(System.String,System.Object)">
            <summary>
            Update the persistent instance with the identifier of the given detached
            instance.
            </summary>
            <param name="entityName">The Entity name.</param>
            <param name="obj">a detached instance containing updated state </param>
            <remarks>
            If there is a persistent instance with the same identifier,
            an exception is thrown. This operation cascades to associated instances
            if the association is mapped with <tt>cascade="save-update"</tt>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Update(System.String,System.Object,System.Object)">
            <summary>
            Update the persistent instance associated with the given identifier.
            </summary>
            <param name="entityName">The Entity name.</param>
            <param name="obj">a detached instance containing updated state </param>
            <param name="id">Identifier of persistent instance</param>
            <remarks>
            If there is a persistent instance with the same identifier,
            an exception is thrown. This operation cascades to associated instances
            if the association is mapped with <tt>cascade="save-update"</tt>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Merge(System.Object)">
            <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with
            the session, it will be loaded. Return the persistent instance. If the
            given instance is unsaved, save a copy of and return it as a newly persistent
            instance. The given instance does not become associated with the session.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="merge"</tt>.<br/>
            The semantics of this method are defined by JSR-220.
            </summary>
            <param name="obj">a detached instance with state to be copied </param>
            <returns> an updated persistent instance </returns>
        </member>
        <member name="M:NHibernate.ISession.Merge(System.String,System.Object)">
            <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with
            the session, it will be loaded. Return the persistent instance. If the
            given instance is unsaved, save a copy of and return it as a newly persistent
            instance. The given instance does not become associated with the session.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="merge"</tt>.<br/>
            The semantics of this method are defined by JSR-220.
            <param name="entityName">Name of the entity.</param>
            <param name="obj">a detached instance with state to be copied </param>
            <returns> an updated persistent instance </returns>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISession.Merge``1(``0)">
            <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with
            the session, it will be loaded. Return the persistent instance. If the
            given instance is unsaved, save a copy of and return it as a newly persistent
            instance. The given instance does not become associated with the session.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="merge"</tt>.<br/>
            The semantics of this method are defined by JSR-220.
            </summary>
            <param name="entity">a detached instance with state to be copied </param>
            <returns> an updated persistent instance </returns>
        </member>
        <member name="M:NHibernate.ISession.Merge``1(System.String,``0)">
            <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with
            the session, it will be loaded. Return the persistent instance. If the
            given instance is unsaved, save a copy of and return it as a newly persistent
            instance. The given instance does not become associated with the session.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="merge"</tt>.<br/>
            The semantics of this method are defined by JSR-220.
            <param name="entityName">Name of the entity.</param>
            <param name="entity">a detached instance with state to be copied </param>
            <returns> an updated persistent instance </returns>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISession.Persist(System.Object)">
            <summary>
            Make a transient instance persistent. This operation cascades to associated
            instances if the association is mapped with <tt>cascade="persist"</tt>.<br/>
            The semantics of this method are defined by JSR-220.
            </summary>
            <param name="obj">a transient instance to be made persistent </param>
        </member>
        <member name="M:NHibernate.ISession.Persist(System.String,System.Object)">
            <summary>
            Make a transient instance persistent. This operation cascades to associated
            instances if the association is mapped with <tt>cascade="persist"</tt>.<br/>
            The semantics of this method are defined by JSR-220.
            </summary>
            <param name="entityName">Name of the entity.</param>
            <param name="obj">a transient instance to be made persistent</param>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.Object)">
            <summary>
            Remove a persistent instance from the datastore.
            </summary>
            <remarks>
            The argument may be an instance associated with the receiving <c>ISession</c> or a
            transient instance with an identifier associated with existing persistent state.
            </remarks>
            <param name="obj">The instance to be removed</param>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String,System.Object)">
            <summary>
            Remove a persistent instance from the datastore. The <b>object</b> argument may be
            an instance associated with the receiving <see cref="T:NHibernate.ISession"/> or a transient
            instance with an identifier associated with existing persistent state.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="delete"</tt>.
            </summary>
            <param name="entityName">The entity name for the instance to be removed. </param>
            <param name="obj">the instance to be removed </param>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String)">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <returns>Returns the number of objects deleted.</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <param name="value">A value to be written to a "?" placeholer in the query</param>
            <param name="type">The hibernate type of value.</param>
            <returns>The number of instances deleted</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <param name="values">A list of values to be written to "?" placeholders in the query</param>
            <param name="types">A list of Hibernate types of the values</param>
            <returns>The number of instances deleted</returns>
        </member>
        <member name="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)">
            <summary>
            Obtain the specified lock level upon the given object.
            </summary>
            <param name="obj">A persistent instance</param>
            <param name="lockMode">The lock level</param>
        </member>
        <member name="M:NHibernate.ISession.Lock(System.String,System.Object,NHibernate.LockMode)">
            <summary>
            Obtain the specified lock level upon the given object.
            </summary>
            <param name="entityName">The Entity name.</param>
            <param name="obj">a persistent or transient instance </param>
            <param name="lockMode">the lock level </param>
            <remarks>
            This may be used to perform a version check (<see cref="F:NHibernate.LockMode.Read"/>), to upgrade to a pessimistic
            lock (<see cref="F:NHibernate.LockMode.Upgrade"/>), or to simply reassociate a transient instance
            with a session (<see cref="F:NHibernate.LockMode.None"/>). This operation cascades to associated
            instances if the association is mapped with <tt>cascade="lock"</tt>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Refresh(System.Object)">
            <summary>
            Re-read the state of the given instance from the underlying database.
            </summary>
            <remarks>
            <para>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </para>
            <para>
            For example,
            <list>
            	<item>Where a database trigger alters the object state upon insert or update</item>
            	<item>After executing direct SQL (eg. a mass update) in the same session</item>
            	<item>After inserting a <c>Blob</c> or <c>Clob</c></item>
            </list>
            </para>
            </remarks>
            <param name="obj">A persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Refresh(System.Object,NHibernate.LockMode)">
            <summary>
            Re-read the state of the given instance from the underlying database, with
            the given <c>LockMode</c>.
            </summary>
            <remarks>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </remarks>
            <param name="obj">a persistent or transient instance</param>
            <param name="lockMode">the lock mode to use</param>
        </member>
        <member name="M:NHibernate.ISession.GetCurrentLockMode(System.Object)">
            <summary>
            Determine the current lock mode of the given object
            </summary>
            <param name="obj">A persistent instance</param>
            <returns>The current lock mode</returns>
        </member>
        <member name="M:NHibernate.ISession.BeginTransaction">
            <summary>
            Begin a unit of work and return the associated <c>ITransaction</c> object.
            </summary>
            <remarks>
            If a new underlying transaction is required, begin the transaction. Otherwise
            continue the new work in the context of the existing underlying transaction.
            The class of the returned <see cref="T:NHibernate.ITransaction"/> object is determined by
            the property <c>transaction_factory</c>
            </remarks>
            <returns>A transaction instance</returns>
        </member>
        <member name="M:NHibernate.ISession.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Begin a transaction with the specified <c>isolationLevel</c>
            </summary>
            <param name="isolationLevel">Isolation level for the new transaction</param>
            <returns>A transaction instance having the specified isolation level</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria``1">
            <summary>
            Creates a new <c>Criteria</c> for the entity class.
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria``1(System.String)">
            <summary>
            Creates a new <c>Criteria</c> for the entity class with a specific alias
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <param name="alias">The alias of the entity</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria(System.Type)">
            <summary>
            Creates a new <c>Criteria</c> for the entity class.
            </summary>
            <param name="persistentClass">The class to Query</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria(System.Type,System.String)">
            <summary>
            Creates a new <c>Criteria</c> for the entity class with a specific alias
            </summary>
            <param name="persistentClass">The class to Query</param>
            <param name="alias">The alias of the entity</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria(System.String)">
            <summary>
            Create a new <c>Criteria</c> instance, for the given entity name.
            </summary>
            <param name="entityName">The name of the entity to Query</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria(System.String,System.String)">
            <summary>
            Create a new <c>Criteria</c> instance, for the given entity name,
            with the given alias.
            </summary>
            <param name="entityName">The name of the entity to Query</param>
            <param name="alias">The alias of the entity</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.QueryOver``1">
            <summary>
            Creates a new <c>IQueryOver&lt;T&gt;</c> for the entity class.
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <returns>An IQueryOver&lt;T&gt; object</returns>
        </member>
        <member name="M:NHibernate.ISession.QueryOver``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new <c>IQueryOver&lt;T&gt;</c> for the entity class.
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <param name="alias">The alias of the entity</param>
            <returns>An IQueryOver&lt;T&gt; object</returns>
        </member>
        <member name="M:NHibernate.ISession.QueryOver``1(System.String)">
            <summary>
            Creates a new <c>IQueryOver{T};</c> for the entity class.
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <param name="entityName">The name of the entity to Query</param>
            <returns>An IQueryOver{T} object</returns>
        </member>
        <member name="M:NHibernate.ISession.QueryOver``1(System.String,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new <c>IQueryOver{T}</c> for the entity class.
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <param name="entityName">The name of the entity to Query</param>
            <param name="alias">The alias of the entity</param>
            <returns>An IQueryOver{T} object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateQuery(System.String)">
            <summary>
            Create a new instance of <c>Query</c> for the given query string
            </summary>
            <param name="queryString">A hibernate query string</param>
            <returns>The query</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateFilter(System.Object,System.String)">
            <summary>
            Create a new instance of <c>Query</c> for the given collection and filter string
            </summary>
            <param name="collection">A persistent collection</param>
            <param name="queryString">A hibernate query</param>
            <returns>A query</returns>
        </member>
        <member name="M:NHibernate.ISession.GetNamedQuery(System.String)">
            <summary>
            Obtain an instance of <see cref="T:NHibernate.IQuery"/> for a named query string defined in the
            mapping file.
            </summary>
            <param name="queryName">The name of a query defined externally.</param>
            <returns>An <see cref="T:NHibernate.IQuery"/> from a named query string.</returns>
            <remarks>
            The query can be either in <c>HQL</c> or <c>SQL</c> format.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.CreateSQLQuery(System.String)">
            <summary>
            Create a new instance of <see cref="T:NHibernate.ISQLQuery"/> for the given SQL query string.
            </summary>
            <param name="queryString">a query expressed in SQL</param>
            <returns>An <see cref="T:NHibernate.ISQLQuery"/> from the SQL string</returns>
        </member>
        <member name="M:NHibernate.ISession.Clear">
            <summary>
            Completely clear the session. Evict all loaded instances and cancel all pending
            saves, updates and deletions. Do not close open enumerables or instances of
            <c>ScrollableResults</c>.
            </summary>
        </member>
        <member name="M:NHibernate.ISession.Get(System.Type,System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. (If the instance, or a proxy for the instance, is
            already associated with the session, return that instance or proxy.)
            </summary>
            <param name="clazz">a persistent class</param>
            <param name="id">an identifier</param>
            <returns>a persistent instance or null</returns>
        </member>
        <member name="M:NHibernate.ISession.Get(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. Obtain the specified lock mode if the instance
            exists.
            </summary>
            <param name="clazz">a persistent class</param>
            <param name="id">an identifier</param>
            <param name="lockMode">the lock mode</param>
            <returns>a persistent instance or null</returns>
        </member>
        <member name="M:NHibernate.ISession.Get(System.String,System.Object)">
            <summary>
            Return the persistent instance of the given named entity with the given identifier,
            or null if there is no such persistent instance. (If the instance, or a proxy for the
            instance, is already associated with the session, return that instance or proxy.)
            </summary>
            <param name="entityName">the entity name </param>
            <param name="id">an identifier </param>
            <returns> a persistent instance or null </returns>
        </member>
        <member name="M:NHibernate.ISession.Get``1(System.Object)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ISession.Get(System.Type,System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.ISession.Get``1(System.Object,NHibernate.LockMode)">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ISession.Get(System.Type,System.Object,NHibernate.LockMode)"/>
            </summary>
        </member>
        <member name="M:NHibernate.ISession.GetEntityName(System.Object)">
            <summary>
            Return the entity name for a persistent entity
            </summary>
            <param name="obj">a persistent entity</param>
            <returns> the entity name </returns>
        </member>
        <member name="M:NHibernate.ISession.EnableFilter(System.String)">
            <summary>
            Enable the named filter for this current session.
            </summary>
            <param name="filterName">The name of the filter to be enabled.</param>
            <returns>The Filter instance representing the enabled filter.</returns>
        </member>
        <member name="M:NHibernate.ISession.GetEnabledFilter(System.String)">
            <summary>
            Retrieve a currently enabled filter by name.
            </summary>
            <param name="filterName">The name of the filter to be retrieved.</param>
            <returns>The Filter instance representing the enabled filter.</returns>
        </member>
        <member name="M:NHibernate.ISession.DisableFilter(System.String)">
            <summary>
            Disable the named filter for the current session.
            </summary>
            <param name="filterName">The name of the filter to be disabled.</param>
        </member>
        <member name="M:NHibernate.ISession.CreateMultiQuery">
            <summary>
            Create a multi query, a query that can send several
            queries to the server, and return all their results in a single
            call.
            </summary>
            <returns>
            An <see cref="T:NHibernate.IMultiQuery"/> that can return
            a list of all the results of all the queries.
            Note that each query result is itself usually a list.
            </returns>
        </member>
        <member name="M:NHibernate.ISession.SetBatchSize(System.Int32)">
            <summary>
            Sets the batch size of the session
            </summary>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISession.GetSessionImplementation">
            <summary>
            Gets the session implementation.
            </summary>
            <remarks>
            This method is provided in order to get the <b>NHibernate</b> implementation of the session from wrapper implementions.
            Implementors of the <seealso cref="T:NHibernate.ISession"/> interface should return the NHibernate implementation of this method.
            </remarks>
            <returns>
            An NHibernate implementation of the <seealso cref="T:NHibernate.Engine.ISessionImplementor"/> interface
            </returns>
        </member>
        <member name="M:NHibernate.ISession.CreateMultiCriteria">
            <summary>
            An <see cref="T:NHibernate.IMultiCriteria"/> that can return a list of all the results
            of all the criterias.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISession.GetSession(NHibernate.EntityMode)">
            <summary>
            Starts a new Session with the given entity mode in effect. This secondary
            Session inherits the connection, transaction, and other context
            information from the primary Session. It doesn't need to be flushed
            or closed by the developer.
            </summary>
            <param name="entityMode">The entity mode to use for the new session.</param>
            <returns>The new session</returns>
        </member>
        <member name="P:NHibernate.ISession.ActiveEntityMode">
            <summary> The entity mode in effect for this session.</summary>
        </member>
        <member name="P:NHibernate.ISession.FlushMode">
            <summary>
            Determines at which points Hibernate automatically flushes the session.
            </summary>
            <remarks>
            For a readonly session, it is reasonable to set the flush mode to <c>FlushMode.Never</c>
            at the start of the session (in order to achieve some extra performance).
            </remarks>
        </member>
        <member name="P:NHibernate.ISession.CacheMode">
            <summary> The current cache mode. </summary>
            <remarks>
            Cache mode determines the manner in which this session can interact with
            the second level cache.
            </remarks>
        </member>
        <member name="P:NHibernate.ISession.SessionFactory">
            <summary>
            Get the <see cref="T:NHibernate.ISessionFactory"/> that created this instance.
            </summary>
        </member>
        <member name="P:NHibernate.ISession.Connection">
            <summary>
            Gets the ADO.NET connection.
            </summary>
            <remarks>
            Applications are responsible for calling commit/rollback upon the connection before
            closing the <c>ISession</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.ISession.IsOpen">
            <summary>
            Is the <c>ISession</c> still open?
            </summary>
        </member>
        <member name="P:NHibernate.ISession.IsConnected">
            <summary>
            Is the <c>ISession</c> currently connected?
            </summary>
        </member>
        <member name="P:NHibernate.ISession.DefaultReadOnly">
            <summary>
            The read-only status for entities (and proxies) loaded into this Session.
            </summary>
            <remarks>
            <para>
            When a proxy is initialized, the loaded entity will have the same read-only setting
            as the uninitialized proxy, regardless of the session's current setting.
            </para>
            <para>
            To change the read-only setting for a particular entity or proxy that is already in 
            this session, see <see cref="M:NHibernate.ISession.SetReadOnly(System.Object,System.Boolean)"/>.
            </para>
            <para>
            To override this session's read-only setting for entities and proxies loaded by a query,
            see <see cref="M:NHibernate.IQuery.SetReadOnly(System.Boolean)"/>.
            </para>
            <para>
            This method is a facade for <see cref="P:NHibernate.Engine.IPersistenceContext.DefaultReadOnly"/>.
            </para>
            </remarks>
            <seealso cref="M:NHibernate.ISession.IsReadOnly(System.Object)"/>
            <seealso cref="M:NHibernate.ISession.SetReadOnly(System.Object,System.Boolean)"/>
        </member>
        <member name="P:NHibernate.ISession.Transaction">
            <summary>
            Get the current Unit of Work and return the associated <c>ITransaction</c> object.
            </summary>
        </member>
        <member name="P:NHibernate.ISession.Statistics">
            <summary> Get the statistics for this session.</summary>
        </member>
        <member name="M:NHibernate.Event.IEventSource.Instantiate(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary> 
            Instantiate an entity instance, using either an interceptor,
            or the given persister
            </summary>
        </member>
        <member name="M:NHibernate.Event.IEventSource.ForceFlush(NHibernate.Engine.EntityEntry)">
            <summary> Force an immediate flush</summary>
        </member>
        <member name="M:NHibernate.Event.IEventSource.Merge(System.String,System.Object,System.Collections.IDictionary)">
            <summary> Cascade merge an entity instance</summary>
        </member>
        <member name="M:NHibernate.Event.IEventSource.Persist(System.String,System.Object,System.Collections.IDictionary)">
            <summary> Cascade persist an entity instance</summary>
        </member>
        <member name="M:NHibernate.Event.IEventSource.PersistOnFlush(System.String,System.Object,System.Collections.IDictionary)">
            <summary> Cascade persist an entity instance during the flush process</summary>
        </member>
        <member name="M:NHibernate.Event.IEventSource.Refresh(System.Object,System.Collections.IDictionary)">
            <summary> Cascade refresh an entity instance</summary>
        </member>
        <member name="M:NHibernate.Event.IEventSource.Delete(System.String,System.Object,System.Boolean,System.Collections.Generic.ISet{System.Object})">
            <summary> Cascade delete an entity instance</summary>
        </member>
        <member name="P:NHibernate.Event.IEventSource.ActionQueue">
            <summary> Get the ActionQueue for this session</summary>
        </member>
        <member name="T:NHibernate.Event.IInitializable">
            <summary> 
            An event listener that requires access to mappings to
            initialize state at initialization time.
            </summary>
        </member>
        <member name="T:NHibernate.Event.InitializeCollectionEvent">
            <summary> 
            An event that occurs when a collection wants to be initialized
            </summary>
        </member>
        <member name="T:NHibernate.Event.IPostCollectionRecreateEventListener">
            <summary> Called after recreating a collection </summary>
        </member>
        <member name="T:NHibernate.Event.IPostCollectionRemoveEventListener">
            <summary> Called after removing a collection </summary>
        </member>
        <member name="T:NHibernate.Event.IPostCollectionUpdateEventListener">
            <summary> Called after updating a collection </summary>
        </member>
        <member name="T:NHibernate.Event.IPostDeleteEventListener">
            <summary> Called after deleting an item from the datastore </summary>
        </member>
        <member name="M:NHibernate.Event.IPostDeleteEventListener.OnPostDelete(NHibernate.Event.PostDeleteEvent)">
            <summary>
            
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.IPostInsertEventListener">
            <summary> Called after inserting an item in the datastore </summary>
        </member>
        <member name="M:NHibernate.Event.IPostInsertEventListener.OnPostInsert(NHibernate.Event.PostInsertEvent)">
            <summary>
            
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.IPostUpdateEventListener">
            <summary>
            Called after updating the datastore
            </summary>
        </member>
        <member name="M:NHibernate.Event.IPostUpdateEventListener.OnPostUpdate(NHibernate.Event.PostUpdateEvent)">
            <summary>
            
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.IPreCollectionRecreateEventListener">
            <summary> Called before recreating a collection </summary>
        </member>
        <member name="T:NHibernate.Event.IPreCollectionRemoveEventListener">
            <summary> Called before removing a collection </summary>
        </member>
        <member name="T:NHibernate.Event.IPreCollectionUpdateEventListener">
            <summary> Called before updating a collection </summary>
        </member>
        <member name="T:NHibernate.Event.IPreDeleteEventListener">
            <summary>
            Called before deleting an item from the datastore
            </summary>
        </member>
        <member name="M:NHibernate.Event.IPreDeleteEventListener.OnPreDelete(NHibernate.Event.PreDeleteEvent)">
            <summary> Return true if the operation should be vetoed</summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.IPreInsertEventListener">
            <summary>
            Called before inserting an item in the datastore
            </summary>
        </member>
        <member name="M:NHibernate.Event.IPreInsertEventListener.OnPreInsert(NHibernate.Event.PreInsertEvent)">
            <summary> Return true if the operation should be vetoed</summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.IPreUpdateEventListener">
            <summary>
            Called before updating the datastore
            </summary>
        </member>
        <member name="M:NHibernate.Event.IPreUpdateEventListener.OnPreUpdate(NHibernate.Event.PreUpdateEvent)">
            <summary> Return true if the operation should be vetoed</summary>
            <param name="event"></param>
        </member>
        <member name="T:NHibernate.Event.ListenerType">
            <summary>
            Values for listener type property.
            </summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.NotValidType">
            <summary>Not allowed in Xml. It represents the default value when an explicit type is assigned.</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Autoflush">
            <summary>Xml value: auto-flush</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Merge">
            <summary>Xml value: merge</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Create">
            <summary>Xml value: create</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.CreateOnFlush">
            <summary>Xml value: create-onflush</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Delete">
            <summary>Xml value: delete</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.DirtyCheck">
            <summary>Xml value: dirty-check</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Evict">
            <summary>Xml value: evict</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Flush">
            <summary>Xml value: flush</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.FlushEntity">
            <summary>Xml value: flush-entity</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Load">
            <summary>Xml value: load</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.LoadCollection">
            <summary>Xml value: load-collection</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Lock">
            <summary>Xml value: lock</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Refresh">
            <summary>Xml value: refresh</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Replicate">
            <summary>Xml value: replicate</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.SaveUpdate">
            <summary>Xml value: save-update</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Save">
            <summary>Xml value: save</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PreUpdate">
            <summary>Xml value: pre-update</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.Update">
            <summary>Xml value: update</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PreLoad">
            <summary>Xml value: pre-load</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PreDelete">
            <summary>Xml value: pre-delete</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PreInsert">
            <summary>Xml value: pre-insert</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PreCollectionRecreate">
            <summary>Xml value: pre-collection-recreate </summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PreCollectionRemove">
            <summary>Xml value: pre-collection-remove </summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PreCollectionUpdate">
            <summary>Xml value: pre-collection-update </summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostLoad">
            <summary>Xml value: post-load</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostInsert">
            <summary>Xml value: post-insert</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostUpdate">
            <summary>Xml value: post-update</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostDelete">
            <summary>Xml value: post-delete</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostCommitUpdate">
            <summary>Xml value: post-commit-update</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostCommitInsert">
            <summary>Xml value: post-commit-insert</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostCommitDelete">
            <summary>Xml value: post-commit-delete</summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostCollectionRecreate">
            <summary>Xml value: post-collection-recreate </summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostCollectionRemove">
            <summary>Xml value: post-collection-remove </summary>
        </member>
        <member name="F:NHibernate.Event.ListenerType.PostCollectionUpdate">
            <summary>Xml value: post-collection-update </summary>
        </member>
        <member name="T:NHibernate.Event.LoadEvent">
            <summary>Defines an event class for the loading of an entity. </summary>
        </member>
        <member name="T:NHibernate.Event.LockEvent">
            <summary>
            Defines an event class for the locking of an entity.
            </summary>
        </member>
        <member name="T:NHibernate.Event.MergeEvent">
            <summary> 
            An event class for merge() and saveOrUpdateCopy()
            </summary>
        </member>
        <member name="T:NHibernate.Event.PersistEvent">
            <summary> An event class for persist() </summary>
        </member>
        <member name="T:NHibernate.Event.PostCollectionRecreateEvent">
            <summary> An event that occurs after a collection is recreated </summary>
        </member>
        <member name="T:NHibernate.Event.PostCollectionRemoveEvent">
            <summary> An event that occurs after a collection is removed </summary>
        </member>
        <member name="T:NHibernate.Event.PostCollectionUpdateEvent">
            <summary> An event that occurs after a collection is updated </summary>
        </member>
        <member name="T:NHibernate.Event.PostDeleteEvent">
            <summary> 
            Occurs after deleting an item from the datastore 
            </summary>
        </member>
        <member name="T:NHibernate.Event.PostInsertEvent">
            <summary> 
            Occurs after inserting an item in the datastore 
            </summary>
        </member>
        <member name="T:NHibernate.Event.PostLoadEvent">
            <summary> 
            Occurs after an an entity instance is fully loaded.
            </summary>
        </member>
        <member name="T:NHibernate.Event.PostUpdateEvent">
            <summary> 
            Occurs after the datastore is updated
            </summary>
        </member>
        <member name="T:NHibernate.Event.PreCollectionRecreateEvent">
            <summary> An event that occurs before a collection is recreated </summary>
        </member>
        <member name="T:NHibernate.Event.PreCollectionRemoveEvent">
            <summary> An event that occurs before a collection is removed </summary>
        </member>
        <member name="T:NHibernate.Event.PreCollectionUpdateEvent">
            <summary> An event that occurs before a collection is updated </summary>
        </member>
        <member name="T:NHibernate.Event.PreDeleteEvent">
            <summary>
            Represents a <tt>pre-delete</tt> event, which occurs just prior to
            performing the deletion of an entity from the database.
            </summary>
        </member>
        <member name="M:NHibernate.Event.PreDeleteEvent.#ctor(System.Object,System.Object,System.Object[],NHibernate.Persister.Entity.IEntityPersister,NHibernate.Event.IEventSource)">
            <summary> 
            Constructs an event containing the pertinent information. 
            </summary>
            <param name="entity">The entity to be deleted. </param>
            <param name="id">The id to use in the deletion. </param>
            <param name="deletedState">The entity's state at deletion time. </param>
            <param name="persister">The entity's persister. </param>
            <param name="source">The session from which the event originated. </param>
        </member>
        <member name="P:NHibernate.Event.PreDeleteEvent.DeletedState">
            <summary> 
            This is the entity state at the
            time of deletion (useful for optomistic locking and such). 
            </summary>
        </member>
        <member name="T:NHibernate.Event.PreInsertEvent">
            <summary> 
            Represents a <tt>pre-insert</tt> event, which occurs just prior to
            performing the insert of an entity into the database.
            </summary>
        </member>
        <member name="P:NHibernate.Event.PreInsertEvent.State">
            <summary> 
            These are the values to be inserted. 
            </summary>
        </member>
        <member name="T:NHibernate.Event.PreLoadEvent">
            <summary> 
            Called before injecting property values into a newly loaded entity instance.
            </summary>
        </member>
        <member name="T:NHibernate.Event.PreUpdateEvent">
            <summary> 
            Represents a <tt>pre-update</tt> event, which occurs just prior to
            performing the update of an entity in the database.
            </summary>
        </member>
        <member name="P:NHibernate.Event.PreUpdateEvent.State">
            <summary>
            Retrieves the state to be used in the update.
            </summary>
        </member>
        <member name="P:NHibernate.Event.PreUpdateEvent.OldState">
            <summary>
            The old state of the entity at the time it was last loaded from the
            database; can be null in the case of detached entities.
            </summary>
        </member>
        <member name="T:NHibernate.Event.RefreshEvent">
            <summary>  
            Defines an event class for the refreshing of an object.
            </summary>
        </member>
        <member name="T:NHibernate.Event.ReplicateEvent">
            <summary>  
            Defines an event class for the replication of an entity.
            </summary>
        </member>
        <member name="T:NHibernate.Event.SaveOrUpdateEvent">
            <summary> 
            An event class for saveOrUpdate()
            </summary>
        </member>
        <member name="T:NHibernate.Exceptions.ADOConnectionException">
            <summary> 
            Implementation of ADOException indicating problems with communicating with the
            database (can also include incorrect ADO setup). 
            </summary>
        </member>
        <member name="T:NHibernate.ADOException">
            <summary>
            Wraps exceptions that occur during ADO.NET calls.
            </summary>
            <remarks>
            Exceptions thrown by various ADO.NET providers are not derived from
            a common base class (<c>SQLException</c> in Java), so <see cref="T:System.Exception"/>
            is used instead in NHibernate.
            </remarks>
        </member>
        <member name="M:NHibernate.ADOException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.ADOException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Exceptions.AdoExceptionContextInfo">
            <summary>
            Collect data of an <see cref="T:NHibernate.ADOException"/> to be converted.
            </summary>
        </member>
        <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.SqlException">
            <summary>
            The <see cref="T:System.Data.Common.DbException"/> to be converted.
            </summary>
        </member>
        <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.Message">
            <summary>
            An optional error message.
            </summary>
        </member>
        <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.Sql">
            <summary>
            The SQL that generate the exception
            </summary>
        </member>
        <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.EntityName">
            <summary>
            Optional EntityName where available in the original exception context.
            </summary>
        </member>
        <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.EntityId">
            <summary>
            Optional EntityId where available in the original exception context.
            </summary>
        </member>
        <member name="M:NHibernate.Exceptions.ADOExceptionHelper.Convert(NHibernate.Exceptions.ISQLExceptionConverter,System.Exception,System.String,NHibernate.SqlCommand.SqlString)">
            <summary> 
            Converts the given SQLException into Exception hierarchy, as well as performing
            appropriate logging. 
            </summary>
            <param name="converter">The converter to use.</param>
            <param name="sqlException">The exception to convert.</param>
            <param name="message">An optional error message.</param>
            <param name="sql">The SQL executed.</param>
            <returns> The converted <see cref="T:NHibernate.ADOException"/>.</returns>
        </member>
        <member name="M:NHibernate.Exceptions.ADOExceptionHelper.Convert(NHibernate.Exceptions.ISQLExceptionConverter,System.Exception,System.String)">
            <summary> 
            Converts the given SQLException into Exception hierarchy, as well as performing
            appropriate logging. 
            </summary>
            <param name="converter">The converter to use.</param>
            <param name="sqlException">The exception to convert.</param>
            <param name="message">An optional error message.</param>
            <returns> The converted <see cref="T:NHibernate.ADOException"/>.</returns>
        </member>
        <member name="M:NHibernate.Exceptions.ADOExceptionHelper.ExtractDbException(System.Exception)">
            <summary> For the given <see cref="T:System.Exception"/>, locates the <see cref="T:System.Data.Common.DbException"/>. </summary>
            <param name="sqlException">The exception from which to extract the <see cref="T:System.Data.Common.DbException"/> </param>
            <returns> The <see cref="T:System.Data.Common.DbException"/>, or null. </returns>
        </member>
        <member name="T:NHibernate.Exceptions.ConstraintViolationException">
            <summary> 
            Implementation of ADOException indicating that the requested DML operation
            resulted in a violation of a defined integrity constraint. 
            </summary>
        </member>
        <member name="P:NHibernate.Exceptions.ConstraintViolationException.ConstraintName">
            <summary> 
            Returns the name of the violated constraint, if known. 
            </summary>
            <returns> The name of the violated constraint, or null if not known. </returns>
        </member>
        <member name="T:NHibernate.Exceptions.DataException">
            <summary> 
            Implementation of ADOException indicating that evaluation of the
            valid SQL statement against the given data resulted in some
            illegal operation, mismatched types or incorrect cardinality. 
            </summary>
        </member>
        <member name="T:NHibernate.Exceptions.IConfigurable">
            <summary> 
            The Configurable interface defines the contract for <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter"/> impls that
            want to be configured prior to usage given the currently defined Hibernate properties. 
            </summary>
        </member>
        <member name="M:NHibernate.Exceptions.IConfigurable.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary> Configure the component, using the given settings and properties. </summary>
            <param name="properties">All defined startup properties. </param>
        </member>
        <member name="T:NHibernate.Exceptions.ISQLExceptionConverter">
            <summary> 
            Defines a contract for implementations that know how to convert a <see cref="T:System.Data.Common.DbException"/>
            into NHibernate's <see cref="T:NHibernate.ADOException"/> hierarchy. 
            </summary>
            <remarks>
            Inspired by Spring's SQLExceptionTranslator.
            
            Implementations <b>must</b> have a constructor which takes a
            <see cref="T:NHibernate.Exceptions.IViolatedConstraintNameExtracter"/> parameter.
            <para/>
            Implementations may implement <see cref="T:NHibernate.Exceptions.IConfigurable"/> if they need to perform
            configuration steps prior to first use.
            </remarks>
            <seealso cref="T:NHibernate.Exceptions.SQLExceptionConverterFactory"/>
        </member>
        <member name="M:NHibernate.Exceptions.ISQLExceptionConverter.Convert(NHibernate.Exceptions.AdoExceptionContextInfo)">
            <summary> 
            Convert the given <see cref="T:System.Data.Common.DbException"/> into custom Exception. 
            </summary>
            <param name="adoExceptionContextInfo">Available information during exception throw.</param>
            <returns> The resulting Exception to throw. </returns>
        </member>
        <member name="T:NHibernate.Exceptions.LockAcquisitionException">
            <summary> 
            Implementation of ADOException indicating a problem acquiring lock
            on the database. 
            </summary>
        </member>
        <member name="T:NHibernate.Exceptions.SQLExceptionConverterFactory">
            <summary> A factory for building SQLExceptionConverter instances. </summary>
        </member>
        <member name="M:NHibernate.Exceptions.SQLExceptionConverterFactory.BuildSQLExceptionConverter(NHibernate.Dialect.Dialect,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary> Build a SQLExceptionConverter instance. </summary>
            <param name="dialect">The defined dialect. </param>
            <param name="properties">The configuration properties. </param>
            <returns> An appropriate <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter"/> instance. </returns>
            <remarks>
            First, looks for a <see cref="F:NHibernate.Cfg.Environment.SqlExceptionConverter"/> property to see
            if the configuration specified the class of a specific converter to use.  If this
            property is set, attempt to construct an instance of that class.  If not set, or
            if construction fails, the converter specific to the dialect will be used.
            </remarks>
        </member>
        <member name="M:NHibernate.Exceptions.SQLExceptionConverterFactory.BuildMinimalSQLExceptionConverter">
            <summary> 
            Builds a minimal converter.  The instance returned here just always converts to <see cref="T:NHibernate.Exceptions.GenericADOException"/>. 
            </summary>
            <returns> The minimal converter. </returns>
        </member>
        <member name="T:NHibernate.Exceptions.SQLGrammarException">
            <summary> 
            Implementation of ADOException indicating that the SQL sent to the database
            server was invalid (syntax error, invalid object references, etc). 
            </summary>
        </member>
        <member name="T:NHibernate.Exceptions.SQLStateConverter">
            <summary> 
            A SQLExceptionConverter implementation which performs no conversion of
            the underlying <see cref="T:System.Data.Common.DbException"/>. 
            Interpretation of a SQL error based on <see cref="T:System.Data.Common.DbException"/>
            is not possible as using the ErrorCode (which is, however, vendor-
            specific). Use of a ErrorCode-based converter should be preferred approach
            for converting/interpreting SQLExceptions. 
            </summary>
        </member>
        <member name="M:NHibernate.Exceptions.SQLStateConverter.HandledNonSpecificException(System.Exception,System.String,System.String)">
            <summary> Handle an exception not converted to a specific type based on the SQLState. </summary>
            <param name="sqlException">The exception to be handled. </param>
            <param name="message">An optional message </param>
            <param name="sql">Optionally, the sql being performed when the exception occurred. </param>
            <returns> The converted exception; should <b>never</b> be null. </returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Exec.IStatementExecutor">
            <summary> 
            Encapsulates the strategy required to execute various types of update, delete,
            and insert statements issued through HQL. 
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Exec.IStatementExecutor.Execute(NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Execute the sql managed by this executor using the given parameters. 
            </summary>
            <param name="parameters">Essentially bind information for this processing. </param>
            <param name="session">The session originating the request. </param>
            <returns> The number of entities updated/deleted. </returns>
            <exception cref="T:NHibernate.HibernateException"/>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.HqlParser.filter">
            True if this is a filter query (allow no FROM clause). *
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.HqlSqlWalker.PopFromClause">
            <summary>
            Returns to the previous 'FROM' context.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NHibernate.Hql.Ast.ANTLR.SqlGenerator" -->
        <member name="T:NHibernate.Hql.Ast.ANTLR.IErrorReporter">
            <summary>
            Implementations will report or handle errors invoked by an ANTLR base parser.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.SqlGenerator.outputStack">
            all append invocations on the buf should go through this Output instance variable.
            The value of this variable may be temporarily substitued by sql function processing code
            to catch generated arguments.
            This is because sql function templates need arguments as separate string chunks
            that will be assembled into the target dialect-specific function call.
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.SqlGenerator.parseErrorHandler">
            <summary>
            Handles parser errors.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SqlGenerator.OptionalSpace">
            <summary>
            Add a space if the previous token was not a space or a parenthesis.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.SqlGenerator.DefaultWriter">
            <summary>
            The default SQL writer.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.SqlGenerator.ISqlWriter">
            <summary>
            Writes SQL fragments.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SqlGenerator.ISqlWriter.CommaBetweenParameters(System.String)">
             todo remove this hack
             The parameter is either ", " or " , ". This is needed to pass sql generating tests as the old
             sql generator uses " , " in the WHERE and ", " in SELECT.
            
             @param comma either " , " or ", "
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.SqlGenerator.QueryWriter">
            <summary>
            The default SQL writer.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AbstractNullnessCheckNode">
            <summary>
            Base class for nodes dealing 'is null' and 'is not null' operators.
            todo : a good deal of this is copied from BinaryLogicOperatorNode; look at consolidating these code fragments
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.UnaryLogicOperatorNode">
            <summary>
            Represents a unary operator node.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerNode">
            <summary>
            A semantic analysis node, that points back to the main analyzer.
            Authoer: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode">
            <summary>
            A base AST node for the intermediate tree.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode._originalText">
            The original text for the node, mostly for debugging.
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode._dataType">
            The data type of this node.  Null for 'no type'.
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode.RenderText(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Retrieve the text to be used for rendering this particular node.
            </summary>
            <param name="sessionFactory">The session factory</param>
            <returns>The text to use for rendering</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IInitializableNode">
            <summary>
            An interface for initializeable AST nodes.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IInitializableNode.Initialize(System.Object)">
            <summary>
            Initializes the node with the parameter.
            </summary>
            <param name="param">the initialization parameter.</param>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerNode._walker">
            A pointer back to the phase 2 processor.
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IUnaryOperatorNode">
            <summary>
            Contract for nodes representing unary operators.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IOperatorNode">
            <summary>
            Contract for nodes representing operators (logic or arithmetic).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IOperatorNode.Initialize">
            <summary>
            Called by the tree walker during hql-sql semantic analysis
            after the operator sub-tree is completely built.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IOperatorNode.DataType">
            <summary>
            Retrieves the data type for the overall operator expression.
            </summary>
            <returns>The expression's data type.</returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IUnaryOperatorNode.Operand">
            <summary>
            Retrieves the node representing the operator's single operand.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.AbstractNullnessCheckNode.ExpansionConnectorType">
            <summary>
            When (if) we need to expand a row value constructor, what is the type of connector to use between the
            expansion fragments.
            </summary>
            <returns>The expansion connector type.</returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.AbstractNullnessCheckNode.ExpansionConnectorText">
            <summary>
            When (if) we need to expand a row value constructor, what is the text of connector to use between the
            expansion fragments.
            </summary>
            <returns>The expansion connector text.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AbstractStatement">
            <summary>
            Convenience implementation of Statement to centralize common functionality.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IDisplayableNode">
            <summary>
            Implementors will return additional display text, which will be used
            by the ASTPrinter to display information (besides the node type and node
            text).
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IDisplayableNode.GetDisplayText">
            <summary>
            Returns additional display text for the AST node.
            </summary>
            <returns>The additional display text.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IStatement">
            <summary>
            Common interface modeling the different HQL statements (i.e., INSERT, UPDATE, DELETE, SELECT).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IStatement.Walker">
            <summary>
            The "phase 2" walker which generated this statement tree.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IStatement.StatementType">
            <summary>
            The main token type representing the type of this statement.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IStatement.NeedsExecutor">
            <summary>
            Does this statement require the StatementExecutor?
            Essentially, at the JDBC level, does this require an executeUpdate()?
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.AbstractStatement.GetDisplayText">
            <summary>
            Returns additional display text for the AST node.
            </summary>
            <returns>The additional display text.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement">
            <summary>
            Type definition for Statements which are restrictable via a where-clause (and
            thus also having a from-clause).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement.FromClause">
            <summary>
            Retreives the from-clause in effect for this statement; could be null if the from-clause
            has not yet been parsed/generated.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement.HasWhereClause">
            <summary>
            Does this statement tree currently contain a where clause?
            Returns True if a where-clause is found in the statement tree and
            that where clause actually defines restrictions; false otherwise.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement.WhereClause">
            <summary>
            Retreives the where-clause defining the restriction(s) in effect for
            this statement.
            Note that this will generate a where-clause if one was not found, so caution
            needs to taken prior to calling this that restrictions will actually exist
            in the resulting statement tree (otherwise "unexpected end of subtree" errors
            might occur during rendering).
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression">
            <summary>
            Represents an element of a projection list, i.e. a select expression.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.SetScalarColumnText(System.Int32)">
            <summary>
            Appends AST nodes that represent the columns after the current AST node.
            (e.g. 'as col0_O_')
            </summary>
            <param name="i">The index of the select expression in the projection list.</param>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.DataType">
            <summary>
            Returns the data type of the select expression.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.FromElement">
            <summary>
            Returns the FROM element that this expression refers to.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.IsConstructor">
            <summary>
            Returns true if the element is a constructor (e.g. new Foo).
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.IsReturnableEntity">
            <summary>
            Returns true if this select expression represents an entity that can be returned.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.Text">
            <summary>
            Sets the text of the node.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AggregateNode">
            <summary>
            Represents an aggregate function i.e. min, max, sum, avg.
            
            Author: Joshua Davis
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AssignmentSpecification">
            <summary> 
            Encapsulates the information relating to an individual assignment within the
            set clause of an HQL update statement.  This information is used during execution
            of the update statements when the updates occur against "multi-table" stuff. 
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BetweenOperatorNode">
            <summary>
            Contract for nodes representing logcial BETWEEN (ternary) operators.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BinaryArithmeticOperatorNode">
            <summary>
            Nodes which represent binary arithmetic operators.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IBinaryOperatorNode">
            <summary>
            Contract for nodes representing binary operators.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IBinaryOperatorNode.LeftHandOperand">
            <summary>
            The left-hand operand of the operator.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IBinaryOperatorNode.RightHandOperand">
            <summary>
            The right-hand operand of the operator.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.BinaryArithmeticOperatorNode.LeftHandOperand">
             Retrieves the left-hand operand of the operator.
            
             @return The left-hand operand
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.BinaryArithmeticOperatorNode.RightHandOperand">
             Retrieves the right-hand operand of the operator.
            
             @return The right-hand operand
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BinaryLogicOperatorNode">
            <summary>
            Contract for nodes representing binary operators.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer">
            <summary>
            Currently this is needed in order to deal with {@link FromElement FromElements} which
            contain "hidden" JDBC parameters from applying filters.
            Would love for this to go away, but that would require that Hibernate's
            internal {@link org.hibernate.engine.JoinSequence join handling} be able to either:<ul>
            <li>render the same AST structures</li>
            <li>render structures capable of being converted to these AST structures</li>
            </ul>
            In the interim, this allows us to at least treat these "hidden" parameters properly which is
            the most pressing need.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.AddEmbeddedParameter(NHibernate.Param.IParameterSpecification)">
            <summary>
            Adds a parameter specification for a parameter encountered within this node.  We use the term 'embedded' here
            because of the fact that the parameter was simply encountered as part of the node's text; it does not exist
            as part of a subtree as it might in a true AST.
            </summary>
            <param name="specification">The generated specification.</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.GetEmbeddedParameters">
            <summary>
            Retrieve all embedded parameter specifications.
            </summary>
            <returns>All embedded parameter specifications; may return null.</returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.Text">
            <summary>
            Set the renderable text of this node.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.HasEmbeddedParameters">
            <summary>
            Determine whether this node contans embedded parameters.  The implication is that
            {@link #getEmbeddedParameters()} is allowed to return null if this method returns false.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.BinaryLogicOperatorNode.Initialize">
            <summary>
            Performs the operator node initialization by seeking out any parameter
            nodes and setting their expected type, if possible.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.BinaryLogicOperatorNode.MutateRowValueConstructorSyntax(System.Int32)">
             Mutate the subtree relating to a row-value-constructor to instead use
             a series of ANDed predicates.  This allows multi-column type comparisons
             and explicit row-value-constructor syntax even on databases which do
             not support row-value-constructor.
             <p/>
             For example, here we'd mutate "... where (col1, col2) = ('val1', 'val2) ..." to
             "... where col1 = 'val1' and col2 = 'val2' ..."
            
             @param valueElements The number of elements in the row value constructor list.
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BooleanLiteralNode">
            <summary>
             Represents a boolean literal within a query.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.LiteralNode">
            <summary>
            Represents a literal.
            
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IExpectedTypeAwareNode">
            <summary>
            Interface for nodes which wish to be made aware of any determined "expected
            type" based on the context within they appear in the query.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.BooleanLiteralNode.ExpectedType">
             Expected-types really only pertinent here for boolean literals...
            
             @param expectedType
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.Case2Node">
            <summary>
            Represents a case ... when .. then ... else ... end expression in a select.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.CaseNode">
            <summary>
            Represents a case ... when .. then ... else ... end expression in a select.
            
            Author: Gavin King
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.CollectionFunction">
            <summary>
            Represents 'elements()' or 'indices()'.
            Author: josh
            Ported by: Steve strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.MethodNode">
            <summary>
            Represents a method call
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.#ctor(NHibernate.Hql.Ast.ANTLR.Tree.FromClause,NHibernate.Hql.Ast.ANTLR.Tree.FromElement,System.String)">
            <summary>
            Constructor form used to initialize <see cref="T:NHibernate.Hql.Ast.ANTLR.Tree.ComponentJoin"/>.
            </summary>
            <param name="fromClause">The FROM clause to which this element belongs.</param>
            <param name="origin">The origin (LHS) of this element.</param>
            <param name="alias">The alias applied to this element.</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.RenderIdentifierSelect(System.Int32,System.Int32)">
            <summary>
            Returns the identifier select SQL fragment.
            </summary>
            <param name="size">The total number of returned types.</param>
            <param name="k">The sequence of the current returned type.</param>
            <returns>the identifier select SQL fragment.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.RenderPropertySelect(System.Int32,System.Int32)">
            <summary>
            Returns the property select SQL fragment.
            </summary>
            <param name="size">The total number of returned types.</param>
            <param name="k">The sequence of the current returned type.</param>
            <returns>the property select SQL fragment.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.RenderScalarIdentifierSelect(System.Int32)">
            <summary>
            Render the identifier select, but in a 'scalar' context (i.e. generate the column alias).
            </summary>
            <param name="i">the sequence of the returned type</param>
            <returns>the identifier select with the column alias.</returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.IsImplied">
            <summary>
            Returns true if this FromElement was implied by a path, or false if this FROM element is explicitly declared in
            the FROM clause.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType">
            <summary>
            Delegate that handles the type and join sequence information for a FromElement.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.RenderIdentifierSelect(System.Int32,System.Int32)">
            <summary>
            Returns the identifier select SQL fragment.
            </summary>
            <param name="size">The total number of returned types.</param>
            <param name="k">The sequence of the current returned type.</param>
            <returns>the identifier select SQL fragment.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.RenderScalarIdentifierSelect(System.Int32)">
            <summary>
            Render the identifier select, but in a 'scalar' context (i.e. generate the column alias).
            </summary>
            <param name="i">the sequence of the returned type</param>
            <returns>the identifier select with the column alias.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.RenderPropertySelect(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns the property select SQL fragment.
            </summary>
            <param name="size">The total number of returned types.</param>
            <param name="k">The sequence of the current returned type.</param>
            <param name="allProperties"></param>
            <returns>the property select SQL fragment.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.GetPropertyType(System.String,System.String)">
            <summary>
            Returns the type of a property, given it's name (the last part) and the full path.
            </summary>
            <param name="propertyName">The last part of the full path to the property.</param>
            <param name="propertyPath">The full property path.</param>
            <returns>The type</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.TrimLeadingCommaAndSpaces(System.String)">
            <summary>
            This accounts for a quirk in Queryable, where it sometimes generates ',  ' in front of the
            SQL fragment.  :-P
            </summary>
            <param name="fragment">A SQL fragment.</param>
            <returns>The fragment, without the leading comma and spaces.</returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.Queryable">
            <summary>
            Returns the Hibernate queryable implementation for the HQL class.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IPropertyMapping">
            <summary>
            Abstraction of all mappings that define properties: entities, collection elements.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToType(System.String)">
            <summary>
            Given a component path expression, get the type of the property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IPropertyMapping.TryToType(System.String,NHibernate.Type.IType@)">
            <summary>
            Given a component path expression, get the type of the property. 
            </summary>
            <param name="propertyName"></param>
            <param name="type"></param>
            <returns>true if a type was found, false if not</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToColumns(System.String,System.String)">
            <summary>
            Given a query alias and a property path, return the qualified column name
            </summary>
            <param name="alias"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToColumns(System.String)">
            <summary> Given a property path, return the corresponding column name(s).</summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IPropertyMapping.Type">
            <summary>
            Get the type of the thing containing the properties
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList">
            <summary>
            Common behavior - a node that contains a list of select expressions.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList.CollectSelectExpressions">
            <summary>
            Returns an array of SelectExpressions gathered from the children of the given parent AST node.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList.CollectSelectExpressions(System.Boolean)">
            <summary>
            Returns an array of SelectExpressions gathered from the children of the given parent AST node.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList.GetFirstSelectExpression">
            <summary>
            Returns the first select expression node that should be considered when building the array of select
            expressions.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.CountNode">
            <summary>
            Represents a COUNT expression in a select.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.DeleteStatement">
            <summary>
            Defines a top-level AST node representing an HQL delete statement. 
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.DotNode">
            <summary>
            Represents a reference to a property or alias expression.  This should duplicate the relevant behaviors in
            PathExpressionParser.
            Author: Joshua Davis
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode">
            <summary>
            The contract for expression sub-trees that can resolve themselves.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.Resolve(System.Boolean,System.Boolean,System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Does the work of resolving an identifier or a dot
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.Resolve(System.Boolean,System.Boolean,System.String)">
            <summary>
            Does the work of resolving an identifier or a dot, but without a parent node
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.Resolve(System.Boolean,System.Boolean)">
            <summary>
            Does the work of resolving an identifier or a dot, but without a parent node or alias
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.ResolveInFunctionCall(System.Boolean,System.Boolean)">
            <summary>
            Does the work of resolving inside of the scope of a function call
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.ResolveIndex(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Does the work of resolving an an index [].
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IPathNode">
            <summary>
            An AST node with a path property.  This path property will be the fully qualified name.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IPathNode.Path">
            <summary>
            Returns the full path name represented by the node.
            </summary>
            <returns>the full path name represented by the node.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromReferenceNode.GetImpliedJoin">
            <summary>
            Sub-classes can override this method if they produce implied joins (e.g. DotNode).
            </summary>
            <returns>an implied join created by this from reference.</returns>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._path">
            <summary>
            The full path, to the root alias of this dot node.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._dereferenceType">
            <summary>
            The type of dereference that hapened (DEREF_xxx).
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._propertyName">
            <summary>
            The identifier that is the name of the property.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._propertyPath">
            <summary>
            The unresolved property path relative to this dot node.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._columns">
            <summary>
            The column names that this resolves to.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._fetch">
            <summary>
            Fetch join or not.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._joinType">
            <summary>
            The type of join to create.   Default is an inner join.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.DotNode.IsReferenceToPrimaryKey(System.String,NHibernate.Type.EntityType)">
            <summary>
            Is the given property name a reference to the primary key of the associated
            entity construed by the given entity type?
            For example, consider a fragment like order.customer.id
            (where order is a from-element alias).  Here, we'd have:
            propertyName = "id" AND
            owningType = ManyToOneType(Customer)
            and are being asked to determine whether "customer.id" is a reference
            to customer's PK...
            </summary>
            <param name="propertyName">The name of the property to check.</param>
            <param name="owningType">The type represeting the entity "owning" the property</param>
            <returns>True if propertyName references the entity's (owningType->associatedEntity) primary key; false otherwise.</returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.DotNode.JoinType">
            <summary>
            Sets the join type for this '.' node structure.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.DotNode.Path">
            <summary>
            Returns the full path of the node.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.FromClause">
            <summary>
            Represents the 'FROM' part of a query or subquery, containing all mapped class references.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._fromElementCounter">
            <summary>
            Counts the from elements as they are added.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._collectionJoinFromElementsByPath">
            <summary>
            All of the implicit FROM xxx JOIN yyy elements that are the destination of a collection.  These are created from
            index operators on collection property references.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._parentFromClause">
            <summary>
            Pointer to the parent FROM clause, if there is one.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._childFromClauses">
            <summary>
            Collection of FROM clauses of which this is the parent.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.IsFromElementAlias(System.String)">
            <summary>
            Convenience method to check whether a given token represents a from-element alias.
            </summary>
            <param name="possibleAlias">The potential from-element alias to check.</param>
            <returns>True if the possibleAlias is an alias to a from-element visible from this point in the query graph.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.ContainsClassAlias(System.String)">
            <summary>
            Returns true if the from node contains the class alias name.
            </summary>
            <param name="alias">The HQL class alias name.</param>
            <returns>true if the from node contains the class alias name.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.ContainsTableAlias(System.String)">
            <summary>
            Returns true if the from node contains the table alias name.
            </summary>
            <param name="alias">The SQL table alias name.</param>
            <returns>true if the from node contains the table alias name.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.AddFromElement(System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Adds a new from element to the from node.
            </summary>
            <param name="path">The reference to the class.</param>
            <param name="alias">The alias AST.</param>
            <returns>The new FROM element.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.GetFromElement(System.String)">
            <summary>
            Retreives the from-element represented by the given alias.
            </summary>
            <param name="aliasOrClassName">The alias by which to locate the from-element.</param>
            <returns>The from-element assigned the given alias, or null if none.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.GetFromElements">
            <summary>
            Returns the list of from elements in order.
            </summary>
            <returns>The list of from elements (instances of FromElement).</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.GetProjectionList">
            <summary>
            Returns the list of from elements that will be part of the result set.
            </summary>
            <returns>the list of from elements that will be part of the result set.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.FindJoinByPath(System.String)">
            <summary>
            Look for an existing implicit or explicit join by the given path.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementFactory.#ctor(NHibernate.Hql.Ast.ANTLR.Tree.FromClause,NHibernate.Hql.Ast.ANTLR.Tree.FromElement,System.String)">
            <summary>
            Creates entity from elements.
            </summary>
            <param name="fromClause"></param>
            <param name="origin"></param>
            <param name="path"></param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementFactory.#ctor(NHibernate.Hql.Ast.ANTLR.Tree.FromClause,NHibernate.Hql.Ast.ANTLR.Tree.FromElement,System.String,System.String,System.String[],System.Boolean)">
            <summary>
            Creates collection from elements.
            </summary>
            <param name="fromClause"></param>
            <param name="origin"></param>
            <param name="path"></param>
            <param name="classAlias"></param>
            <param name="columns"></param>
            <param name="implied"></param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerTreeNodeStream.InsertChild(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Insert a new node into both the Tree and the Node Array. Add DOWN and UP nodes if needed.
            </summary>
            <param name="parent">The parent node</param>
            <param name="child">The child node</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerTreeNodeStream.NumberOfChildNodes(System.Int32)">
            <summary>
            Count the number of child nodes (including DOWNs and UPs) of a parent node
            </summary>
            <param name="parentIndex">The index of the parent in the node array</param>
            <returns>The number of child nodes</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IndexNode">
            <summary>
            Represents the [] operator and provides it's semantics.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.InLogicOperatorNode">
            <summary>
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement">
            <summary> 
            Defines a top-level AST node representing an HQL "insert select" statement. 
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement.Validate">
            <summary> Performs detailed semantic validation on this insert statement tree. </summary>
            <exception cref="T:NHibernate.QueryException">Indicates validation failure.</exception>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement.IntoClause">
            <summary> Retreive this insert statement's into-clause. </summary>
            <returns> The into-clause </returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement.SelectClause">
            <summary> Retreive this insert statement's select-clause.</summary>
            <returns> The select-clause. </returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IntoClause">
            <summary>
            Represents an entity referenced in the INTO clause of an HQL
            INSERT statement.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IntoClause.GetDisplayText">
            <summary>
            Returns additional display text for the AST node.
            </summary>
            <returns>The additional display text.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IntoClause.AreCompatible(NHibernate.Type.IType,NHibernate.Type.IType)">
            <summary>
            Determine whether the two types are "assignment compatible".
            </summary>
            <param name="target">The type defined in the into-clause.</param>
            <param name="source">The type defined in the select clause.</param>
            <returns>True if they are assignment compatible.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.ISessionFactoryAwareNode">
            <summary>
            Interface for nodes which require access to the SessionFactory
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IsNotNullLogicOperatorNode">
            <summary>
            IsNotNullLogicOperatorNode implementation
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IsNullLogicOperatorNode">
            <summary>
            Represents a 'is null' check.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.JavaConstantNode">
            <summary>
            A node representing a static Java constant.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.OrderByClause">
            <summary>
            Implementation of OrderByClause.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.ParameterNode">
            <summary>
            Implementation of ParameterNode.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.QueryNode.GetSelectClause">
            <summary>
            Locate the select clause that is part of this select statement.
            Note, that this might return null as derived select clauses (i.e., no
            select clause at the HQL-level) get generated much later than when we
            get created; thus it depends upon lifecycle.
            </summary>
            <returns>Our select clause, or null.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause">
            <summary>
            Represents the list of expressions in a SELECT clause.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.InitializeDerivedSelectClause(NHibernate.Hql.Ast.ANTLR.Tree.FromClause)">
            <summary>
            Prepares a derived (i.e., not explicitly defined in the query) select clause.
            </summary>
            <param name="fromClause">The from clause to which this select clause is linked.</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.InitializeExplicitSelectClause(NHibernate.Hql.Ast.ANTLR.Tree.FromClause)">
            <summary>
            Prepares an explicitly defined select clause.
            </summary>
            <param name="fromClause">The from clause linked to this select clause.</param>
            <exception cref="T:NHibernate.Hql.Ast.ANTLR.SemanticException"></exception>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.FromElementsForLoad">
            <summary>
            FromElements which need to be accounted for in the load phase (either for return or for fetch).
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.ColumnNames">
            <summary>
            The column alias names being used in the generated SQL.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.Constructor">
            <summary>
            The constructor to use for dynamic instantiation queries.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.QueryReturnAliases">
            <summary>
            The HQL aliases, or generated aliases
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.QueryReturnTypes">
            <summary>
            The types actually being returned from this query at the "object level".
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionImpl">
            <summary>
            A select expression that was generated by a FROM element.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SqlFragment">
            <summary>
            Represents an SQL fragment in the AST.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.UpdateStatement">
            <summary> 
            Defines a top-level AST node representing an HQL update statement. 
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Util.AliasGenerator">
            <summary>
            Generates class/table/column aliases during semantic analysis and SQL rendering.
            Its essential purpose is to keep an internal counter to ensure that the
            generated aliases are unique.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Util.ASTAppender">
            <summary>
            Appends child nodes to a parent efficiently.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Util.ASTIterator">
            <summary>
            Depth first iteration of an ANTLR AST.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ASTUtil.GetDebugstring(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Returns the 'list' representation with some brackets around it for debugging.
            </summary>
            <param name="n">The tree.</param>
            <returns>The list representation of the tree.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ASTUtil.IsSubtreeChild(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Determine if a given node (test) is contained anywhere in the subtree
            of another given node (fixture).
            </summary>
            <param name="fixture">The node against which to be checked for children.</param>
            <param name="test">The node to be tested as being a subtree child of the parent.</param>
            <returns>True if child is contained in the parent's collection of children.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ASTUtil.FindTypeInChildren(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,System.Int32)">
            <summary>
            Finds the first node of the specified type in the chain of children.
            </summary>
            <param name="parent">The parent</param>
            <param name="type">The type to find.</param>
            <returns>The first node of the specified type, or null if not found.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Util.FilterPredicate">
            <summary>
            Filters nodes in/out of a tree.
            </summary>
            <param name="node">The node to check.</param>
            <returns>true to keep the node, false if the node should be filtered out.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ColumnHelper.GenerateScalarColumns(NHibernate.Hql.Ast.ANTLR.Tree.IASTFactory,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,System.String[],System.Int32)">
            <summary>
            Generates the scalar column AST nodes for a given array of SQL columns
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Util.JoinProcessor">
            <summary>
            Performs the post-processing of the join information gathered during semantic analysis.
            The join generating classes are complex, this encapsulates some of the JoinSequence-related
            code.
            Author: Joshua Davis
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.JoinProcessor.#ctor(NHibernate.Hql.Ast.ANTLR.HqlSqlWalker)">
            <summary>
            Constructs a new JoinProcessor.
            </summary>
            <param name="walker">The walker to which we are bound, giving us access to needed resources.</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.JoinProcessor.ToHibernateJoinType(System.Int32)">
            <summary>
            Translates an AST join type (i.e., the token type) into a JoinFragment.XXX join type.
            </summary>
            <param name="astJoinType">The AST join type (from HqlSqlWalker)</param>
            <returns>a JoinType.XXX join type.</returns>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Util.LiteralProcessor.EXACT">
            <summary>
             Indicates that Float and Double literal values should
            be treated using the SQL "exact" format (i.e., '.001')
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Util.LiteralProcessor.APPROXIMATE">
            <summary>
            Indicates that Float and Double literal values should
            be treated using the SQL "approximate" format (i.e., '1E-3')
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.Util.LiteralProcessor.DECIMAL_LITERAL_FORMAT">
            <summary>
            In what format should Float and Double literal values be sent
            to the database?
            See #EXACT, #APPROXIMATE
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.NodeTraverser.TraverseDepthFirst(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Traverse the AST tree depth first. Note that the AST passed in is not visited itself.  Visitation starts
            with its children.
            </summary>
            <param name="ast">ast</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.Util.PathHelper.ParsePath(System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTFactory)">
            <summary>
            Turns a path into an AST.
            </summary>
            <param name="path">The path.</param>
            <param name="factory">The AST factory to use.</param>
            <returns>An HQL AST representing the path.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.Util.SyntheticAndFactory">
            <summary>
            Creates synthetic and nodes based on the where fragment part of a JoinSequence.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.ASTQueryTranslatorFactory">
            <summary>
            Generates translators which uses the Antlr-based parser to perform
            the translation.
            
            Author: Gavin King
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.IQueryTranslatorFactory">
            <summary>
            Facade for generation of <see cref="T:NHibernate.Hql.IQueryTranslator"/> 
            and <see cref="T:NHibernate.Hql.IFilterTranslator"/> instances.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslatorFactory.CreateQueryTranslators(System.String,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter},NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Construct a <see cref="T:NHibernate.Hql.IQueryTranslator"/> instance 
            capable of translating an HQL query string.
            </summary>
            <param name="queryString">The query string to be translated</param>
            <param name="collectionRole"></param>
            <param name="shallow"></param>
            <param name="filters">Currently enabled filters</param>
            <param name="factory">The session factory</param>
            <returns>An appropriate translator.</returns>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslatorFactory.CreateQueryTranslators(NHibernate.IQueryExpression,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter},NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Construct a <see cref="T:NHibernate.Hql.IQueryTranslator"/> instance 
            capable of translating a Linq expression.
            </summary>
            <param name="queryExpression">The query expression to be translated</param>
            <param name="collectionRole"></param>
            <param name="shallow"></param>
            <param name="filters">Currently enabled filters</param>
            <param name="factory">The session factory</param>
            <returns>An appropriate translator.</returns>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.CaseInsensitiveStringStream">
             <summary>
             Look ahead for tokenizing is all lowercase, whereas the original case of an input stream is preserved.
             Copied from http://www.antlr.org/wiki/pages/viewpage.action?pageId=1782
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.CollectionProperties">
            <summary>
            Provides a map of collection function names to the corresponding property names.
            Authoer: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.QueryException">
            <summary>
            A problem occurred translating a Hibernate query to SQL due to invalid query syntax, etc.
            </summary>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="queryString">The query that contains the error.</param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.QueryException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.QueryException.QueryString">
            <summary>
            Gets or sets the <see cref="T:System.String"/> of HQL that caused the Exception.
            </summary>
        </member>
        <member name="P:NHibernate.QueryException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.QueryException"/>.
            </summary>
            <value>The error message that explains the reason for this exception including the HQL.</value>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.ErrorCounter">
            <summary>
            An error handler that counts parsing errors and warnings.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.IParseErrorHandler">
            <summary>
            Defines the behavior of an error handler for the HQL parsers.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.HqlToken">
            <summary>
            A custom token class for the HQL grammar.
            </summary>
        </member>
        <member name="F:NHibernate.Hql.Ast.ANTLR.HqlToken._previousTokenType">
            <summary>
            The previous token type.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.HqlToken.#ctor(Antlr.Runtime.ICharStream,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Public constructor
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.HqlToken.#ctor(Antlr.Runtime.IToken)">
            <summary>
            Public constructor
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.HqlToken.ToString">
            <summary>
            Returns a string representation of the object.
            </summary>
            <returns>The debug string</returns>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.HqlToken.PossibleId">
            <summary>
            Indicates if the token could be an identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.Ast.ANTLR.HqlToken.PreviousType">
            <summary>
            Returns the previous token type.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.Ast.ANTLR.InvalidPathException">
            <summary>
            Exception thrown when an invalid path is found in a query.
            Author: josh
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Hql.IFilterTranslator">
            <summary> 
            Specialized interface for filters.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.IQueryTranslator">
            <summary>
            Defines the constract of an HQL->SQL translator.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.Compile(System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>
            Compile a "normal" query. This method may be called multiple times. Subsequent invocations are no-ops.
            </summary>
            <param name="replacements">Defined query substitutions.</param>
            <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
            <exception cref="T:NHibernate.QueryException">There was a problem parsing the query string.</exception>
            <exception cref="T:NHibernate.MappingException">There was a problem querying defined mappings.</exception>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.List(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters)">
            <summary>
            Perform a list operation given the underlying query definition.
            </summary>
            <param name="session">The session owning this query.</param>
            <param name="queryParameters">The query bind parameters.</param>
            <returns>The query list results.</returns>
            <exception cref="T:NHibernate.HibernateException"></exception>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.ExecuteUpdate(NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform a bulk update/delete operation given the underlying query defintion.
            </summary>
            <param name="queryParameters">The query bind parameters.</param>
            <param name="session">The session owning this query.</param>
            <returns>The number of entities updated or deleted.</returns>
            <exception cref="T:NHibernate.HibernateException"></exception>
        </member>
        <member name="M:NHibernate.Hql.IQueryTranslator.GetColumnNames">
            <summary>
            Returns the column names in the generated SQL.
            </summary>
            <returns>the column names in the generated SQL.</returns>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.QuerySpaces">
            <summary>
            The set of query spaces (table names) that the query referrs to.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.SQLString">
            <summary>
            The SQL string generated by the translator.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.QueryString">
            <summary>
            The HQL string processed by the translator.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.EnabledFilters">
            <summary>
            Returns the filters enabled for this query translator.
            </summary>
            <returns>Filters enabled for this query execution.</returns>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.ReturnTypes">
            <summary>
            Returns an array of Types represented in the query result.
            </summary>
            <returns>Query return types.</returns>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.ReturnAliases">
            <summary>
            Returns an array of HQL aliases
            </summary>
            <returns>Returns an array of HQL aliases</returns>
        </member>
        <member name="P:NHibernate.Hql.IQueryTranslator.ContainsCollectionFetches">
            <summary>
            Does the translated query contain collection fetches?
            </summary>
            <returns>True if the query does contain collection fetched; false otherwise.</returns>
        </member>
        <member name="M:NHibernate.Hql.IFilterTranslator.Compile(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary> 
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
            <param name="collectionRole">the role name of the collection used as the basis for the filter.</param>
            <param name="replacements">Defined query substitutions.</param>
            <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.#ctor(System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter},NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Creates a new AST-based query translator.
            </summary>
            <param name="queryIdentifier">The query-identifier (used in stats collection)</param>
            <param name="parsedQuery">The hql query to translate</param>
            <param name="enabledFilters">Currently enabled filters</param>
            <param name="factory">The session factory constructing this translator instance.</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.Compile(System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>
            Compile a "normal" query. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
            <param name="replacements">Defined query substitutions.</param>
            <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.Compile(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
            <summary>
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
            <param name="collectionRole">the role name of the collection used as the basis for the filter.</param>
            <param name="replacements">Defined query substitutions.</param>
            <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.DoCompile(System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean,System.String)">
            <summary>
            Performs both filter and non-filter compiling.
            </summary>
            <param name="replacements">Defined query substitutions.</param>
            <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
            <param name="collectionRole">the role name of the collection used as the basis for the filter, NULL if this is not a filter.</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Construct a new SessionFactoryHelperExtensions instance.
            </summary>
            <param name="sfi">The SessionFactory impl to be encapsulated.</param>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindSQLFunction(System.String)">
            <summary>
            Locate a registered sql function by name.
            </summary>
            <param name="functionName">The name of the function to locate</param>
            <returns>The sql function, or null if not found.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.RequireSQLFunction(System.String)">
            <summary>
            Locate a registered sql function by name.
            </summary>
            <param name="functionName">The name of the function to locate</param>
            <returns>The sql function, or throws QueryException if no matching sql functions could be found.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindFunctionReturnType(System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
            <summary>
            Find the function return type given the function name and the first argument expression node.
            </summary>
            <param name="functionName">The function name.</param>
            <param name="first">The first argument expression.</param>
            <returns>the function return type given the function name and the first argument expression node.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetImportedClassName(System.String)">
            <summary>
            Given a (potentially unqualified) class name, locate its imported qualified name.
            </summary>
            <param name="className">The potentially unqualified class name</param>
            <returns>The qualified class name.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.HasPhysicalDiscriminatorColumn(NHibernate.Persister.Entity.IQueryable)">
            <summary>
            Does the given persister define a physical discriminator column
            for the purpose of inheritence discrimination?
            </summary>
            <param name="persister">The persister to be checked.</param>
            <returns>True if the persister does define an actual discriminator column.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetCollectionPersister(System.String)">
            <summary>
            Locate the collection persister by the collection role.
            </summary>
            <param name="collectionFilterRole">The collection role name.</param>
            <returns>The defined CollectionPersister for this collection role, or null.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetIdentifierOrUniqueKeyPropertyName(NHibernate.Type.EntityType)">
            <summary>
            Determine the name of the property for the entity encapsulated by the
            given type which represents the id or unique-key.
            </summary>
            <param name="entityType">The type representing the entity.</param>
            <returns>The corresponding property name</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetCollectionElementColumns(System.String,System.String)">
            <summary>
            Retrieves the column names corresponding to the collection elements for the given
            collection role.
            </summary>
            <param name="role">The collection role</param>
            <param name="roleAlias">The sql column-qualification alias (i.e., the table alias)</param>
            <returns>the collection element columns</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetElementAssociationType(NHibernate.Type.CollectionType)">
            <summary>
            Essentially the same as GetElementType, but requiring that the
            element type be an association type.
            </summary>
            <param name="collectionType">The collection type to be checked.</param>
            <returns>The AssociationType of the elements of the collection.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.RequireQueryableCollection(System.String)">
            <summary>
            Locate the collection persister by the collection role, requiring that
            such a persister exist.
            </summary>
            <param name="role">The collection role name.</param>
            <returns>The defined CollectionPersister for this collection role.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.RequireClassPersister(System.String)">
            <summary>
            Locate the persister by class or entity name, requiring that such a persister
            exist.
            </summary>
            <param name="name">The class or entity name</param>
            <returns>The defined persister for this entity</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindQueryableUsingImports(System.String)">
            <summary>
            Given a (potentially unqualified) class name, locate its persister.
            </summary>
            <param name="className">The (potentially unqualified) class name.</param>
            <returns>The defined persister for this class, or null if none found.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindQueryableUsingImports(NHibernate.Engine.ISessionFactoryImplementor,System.String)">
            <summary>
            Given a (potentially unqualified) class name, locate its persister.
            </summary>
            <param name="sfi">The session factory implementor.</param>
            <param name="className">The (potentially unqualified) class name.</param>
            <returns>The defined persister for this class, or null if none found.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindEntityPersisterByName(System.String)">
            <summary>
            Locate the persister by class or entity name.
            </summary>
            <param name="name">The class or entity name</param>
            <returns>The defined persister for this entity, or null if none found.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.CreateCollectionJoinSequence(NHibernate.Persister.Collection.IQueryableCollection,System.String)">
            <summary>
            Create a join sequence rooted at the given collection.
            </summary>
            <param name="collPersister">The persister for the collection at which the join should be rooted.</param>
            <param name="collectionName">The alias to use for qualifying column references.</param>
            <returns>The generated join sequence.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.CreateJoinSequence">
            <summary>
            Generate an empty join sequence instance.
            </summary>
            <returns>The generated join sequence.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.CreateJoinSequence(System.Boolean,NHibernate.Type.IAssociationType,System.String,NHibernate.SqlCommand.JoinType,System.String[])">
            <summary>
            Generate a join sequence representing the given association type.
            </summary>
            <param name="implicitJoin">Should implicit joins (theta-style) or explicit joins (ANSI-style) be rendered</param>
            <param name="associationType">The type representing the thing to be joined into.</param>
            <param name="tableAlias">The table alias to use in qualifing the join conditions</param>
            <param name="joinType">The type of join to render (inner, outer, etc)</param>
            <param name="columns">The columns making up the condition of the join.</param>
            <returns>The generated join sequence.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetCollectionPropertyMapping(System.String)">
            <summary>
            Retreive a PropertyMapping describing the given collection role.
            </summary>
            <param name="role">The collection role for whcih to retrieve the property mapping.</param>
            <returns>The property mapping.</returns>
        </member>
        <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetElementType(NHibernate.Type.CollectionType)">
            <summary>
            Given a collection type, determine the Type representing elements
            within instances of that collection.
            </summary>
            <param name="collectionType">The collection type to be checked.</param>
            <returns>The Type of the elements of the collection.</returns>
        </member>
        <member name="T:NHibernate.Hql.Util.SessionFactoryHelper">
            <summary>
            Wraps SessionFactoryImpl, adding more lookup behaviors and encapsulating some of the error handling.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.Util.SessionFactoryHelper.GetCollectionPersister(System.String)">
            <summary>
            Locate the collection persister by the collection role.
            </summary>
            <param name="role">The collection role name.</param>
            <returns>The defined CollectionPersister for this collection role, or null.</returns>
        </member>
        <member name="M:NHibernate.Hql.Util.SessionFactoryHelper.RequireClassPersister(System.String)">
            <summary>
            Locate the persister by class or entity name, requiring that such a persister
            exists
            </summary>
            <param name="name">The class or entity name</param>
            <returns>The defined persister for this entity</returns>
        </member>
        <member name="M:NHibernate.Hql.Util.SessionFactoryHelper.FindEntityPersisterByName(System.String)">
            <summary>
            Locate the persister by class or entity name.
            </summary>
            <param name="name">The class or entity name</param>
            <returns>The defined persister for this entity, or null if none found.</returns>
        </member>
        <member name="M:NHibernate.Hql.Util.SessionFactoryHelper.GetCollectionPropertyMapping(System.String)">
            <summary>
            Retreive a PropertyMapping describing the given collection role.
            </summary>
            <param name="role">The collection role for whcih to retrieve the property mapping.</param>
            <returns>The property mapping.</returns>
        </member>
        <member name="T:NHibernate.Hql.NameGenerator">
            <summary>
            Provides utility methods for generating HQL / SQL names.
            Shared by both the 'classic' and 'new' query translators.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.QuerySplitter.ConcreteQueries(System.String,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Handle Hibernate "implicit" polymorphism, by translating the query string into 
            several "concrete" queries against mapped classes.
            </summary>
            <param name="query"></param>
            <param name="factory"></param>
            <returns></returns>
            <exception cref="T:NHibernate.MappingException"/>
        </member>
        <member name="T:NHibernate.Id.Enhanced.IAccessCallback">
            <summary>
            Contract for providing callback access to an <see cref="T:NHibernate.Id.Enhanced.IDatabaseStructure"/>,
            typically from the <see cref="T:NHibernate.Id.Enhanced.IOptimizer"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.IAccessCallback.GetNextValue">
            <summary>
            Retrieve the next value from the underlying source.
            </summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.IDatabaseStructure">
            <summary> 
            Encapsulates definition of the underlying data structure backing a sequence-style generator. 
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.BuildCallback(NHibernate.Engine.ISessionImplementor)">
            <summary> 
            A callback to be able to get the next value from the underlying
            structure as needed.
             </summary>
            <param name="session">The session. </param>
            <returns> The next value. </returns>
        </member>
        <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.Prepare(NHibernate.Id.Enhanced.IOptimizer)">
            <summary> 
            Prepare this structure for use.  Called sometime after instantiation,
            but before first use. 
            </summary>
            <param name="optimizer">The optimizer being applied to the generator. </param>
        </member>
        <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary> Commands needed to create the underlying structures.</summary>
            <param name="dialect">The database dialect being used. </param>
            <returns> The creation commands. </returns>
        </member>
        <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.SqlDropStrings(NHibernate.Dialect.Dialect)">
            <summary> Commands needed to drop the underlying structures.</summary>
            <param name="dialect">The database dialect being used. </param>
            <returns> The drop commands. </returns>
        </member>
        <member name="P:NHibernate.Id.Enhanced.IDatabaseStructure.Name">
            <summary> The name of the database structure (table or sequence).</summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.IDatabaseStructure.TimesAccessed">
            <summary> How many times has this structure been accessed through this reference?</summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.IDatabaseStructure.IncrementSize">
            <summary> The configured increment size</summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.IOptimizer">
            <summary>
            Performs optimization on an optimizable identifier generator.  Typically
            this optimization takes the form of trying to ensure we do not have to
            hit the database on each and every request to get an identifier value.
            </summary>
            <remarks>
            <para>
            Optimizers work on constructor injection.  They should provide
            a constructor with the following arguments.
            </para>
            - <see cref="T:System.Type"/> The return type for the generated values.
            - <langword>int</langword> The increment size.
            </remarks>
        </member>
        <member name="M:NHibernate.Id.Enhanced.IOptimizer.Generate(NHibernate.Id.Enhanced.IAccessCallback)">
            <summary>
            Generate an identifier value accounting for this specific optimization. 
            </summary>
            <param name="callback">Callback to access the underlying value source. </param>
            <returns>The generated identifier value.</returns>
        </member>
        <member name="P:NHibernate.Id.Enhanced.IOptimizer.LastSourceValue">
            <summary>
            A common means to access the last value obtained from the underlying
            source.  This is intended for testing purposes, since accessing the
            unerlying database source directly is much more difficult.
             </summary>
            <value>
            The last value we obtained from the underlying source; -1 indicates we have not yet consulted with the source.
            </value>
        </member>
        <member name="P:NHibernate.Id.Enhanced.IOptimizer.IncrementSize">
            <summary>
            Defined increment size. 
            </summary>
            <value> The increment size.</value>
        </member>
        <member name="P:NHibernate.Id.Enhanced.IOptimizer.ApplyIncrementSizeToSourceValues">
            <summary> 
            Are increments to be applied to the values stored in the underlying
            value source?
            </summary>
            <returns>
            True if the values in the source are to be incremented
            according to the defined increment size; false otherwise, in which
            case the increment is totally an in memory construct.
            </returns>
        </member>
        <member name="T:NHibernate.Id.Enhanced.OptimizerFactory.IInitialValueAwareOptimizer">
            <summary>
            Marker interface for an optimizer that wishes to know the user-specified initial value.
            <p/>
            Used instead of constructor injection since that is already a public understanding and
            because not all optimizers care.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.OptimizerFactory.IInitialValueAwareOptimizer.InjectInitialValue(System.Int64)">
            <summary>
            Reports the user-specified initial value to the optimizer.
            <p/>
            <tt>-1</tt> is used to indicate that the user did not specify.
            <param name="initialValue">The initial value specified by the user, or <tt>-1</tt> to indicate that the
            user did not specify.</param>
            </summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.OptimizerFactory.OptimizerSupport">
            <summary>
            Common support for optimizer implementations.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.OptimizerFactory.OptimizerSupport.#ctor(System.Type,System.Int32)">
            <summary>
            Construct an optimizer
            </summary>
            <param name="returnClass">The expected id class.</param>
            <param name="incrementSize">The increment size.</param>
        </member>
        <member name="P:NHibernate.Id.Enhanced.OptimizerFactory.HiLoOptimizer.LastSourceValue">
            <summary>
            Exposure intended for testing purposes.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.OptimizerFactory.HiLoOptimizer.HiValue">
            <summary>
            Exposure intended for testing purposes.
            </summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.OptimizerFactory.PooledOptimizer">
            <summary>
            Optimizer which uses a pool of values, storing the next low value of the range in the database.
            <para>
            Note that this optimizer works essentially the same as the HiLoOptimizer, except that here the
            bucket ranges are actually encoded into the database structures.
            </para>
            <para>
            Note that if you prefer that the database value be interpreted as the bottom end of our current
            range, then use the PooledLoOptimizer strategy.
            </para>
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.OptimizerFactory.PooledOptimizer.LastValue">
            <summary>
            Exposure intended for testing purposes.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.OptimizerFactory.PooledLoOptimizer.LastValue">
            <summary>
            Exposure intended for testing purposes.
            </summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.SequenceStructure">
            <summary>
            Describes a sequence.
            </summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.SequenceStyleGenerator">
            <summary>
            Generates identifier values based on an sequence-style database structure.
            Variations range from actually using a sequence to using a table to mimic
            a sequence. These variations are encapsulated by the <see cref="T:NHibernate.Id.Enhanced.IDatabaseStructure"/>
            interface internally.
            </summary>
            <remarks>
            General configuration parameters:
            <table>
              <tr>
                <td><b>NAME</b></td>
                <td><b>DEFAULT</b></td>
                <td><b>DESCRIPTION</b></td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.SequenceParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.DefaultSequenceName"/></td>
                <td>The name of the sequence/table to use to store/retrieve values</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.InitialParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.DefaultInitialValue"/></td>
                <td>The initial value to be stored for the given segment; the effect in terms of storage varies based on <see cref="P:NHibernate.Id.Enhanced.SequenceStyleGenerator.Optimizer"/> and <see cref="P:NHibernate.Id.Enhanced.SequenceStyleGenerator.DatabaseStructure"/></td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.IncrementParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.DefaultIncrementSize"/></td>
                <td>The increment size for the underlying segment; the effect in terms of storage varies based on <see cref="P:NHibernate.Id.Enhanced.SequenceStyleGenerator.Optimizer"/> and <see cref="P:NHibernate.Id.Enhanced.SequenceStyleGenerator.DatabaseStructure"/></td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.OptimizerParam"/></td>
                <td><i>depends on defined increment size</i></td>
                <td>Allows explicit definition of which optimization strategy to use</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.ForceTableParam"/></td>
                <td><b><i>false</i></b></td>
                <td>Allows explicit definition of which optimization strategy to use</td>
              </tr>
            </table>
            <p/>
            Configuration parameters used specifically when the underlying structure is a table:
            <table>
              <tr>
                <td><b>NAME</b></td>
                <td><b>DEFAULT</b></td>
                <td><b>DESCRIPTION</b></td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.ValueColumnParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.SequenceStyleGenerator.DefaultValueColumnName"/></td>
                <td>The name of column which holds the sequence value for the given segment</td>
              </tr>
            </table>
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IPersistentIdentifierGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that requires creation of database objects
            All <see cref="T:NHibernate.Id.IPersistentIdentifierGenerator"/>s that also implement 
            An <see cref="T:NHibernate.Id.IConfigurable"/>  have access to a special mapping parameter: schema
            </summary>
        </member>
        <member name="T:NHibernate.Id.IIdentifierGenerator">
            <summary>
            The general contract between a class that generates unique
            identifiers and the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            <para>
            It is not intended that this interface ever be exposed to the 
            application.  It <b>is</b> intended that users implement this interface
            to provide custom identifier generation strategies.
            </para>
            <para>
            Implementors should provide a public default constructor.
            </para>
            <para>
            Implementations that accept configuration parameters should also
            implement <see cref="T:NHibernate.Id.IConfigurable"/>.
            </para>
            <para>
            Implementors <b>must</b> be threadsafe.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IIdentifierGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new identifier
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier</returns>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the underlying database objects
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the sql to create the 
            necessary database objects.
            </returns>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects.
            </returns>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects.
            </summary>
            <returns>
            A key unique to the underlying database objects.
            </returns>
            <remarks>
            Prevents us from trying to create/remove them multiple times
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IConfigurable">
            <summary>
            An <c>IdentiferGenerator</c> that supports "configuration".
            </summary>
        </member>
        <member name="M:NHibernate.Id.IConfigurable.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Configure this instance, given the values of parameters
            specified by the user as <c>&lt;param&gt;</c> elements.
            This method is called just once, followed by instantiation.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.Enhanced.SequenceStyleGenerator.DetermineSequenceName(System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Determine the name of the sequence (or table if this resolves to a physical table) to use.
            Called during configuration.
            </summary>
            <param name="parms"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Id.Enhanced.SequenceStyleGenerator.DetermineValueColumnName(System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Determine the name of the column used to store the generator value in
            the db. Called during configuration, if a physical table is being used.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.SequenceStyleGenerator.DetermineInitialValue(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Determine the initial sequence value to use. This value is used when
            initializing the database structure (i.e. sequence/table). Called
            during configuration.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.SequenceStyleGenerator.DetermineIncrementSize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Determine the increment size to be applied. The exact implications of
            this value depends on the optimizer being used. Called during configuration.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.SequenceStyleGenerator.DetermineOptimizationStrategy(System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
            <summary>
            Determine the optimizer to use. Called during configuration.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.SequenceStyleGenerator.DetermineAdjustedIncrementSize(System.String,System.Int32)">
            <summary>
            In certain cases we need to adjust the increment size based on the
            selected optimizer. This is the hook to achieve that.
            </summary>
            <param name="optimizationStrategy">The determined optimizer strategy.</param>
            <param name="incrementSize">The determined, unadjusted, increment size.</param>
        </member>
        <member name="M:NHibernate.Id.Enhanced.SequenceStyleGenerator.RequiresPooledSequence(System.Int32,System.Int32,NHibernate.Id.Enhanced.IOptimizer)">
            <summary>
            Do we require a sequence with the ability to set initialValue and incrementSize
            larger than 1?
            </summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.TableGenerator">
             <summary>
             An enhanced version of table-based id generation.
             </summary>
             <remarks>
             Unlike the simplistic legacy one (which, btw, was only ever intended for subclassing
             support) we "segment" the table into multiple values. Thus a single table can
             actually serve as the persistent storage for multiple independent generators.  One
             approach would be to segment the values by the name of the entity for which we are
             performing generation, which would mean that we would have a row in the generator
             table for each entity name.  Or any configuration really; the setup is very flexible.
             <para>
             In this respect it is very similar to the legacy
             MultipleHiLoPerTableGenerator (not available in NHibernate) in terms of the
             underlying storage structure (namely a single table capable of holding
             multiple generator values). The differentiator is, as with
             <see cref="T:NHibernate.Id.Enhanced.SequenceStyleGenerator"/> as well, the externalized notion
             of an optimizer.
             </para>
             <para>
             <b>NOTE</b> that by default we use a single row for all generators (based
             on <see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaultSegmentValue"/>).  The configuration parameter
             <see cref="F:NHibernate.Id.Enhanced.TableGenerator.ConfigPreferSegmentPerEntity"/> can be used to change that to
             instead default to using a row for each entity name.
             </para>
             Configuration parameters:
            <table>
            	 <tr>
                <td><b>NAME</b></td>
                <td><b>DEFAULT</b></td>
                <td><b>DESCRIPTION</b></td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.TableParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaultTable"/></td>
                <td>The name of the table to use to store/retrieve values</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.ValueColumnParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaultValueColumn"/></td>
                <td>The name of column which holds the sequence value for the given segment</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.SegmentColumnParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaultSegmentColumn"/></td>
                <td>The name of the column which holds the segment key</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.SegmentValueParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaultSegmentValue"/></td>
                <td>The value indicating which segment is used by this generator; refers to values in the <see cref="F:NHibernate.Id.Enhanced.TableGenerator.SegmentColumnParam"/> column</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.SegmentLengthParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaultSegmentLength"/></td>
                <td>The data length of the <see cref="F:NHibernate.Id.Enhanced.TableGenerator.SegmentColumnParam"/> column; used for schema creation</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.InitialParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaltInitialValue"/></td>
                <td>The initial value to be stored for the given segment</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.IncrementParam"/></td>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.DefaultIncrementSize"/></td>
                <td>The increment size for the underlying segment; see the discussion on <see cref="P:NHibernate.Id.Enhanced.TableGenerator.Optimizer"/> for more details.</td>
              </tr>
              <tr>
                <td><see cref="F:NHibernate.Id.Enhanced.TableGenerator.OptimizerParam"/></td>
                <td><i>depends on defined increment size</i></td>
                <td>Allows explicit definition of which optimization strategy to use</td>
              </tr>
            </table>
             </remarks>
        </member>
        <member name="M:NHibernate.Id.Enhanced.TableGenerator.DetermineGeneratorTableName(System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
             Determine the table name to use for the generator values. Called during configuration.
            </summary>
            <param name="parms">The parameters supplied in the generator config (plus some standard useful extras).</param>
        </member>
        <member name="M:NHibernate.Id.Enhanced.TableGenerator.DetermineSegmentColumnName(System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Determine the name of the column used to indicate the segment for each
            row.  This column acts as the primary key.
            Called during configuration.
            </summary>
            <param name="parms">The parameters supplied in the generator config (plus some standard useful extras).</param>
        </member>
        <member name="M:NHibernate.Id.Enhanced.TableGenerator.DetermineValueColumnName(System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Determine the name of the column in which we will store the generator persistent value.
            Called during configuration.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.TableGenerator.DetermineSegmentValue(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Determine the segment value corresponding to this generator instance. Called during configuration.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.TableGenerator.DetermineDefaultSegmentValue(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Used in the cases where <see cref="M:NHibernate.Id.Enhanced.TableGenerator.DetermineSegmentValue(System.Collections.Generic.IDictionary{System.String,System.String})"/> is unable to
            determine the value to use.
            </summary>
        </member>
        <member name="M:NHibernate.Id.Enhanced.TableGenerator.DetermineSegmentColumnSize(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Determine the size of the <see cref="P:NHibernate.Id.Enhanced.TableGenerator.SegmentColumnName"/> segment column.
            Called during configuration.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.IdentifierType">
            <summary>
            Type mapping for the identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.TableName">
            <summary>
            The name of the table in which we store this generator's persistent state.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.SegmentColumnName">
            <summary>
            The name of the column in which we store the segment to which each row
            belongs. The value here acts as primary key.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.SegmentValue">
            <summary>
            The value in the column identified by <see cref="P:NHibernate.Id.Enhanced.TableGenerator.SegmentColumnName"/> which
            corresponds to this generator instance.  In other words, this value
            indicates the row in which this generator instance will store values.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.SegmentValueLength">
            <summary>
            The size of the column identified by <see cref="P:NHibernate.Id.Enhanced.TableGenerator.SegmentColumnName"/>
            in the underlying table.
            </summary>
            <remarks>
            Should really have been called 'segmentColumnLength' or even better 'segmentColumnSize'.
            </remarks>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.ValueColumnName">
            <summary>
            The name of the column in which we store our persistent generator value.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.InitialValue">
            <summary>
            The initial value to use when we find no previous state in the
            generator table corresponding to this instance.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.IncrementSize">
            <summary>
            The amount of increment to use.  The exact implications of this
            depends on the optimizer being used, see <see cref="P:NHibernate.Id.Enhanced.TableGenerator.Optimizer"/>.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.Optimizer">
            <summary>
            The optimizer being used by this generator. This mechanism
            allows avoiding calling the database each time a new identifier
            is needed.
            </summary>
        </member>
        <member name="P:NHibernate.Id.Enhanced.TableGenerator.TableAccessCount">
            <summary>
            The table access count. Only really useful for unit test assertions.
            </summary>
        </member>
        <member name="T:NHibernate.Id.Enhanced.TableStructure">
            <summary>
            Describes a table used to mimic sequence behavior
            </summary>
        </member>
        <member name="T:NHibernate.Id.Insert.AbstractReturningDelegate">
            <summary> 
            Abstract InsertGeneratedIdentifierDelegate implementation where the
            underlying strategy causes the generated identitifer to be returned as an
            effect of performing the insert statement.  Thus, there is no need for an
            additional sql statement to determine the generated identitifer. 
            </summary>
        </member>
        <member name="T:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate">
            <summary> 
            Responsible for handling delegation relating to variants in how
            insert-generated-identifier generator strategies dictate processing:
            <ul>
            <li>building the sql insert statement</li>
            <li>determination of the generated identifier value</li>
            </ul> 
            </summary>
        </member>
        <member name="M:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate.PrepareIdentifierGeneratingInsert">
            <summary> 
            Build a <see cref="T:NHibernate.SqlCommand.SqlInsertBuilder"/> specific to the delegate's mode
            of handling generated key values. 
            </summary>
            <returns> The insert object. </returns>
        </member>
        <member name="M:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate.PerformInsert(NHibernate.SqlCommand.SqlCommandInfo,NHibernate.Engine.ISessionImplementor,NHibernate.Id.Insert.IBinder)">
            <summary> 
            Perform the indicated insert SQL statement and determine the identifier value generated. 
            </summary>
            <param name="insertSQL"> </param>
            <param name="session"> </param>
            <param name="binder"> </param>
            <returns> The generated identifier value. </returns>
        </member>
        <member name="T:NHibernate.Id.Insert.AbstractSelectingDelegate">
            <summary> 
            Abstract InsertGeneratedIdentifierDelegate implementation where the
            underlying strategy requires an subsequent select after the insert
            to determine the generated identifier. 
            </summary>
        </member>
        <member name="M:NHibernate.Id.Insert.AbstractSelectingDelegate.GetResult(NHibernate.Engine.ISessionImplementor,System.Data.IDataReader,System.Object)">
            <summary> Extract the generated key value from the given result set. </summary>
            <param name="session">The session </param>
            <param name="rs">The result set containing the generated primay key values. </param>
            <param name="entity">The entity being saved. </param>
            <returns> The generated identifier </returns>
        </member>
        <member name="M:NHibernate.Id.Insert.AbstractSelectingDelegate.BindParameters(NHibernate.Engine.ISessionImplementor,System.Data.IDbCommand,System.Object)">
            <summary> Bind any required parameter values into the SQL command <see cref="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL"/>. </summary>
            <param name="session">The session </param>
            <param name="ps">The prepared <see cref="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL"/> command </param>
            <param name="entity">The entity being saved. </param>
        </member>
        <member name="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL">
            <summary> Get the SQL statement to be used to retrieve generated key values. </summary>
            <returns> The SQL command string </returns>
        </member>
        <member name="P:NHibernate.Id.Insert.AbstractSelectingDelegate.ParametersTypes">
            <summary>
            Types of any required parameter values into the SQL command <see cref="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Id.Insert.IdentifierGeneratingInsert">
            <summary> 
            Nothing more than a distinguishing subclass of Insert used to indicate
            intent.  
            Some subclasses of this also provided some additional
            functionality or semantic to the genernated SQL statement string.
             </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlInsertBuilder">
            <summary>
            A class that builds an <c>INSERT</c> sql statement.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ISqlStringBuilder">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ISqlStringBuilder.ToSqlString">
            <summary>
            Builds a SqlString from the internal data.
            </summary>
            <returns>A valid SqlString that can be converted into an IDbCommand</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,NHibernate.Type.IType)">
            <summary>
            Adds the Property's columns to the INSERT sql
            </summary>
            <param name="columnName">The column name for the Property</param>
            <param name="propertyType">The IType of the property.</param>
            <returns>The SqlInsertBuilder.</returns>
            <remarks>The column will be associated with a parameter.</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">The value to set for the column.</param>
            <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.String)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="T:NHibernate.Id.Insert.InsertSelectIdentityInsert">
            <summary> 
            Specialized IdentifierGeneratingInsert which appends the database
            specific clause which signifies to return generated IDENTITY values
            to the end of the insert statement. 
            </summary>
        </member>
        <member name="T:NHibernate.Id.Insert.NoCommentsInsert">
            <summary>
            Disable comments on insert.
            </summary>
        </member>
        <member name="T:NHibernate.Id.Insert.OutputParamReturningDelegate">
            <summary> 
            <see cref="T:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate"/> implementation where the
            underlying strategy causes the generated identitifer to be returned, as an
            effect of performing the insert statement, in a Output parameter.
            Thus, there is no need for an additional sql statement to determine the generated identitifer. 
            </summary>
        </member>
        <member name="T:NHibernate.Id.Insert.ReturningIdentifierInsert">
            <summary> 
            Specialized IdentifierGeneratingInsert which appends the database
            specific clause which signifies to return generated identifier values
            to the end of the insert statement. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.AbstractPostInsertGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            The IdentityGenerator for autoincrement/identity key generation. 
            </summary>
            <param name="s">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity the id is being generated for.</param>
            <returns>
            <c>IdentityColumnIndicator</c> Indicates to the Session that identity (i.e. identity/autoincrement column)
            key generation should be used.
            </returns>
        </member>
        <member name="T:NHibernate.Id.Assigned">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns the current identifier
            assigned to an instance.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="assigned" /&gt;</code>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.Assigned.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generates a new identifier by getting the value of the identifier
            for the <c>obj</c> parameter.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The value that was assigned to the mapped <c>id</c>'s property.</returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown when a <see cref="T:NHibernate.Collection.IPersistentCollection"/> is passed in as the <c>obj</c> or
            if the identifier of <c>obj</c> is null.
            </exception>
        </member>
        <member name="T:NHibernate.Id.CounterGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a <c>Int64</c> constructed from the system
            time and a counter value. Not safe for use in a clustser!
            </summary>
        </member>
        <member name="T:NHibernate.Id.ForeignGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that uses the value of 
            the id property of an associated object
            </summary>
            <remarks>
            <para>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="foreign"&gt;
            	&lt;param name="property"&gt;AssociatedObject&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </para>
            The mapping parameter <c>property</c> is required.
            </remarks>
        </member>
        <member name="M:NHibernate.Id.ForeignGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generates an identifer from the value of a Property. 
            </summary>
            <param name="sessionImplementor">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>
            The identifier value from the associated object or  
            <see cref="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator"/> if the <c>session</c>
            already contains <c>obj</c>.
            </returns>
        </member>
        <member name="M:NHibernate.Id.ForeignGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Configures the ForeignGenerator by reading the value of <c>property</c> 
            from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
            <exception cref="T:NHibernate.MappingException">
            Thrown if the key <c>property</c> is not found in the <c>parms</c> parameter.
            </exception>
        </member>
        <member name="T:NHibernate.Id.GuidCombGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <see cref="T:System.Guid"/> values 
            using a strategy suggested Jimmy Nilsson's 
            <a href="http://www.informit.com/articles/article.asp?p=25862">article</a>
            on <a href="http://www.informit.com">informit.com</a>. 
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid.comb" /&gt;</code>
            </p>
            <p>
            The <c>comb</c> algorithm is designed to make the use of GUIDs as Primary Keys, Foreign Keys, 
            and Indexes nearly as efficient as ints.
            </p>
            <p>
            This code was contributed by Donald Mull.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.GuidCombGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.Guid"/> using the comb algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Guid"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.GuidCombGenerator.GenerateComb">
            <summary>
            Generate a new <see cref="T:System.Guid"/> using the comb algorithm.
            </summary>
        </member>
        <member name="T:NHibernate.Id.GuidGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <see cref="T:System.Guid"/> values 
            using <see cref="M:System.Guid.NewGuid">Guid.NewGuid()</see>. 
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid" /&gt;</code>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.GuidGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.Guid"/> for the identifier.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Guid"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.IdentifierGenerationException">
            <summary>
            Thrown by <see cref="T:NHibernate.Id.IIdentifierGenerator"/> implementation class when ID generation fails
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Id.IdentifierGeneratorFactory">
            <summary>
            Factory methods for <c>IdentifierGenerator</c> framework.
            </summary>
            <remarks>
            <p>The built in strategies for identifier generation in NHibernate are:</p>
            <list type="table">
            	<listheader>
            		<term>strategy</term>
            		<description>Implementation of strategy</description>
            	</listheader>
            	<item>
            		<term>assigned</term>
            		<description><see cref="T:NHibernate.Id.Assigned"/></description>
            	</item>
            	<item>
            		<term>counter</term>
            		<description><see cref="T:NHibernate.Id.CounterGenerator"/></description>
            	</item>
            	<item>
            		<term>foreign</term>
            		<description><see cref="T:NHibernate.Id.ForeignGenerator"/></description>
            	</item>
            	<item>
            		<term>guid</term>
            		<description><see cref="T:NHibernate.Id.GuidGenerator"/></description>
            	</item>
            	<item>
            		<term>guid.comb</term>
            		<description><see cref="T:NHibernate.Id.GuidCombGenerator"/></description>
            	</item>
            	<item>
            		<term>guid.native</term>
            		<description><see cref="T:NHibernate.Id.NativeGuidGenerator"/></description>
            	</item>
            	<item>
            		<term>hilo</term>
            		<description><see cref="T:NHibernate.Id.TableHiLoGenerator"/></description>
            	</item>
            	<item>
            		<term>identity</term>
            		<description><see cref="T:NHibernate.Id.IdentityGenerator"/></description>
            	</item>
            	<item>
            		<term>native</term>
            		<description>
            			Chooses between <see cref="T:NHibernate.Id.IdentityGenerator"/>, <see cref="T:NHibernate.Id.SequenceGenerator"/>
            			, and <see cref="T:NHibernate.Id.TableHiLoGenerator"/> based on the 
            			<see cref="T:NHibernate.Dialect.Dialect"/>'s capabilities.
            		</description>
            	</item>
            	<item>
            		<term>seqhilo</term>
            		<description><see cref="T:NHibernate.Id.SequenceHiLoGenerator"/></description>
            	</item>
            	<item>
            		<term>sequence</term>
            		<description><see cref="T:NHibernate.Id.SequenceGenerator"/></description>
            	</item>
            	<item>
            		<term>enhanced-sequence</term>
            		<description><see cref="T:NHibernate.Id.Enhanced.SequenceStyleGenerator"/></description>
            	</item>
            	<item>
            		<term>uuid.hex</term>
            		<description><see cref="T:NHibernate.Id.UUIDHexGenerator"/></description>
            	</item>
            	<item>
            		<term>uuid.string</term>
            		<description><see cref="T:NHibernate.Id.UUIDStringGenerator"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.GetGeneratedIdentity(System.Data.IDataReader,NHibernate.Type.IType,NHibernate.Engine.ISessionImplementor)">
            <summary> Get the generated identifier when using identity columns</summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> to read the identifier value from.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IIdentifierType"/> the value should be converted to.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the value is retrieved in.</param>
            <returns> The value for the identifier. </returns>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Get(System.Data.IDataReader,NHibernate.Type.IType,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Gets the value of the identifier from the <see cref="T:System.Data.IDataReader"/> and
            ensures it is the correct <see cref="T:System.Type"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> to read the identifier value from.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IIdentifierType"/> the value should be converted to.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the value is retrieved in.</param>
            <returns>
            The value for the identifier.
            </returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown if there is any problem getting the value from the <see cref="T:System.Data.IDataReader"/>
            or with converting it to the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.idgenerators">
            <summary>
            An <see cref="T:System.Collections.Hashtable"/> where the <c>key</c> is the strategy and 
            the <c>value</c> is the <see cref="T:System.Type"/> for the strategy.
            </summary>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator">
            <summary>
            When this is returned by <c>Generate()</c> it indicates that the object
            has already been saved.
            </summary>
            <value>
            <see cref="F:System.String.Empty">String.Empty</see>
            </value>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.PostInsertIndicator">
            <summary>
            When this is return
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.#cctor">
            <summary>
            Initializes the static fields in <see cref="T:NHibernate.Id.IdentifierGeneratorFactory"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Create(System.String,NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Creates an <see cref="T:NHibernate.Id.IIdentifierGenerator"/> from the named strategy.
            </summary>
            <param name="strategy">
            The name of the generator to create.  This can be one of the NHibernate abbreviations (ie - <c>native</c>, 
            <c>sequence</c>, <c>guid.comb</c>, etc...), a full class name if the Type is in the NHibernate assembly, or
            a full type name if the strategy is in an external assembly.
            </param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> that the retured identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of <c>&lt;param&gt;</c> values from the mapping.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
            <returns>
            An instantiated and configured <see cref="T:NHibernate.Id.IIdentifierGenerator"/>.
            </returns>
            <exception cref="T:NHibernate.MappingException">
            Thrown if there are any exceptions while creating the <see cref="T:NHibernate.Id.IIdentifierGenerator"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.CreateNumber(System.Int64,System.Type)">
            <summary>
            Create the correct boxed <see cref="T:System.Type"/> for the identifier.
            </summary>
            <param name="value">The value of the new identifier.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <returns>
            The identifier value converted to the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            The <c>type</c> parameter must be an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>,
            or <see cref="T:System.Int64"/>.
            </exception>
        </member>
        <member name="T:NHibernate.Id.IdentityGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that indicates to the <see cref="T:NHibernate.ISession"/> that identity
            (ie. identity/autoincrement column) key generation should be used.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="identity" /&gt;</code> 
            or if the database natively supports identity columns 
            <code>&lt;generator class="native" /&gt;</code>
            </p>
            <p>
            This indicates to NHibernate that the database generates the id when
            the entity is inserted.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IdentityGenerator.InsertSelectDelegate">
            <summary> 
            Delegate for dealing with IDENTITY columns where the dialect supports returning
            the generated IDENTITY value directly from the insert statement.
            </summary>
        </member>
        <member name="T:NHibernate.Id.IdentityGenerator.BasicDelegate">
            <summary> 
            Delegate for dealing with IDENTITY columns where the dialect requires an
            additional command execution to retrieve the generated IDENTITY value
            </summary>
        </member>
        <member name="F:NHibernate.Id.IdGeneratorParmsNames.EntityName">
            <summary> The configuration parameter holding the entity name</summary>
        </member>
        <member name="T:NHibernate.Id.IncrementGenerator">
            <summary>
            An <c>IIdentifierGenerator</c> that returns a <c>Int64</c>, constructed by
            counting from the maximum primary key value at startup. Not safe for use in a
            cluster!
            </summary>
            <remarks>
            <para>
            java author Gavin King, .NET port Mark Holden
            </para>
            <para>
            Mapping parameters supported, but not usually needed: table, column.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
             <summary>
            
             </summary>
             <param name="type"></param>
             <param name="parms"></param>
             <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
             <summary>
            
             </summary>
             <param name="session"></param>
             <param name="obj"></param>
             <returns></returns>
        </member>
        <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Schema">
            <summary> The configuration parameter holding the schema name</summary>
        </member>
        <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Table">
            <summary> 
            The configuration parameter holding the table name for the
            generated id
            </summary>
        </member>
        <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Tables">
            <summary> 
            The configuration parameter holding the table names for all
            tables for which the id must be unique
            </summary>
        </member>
        <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.PK">
            <summary> 
            The configuration parameter holding the primary key column
            name of the generated id
            </summary>
        </member>
        <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Catalog">
            <summary> The configuration parameter holding the catalog name</summary>
        </member>
        <member name="T:NHibernate.Id.IPostInsertIdentityPersister">
            <summary> 
            A persister that may have an identity assigned by execution of a SQL <tt>INSERT</tt>. 
            </summary>
        </member>
        <member name="M:NHibernate.Id.IPostInsertIdentityPersister.GetSelectByUniqueKeyString(System.String)">
            <summary> 
            Get a SQL select string that performs a select based on a unique
            key determined by the given property name). 
            </summary>
            <param name="propertyName">
            The name of the property which maps to the
            column(s) to use in the select statement restriction.
            </param>
            <returns> The SQL select string </returns>
        </member>
        <member name="P:NHibernate.Id.IPostInsertIdentityPersister.IdentitySelectString">
            <summary> 
            Get the database-specific SQL command to retrieve the last
            generated IDENTITY value.
            </summary>
        </member>
        <member name="P:NHibernate.Id.IPostInsertIdentityPersister.RootTableKeyColumnNames">
            <summary> The names of the primary key columns in the root table. </summary>
            <returns> The primary key column names. </returns>
        </member>
        <member name="P:NHibernate.Id.IPostInsertIdentityPersister.IdentifierType">
            <summary>
            Get the identifier type
            </summary>
        </member>
        <member name="T:NHibernate.Id.NativeGuidGenerator">
            <summary>
            Generates Guid values using the server side Guid function.
            </summary>
        </member>
        <member name="T:NHibernate.Id.SelectGenerator">
            <summary> 
            A generator that selects the just inserted row to determine the identifier
            value assigned by the database. The correct row is located using a unique key.
            </summary>
            <remarks>One mapping parameter is required: key (unless a natural-id is defined in the mapping).</remarks>
        </member>
        <member name="T:NHibernate.Id.SelectGenerator.SelectGeneratorDelegate">
            <summary> The delegate for the select generation strategy.</summary>
        </member>
        <member name="T:NHibernate.Id.SequenceGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <c>Int64</c> values using an 
            oracle-style sequence. A higher performance algorithm is 
            <see cref="T:NHibernate.Id.SequenceHiLoGenerator"/>.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="sequence"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>sequence</c> parameter is required while the <c>schema</c> is optional.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.SequenceGenerator.Sequence">
            <summary>
            The name of the sequence parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.SequenceGenerator.Parameters">
            <summary> 
            The parameters parameter, appended to the create sequence DDL.
            For example (Oracle): <tt>INCREMENT BY 1 START WITH 1 MAXVALUE 100 NOCACHE</tt>.
            </summary>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Configures the SequenceGenerator by reading the value of <c>sequence</c> and
            <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by using a database sequence.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the database objects for a SequenceGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the Dialect specific sql to 
            create the necessary database objects for the SequenceGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects for a SequenceGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects for the SequenceGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects for a SequenceGenerator.
            </summary>
            <returns>
            The configured sequence name.
            </returns>
        </member>
        <member name="T:NHibernate.Id.SequenceHiLoGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that combines a hi/lo algorithm with an underlying
            oracle-style sequence that generates hi values.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="seqhilo"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>sequence</c> parameter is required, the <c>max_lo</c> and <c>schema</c> are optional.
            </p>
            <p>
            The user may specify a <c>max_lo</c> value to determine how often new hi values are
            fetched. If sequences are not avaliable, <c>TableHiLoGenerator</c> might be an
            alternative.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.SequenceHiLoGenerator.MaxLo">
            <summary>
            The name of the maximum low value parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.SequenceHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Configures the SequenceHiLoGenerator by reading the value of <c>sequence</c>, <c>max_lo</c>, 
            and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.SequenceHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by using a database sequence.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.SequenceIdentityGenerator">
            <summary>
            A generator which combines sequence generation with immediate retrieval
            by attaching a output parameter to the SQL command
            In this respect it works much like ANSI-SQL IDENTITY generation.
            </summary>
        </member>
        <member name="T:NHibernate.Id.TableGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that uses a database table to store the last
            generated value.
            </summary>
            <remarks>
            <p>
            It is not intended that applications use this strategy directly. However,
            it may be used to build other (efficient) strategies. The return type is
            <c>System.Int32</c>
            </p>
            <p>
            The hi value MUST be fetched in a separate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and commit it.
            Hence this implementation may not be used when the user is supplying connections.
            </p>
            <p>
            The mapping parameters <c>table</c> and <c>column</c> are required.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.Where">
            <summary>
            An additional where clause that is added to 
            the queries against the table.
            </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.ColumnParamName">
            <summary>
            The name of the column parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.TableParamName">
            <summary>
            The name of the table parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.DefaultColumnName">
            <summary>Default column name </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.DefaultTableName">
            <summary>Default table name </summary>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Configures the TableGenerator by reading the value of <c>table</c>, 
            <c>column</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by selecting and updating a value in a table.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the database objects for a TableGenerator.
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the Dialect specific sql to 
            create the necessary database objects and to create the first value as <c>1</c> 
            for the TableGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects for a TableGenerator.
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects for the TableGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects for a TableGenerator.
            </summary>
            <returns>
            The configured table name.
            </returns>
        </member>
        <member name="T:NHibernate.Id.TableHiLoGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns an <c>Int64</c>, constructed using
            a hi/lo algorithm.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="hilo"&gt;
            	&lt;param name="table"&gt;table&lt;/param&gt;
            	&lt;param name="column"&gt;id_column&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>table</c> and <c>column</c> parameters are required, the <c>max_lo</c> and 
            <c>schema</c> are optional.
            </p>
            <p>
            The hi value MUST be fecthed in a separate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and 
            commit it. Hence this implementation may not be used when the user is supplying
            connections.  In that case a <see cref="T:NHibernate.Id.SequenceHiLoGenerator"/> would be a 
            better choice (where supported).
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.TableHiLoGenerator.MaxLo">
            <summary>
            The name of the max lo parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.TableHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Configures the TableHiLoGenerator by reading the value of <c>table</c>, 
            <c>column</c>, <c>max_lo</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.TableHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a <see cref="T:System.Int64"/> for the identifier by selecting and updating a value in a table.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.UUIDHexGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a string of length
            32, 36, or 38 depending on the configuration.  
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="uuid.hex"&gt;
            	&lt;param name="format"&gt;format_string&lt;/param&gt;
            	&lt;param name="seperator"&gt;seperator_string&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>format</c> and <c>seperator</c> parameters are optional.
            </p>
            <p>
            The identifier string will consist of only hex digits.  Optionally, the identifier string
            may be generated with enclosing characters and seperators between each component 
            of the UUID.  If there are seperators then the string length will be 36.  If a format
            that has enclosing brackets is used, then the string length will be 38.
            </p>
            <p>
            <c>format</c> is either 
            "N" (<c>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</c>), 
            "D" (<c>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</c>), 
            "B" (<c>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</c>), 
            or "P" (<c>(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</c>).  These formats are described in
            the <see cref="M:System.Guid.ToString(System.String)">Guid.ToString(String)</see> method.
            If no <c>format</c> is specified the default is "N".
            </p>
            <p>
            <c>seperator</c> is the char that will replace the "-" if specified.  If no value is
            configured then the default seperator for the format will be used.  If the format "D", "B", or
            "P" is specified, then the seperator will replace the "-".  If the format is "N" then this
            parameter will be ignored.
            </p>
            <p>
            This class is based on <see cref="T:System.Guid"/>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.UUIDHexGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.String"/> for the identifier using the "uuid.hex" algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.UUIDHexGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
            <summary>
            Configures the UUIDHexGenerator by reading the value of <c>format</c> and
            <c>seperator</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.UUIDHexGenerator.GenerateNewGuid">
            <summary>
            Generate a Guid into a string using the <c>format</c>.
            </summary>
            <returns>A new Guid string</returns>
        </member>
        <member name="T:NHibernate.Id.UUIDStringGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a string of length
            16.  
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="uuid.string" /&gt;</code>
            </p>
            <para>
            The identifier string will NOT consist of only alphanumeric characters.  Use
            this only if you don't mind unreadable identifiers.
            </para>
            <para>
            This impelementation was known to be incompatible with Postgres.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.UUIDStringGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.String"/> for the identifier using the "uuid.string" algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.String"/>.</returns>
        </member>
        <member name="T:NHibernate.Impl.AbstractDetachedQuery">
            <summary>
            Base class to create queries in "detached mode" where the NHibernate session is not available.
            </summary>
            <seealso cref="T:NHibernate.IDetachedQuery"/>
            <seealso cref="T:NHibernate.Impl.AbstractQueryImpl"/>
            <remarks>
            The behaviour of each method is basically the same of <see cref="T:NHibernate.Impl.AbstractQueryImpl"/> methods.
            The main difference is on <see cref="M:NHibernate.Impl.AbstractDetachedQuery.SetProperties(System.Object)"/>:
            If you mix <see cref="T:System.Object"/> with named parameters setter, if same param name are found,
            the value of the parameter setter override the value read from the POCO.
            </remarks>
        </member>
        <member name="T:NHibernate.IDetachedQuery">
            <summary>
            Interface  to create queries in "detached mode" where the NHibernate session is not available.
            All methods have the same semantics as the corresponding methods of the <see cref="T:NHibernate.IQuery"/> interface.
            </summary>
        </member>
        <member name="M:NHibernate.IDetachedQuery.GetExecutableQuery(NHibernate.ISession)">
            <summary>
            Get an executable instance of <see cref="T:NHibernate.IQuery"/>,
            to actually run the query.</summary>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetMaxResults(System.Int32)">
            <summary>
            Set the maximum number of rows to retrieve.
            </summary>
            <param name="maxResults">The maximum number of rows to retreive.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetFirstResult(System.Int32)">
            <summary>
            Sets the first row to retrieve.
            </summary>
            <param name="firstResult">The first row to retreive.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set.
            </summary>
            <param name="cacheable">Should the query results be cacheable?</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="cacheRegion">The name of a query cache region, or <see langword="null" />
            for the default query cache</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetReadOnly(System.Boolean)">
            <summary> 
            Entities retrieved by this query will be loaded in 
            a read-only mode where Hibernate will never dirty-check
            them or make changes persistent. 
            </summary>
            <param name="readOnly">Enable/Disable read -only mode</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetTimeout(System.Int32)">
            <summary>
            The timeout for the underlying ADO query
            </summary>
            <param name="timeout"></param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetFetchSize(System.Int32)">
            <summary> Set a fetch size for the underlying ADO query.</summary>
            <param name="fetchSize">the fetch size </param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            Set the lockmode for the objects idententified by the
            given alias that appears in the <c>FROM</c> clause.
            </summary>
            <param name="alias">alias a query alias, or <c>this</c> for a collection filter</param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetComment(System.String)">
            <summary> Add a comment to the generated SQL.</summary>
            <param name="comment">a human-readable string </param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetParameter(System.Int32,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to an indexed parameter.
            </summary>
            <param name="position">Position of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The Hibernate type</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to a named query parameter
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetParameter(System.Int32,System.Object)">
            <summary>
            Bind a value to an indexed parameter, guessing the Hibernate type from
            the class of the given object.
            </summary>
            <param name="position">The position of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetParameter(System.String,System.Object)">
            <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType"/>
            from the class of the given object.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetParameterList(System.String,System.Collections.IEnumerable,NHibernate.Type.IType)">
            <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
            <param name="type">The Hibernate type of the values</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetParameterList(System.String,System.Collections.IEnumerable)">
            <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetProperties(System.Object)">
            <summary>
            Bind the property values of the given object to named parameters of the query,
            matching property names with parameter names and mapping property types to
            Hibernate types using heuristics.
            </summary>
            <param name="obj">Any POCO</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetAnsiString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetAnsiString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetBinary(System.Int32,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetBinary(System.String,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetBoolean(System.Int32,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetBoolean(System.String,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetByte(System.Int32,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetByte(System.String,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetCharacter(System.Int32,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetCharacter(System.String,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetDateTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetDateTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <param name="name">The name of the parameter</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetDecimal(System.Int32,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetDecimal(System.String,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetDouble(System.Int32,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetDouble(System.String,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetEntity(System.Int32,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to an indexed parameter.
            </summary>
            <param name="position">Position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetEntity(System.String,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetEnum(System.Int32,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetEnum(System.String,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetInt16(System.Int32,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetInt16(System.String,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetInt32(System.Int32,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetInt32(System.String,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetInt64(System.Int32,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetInt64(System.String,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetSingle(System.Int32,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetSingle(System.String,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetTimestamp(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetTimestamp(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetGuid(System.Int32,System.Guid)">
            <summary>
            Bind an instance of a <see cref="T:System.Guid"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">An instance of a <see cref="T:System.Guid"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetGuid(System.String,System.Guid)">
            <summary>
            Bind an instance of a <see cref="T:System.Guid"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">An instance of a <see cref="T:System.Guid"/>.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetFlushMode(NHibernate.FlushMode)">
            <summary>
            Override the current session flush mode, just for this query.
            </summary>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetIgnoreUknownNamedParameters(System.Boolean)">
            <summary>
            Set the value to ignore unknown parameters names.
            </summary>
            <param name="ignoredUnknownNamedParameters">True to ignore unknown parameters names.</param>
        </member>
        <member name="M:NHibernate.IDetachedQuery.SetCacheMode(NHibernate.CacheMode)">
            <summary> Override the current session cache mode, just for this query. </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="T:NHibernate.Impl.IDetachedQueryImplementor">
            <summary>
            Interface for DetachedQuery implementors.
            </summary>
            <remarks>
            When you are working with queries in "detached mode" you may need some additional services like clone, 
            copy of parameters from another query and so on.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.IDetachedQueryImplementor.CopyTo(NHibernate.IDetachedQuery)">
            <summary>
            Copy all properties to a given <see cref="T:NHibernate.IDetachedQuery"/>.
            </summary>
            <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery"/>.</param>
            <remarks>
            Usually the implementation use <see cref="T:NHibernate.IDetachedQuery"/> to set properties to the <paramref name="destination"/>.
            This mean that existing properties are merged/overriden.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.IDetachedQueryImplementor.SetParametersTo(NHibernate.IDetachedQuery)">
            <summary>
            Set only parameters to a given <see cref="T:NHibernate.IDetachedQuery"/>.
            </summary>
            <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery"/>.</param>
            <remarks>
            Existing parameters are merged/overriden.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.IDetachedQueryImplementor.OverrideInfoFrom(NHibernate.Impl.IDetachedQueryImplementor)">
            <summary>
            Override all properties reading new values from a given <see cref="T:NHibernate.Impl.IDetachedQueryImplementor"/>.
            </summary>
            <param name="origin">The given origin.</param>
        </member>
        <member name="M:NHibernate.Impl.IDetachedQueryImplementor.OverrideParametersFrom(NHibernate.Impl.IDetachedQueryImplementor)">
            <summary>
            Override all parameters reading new values from a given <see cref="T:NHibernate.Impl.IDetachedQueryImplementor"/>.
            </summary>
            <param name="origin">The given origin.</param>
        </member>
        <member name="M:NHibernate.Impl.AbstractDetachedQuery.SetCacheMode(NHibernate.CacheMode)">
            <summary> Override the current session cache mode, just for this query. </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractDetachedQuery.SetQueryProperties(NHibernate.IQuery)">
            <summary>
            Fill all <see cref="T:NHibernate.IQuery"/> properties.
            </summary>
            <param name="q">The <see cref="T:NHibernate.IQuery"/>.</param>
            <remarks>
            Query properties are overriden/merged.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.AbstractDetachedQuery.CopyTo(NHibernate.IDetachedQuery)">
            <summary>
            Copy all properties to a given <see cref="T:NHibernate.IDetachedQuery"/>.
            </summary>
            <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery"/>.</param>
            <remarks>
            The method use <see cref="T:NHibernate.IDetachedQuery"/> to set properties of <paramref name="destination"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.AbstractDetachedQuery.SetParametersTo(NHibernate.IDetachedQuery)">
            <summary>
            Set only parameters to a given <see cref="T:NHibernate.IDetachedQuery"/>.
            </summary>
            <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery"/>.</param>
            <remarks>
            The method use <see cref="T:NHibernate.IDetachedQuery"/> to set properties of <paramref name="destination"/>.
            Existing parameters in <paramref name="destination"/> are merged/overriden.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.AbstractDetachedQuery.CopyParametersFrom(NHibernate.Impl.IDetachedQueryImplementor)">
            <summary>
            Clear all existing parameters and copy new parameters from a given origin.
            </summary>
            <param name="origin">The origin of parameters.</param>
            <returns>The current instance</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="origin"/> is null.</exception>
        </member>
        <member name="T:NHibernate.Impl.AbstractQueryImpl">
            <summary>
            Abstract implementation of the IQuery interface.
            </summary>
        </member>
        <member name="T:NHibernate.IQuery">
            <summary>
            An object-oriented representation of a NHibernate query.
            </summary>
            <remarks>
            An <c>IQuery</c> instance is obtained by calling <see cref="M:NHibernate.ISession.CreateQuery(System.String)"/>.
            Key features of this interface include:
            <list type="bullet">
            	<item>
            		Paging: A particular page of the result set may be selected by calling
            		<see cref="M:NHibernate.IQuery.SetMaxResults(System.Int32)"/>, <see cref="M:NHibernate.IQuery.SetFirstResult(System.Int32)"/>.  The generated SQL
            		depends on the capabilities of the <see cref="T:NHibernate.Dialect.Dialect"/>.  Some
            		Dialects are for databases that have built in paging (LIMIT) and those capabilities
            		will be used to limit the number of records returned by the SQL statement.
            		If the database does not support LIMITs then all of the records will be returned,
            		but the objects created will be limited to the specific results requested.
            	</item>
            	<item>
            		Named parameters
            	</item>
            	<item>
            		Ability to return 'read-only' entities
            	</item>
            </list>
            <para>
            Named query parameters are tokens of the form <c>:name</c> in the query string. For example, a
            value is bound to the <c>Int32</c> parameter <c>:foo</c> by calling:
            <code>
            SetParameter("foo", foo, NHibernateUtil.Int32);
            </code>
            A name may appear multiple times in the query string.
            </para>
            <para>
            Unnamed parameters <c>?</c> are also supported. To bind a value to an unnamed
            parameter use a Set method that accepts an <c>Int32</c> positional argument - numbered from
            zero.
            </para>
            <para>
            You may not mix and match unnamed parameters and named parameters in the same query.
            </para>
            <para>
            Queries are executed by calling <see cref="M:NHibernate.IQuery.List"/> or <see cref="M:NHibernate.IQuery.Enumerable"/>. A query
            may be re-executed by subsequent invocations. Its lifespan is, however, bounded by the lifespan
            of the <c>ISession</c> that created it.
            </para>
            <para>
            Implementors are not intended to be threadsafe.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.Enumerable">
            <summary>
            Return the query results as an <see cref="T:System.Collections.IEnumerable"/>. If the query contains multiple results
            per row, the results are returned in an instance of <c>object[]</c>.
            </summary>
            <remarks>
            <p>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only.
            </p>
            <p>
            This is a good strategy to use if you expect a high number of the objects
            returned to be already loaded in the <see cref="T:NHibernate.ISession"/> or in the 2nd level cache.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.Enumerable``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.Enumerable"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IQuery.List">
            <summary>
            Return the query results as an <see cref="T:System.Collections.IList"/>. If the query contains multiple results per row,
            the results are returned in an instance of <c>object[]</c>.
            </summary>
            <returns>The <see cref="T:System.Collections.IList"/> filled with the results.</returns>
            <remarks>
            This is a good strategy to use if you expect few of the objects being returned are already loaded
            or if you want to fill the 2nd level cache.
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.List(System.Collections.IList)">
            <summary>
            Return the query results an place them into the <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="results">The <see cref="T:System.Collections.IList"/> to place the results in.</param>
        </member>
        <member name="M:NHibernate.IQuery.List``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.List"/>.
            </summary>
        </member>
        <member name="M:NHibernate.IQuery.UniqueResult">
            <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
            <returns>the single result or <see langword="null"/></returns>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when there is more than one matching result.
            </exception>
        </member>
        <member name="M:NHibernate.IQuery.UniqueResult``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.UniqueResult"/>.
            </summary>
        </member>
        <member name="M:NHibernate.IQuery.ExecuteUpdate">
            <summary>
            Execute the update or delete statement.
            </summary>
            <returns> The number of entities updated or deleted. </returns>
        </member>
        <member name="M:NHibernate.IQuery.SetMaxResults(System.Int32)">
            <summary>
            Set the maximum number of rows to retrieve.
            </summary>
            <param name="maxResults">The maximum number of rows to retreive.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetFirstResult(System.Int32)">
            <summary>
            Sets the first row to retrieve.
            </summary>
            <param name="firstResult">The first row to retreive.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetReadOnly(System.Boolean)">
            <summary>
            Set the read-only mode for entities (and proxies) loaded by this query. This setting 
            overrides the default setting for the session (see <see cref="P:NHibernate.ISession.DefaultReadOnly"/>).
            </summary>
            <remarks>
            <para>
            Read-only entities can be modified, but changes are not persisted. They are not 
            dirty-checked and snapshots of persistent state are not maintained.
            </para>
            <para>
            When a proxy is initialized, the loaded entity will have the same read-only setting 
            as the uninitialized proxy, regardless of the session's current setting.
            </para>
            <para>
            The read-only setting has no impact on entities or proxies returned by the criteria
            that existed in the session before the criteria was executed.
            </para>
            </remarks>
            <param name="readOnly">
            If <c>true</c>, entities (and proxies) loaded by the query will be read-only.
            </param>
            <returns><c>this</c> (for method chaining)</returns>
            <seealso cref="P:NHibernate.IQuery.IsReadOnly"/>
        </member>
        <member name="M:NHibernate.IQuery.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set.
            </summary>
            <param name="cacheable">Should the query results be cacheable?</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="cacheRegion">The name of a query cache region, or <see langword="null" />
            for the default query cache</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimeout(System.Int32)">
            <summary>
            The timeout for the underlying ADO query
            </summary>
            <param name="timeout"></param>
        </member>
        <member name="M:NHibernate.IQuery.SetFetchSize(System.Int32)">
            <summary> Set a fetch size for the underlying ADO query.</summary>
            <param name="fetchSize">the fetch size </param>
        </member>
        <member name="M:NHibernate.IQuery.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            Set the lockmode for the objects idententified by the
            given alias that appears in the <c>FROM</c> clause.
            </summary>
            <param name="alias">alias a query alias, or <c>this</c> for a collection filter</param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.IQuery.SetComment(System.String)">
            <summary> Add a comment to the generated SQL.</summary>
            <param name="comment">a human-readable string </param>
        </member>
        <member name="M:NHibernate.IQuery.SetFlushMode(NHibernate.FlushMode)">
            <summary>
            Override the current session flush mode, just for this query.
            </summary>
        </member>
        <member name="M:NHibernate.IQuery.SetCacheMode(NHibernate.CacheMode)">
            <summary> Override the current session cache mode, just for this query. </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to an indexed parameter.
            </summary>
            <param name="position">Position of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The NHibernate type</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to a named query parameter
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter``1(System.Int32,``0)">
            <summary>
            Bind a value to an indexed parameter.
            </summary>
            <param name="position">Position of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The possibly null parameter value</param>
            <typeparam name="T">The parameter's <see cref="N:NHibernate.Type"/> </typeparam>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter``1(System.String,``0)">
            <summary>
            Bind a value to a named query parameter
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The possibly null parameter value</param>
            <typeparam name="T">The parameter's <see cref="N:NHibernate.Type"/> </typeparam>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object)">
            <summary>
            Bind a value to an indexed parameter, guessing the NHibernate type from
            the class of the given object.
            </summary>
            <param name="position">The position of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object)">
            <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType"/>
            from the class of the given object.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.IEnumerable,NHibernate.Type.IType)">
            <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
            <param name="type">The NHibernate type of the values</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.IEnumerable)">
            <summary>
            Bind multiple values to a named query parameter, guessing the NHibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
        </member>
        <member name="M:NHibernate.IQuery.SetProperties(System.Object)">
            <summary>
            Bind the property values of the given object to named parameters of the query,
            matching property names with parameter names and mapping property types to
            NHibernate types using heuristics.
            </summary>
            <param name="obj">Any PONO</param>
        </member>
        <member name="M:NHibernate.IQuery.SetAnsiString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetAnsiString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBinary(System.Int32,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBinary(System.String,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBoolean(System.Int32,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBoolean(System.String,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetByte(System.Int32,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetByte(System.String,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCharacter(System.Int32,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCharacter(System.String,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDateTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDateTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <param name="name">The name of the parameter</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDecimal(System.Int32,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDecimal(System.String,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDouble(System.Int32,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDouble(System.String,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEnum(System.Int32,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEnum(System.String,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt16(System.Int32,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt16(System.String,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt32(System.Int32,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt32(System.String,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt64(System.Int32,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt64(System.String,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetSingle(System.Int32,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetSingle(System.String,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimestamp(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimestamp(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetGuid(System.Int32,System.Guid)">
            <summary>
            Bind an instance of a <see cref="T:System.Guid"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">An instance of a <see cref="T:System.Guid"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetGuid(System.String,System.Guid)">
            <summary>
            Bind an instance of a <see cref="T:System.Guid"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">An instance of a <see cref="T:System.Guid"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEntity(System.Int32,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to an indexed parameter.
            </summary>
            <param name="position">Position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEntity(System.String,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
        </member>
        <member name="M:NHibernate.IQuery.Future``1">
            <summary>
            Get a enumerable that when enumerated will execute
            a batch of queries in a single database roundtrip
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IQuery.FutureValue``1">
            <summary>
            Get an IFutureValue instance, whose value can be retrieved through
            its Value property. The query is not executed until the Value property
            is retrieved, which will execute other Future queries as well in a
            single roundtrip
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:NHibernate.IQuery.QueryString">
            <summary>
            The query string
            </summary>
        </member>
        <member name="P:NHibernate.IQuery.ReturnTypes">
            <summary>
            The NHibernate types of the query result set.
            </summary>
        </member>
        <member name="P:NHibernate.IQuery.ReturnAliases">
            <summary> Return the HQL select clause aliases (if any)</summary>
            <returns> An array of aliases as strings </returns>
        </member>
        <member name="P:NHibernate.IQuery.NamedParameters">
            <summary>
            The names of all named parameters of the query
            </summary>
            <value>The parameter names, in no particular order</value>
        </member>
        <member name="P:NHibernate.IQuery.IsReadOnly">
            <summary>
            Will entities (and proxies) returned by the query be loaded in read-only mode?
            </summary>
            <remarks>
            <para>
            If the query's read-only setting is not initialized (with <see cref="M:NHibernate.IQuery.SetReadOnly(System.Boolean)"/>),
            the value of the session's <see cref="P:NHibernate.ISession.DefaultReadOnly"/> property is
            returned instead.
            </para>
            <para>
            The value of this property has no effect on entities or proxies returned by the
            query that existed in the session before the query was executed.
            </para>
            </remarks>
            <returns>
            <c>true</c> if entities and proxies loaded by the query will be put in read-only mode, otherwise <c>false</c>.
            </returns>
            <seealso cref="M:NHibernate.IQuery.SetReadOnly(System.Boolean)"/>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.VerifyParameters(System.Boolean)">
            <summary>
            Perform parameter validation.  Used prior to executing the encapsulated query.
            </summary>
            <param name="reserveFirstParameter">
            if true, the first ? will not be verified since
            its needed for e.g. callable statements returning a out parameter
            </param>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Object)">
            <summary>
            Guesses the <see cref="T:NHibernate.Type.IType"/> from the <c>param</c>'s value.
            </summary>
            <param name="param">The object to guess the <see cref="T:NHibernate.Type.IType"/> of.</param>
            <returns>An <see cref="T:NHibernate.Type.IType"/> for the object.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>param</c> is null because the <see cref="T:NHibernate.Type.IType"/>
            can't be guess from a null value.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Type)">
            <summary>
            Guesses the <see cref="T:NHibernate.Type.IType"/> from the <see cref="T:System.Type"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to guess the <see cref="T:NHibernate.Type.IType"/> of.</param>
            <returns>An <see cref="T:NHibernate.Type.IType"/> for the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>clazz</c> is null because the <see cref="T:NHibernate.Type.IType"/>
            can't be guess from a null type.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.ExpandParameterLists(System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue})">
            <summary>
            Warning: adds new parameters to the argument by side-effect, as well as mutating the query string!
            </summary>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.ExpandParameterList(System.String,System.String,NHibernate.Engine.TypedValue,System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue})">
            <summary>
            Warning: adds new parameters to the argument by side-effect, as well as mutating the query string!
            </summary>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetReadOnly(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetCacheMode(NHibernate.CacheMode)">
            <summary> Override the current session cache mode, just for this query.
            </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="P:NHibernate.Impl.AbstractQueryImpl.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl2.ExpandParameters(System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue})">
            <summary> 
            Warning: adds new parameters to the argument by side-effect, as well as mutating the query expression tree!
            </summary>
        </member>
        <member name="T:NHibernate.Impl.AbstractSessionImpl">
            <summary> Functionality common to stateless and stateful sessions </summary>
        </member>
        <member name="T:NHibernate.Impl.CollectionFilterImpl">
            <summary>
            Implementation of the <see cref="T:NHibernate.IQuery"/> interface for collection filters.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.QueryImpl">
            <summary> 
            Default implementation of the <see cref="T:NHibernate.IQuery"/>,
            for "ordinary" HQL queries (not collection filters)
            </summary>
            <seealso cref="T:NHibernate.Impl.CollectionFilterImpl"/>
        </member>
        <member name="T:NHibernate.Impl.CriteriaImpl">
            <summary>
            Implementation of the <see cref="T:NHibernate.ICriteria"/> interface
            </summary>
        </member>
        <member name="T:NHibernate.ICriteria">
            <summary>
            Criteria is a simplified API for retrieving entities by composing
            <see cref="T:NHibernate.Criterion.Expression"/> objects.
            </summary>
            <remarks>
            <para>
            Using criteria is a very convenient approach for functionality like "search" screens
            where there is a variable number of conditions to be placed upon the result set.
            </para>
            <para>
            The Session is a factory for ICriteria. Expression instances are usually obtained via
            the factory methods on <see cref="T:NHibernate.Criterion.Expression"/>. eg:
            </para>
            <code>
            IList cats = session.CreateCriteria(typeof(Cat))
            	.Add(Expression.Like("name", "Iz%"))
            	.Add(Expression.Gt("weight", minWeight))
            	.AddOrder(Order.Asc("age"))
            	.List();
            </code>
            You may navigate associations using <see cref="M:NHibernate.ICriteria.CreateAlias(System.String,System.String)"/>
            or <see cref="M:NHibernate.ICriteria.CreateCriteria(System.String)"/>. eg:
            <code>
            	IList&lt;Cat&gt; cats = session.CreateCriteria&lt;Cat&gt;
            		.CreateCriteria("kittens")
            		.Add(Expression.like("name", "Iz%"))
            		.List&lt;Cat&gt;();
            </code>
            <para>
            You may specify projection and aggregation using <c>Projection</c> instances obtained
            via the factory methods on <c>Projections</c>. eg:
            <code>
            	IList&lt;Cat&gt; cats = session.CreateCriteria&lt;Cat&gt;
            		.SetProjection(
            			Projections.ProjectionList()
            				.Add(Projections.RowCount())
            				.Add(Projections.Avg("weight"))
            				.Add(Projections.Max("weight"))
            				.Add(Projections.Min("weight"))
            				.Add(Projections.GroupProperty("color")))
            		.AddOrder(Order.Asc("color"))
            		.List&lt;Cat&gt;();
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.ICriteria.SetProjection(NHibernate.Criterion.IProjection[])">
            <summary>
            Used to specify that the query results will be a projection (scalar in
            nature).  Implicitly specifies the projection result transformer.
            </summary>
            <param name="projection">The projection representing the overall "shape" of the
            query results.</param>
            <returns>This instance (for method chaining)</returns>
            <remarks>
            <para>
            The individual components contained within the given <see cref="T:NHibernate.Criterion.IProjection"/>
            determines the overall "shape" of the query result.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.ICriteria.Add(NHibernate.Criterion.ICriterion)">
            <summary>
            Add an Expression to constrain the results to be retrieved.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.AddOrder(NHibernate.Criterion.Order)">
            <summary>
            An an Order to the result set
            </summary>
            <param name="order"></param>
        </member>
        <member name="M:NHibernate.ICriteria.SetFetchMode(System.String,NHibernate.FetchMode)">
            <summary>
            Specify an association fetching strategy.  Currently, only
            one-to-many and one-to-one associations are supported.
            </summary>
            <param name="associationPath">A dot separated property path.</param>
            <param name="mode">The Fetch mode.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetLockMode(NHibernate.LockMode)">
            <summary>
            Set the lock mode of the current entity
            </summary>
            <param name="lockMode">the lock mode</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            Set the lock mode of the aliased entity
            </summary>
            <param name="alias">an alias</param>
            <param name="lockMode">the lock mode</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String,NHibernate.SqlCommand.JoinType)">
            <summary>
            Join an association using the specified join-type, assigning an alias to the joined
            association
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <param name="joinType">The type of join to use.</param>
            <returns>this (for method chaining)</returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String,NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Join an association using the specified join-type, assigning an alias to the joined
            association
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <param name="joinType">The type of join to use.</param>
            <param name="withClause">The criteria to be added to the join condition (ON clause)</param>
            <returns>this (for method chaining)</returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity
            </summary>
            <param name="associationPath"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,NHibernate.SqlCommand.JoinType)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity,
            using the specified join type.
            </summary>
            <param name="associationPath">A dot-separated property path</param>
            <param name="joinType">The type of join to use</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity,
            assigning the given alias
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String,NHibernate.SqlCommand.JoinType)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity,
            assigning the given alias and using the specified join type.
            </summary>
            <param name="associationPath">A dot-separated property path</param>
            <param name="alias">The alias to assign to the joined association (for later reference).</param>
            <param name="joinType">The type of join to use.</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String,NHibernate.SqlCommand.JoinType,NHibernate.Criterion.ICriterion)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity,
            assigning the given alias and using the specified join type.
            </summary>
            <param name="associationPath">A dot-separated property path</param>
            <param name="alias">The alias to assign to the joined association (for later reference).</param>
            <param name="joinType">The type of join to use.</param>
            <param name="withClause">The criteria to be added to the join condition (ON clause)</param>
            <returns>The created "sub criteria"</returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This determines the
            "shape" of the query result set.
            <seealso cref="F:NHibernate.Criterion.CriteriaSpecification.RootEntity"/>
            <seealso cref="F:NHibernate.Criterion.CriteriaSpecification.DistinctRootEntity"/>
            <seealso cref="F:NHibernate.Criterion.CriteriaSpecification.AliasToEntityMap"/>
            </summary>
            <param name="resultTransformer"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetMaxResults(System.Int32)">
            <summary>
            Set a limit upon the number of objects to be retrieved
            </summary>
            <param name="maxResults"></param>
        </member>
        <member name="M:NHibernate.ICriteria.SetFirstResult(System.Int32)">
            <summary>
            Set the first result to be retrieved
            </summary>
            <param name="firstResult"></param>
        </member>
        <member name="M:NHibernate.ICriteria.SetFetchSize(System.Int32)">
            <summary> Set a fetch size for the underlying ADO query. </summary>
            <param name="fetchSize">the fetch size </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetTimeout(System.Int32)">
            <summary>
            Set a timeout for the underlying ADO.NET query
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set
            </summary>
            <param name="cacheable"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetCacheRegion(System.String)">
            <summary>
            Set the name of the cache region.
            </summary>
            <param name="cacheRegion">the name of a query cache region, or <see langword="null" />
            for the default query cache</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetComment(System.String)">
            <summary> Add a comment to the generated SQL. </summary>
            <param name="comment">a human-readable string </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetFlushMode(NHibernate.FlushMode)">
            <summary> Override the flush mode for this particular query. </summary>
            <param name="flushMode">The flush mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetCacheMode(NHibernate.CacheMode)">
            <summary> Override the cache mode for this particular query. </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.ICriteria.List">
            <summary>
            Get the results
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.UniqueResult">
            <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
            <returns>the single result or <see langword="null"/></returns>
            <exception cref="T:NHibernate.HibernateException">
            If there is more than one matching result
            </exception>
        </member>
        <member name="M:NHibernate.ICriteria.Future``1">
            <summary>
            Get a enumerable that when enumerated will execute
            a batch of queries in a single database roundtrip
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.FutureValue``1">
            <summary>
            Get an IFutureValue instance, whose value can be retrieved through
            its Value property. The query is not executed until the Value property
            is retrieved, which will execute other Future queries as well in a
            single roundtrip
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetReadOnly(System.Boolean)">
            <summary>
            Set the read-only mode for entities (and proxies) loaded by this Criteria. This
            setting overrides the default for the session (see <see cref="P:NHibernate.ISession.DefaultReadOnly"/>).
            </summary>
            <remarks>
            <para>
            To set the <em>default</em> read-only setting for entities and proxies that are loaded 
            into the session, see <see cref="P:NHibernate.ISession.DefaultReadOnly"/>.
            </para>
            <para>
            Read-only entities can be modified, but changes are not persisted. They are not
            dirty-checked and snapshots of persistent state are not maintained.
            </para>
            <para>
            When a proxy is initialized, the loaded entity will have the same read-only setting
            as the uninitialized proxy has, regardless of the session's current setting.
            </para>
            <para>
            The read-only setting has no impact on entities or proxies returned by the criteria
            that existed in the session before the criteria was executed.
            </para>
            </remarks>
            <param name="readOnly">
            If <c>true</c>, entities (and proxies) loaded by the criteria will be read-only.
            </param>
            <returns><c>this</c> (for method chaining)</returns>
            <seealso cref="P:NHibernate.ICriteria.IsReadOnly"/>
            <seealso cref="P:NHibernate.ICriteria.IsReadOnlyInitialized"/>
        </member>
        <member name="M:NHibernate.ICriteria.List(System.Collections.IList)">
            <summary>
            Get the results and fill the <see cref="T:System.Collections.IList"/>
            </summary>
            <param name="results">The list to fill with the results.</param>
        </member>
        <member name="M:NHibernate.ICriteria.List``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ICriteria.List"/>.
            </summary>
        </member>
        <member name="M:NHibernate.ICriteria.UniqueResult``1">
            <summary>
            Strongly-typed version of <see cref="M:NHibernate.ICriteria.UniqueResult"/>.
            </summary>
        </member>
        <member name="M:NHibernate.ICriteria.ClearOrders">
            <summary>
            Clear all orders from criteria.
            </summary>
        </member>
        <member name="M:NHibernate.ICriteria.GetCriteriaByPath(System.String)">
            <summary>
            Allows to get a sub criteria by path.
            Will return null if the criteria does not exists.
            </summary>
            <param name="path">The path.</param>
        </member>
        <member name="M:NHibernate.ICriteria.GetCriteriaByAlias(System.String)">
            <summary>
            Alows to get a sub criteria by alias.
            Will return null if the criteria does not exists
            </summary>
            <param name="alias">The alias.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.GetRootEntityTypeIfAvailable">
            <summary>
            Gets the root entity type if available, throws otherwise
            </summary>
            <remarks>
            This is an NHibernate specific method, used by several dependent
            frameworks for advance integration with NHibernate.
            </remarks>
        </member>
        <member name="P:NHibernate.ICriteria.Alias">
            <summary>
            Get the alias of the entity encapsulated by this criteria instance.
            </summary>
            <value>The alias for the encapsulated entity.</value>
        </member>
        <member name="P:NHibernate.ICriteria.IsReadOnlyInitialized">
            <summary>
            Was the read-only mode explicitly initialized?
            </summary>
            <returns><c>true</c> if the read-only mode was explicitly initialized, otherwise <c>false</c>.</returns>
            <seealso cref="M:NHibernate.ICriteria.SetReadOnly(System.Boolean)"/>
            <seealso cref="P:NHibernate.ICriteria.IsReadOnly"/>///
        </member>
        <member name="P:NHibernate.ICriteria.IsReadOnly">
            <summary>
            Will entities (and proxies) loaded by this Criteria be put in read-only mode?
            </summary>
            <remarks>
            <para>
            If the read-only setting was not initialized, then the value of the session's
            <see cref="P:NHibernate.ISession.DefaultReadOnly"/> property is returned instead.
            </para>
            <para>
            The read-only setting has no impact on entities or proxies returned by the
            Criteria that existed in the session before the Criteria was executed.
            </para>
            </remarks>
            <returns>
            <c>true</c> if entities and proxies loaded by the criteria will be put in read-only mode,
            otherwise <c>false</c>.
            </returns>
            <seealso cref="M:NHibernate.ICriteria.SetReadOnly(System.Boolean)"/>
            <seealso cref="P:NHibernate.ICriteria.IsReadOnlyInitialized"/>
        </member>
        <member name="M:NHibernate.Impl.CriteriaImpl.SetReadOnly(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Impl.CriteriaImpl.SetCacheMode(NHibernate.CacheMode)">
            <summary> Override the cache mode for this particular query. </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="P:NHibernate.Impl.CriteriaImpl.IsReadOnlyInitialized">
            <inheritdoc />
        </member>
        <member name="P:NHibernate.Impl.CriteriaImpl.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Impl.CriteriaImpl.Subcriteria.SetCacheMode(NHibernate.CacheMode)">
            <summary> Override the cache mode for this particular query. </summary>
            <param name="cacheMode">The cache mode to use. </param>
            <returns> this (for method chaining) </returns>
        </member>
        <member name="M:NHibernate.Impl.CriteriaImpl.Subcriteria.Clone">
            <summary>
            The Clone is supported only by a root criteria.
            </summary>
            <returns>The clone of the root criteria.</returns>
        </member>
        <member name="T:NHibernate.Impl.DetachedNamedQuery">
            <summary>
            Named query in "detached mode" where the NHibernate session is not available.
            </summary>
            <seealso cref="T:NHibernate.Impl.AbstractDetachedQuery"/>
            <seealso cref="T:NHibernate.IDetachedQuery"/>
            <seealso cref="T:NHibernate.IQuery"/>
            <seealso cref="M:NHibernate.ISession.GetNamedQuery(System.String)"/>
        </member>
        <member name="M:NHibernate.Impl.DetachedNamedQuery.#ctor(System.String)">
            <summary>
            Create a new instance of <see cref="T:NHibernate.Impl.DetachedNamedQuery"/> for a named query string defined in the mapping file.
            </summary>
            <param name="queryName">The name of a query defined externally.</param>
            <remarks>
            The query can be either in HQL or SQL format.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.DetachedNamedQuery.GetExecutableQuery(NHibernate.ISession)">
            <summary>
            Get an executable instance of <see cref="T:NHibernate.IQuery"/>, to actually run the query.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.DetachedNamedQuery.Clone">
            <summary>
            Creates a new DetachedNamedQuery that is a deep copy of the current instance.
            </summary>
            <returns>The clone.</returns>
        </member>
        <member name="P:NHibernate.Impl.DetachedNamedQuery.QueryName">
            <summary>
            Get the query name.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.DetachedQuery">
            <summary>
            Query in "detached mode" where the NHibernate session is not available.
            </summary>
            <seealso cref="T:NHibernate.Impl.AbstractDetachedQuery"/>
            <seealso cref="T:NHibernate.IDetachedQuery"/>
            <seealso cref="T:NHibernate.IQuery"/>
        </member>
        <member name="M:NHibernate.Impl.DetachedQuery.#ctor(System.String)">
            <summary>
            Create a new instance of <see cref="T:NHibernate.Impl.DetachedQuery"/> for the given query string.
            </summary>
            <param name="hql">A hibernate query string</param>
        </member>
        <member name="M:NHibernate.Impl.DetachedQuery.GetExecutableQuery(NHibernate.ISession)">
            <summary>
            Get an executable instance of <see cref="T:NHibernate.IQuery"/>, to actually run the query.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.DetachedQuery.Clone">
            <summary>
            Creates a new DetachedQuery that is a deep copy of the current instance.
            </summary>
            <returns>The clone.</returns>
        </member>
        <member name="P:NHibernate.Impl.DetachedQuery.Hql">
            <summary>
            Get the HQL string.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.EnumerableImpl">
            <summary>
            Provides an <see cref="T:System.Collections.IEnumerable"/> wrapper over the results of an <see cref="T:NHibernate.IQuery"/>.
            </summary>
            <remarks>
            This is the IteratorImpl in H2.0.3
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.#ctor(System.Data.IDataReader,System.Data.IDbCommand,NHibernate.Event.IEventSource,System.Boolean,NHibernate.Type.IType[],System.String[][],NHibernate.Engine.RowSelection,NHibernate.Hql.HolderInstantiator)">
            <summary>
            Create an <see cref="T:System.Collections.IEnumerable"/> wrapper over an <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to enumerate over.</param>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> used to create the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="session">The <see cref="T:NHibernate.ISession"/> to use to load objects.</param>
            <param name="readOnly"></param>
            <param name="types">The <see cref="T:NHibernate.Type.IType"/>s contained in the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="columnNames">The names of the columns in the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection"/> that should be applied to the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="holderInstantiator">Instantiator of the result holder (used for "select new SomeClass(...)" queries).</param>
            <remarks>
            The <see cref="T:System.Data.IDataReader"/> should already be positioned on the first record in <see cref="T:NHibernate.Engine.RowSelection"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the query results.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the query results.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.MoveNext">
             <summary>
             Advances the enumerator to the next element of the query results.
             </summary>
             <returns>
             <see langword="true" /> if the enumerator was successfully advanced to the next query results
             ; <see langword="false" /> if the enumerator has passed the end of the query results.
            </returns>
        </member>
        <member name="F:NHibernate.Impl.EnumerableImpl._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this EnumerableImpl is being Disposed of or Finalized.</param>
            <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.EnumerableImpl.Current">
            <summary>
            Gets the current element in the query results.
            </summary>
            <value>
            The current element in the query results which is either an object or 
            an object array.
            </value>
            <remarks>
            If the <see cref="T:NHibernate.IQuery"/> only returns one type of Entity then an object will
            be returned.  If this is a multi-column resultset then an object array will be
            returned.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.LambdaSubqueryType">
            <summary>
            Subquery type enumeration
            </summary>
        </member>
        <member name="F:NHibernate.Impl.LambdaSubqueryType.Exact">
            <summary>exact</summary>
        </member>
        <member name="F:NHibernate.Impl.LambdaSubqueryType.All">
            <summary>all</summary>
        </member>
        <member name="F:NHibernate.Impl.LambdaSubqueryType.Some">
            <summary>some</summary>
        </member>
        <member name="T:NHibernate.Impl.ExpressionProcessor">
            <summary>
            Converts lambda expressions to NHibernate criterion/order
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.FindValue(System.Linq.Expressions.Expression)">
            <summary>
            Invoke the expression to extract its runtime value
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.FindMemberProjection(System.Linq.Expressions.Expression)">
            <summary>
            Retrieves the projection for the expression
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.FindMemberExpression(System.Linq.Expressions.Expression)">
            <summary>
            Retrieves the name of the property from a member expression
            </summary>
            <param name="expression">An expression tree that can contain either a member, or a conversion from a member.
            If the member is referenced from a null valued object, then the container is treated as an alias.</param>
            <returns>The name of the member property</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.FindPropertyExpression(System.Linq.Expressions.Expression)">
            <summary>
            Retrieves the name of the property from a member expression (without leading member access)
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.FindDetachedCriteria(System.Linq.Expressions.Expression)">
            <summary>
            Retrieves a detached criteria from an appropriate lambda expression
            </summary>
            <param name="expression">Expresson for detached criteria using .As&lt;>() extension"/></param>
            <returns>Evaluated detached criteria</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessExpression``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Convert a lambda expression to NHibernate ICriterion
            </summary>
            <typeparam name="T">The type of the lambda expression</typeparam>
            <param name="expression">The lambda expression to convert</param>
            <returns>NHibernate ICriterion</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessExpression(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Convert a lambda expression to NHibernate ICriterion
            </summary>
            <param name="expression">The lambda expression to convert</param>
            <returns>NHibernate ICriterion</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessOrder``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Func{System.String,NHibernate.Criterion.Order})">
            <summary>
            Convert a lambda expression to NHibernate Order
            </summary>
            <typeparam name="T">The type of the lambda expression</typeparam>
            <param name="expression">The lambda expression to convert</param>
            <param name="orderDelegate">The appropriate order delegate (order direction)</param>
            <returns>NHibernate Order</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessOrder(System.Linq.Expressions.Expression{System.Func{System.Object}},System.Func{System.String,NHibernate.Criterion.Order})">
            <summary>
            Convert a lambda expression to NHibernate Order
            </summary>
            <param name="expression">The lambda expression to convert</param>
            <param name="orderDelegate">The appropriate order delegate (order direction)</param>
            <returns>NHibernate Order</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessOrder(System.Linq.Expressions.LambdaExpression,System.Func{System.String,NHibernate.Criterion.Order})">
            <summary>
            Convert a lambda expression to NHibernate Order
            </summary>
            <param name="expression">The lambda expression to convert</param>
            <param name="orderDelegate">The appropriate order delegate (order direction)</param>
            <returns>NHibernate Order</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessOrder(System.Linq.Expressions.LambdaExpression,System.Func{System.String,NHibernate.Criterion.Order},System.Func{NHibernate.Criterion.IProjection,NHibernate.Criterion.Order})">
            <summary>
            Convert a lambda expression to NHibernate Order
            </summary>
            <param name="expression">The lambda expression to convert</param>
            <param name="orderStringDelegate">The appropriate order delegate (order direction)</param>
            <param name="orderProjectionDelegate">The appropriate order delegate (order direction)</param>
            <returns>NHibernate Order</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessSubquery``1(NHibernate.Impl.LambdaSubqueryType,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Convert a lambda expression to NHibernate subquery AbstractCriterion
            </summary>
            <typeparam name="T">type of member expression</typeparam>
            <param name="subqueryType">type of subquery</param>
            <param name="expression">lambda expression to convert</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProcessSubquery(NHibernate.Impl.LambdaSubqueryType,System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
            Convert a lambda expression to NHibernate subquery AbstractCriterion
            </summary>
            <param name="subqueryType">type of subquery</param>
            <param name="expression">lambda expression to convert</param>
            <returns>NHibernate.ICriterion.AbstractCriterion</returns>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.RegisterCustomMethodCall(System.Linq.Expressions.Expression{System.Func{System.Boolean}},System.Func{System.Linq.Expressions.MethodCallExpression,NHibernate.Criterion.ICriterion})">
            <summary>
            Register a custom method for use in a QueryOver expression
            </summary>
            <param name="function">Lambda expression demonstrating call of custom method</param>
            <param name="functionProcessor">function to convert MethodCallExpression to ICriterion</param>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.RegisterCustomProjection``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{System.Linq.Expressions.MethodCallExpression,NHibernate.Criterion.IProjection})">
            <summary>
            Register a custom projection for use in a QueryOver expression
            </summary>
            <param name="function">Lambda expression demonstrating call of custom method</param>
            <param name="functionProcessor">function to convert MethodCallExpression to IProjection</param>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.RegisterCustomProjection``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{System.Linq.Expressions.MemberExpression,NHibernate.Criterion.IProjection})">
            <summary>
            Register a custom projection for use in a QueryOver expression
            </summary>
            <param name="function">Lambda expression demonstrating call of custom method</param>
            <param name="functionProcessor">function to convert MethodCallExpression to IProjection</param>
        </member>
        <member name="M:NHibernate.Impl.ExpressionProcessor.ProjectionInfo.AsProperty">
            <summary>
            Retreive the property name from a supplied PropertyProjection
            Note:  throws is the supplied IProjection is not a PropertyProjection
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ExpressionQueryImpl.ExpandParameters(System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue})">
            <summary> 
            Warning: adds new parameters to the argument by side-effect, as well as mutating the query expression tree!
            </summary>
        </member>
        <member name="T:NHibernate.Impl.FilterImpl">
            <summary>
            </summary>
        </member>
        <member name="T:NHibernate.IFilter">
            <summary>
            Type definition of Filter.  Filter defines the user's view into enabled dynamic filters,
            allowing them to set filter parameter values.
            </summary>
        </member>
        <member name="M:NHibernate.IFilter.SetParameter(System.String,System.Object)">
            <summary>
            Set the named parameter's value list for this filter. 
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="value">The values to be applied.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.IFilter.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.IFilter.SetParameterList(System.String,System.Object[])">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.IFilter.Validate">
            <summary>
            Perform validation of the filter state.  This is used to verify the
            state of the filter after its enablement and before its use.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.IFilter.Name">
            <summary>
            Get the name of this filter. 
            </summary>
            <returns>This filter's name.</returns>
        </member>
        <member name="P:NHibernate.IFilter.FilterDefinition">
            <summary>
            Get the filter definition containing additional information about the
            filter (such as default-condition and expected parameter names/types).
            </summary>
            <returns>The filter definition</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.SetParameter(System.String,System.Object)">
            <summary>
            Set the named parameter's value for this filter.
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="value">The value to be applied.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.SetParameterList(System.String,System.Object[])">
            <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
            <param name="name">The parameter's name.</param>
            <param name="values">The values to be expanded into an SQL IN list.</param>
            <returns>This FilterImpl instance (for method chaining).</returns>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.Validate">
            <summary>
            Perform validation of the filter state.  This is used to verify the
            state of the filter after its enablement and before its use.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.FilterImpl.Name">
            <summary>
            Get the name of this filter.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.MessageHelper">
            <summary>
            Helper methods for rendering log messages and exception messages
            </summary>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.Type,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to create the string from.</param>
            <param name="id">The identifier of the object.</param>
            <returns>A descriptive <see cref="T:System.String"/> in the format of <c>[classname#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question.</param>
            <param name="id">The identifier of the object.</param>
            <param name="factory">The <see cref="T:NHibernate.ISessionFactory"/>.</param>
            <returns>A descriptive <see cref="T:System.String"/> in the format of <c>[classname#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Type.IType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question.</param>
            <param name="id">The identifier of the object.</param>
            <param name="factory">The <see cref="T:NHibernate.ISessionFactory"/>.</param>
            <param name="identifierType">The NHibernate type of the identifier.</param>
            <returns>A descriptive <see cref="T:System.String"/> in the format of <c>[classname#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question</param>
            <param name="id">The id</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[FooBar#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> for the class in question</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[FooBar]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the class in question</param>
            <param name="id">The id</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[collectionrole#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.String,System.String,System.Object)">
            <summary> 
            Generate an info message string relating to a given property value
            for an entity. 
            </summary>
            <param name="entityName">The entity name </param>
            <param name="propertyName">The name of the property </param>
            <param name="key">The property value. </param>
            <returns> An info string, in the form [Foo.bars#1] </returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Collection.ICollectionPersister,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> 
            Generate an info message string relating to a particular managed
            collection.
            </summary>
            <param name="persister">The persister for the collection </param>
            <param name="id">The id value of the owner </param>
            <param name="factory">The session factory </param>
            <returns> An info string, in the form [Foo.bars#1] </returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.String,System.Object)">
            <summary> 
            Generate an info message string relating to a particular entity,
            based on the given entityName and id. 
            </summary>
            <param name="entityName">The defined entity name. </param>
            <param name="id">The entity id value. </param>
            <returns> An info string, in the form [FooBar#1]. </returns>
        </member>
        <member name="T:NHibernate.IMultiCriteria">
            <summary>
            Combines several queries into a single DB call
            </summary>
        </member>
        <member name="M:NHibernate.IMultiCriteria.List">
            <summary>
            Get all the results
            </summary>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add(System.Type,NHibernate.ICriteria)">
            <summary>
            Adds the specified criteria to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="resultGenericListType">Return results in a <see cref="T:System.Collections.Generic.List`1"/></param>
            <param name="criteria">The criteria.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(NHibernate.ICriteria)">
            <summary>
            Adds the specified criteria to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="criteria">The criteria.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(System.String,NHibernate.ICriteria)">
            <summary>
            Adds the specified criteria to the query, and associates it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="key">The key</param>
            <param name="criteria">The criteria</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Adds the specified detached criteria. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="detachedCriteria">The detached criteria.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(System.String,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Adds the specified detached criteria, and associates it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="key">The key</param>
            <param name="detachedCriteria">The detached criteria</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add(NHibernate.ICriteria)">
            <summary>
            Adds the specified criteria to the query
            </summary>
            <param name="criteria">The criteria.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add(System.String,NHibernate.ICriteria)">
            <summary>
            Adds the specified criteria to the query, and associates it with the given key
            </summary>
            <param name="key">The key</param>
            <param name="criteria">The criteria</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Adds the specified detached criteria.
            </summary>
            <param name="detachedCriteria">The detached criteria.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add(System.String,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Adds the specified detached criteria, and associates it with the given key
            </summary>
            <param name="key">The key</param>
            <param name="detachedCriteria">The detached criteria</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add(System.Type,NHibernate.IQueryOver)">
            <summary>
            Adds the specified IQueryOver to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="resultGenericListType">Return results in a <see cref="T:System.Collections.Generic.List`1"/></param>
            <param name="queryOver">The IQueryOver.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(NHibernate.IQueryOver{``0})">
            <summary>
            Adds the specified IQueryOver to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="queryOver">The IQueryOver.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(NHibernate.IQueryOver)">
            <summary>
            Adds the specified IQueryOver to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="queryOver">The IQueryOver.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(System.String,NHibernate.IQueryOver{``0})">
            <summary>
            Adds the specified IQueryOver to the query, and associates it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="key">The key</param>
            <param name="queryOver">The IQueryOver</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.Add``1(System.String,NHibernate.IQueryOver)">
            <summary>
            Adds the specified IQueryOver to the query, and associates it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="key">The key</param>
            <param name="queryOver">The IQueryOver</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.SetCacheable(System.Boolean)">
            <summary>
            Sets whatevert this criteria is cacheable.
            </summary>
            <param name="cachable">if set to <c>true</c> [cachable].</param>
        </member>
        <member name="M:NHibernate.IMultiCriteria.SetCacheRegion(System.String)">
            <summary>
             Set the cache region for thie criteria
            </summary>
            <param name="region">The region</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.ForceCacheRefresh(System.Boolean)">
            <summary>
             Force a cache refresh
            </summary>
            <param name="forceRefresh"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Sets the result transformer for all the results in this mutli criteria instance
            </summary>
            <param name="resultTransformer">The result transformer.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IMultiCriteria.GetResult(System.String)">
            <summary>
            Returns the result of one of the Criteria based on the key
            </summary>
            <param name="key">The key</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.MultiCriteriaImpl.#ctor(NHibernate.Impl.SessionImpl,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Impl.MultiCriteriaImpl"/> class.
            </summary>
            <param name="session">The session.</param>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:NHibernate.Type.ICacheAssembler.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary> Return a cacheable "disassembled" representation of the object.</summary>
            <param name="value">the value to cache </param>
            <param name="session">the session </param>
            <param name="owner">optional parent entity object (needed for collections) </param>
            <returns> the disassembled, deep cloned state </returns>		
        </member>
        <member name="M:NHibernate.Type.ICacheAssembler.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary> Reconstruct the object from its cached "disassembled" state.</summary>
            <param name="cached">the disassembled state from the cache </param>
            <param name="session">the session </param>
            <param name="owner">the parent entity object </param>
            <returns> the the object </returns>
        </member>
        <member name="M:NHibernate.Type.ICacheAssembler.BeforeAssemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Called before assembling a query result set from the query cache, to allow batch fetching
            of entities missing from the second-level cache.
            </summary>
        </member>
        <member name="T:NHibernate.IMultiQuery">
            <summary>
            Combines sevaral queries into a single database call
            </summary>
        </member>
        <member name="M:NHibernate.IMultiQuery.List">
            <summary>
            Get all the results
            </summary>
            <remarks>
            The result is a IList of IList.
            </remarks>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add(System.Type,NHibernate.IQuery)">
            <summary>
            Adds the specified query to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="resultGenericListType">Return results in a <see cref="T:System.Collections.Generic.List`1"/></param>
            <param name="query">The query.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add``1(NHibernate.IQuery)">
            <summary>
            Add the specified HQL query to the multi query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="query">The query</param>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add``1(System.String,NHibernate.IQuery)">
            <summary>
            Add the specified HQL query to the multi query, and associate it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="key">The key to get results of the specific query.</param>
            <param name="query">The query</param>
            <returns>The instance for method chain.</returns>
            <seealso cref="M:NHibernate.IMultiQuery.GetResult(System.String)"/>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add``1(System.String,System.String)">
            <summary>
            Add the specified HQL Query to the multi query, and associate it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="key">The key to get results of the specific query.</param>
            <param name="hql">The query</param>
            <returns>The instance for method chain.</returns>
            <seealso cref="M:NHibernate.IMultiQuery.GetResult(System.String)"/>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add``1(System.String)">
            <summary>
            Add the specified HQL query to the multi query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="hql">The query</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.AddNamedQuery``1(System.String)">
            <summary>
            Add a named query to the multi query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="queryName">The query</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.AddNamedQuery``1(System.String,System.String)">
            <summary>
            Add a named query to the multi query, and associate it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
            <param name="key">The key to get results of the specific query.</param>
            <param name="queryName">The query</param>
            <returns>The instance for method chain.</returns>
            <seealso cref="M:NHibernate.IMultiQuery.GetResult(System.String)"/>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add(System.String,NHibernate.IQuery)">
            <summary>
            Add the specified HQL query to the multi query, and associate it with the given key
            </summary>
            <param name="key">The key to get results of the specific query.</param>
            <param name="query">The query</param>
            <returns>The instance for method chain.</returns>
            <seealso cref="M:NHibernate.IMultiQuery.GetResult(System.String)"/>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add(NHibernate.IQuery)">
            <summary>
            Add the specified HQL query to the multi query
            </summary>
            <param name="query">The query</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add(System.String,System.String)">
            <summary>
            Add the specified HQL Query to the multi query, and associate it with the given key
            </summary>
            <param name="key">The key to get results of the specific query.</param>
            <param name="hql">The query</param>
            <returns>The instance for method chain.</returns>
            <seealso cref="M:NHibernate.IMultiQuery.GetResult(System.String)"/>
        </member>
        <member name="M:NHibernate.IMultiQuery.Add(System.String)">
            <summary>
            Add the specified HQL query to the multi query
            </summary>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.AddNamedQuery(System.String)">
            <summary>
            Add a named query to the multi query
            </summary>
            <param name="queryName">The query</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.AddNamedQuery(System.String,System.String)">
            <summary>
            Add a named query to the multi query, and associate it with the given key
            </summary>
            <param name="key">The key to get results of the specific query.</param>
            <param name="queryName">The query</param>
            <returns>The instance for method chain.</returns>
            <seealso cref="M:NHibernate.IMultiQuery.GetResult(System.String)"/>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set.
            </summary>
            <param name="cacheable">Should the query results be cacheable?</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="region">The name of a query cache region, or <see langword="null" />
            for the default query cache</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetForceCacheRefresh(System.Boolean)">
            Should the query force a refresh of the specified query cache region?
            This is particularly useful in cases where underlying data may have been
            updated via a separate process (i.e., not modified through Hibernate) and
            allows the application to selectively refresh the query cache regions
            based on its knowledge of those events.
            <param name="forceCacheRefresh">Should the query result in a forcible refresh of
            the query cache?</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetTimeout(System.Int32)">
            <summary>
            The timeout for the underlying ADO query
            </summary>
            <param name="timeout"></param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to a named query parameter
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameter(System.String,System.Object)">
            <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType"/>
            from the class of the given object.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The non-null parameter value</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameterList(System.String,System.Collections.IEnumerable,NHibernate.Type.IType)">
            <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
            <param name="type">The Hibernate type of the values</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetParameterList(System.String,System.Collections.IEnumerable)">
            <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetAnsiString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetBinary(System.String,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetBoolean(System.String,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetByte(System.String,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetCharacter(System.String,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetDateTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <param name="name">The name of the parameter</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetDecimal(System.String,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetDouble(System.String,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetEntity(System.String,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent class</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetEnum(System.String,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent enumeration</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetInt16(System.String,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetInt32(System.String,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetInt64(System.String,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetSingle(System.String,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetGuid(System.String,System.Guid)">
            <summary>
            Bind an instance of a <see cref="T:System.Guid"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">An instance of a <see cref="T:System.Guid"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetTimestamp(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetFlushMode(NHibernate.FlushMode)">
            <summary>
            Override the current session flush mode, just for this query.
            </summary>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
            <remarks>
            The <param name="transformer"/> will be applied after the transformer of each single query.
            </remarks>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.IMultiQuery.GetResult(System.String)">
            <summary>
            Returns the result of one of the query based on the key
            </summary>
            <param name="key">The key</param>
            <returns>The instance for method chain.</returns>
        </member>
        <member name="M:NHibernate.Impl.MultiQueryImpl.List">
            <summary>
            Return the query results of all the queries
            </summary>
        </member>
        <member name="M:NHibernate.Impl.Printer.ToString(System.Object,NHibernate.EntityMode)">
            <summary>
            
            </summary>
            <param name="entity">an actual entity object, not a proxy!</param>
            <param name="entityMode"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryImpl">
            <summary>
             Concrete implementation of a SessionFactory.
            </summary>
            <remarks>
            Has the following responsibilities:
            <list type="">
            <item>
            Caches configuration settings (immutably)</item>
            <item>
            Caches "compiled" mappings - ie. <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> 
            and <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/>
            </item>
            <item>
            Caches "compiled" queries (memory sensitive cache)
            </item>
            <item>
            Manages <c>PreparedStatements/IDbCommands</c> - how true in NH?
            </item>
            <item>
            Delegates <c>IDbConnection</c> management to the <see cref="T:NHibernate.Connection.IConnectionProvider"/>
            </item>
            <item>
            Factory for instances of <see cref="T:NHibernate.ISession"/>
            </item>
            </list>
            <para>
            This class must appear immutable to clients, even if it does all kinds of caching
            and pooling under the covers.  It is crucial that the class is not only thread safe
            , but also highly concurrent.  Synchronization must be used extremely sparingly.
            </para>
            </remarks>
            <seealso cref="T:NHibernate.Connection.IConnectionProvider"/>
            <seealso cref="T:NHibernate.ISession"/>
            <seealso cref="T:NHibernate.Hql.IQueryTranslator"/>
            <seealso cref="T:NHibernate.Persister.Entity.IEntityPersister"/>
            <seealso cref="T:NHibernate.Persister.Collection.ICollectionPersister"/>
        </member>
        <member name="F:NHibernate.Impl.SessionFactoryImpl.implementorToEntityName">
            <summary>
            NH specific : to avoid the use of entityName for generic implementation
            </summary>
            <remarks>this is a shortcut.</remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetNamedQuery(System.String)">
            <summary>
            Gets the <c>hql</c> query identified by the <c>name</c>.
            </summary>
            <param name="queryName">The name of that identifies the query.</param>
            <returns>
            A <c>hql</c> query or <see langword="null" /> if the named
            query does not exist.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetReturnAliases(System.String)">
            <summary> Get the return aliases of a query</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetImplementors(System.String)">
            <summary>
            Return the names of all persistent (mapped) classes that extend or implement the
            given class or interface, accounting for implicit/explicit polymorphism settings
            and excluding mapped subclasses/joined-subclasses of other classes in the result.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllClassMetadata">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllCollectionMetadata">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.Close">
            <summary>
            Closes the session factory, releasing all held resources.
            <list>
            <item>cleans up used cache regions and "stops" the cache provider.</item>
            <item>close the ADO.NET connection</item>
            </list>
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenStatelessSession">
            <summary> Get a new stateless session.</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenStatelessSession(System.Data.IDbConnection)">
            <summary> Get a new stateless session for the given ADO.NET connection.</summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.Dialect">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.TransactionFactory">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.StatisticsImplementor">
            <summary> Statistics SPI</summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.Statistics">
            <summary> Get the statistics for this session factory</summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.CurrentSessionContext">
            <summary>
            Gets the ICurrentSessionContext instance attached to this session factory.
            </summary>
        </member>
        <member name="T:NHibernate.Proxy.IEntityNotFoundDelegate">
            <summary> 
            Delegate to handle the scenario of an entity not found by a specified id. 
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.IEntityNotFoundDelegate.HandleEntityNotFound(System.String,System.Object)">
            <summary>
            Delegate method to handle the scenario of an entity not found.
            </summary>
            <param name="entityName">The entityName (may be the class fullname)</param>
            <param name="id">The requested id not founded.</param>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryObjectFactory">
            <summary>
            Resolves <see cref="T:NHibernate.ISessionFactory"/> lookups and deserialization.
            </summary>
            <remarks>
            <para>
            This is used heavily be Deserialization.  Currently a SessionFactory is not really serialized. 
            All that is serialized is it's name and uid.  During Deserializaiton the serialized SessionFactory
            is converted to the one contained in this object.  So if you are serializing across AppDomains
            you should make sure that "name" is specified for the SessionFactory in the hbm.xml file and that the
            other AppDomain has a configured SessionFactory with the same name.  If
            you are serializing in the same AppDomain then there will be no problem because the uid will
            be in this object.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.AddInstance(System.String,System.String,NHibernate.ISessionFactory,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Adds an Instance of the SessionFactory to the local "cache".
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <param name="name">The name of the ISessionFactory.</param>
            <param name="instance">The ISessionFactory.</param>
            <param name="properties">The configured properties for the ISessionFactory.</param>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.RemoveInstance(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Removes the Instance of the SessionFactory from the local "cache".
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <param name="name">The name of the ISessionFactory.</param>
            <param name="properties">The configured properties for the ISessionFactory.</param>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetNamedInstance(System.String)">
            <summary>
            Returns a Named Instance of the SessionFactory from the local "cache" identified by name.
            </summary>
            <param name="name">The name of the ISessionFactory.</param>
            <returns>An instantiated ISessionFactory.</returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetInstance(System.String)">
            <summary>
            Returns an Instance of the SessionFactory from the local "cache" identified by UUID.
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <returns>An instantiated ISessionFactory.</returns>
        </member>
        <member name="P:NHibernate.Impl.SessionIdLoggingContext.SessionId">
            <summary>
            We always set the result to use a thread static variable, on the face of it,
            it looks like it is not a valid choice, since ASP.Net and WCF may decide to switch
            threads on us. But, since SessionIdLoggingContext is only used inside NH calls, and since
            NH calls are never async, this isn't an issue for us.
            In addition to that, attempting to match to the current context has proven to be performance hit.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.SessionImpl">
            <summary>
            Concrete implementation of an <see cref="T:NHibernate.ISession"/>, also the central, organizing component
            of NHibernate's internal implementation.
            </summary>
            <remarks>
            Exposes two interfaces: <see cref="T:NHibernate.ISession"/> itself, to the application and 
            <see cref="T:NHibernate.Engine.ISessionImplementor"/> to other components of NHibernate. This is where the 
            hard stuff is... This class is NOT THREADSAFE.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to recreate the Session during the deserialization.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <remarks>
            This is needed because we have to do some checking before the serialization process
            begins.  I don't know how to add logic in ISerializable.GetObjectData and have .net
            write all of the serializable fields out.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Verify the ISession can be serialized and write the fields to the Serializer.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <remarks>
            The fields are marked with [NonSerializable] as just a point of reference.  This method
            has complete control and what is serialized and those attributes are ignored.  However,
            this method should be in synch with the attributes for easy readability.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>
            Once the entire object graph has been deserialized then we can hook the
            collections, proxies, and entities back up to the ISession.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.#ctor(System.Data.IDbConnection,NHibernate.Impl.SessionFactoryImpl,System.Boolean,System.Int64,NHibernate.IInterceptor,NHibernate.EntityMode,System.Boolean,System.Boolean,System.Boolean,NHibernate.ConnectionReleaseMode)">
            <summary>
            Constructor used for OpenSession(...) processing, as well as construction
            of sessions for GetCurrentSession().
            </summary>
            <param name="connection">The user-supplied connection to use for this session.</param>
            <param name="factory">The factory from which this session was obtained</param>
            <param name="autoclose">NOT USED</param>
            <param name="timestamp">The timestamp for this session</param>
            <param name="interceptor">The interceptor to be applied to this session</param>
            <param name="entityMode">The entity-mode for this session</param>
            <param name="flushBeforeCompletionEnabled">Should we auto flush before completion of transaction</param>
            <param name="autoCloseSessionEnabled">Should we auto close after completion of transaction</param>
            <param name="ignoreExceptionBeforeTransactionCompletion">Should we ignore exceptions in IInterceptor.BeforeTransactionCompletion</param>
            <param name="connectionReleaseMode">The mode by which we should release JDBC connections.</param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.#ctor(NHibernate.Impl.SessionImpl,NHibernate.EntityMode)">
            <summary>
            Constructor used in building "child sessions".
            </summary>
            <param name="parent">The parent Session</param>
            <param name="entityMode">The entity mode</param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Close">
            <summary>
            Close the session and release all resources
            <remarks>
            Do not call this method inside a transaction scope, use <c>Dispose</c> instead, since
            Close() is not aware of distributed transactions
            </remarks>
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AfterTransactionCompletion(System.Boolean,NHibernate.ITransaction)">
            <summary>
            Ensure that the locks are downgraded to <see cref="F:NHibernate.LockMode.None"/>
            and that all of the softlocks in the <see cref="N:NHibernate.Cache"/> have
            been released.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object)">
            <summary>
            Save a transient object. An id is generated, assigned to the object and returned
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object,System.Object)">
            <summary>
            Save a transient object with a manually assigned ID
            </summary>
            <param name="obj"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Delete(System.Object)">
            <summary>
            Delete a persistent object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Delete(System.String,System.Object)">
            <summary> Delete a persistent object (by explicit entity name)</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateFilter(System.Object,System.String)">
             <summary>
            
             </summary>
             <param name="collection"></param>
             <param name="queryString"></param>
             <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Instantiate(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
            <summary>
            Give the interceptor an opportunity to override the default instantiation
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ForceFlush(NHibernate.Engine.EntityEntry)">
            <summary> Force an immediate flush</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Merge(System.String,System.Object,System.Collections.IDictionary)">
            <summary> Cascade merge an entity instance</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Persist(System.String,System.Object,System.Collections.IDictionary)">
            <summary> Cascade persist an entity instance</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PersistOnFlush(System.String,System.Object,System.Collections.IDictionary)">
            <summary> Cascade persist an entity instance during the flush process</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Refresh(System.Object,System.Collections.IDictionary)">
            <summary> Cascade refresh an entity instance</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Delete(System.String,System.Object,System.Boolean,System.Collections.Generic.ISet{System.Object})">
            <summary> Cascade delete an entity instance</summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AutoFlushIfRequired(System.Collections.Generic.ISet{System.String})">
            <summary>
            detect in-memory changes, determine if the changes are to tables
            named in the query and, if so, complete execution the flush
            </summary>
            <param name="querySpaces"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Load(System.Type,System.Object,NHibernate.LockMode)">
             <summary>
             Load the data for the object with the specified id into a newly created object
             using "for update", if supported. A new key will be assigned to the object.
             This should return an existing proxy where appropriate.
            
             If the object does not exist in the database, an exception is thrown.
             </summary>
             <param name="entityClass"></param>
             <param name="id"></param>
             <param name="lockMode"></param>
             <returns></returns>
             <exception cref="T:NHibernate.ObjectNotFoundException">
             Thrown when the object with the specified id does not exist in the database.
             </exception>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Get(System.Type,System.Object,NHibernate.LockMode)">
             <summary>
             Load the data for the object with the specified id into a newly created object
             using "for update", if supported. A new key will be assigned to the object.
             This should return an existing proxy where appropriate.
            
             If the object does not exist in the database, null is returned.
             </summary>
             <param name="clazz"></param>
             <param name="id"></param>
             <param name="lockMode"></param>
             <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ImmediateLoad(System.String,System.Object)">
            <summary>
            Load the data for the object with the specified id into a newly created object.
            This is only called when lazily initializing a proxy.
            Do NOT return a proxy.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InternalLoad(System.String,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Return the object with the specified id or throw exception if no row with that id exists. Defer the load,
            return a new proxy or return an existing proxy if possible. Do not check if the object was deleted.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Flush">
             <summary>
            
             </summary>
             <remarks>
             This can be called from commit() or at the start of a List() method.
             <para>
             Perform all the necessary SQL statements in a sensible order, to allow
             users to repect foreign key constraints:
             <list type="">
            		<item>Inserts, in the order they were performed</item>
            		<item>Updates</item>
            		<item>Deletion of collection elements</item>
            		<item>Insertion of collection elements</item>
            		<item>Deletes, in the order they were performed</item>
             </list>
             </para>
             <para>
             Go through all the persistent objects and look for collections they might be
             holding. If they had a nonpersistable collection, substitute a persistable one
             </para>
             </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetIdentifier(System.Object)">
            <summary>
            Not for internal use
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetContextEntityIdentifier(System.Object)">
            <summary>
            Get the id value for an object that is actually associated with the session.
            This is a bit stricter than GetEntityIdentifierIfNotUnsaved().
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InitializeCollection(NHibernate.Collection.IPersistentCollection,System.Boolean)">
            <summary>
            called by a collection that wants to initialize itself
            </summary>
            <param name="collection"></param>
            <param name="writing"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Disconnect">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Dispose">
            <summary>
            Perform a soft (distributed transaction aware) close of the session
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this Session is being Disposed of or Finalized.</param>
            <remarks>
            If this Session is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this Session back to life.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Evict(System.Object)">
            <summary>
            remove any hard references to the entity that are held by the infrastructure
            (references held by application or other persistant instances are okay)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.SetReadOnly(System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.IsReadOnly(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Batcher">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Timestamp">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.ActionQueue">
            <summary> Get the ActionQueue for this session</summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.FlushMode">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.IsConnected">
            <summary>
            Gets if the ISession is connected.
            </summary>
            <value>
            <see langword="true"/> if the ISession is connected.
            </value>
            <remarks>
            An ISession is considered connected if there is an <see cref="T:System.Data.IDbConnection"/> (regardless
            of its state) or if it the field <c>connect</c> is true.  Meaning that it will connect
            at the next operation that requires a connection.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Statistics">
            <summary> Get the statistics for this session.</summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Listeners">
            <summary> Retrieves the configured event listeners from this event source. </summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.DefaultReadOnly">
            <inheritdoc />
        </member>
        <member name="T:NHibernate.Impl.SqlQueryImpl">
            <summary>
            Implements SQL query passthrough
            </summary>
            <example>
            An example mapping is:
            <code>
            &lt;sql-query-name name="mySqlQuery"&gt;
            &lt;return alias="person" class="eg.Person" /&gt;
            	SELECT {person}.NAME AS {person.name}, {person}.AGE AS {person.age}, {person}.SEX AS {person.sex}
            	FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
            &lt;/sql-query-name&gt;
            </code>
            </example>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String)">
            <summary>
            Declare a "root" entity, without specifying an alias
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.String)">
            <summary>
            Declare a "root" entity
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.String,NHibernate.LockMode)">
            <summary>
            Declare a "root" entity, specifying a lock mode
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.Type)">
            <summary>
            Declare a "root" entity, without specifying an alias
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.Type)">
            <summary>
            Declare a "root" entity
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.Type,NHibernate.LockMode)">
            <summary>
            Declare a "root" entity, specifying a lock mode
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddJoin(System.String,System.String)">
            <summary>
            Declare a "joined" entity
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddJoin(System.String,System.String,NHibernate.LockMode)">
            <summary>
            Declare a "joined" entity, specifying a lock mode
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.AddScalar(System.String,NHibernate.Type.IType)">
            <summary>
            Declare a scalar query result
            </summary>
        </member>
        <member name="M:NHibernate.ISQLQuery.SetResultSetMapping(System.String)">
            <summary>
            Use a predefined named ResultSetMapping
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SqlQueryImpl.#ctor(NHibernate.Engine.NamedSQLQueryDefinition,NHibernate.Engine.ISessionImplementor,NHibernate.Engine.Query.ParameterMetadata)">
            <summary> Constructs a SQLQueryImpl given a sql query defined in the mappings. </summary>
            <param name="queryDef">The representation of the defined sql-query. </param>
            <param name="session">The session to which this SQLQueryImpl belongs. </param>
            <param name="parameterMetadata">Metadata about parameters found in the query. </param>
        </member>
        <member name="T:NHibernate.IStatelessSession">
            <summary>
            A command-oriented API for performing bulk operations against a database.
            </summary>
            <remarks>
            A stateless session does not implement a first-level cache nor
            interact with any second-level cache, nor does it implement
            transactional write-behind or automatic dirty checking, nor do
            operations cascade to associated instances. Collections are
            ignored by a stateless session. Operations performed via a
            stateless session bypass NHibernate's event model and
            interceptors. Stateless sessions are vulnerable to data
            aliasing effects, due to the lack of a first-level cache.
            <para/>
            For certain kinds of transactions, a stateless session may
            perform slightly faster than a stateful session.
            </remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.GetSessionImplementation">
            <summary>
            Gets the stateless session implementation.
            </summary>
            <remarks>
            This method is provided in order to get the <b>NHibernate</b> implementation of the session from wrapper implementations.
            Implementors of the <seealso cref="T:NHibernate.IStatelessSession"/> interface should return the NHibernate implementation of this method.
            </remarks>
            <returns>
            An NHibernate implementation of the <see cref="T:NHibernate.Engine.ISessionImplementor"/> interface
            </returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.Close">
            <summary>Close the stateless session and release the ADO.NET connection.</summary>
        </member>
        <member name="M:NHibernate.IStatelessSession.Insert(System.Object)">
            <summary>Insert an entity.</summary>
            <param name="entity">A new transient instance</param>
            <returns>The identifier of the instance</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.Insert(System.String,System.Object)">
            <summary>Insert a row.</summary>
            <param name="entityName">The name of the entity to be inserted</param>
            <param name="entity">A new transient instance</param>
            <returns>The identifier of the instance</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.Update(System.Object)">
            <summary>Update an entity.</summary>
            <param name="entity">A detached entity instance</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.Update(System.String,System.Object)">
            <summary>Update an entity.</summary>
            <param name="entityName">The name of the entity to be updated</param>
            <param name="entity">A detached entity instance</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.Delete(System.Object)">
            <summary>Delete an entity.</summary>
            <param name="entity">A detached entity instance</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.Delete(System.String,System.Object)">
            <summary>Delete an entity.</summary>
            <param name="entityName">The name of the entity to be deleted</param>
            <param name="entity">A detached entity instance</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.Get(System.String,System.Object)">
            <summary>Retrieve a entity.</summary>
            <returns>A detached entity instance</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.Get``1(System.Object)">
            <summary>
            Retrieve an entity.
            </summary>
            <returns>A detached entity instance</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.Get(System.String,System.Object,NHibernate.LockMode)">
            <summary>
            Retrieve an entity, obtaining the specified lock mode.
            </summary>
            <returns>A detached entity instance</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.Get``1(System.Object,NHibernate.LockMode)">
            <summary>
            Retrieve an entity, obtaining the specified lock mode.
            </summary>
            <returns>A detached entity instance</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.Refresh(System.Object)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entity">The entity to be refreshed.</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.Refresh(System.String,System.Object)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entityName">The name of the entity to be refreshed.</param>
            <param name="entity">The entity to be refreshed.</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.Refresh(System.Object,NHibernate.LockMode)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entity">The entity to be refreshed.</param>
            <param name="lockMode">The LockMode to be applied.</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.Refresh(System.String,System.Object,NHibernate.LockMode)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entityName">The name of the entity to be refreshed.</param>
            <param name="entity">The entity to be refreshed.</param>
            <param name="lockMode">The LockMode to be applied.</param>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateQuery(System.String)">
            <summary>
            Create a new instance of <tt>Query</tt> for the given HQL query string.
            </summary>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.GetNamedQuery(System.String)">
            <summary>
            Obtain an instance of <see cref="T:NHibernate.IQuery"/> for a named query string defined in
            the mapping file.
            </summary>
            <remarks>
            The query can be either in <c>HQL</c> or <c>SQL</c> format.
            Entities returned by the query are detached.
            </remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateCriteria``1">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity class,
            or a superclass of an entity class.
            </summary>
            <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
            <returns>The <see cref="T:NHibernate.ICriteria"/>.</returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateCriteria``1(System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity class,
            or a superclass of an entity class, with the given alias.
            </summary>
            <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
            <param name="alias">The alias of the entity</param>
            <returns>The <see cref="T:NHibernate.ICriteria"/>.</returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.Type)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity class,
            or a superclass of an entity class.
            </summary>
            <param name="entityType">A class, which is persistent, or has persistent subclasses</param>
            <returns>The <see cref="T:NHibernate.ICriteria"/>.</returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.Type,System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity class,
            or a superclass of an entity class, with the given alias.
            </summary>
            <param name="entityType">A class, which is persistent, or has persistent subclasses</param>
            <param name="alias">The alias of the entity</param>
            <returns>The <see cref="T:NHibernate.ICriteria"/>.</returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity name.
            </summary>
            <param name="entityName">The entity name.</param>
            <returns>The <see cref="T:NHibernate.ICriteria"/>.</returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.String,System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity name,
            with the given alias.
            </summary>
            <param name="entityName">The entity name.</param>
            <param name="alias">The alias of the entity</param>
            <returns>The <see cref="T:NHibernate.ICriteria"/>.</returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.IStatelessSession.QueryOver``1">
            <summary>
            Creates a new <c>IQueryOver&lt;T&gt;</c> for the entity class.
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <returns>An ICriteria&lt;T&gt; object</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.QueryOver``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates a new <c>IQueryOver&lt;T&gt;</c> for the entity class.
            </summary>
            <typeparam name="T">The entity class</typeparam>
            <returns>An ICriteria&lt;T&gt; object</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.CreateSQLQuery(System.String)">
            <summary>
            Create a new instance of <see cref="T:NHibernate.ISQLQuery"/> for the given SQL query string.
            Entities returned by the query are detached.
            </summary>
            <param name="queryString">A SQL query</param>
            <returns>The <see cref="T:NHibernate.ISQLQuery"/></returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.BeginTransaction">
            <summary>
            Begin a NHibernate transaction
            </summary>
            <returns>A NHibernate transaction</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Begin a NHibernate transaction with the specified isolation level
            </summary>
            <param name="isolationLevel">The isolation level</param>
            <returns>A NHibernate transaction</returns>
        </member>
        <member name="M:NHibernate.IStatelessSession.SetBatchSize(System.Int32)">
            <summary>
            Sets the batch size of the session
            </summary>
            <param name="batchSize">The batch size.</param>
            <returns>The same instance of the session for methods chain.</returns>
        </member>
        <member name="P:NHibernate.IStatelessSession.Connection">
            <summary>
            Returns the current ADO.NET connection associated with this instance.
            </summary>
            <remarks>
            If the session is using aggressive connection release (as in a
            CMT environment), it is the application's responsibility to
            close the connection returned by this call. Otherwise, the
            application should not close the connection.
            </remarks>
        </member>
        <member name="P:NHibernate.IStatelessSession.Transaction">
            <summary>Get the current NHibernate transaction.</summary>
        </member>
        <member name="P:NHibernate.IStatelessSession.IsOpen">
            <summary>
            Is the <c>IStatelessSession</c> still open?
            </summary>
        </member>
        <member name="P:NHibernate.IStatelessSession.IsConnected">
            <summary>
            Is the <c>IStatelessSession</c> currently connected?
            </summary>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.GetSessionImplementation">
            <summary>
            Gets the stateless session implementation.
            </summary>
            <remarks>
            This method is provided in order to get the <b>NHibernate</b> implementation of the session from wrapper implementations.
            Implementors of the <seealso cref="T:NHibernate.IStatelessSession"/> interface should return the NHibernate implementation of this method.
            </remarks>
            <returns>
            An NHibernate implementation of the <seealso cref="T:NHibernate.Engine.ISessionImplementor"/> interface
            </returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Close">
            <summary> Close the stateless session and release the ADO.NET connection.</summary>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Insert(System.Object)">
            <summary> Insert a entity.</summary>
            <param name="entity">A new transient instance </param>
            <returns> the identifier of the instance </returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Insert(System.String,System.Object)">
            <summary> Insert a row. </summary>
            <param name="entityName">The entityName for the entity to be inserted </param>
            <param name="entity">a new transient instance </param>
            <returns> the identifier of the instance </returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Update(System.Object)">
            <summary> Update a entity.</summary>
            <param name="entity">a detached entity instance </param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Update(System.String,System.Object)">
            <summary>Update a entity.</summary>
            <param name="entityName">The entityName for the entity to be updated </param>
            <param name="entity">a detached entity instance </param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Delete(System.Object)">
            <summary> Delete a entity. </summary>
            <param name="entity">a detached entity instance </param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Delete(System.String,System.Object)">
            <summary> Delete a entity. </summary>
            <param name="entityName">The entityName for the entity to be deleted </param>
            <param name="entity">a detached entity instance </param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Get(System.String,System.Object)">
            <summary> Retrieve a entity. </summary>
            <returns> a detached entity instance </returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Get``1(System.Object)">
             <summary> Retrieve a entity.
            
             </summary>
             <returns> a detached entity instance
             </returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Get(System.String,System.Object,NHibernate.LockMode)">
            <summary>
            Retrieve a entity, obtaining the specified lock mode.
            </summary>
            <returns> a detached entity instance </returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Get``1(System.Object,NHibernate.LockMode)">
            <summary>
            Retrieve a entity, obtaining the specified lock mode.
            </summary>
            <returns> a detached entity instance </returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.Object)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entity">The entity to be refreshed. </param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.String,System.Object)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entityName">The entityName for the entity to be refreshed. </param>
            <param name="entity">The entity to be refreshed.</param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.Object,NHibernate.LockMode)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entity">The entity to be refreshed. </param>
            <param name="lockMode">The LockMode to be applied.</param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.String,System.Object,NHibernate.LockMode)">
            <summary>
            Refresh the entity instance state from the database.
            </summary>
            <param name="entityName">The entityName for the entity to be refreshed. </param>
            <param name="entity">The entity to be refreshed. </param>
            <param name="lockMode">The LockMode to be applied. </param>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria``1">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity class,
            or a superclass of an entity class.
            </summary>
            <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
            <returns> The <see cref="T:NHibernate.ICriteria"/>. </returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria``1(System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity class,
            or a superclass of an entity class, with the given alias.
            </summary>
            <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
            <param name="alias">The alias of the entity</param>
            <returns> The <see cref="T:NHibernate.ICriteria"/>. </returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria(System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity name.
            </summary>
            <param name="entityName">The entity name. </param>
            <returns> The <see cref="T:NHibernate.ICriteria"/>. </returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria(System.String,System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/> instance, for the given entity name,
            with the given alias.
            </summary>
            <param name="entityName">The entity name. </param>
            <param name="alias">The alias of the entity</param>
            <returns> The <see cref="T:NHibernate.ICriteria"/>. </returns>
            <remarks>Entities returned by the query are detached.</remarks>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.BeginTransaction">
            <summary>
            Begin a NHibernate transaction
            </summary>
            <returns>A NHibernate transaction</returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Begin a NHibernate transaction with the specified isolation level
            </summary>
            <param name="isolationLevel">The isolation level</param>
            <returns>A NHibernate transaction</returns>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.StatelessSessionImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:NHibernate.Impl.StatelessSessionImpl.Transaction">
            <summary> Get the current Hibernate transaction.</summary>
        </member>
        <member name="T:NHibernate.Intercept.IFieldInterceptor">
            <summary> Contract for field interception handlers. </summary>
        </member>
        <member name="M:NHibernate.Intercept.IFieldInterceptor.IsInitializedField(System.String)">
            <summary> The the given field initialized for the entity to which we are bound? </summary>
            <param name="field">The name of the field to check </param>
            <returns> True if the given field is initialized; otherwise false.</returns>
        </member>
        <member name="M:NHibernate.Intercept.IFieldInterceptor.MarkDirty">
            <summary> Forcefully mark the entity as being dirty.</summary>
        </member>
        <member name="M:NHibernate.Intercept.IFieldInterceptor.ClearDirty">
            <summary> Clear the internal dirty flag.</summary>
        </member>
        <member name="M:NHibernate.Intercept.IFieldInterceptor.Intercept(System.Object,System.String,System.Object)">
            <summary> Intercept field set/get </summary>
        </member>
        <member name="P:NHibernate.Intercept.IFieldInterceptor.IsDirty">
            <summary> Is the entity considered dirty? </summary>
            <value> True if the entity is dirty; otherwise false. </value>
        </member>
        <member name="P:NHibernate.Intercept.IFieldInterceptor.Session">
            <summary> Use to associate the entity to which we are bound to the given session. </summary>
        </member>
        <member name="P:NHibernate.Intercept.IFieldInterceptor.IsInitialized">
            <summary> Is the entity to which we are bound completely initialized? </summary>
        </member>
        <member name="P:NHibernate.Intercept.IFieldInterceptor.EntityName">
            <summary> Get the entity-name of the field DeclaringType.</summary>
        </member>
        <member name="P:NHibernate.Intercept.IFieldInterceptor.MappedClass">
            <summary> Get the MappedClass (field container).</summary>
        </member>
        <member name="T:NHibernate.Intercept.FieldInterceptionHelper">
            <summary> Helper class for dealing with enhanced entity classes. </summary>
        </member>
        <member name="F:NHibernate.Intercept.LazyPropertyInitializer.UnfetchedProperty">
            <summary> Marker value for uninitialized properties</summary>
        </member>
        <member name="T:NHibernate.Intercept.ILazyPropertyInitializer">
            <summary> Contract for controlling how lazy properties get initialized. </summary>
        </member>
        <member name="M:NHibernate.Intercept.ILazyPropertyInitializer.InitializeLazyProperty(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> Initialize the property, and return its new value</summary>
        </member>
        <member name="T:NHibernate.Linq.Clauses.NhJoinClause">
            <summary>
            All joins are created as outer joins. An optimization in <see cref="T:NHibernate.Linq.Visitors.WhereJoinDetector"/> finds
            joins that may be inner joined and calls <see cref="M:NHibernate.Linq.Clauses.NhJoinClause.MakeInner"/> on them.
            <see cref="T:NHibernate.Linq.Visitors.QueryModelVisitor"/>'s <see cref="M:NHibernate.Linq.Visitors.QueryModelVisitor.VisitAdditionalFromClause(Remotion.Linq.Clauses.AdditionalFromClause,Remotion.Linq.QueryModel,System.Int32)"/> will
            then emit the correct HQL join.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.ExpressionTransformers.RemoveCharToIntConversion">
            <summary>
            Remove unwanted char-to-int conversions in binary expressions
            </summary>
            <remarks>
            The LINQ expression tree may contain unwanted type conversions that were not in the original expression written by the user. For example,
            <c>list.Where(someChar => someChar == 'A')</c> becomes the equivalent of <c>list.Where(someChar => (int)someChar == 55)</c> in the expression
            tree. Converting this directly to a HQL/SQL statement would yield <code>CAST(x AS INT)</code> which does not work in MSSQLSERVER, and possibly
            other databases.
            </remarks> 
        </member>
        <member name="T:NHibernate.Linq.ExpressionTransformers.RemoveRedundantCast">
            <summary>
            Remove redundant casts to the same type or to superclass (upcast) in <see cref="F:System.Linq.Expressions.ExpressionType.Convert"/>, <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked"/> 
            and <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs"/> <see cref="T:System.Linq.Expressions.UnaryExpression"/>s  
            </summary>
        </member>
        <member name="T:NHibernate.Linq.ExpressionTransformers.SimplifyCompareTransformer">
            <summary>
            Applications of the string.Compare(a,b) and a.CompareTo(b) (for various types)
            that are then immediately compared to 0 can be simplified by removing the 
            Compare/CompareTo method call. The comparison operator is then applied
            directly to the arguments for the Compare/CompareTo call.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.GroupBy.AggregatingGroupByRewriter">
            <summary>
            An AggregatingGroupBy is a query such as:
            <code>
            	from p in db.Products
            	group p by p.Category.CategoryId
            	into g
            	select new
            	{
            		g.Key,
            		MaxPrice = g.Max(p => p.UnitPrice)
            	};
            </code>
            <para>
            Where the grouping operation is being fully aggregated and hence does not create any form of hierarchy.
            This class takes such queries, flattens out the re-linq sub-query and re-writes the outer select
            </para>
            </summary>
        </member>
        <member name="T:NHibernate.Linq.GroupBy.IsNonAggregatingGroupByDetectionVisitor">
            <summary>
            Detects if an expression tree contains naked QuerySourceReferenceExpression
            </summary>
        </member>
        <member name="T:NHibernate.Linq.GroupJoin.AggregatingGroupJoinRewriter">
            <summary>
            An AggregatingGroupJoin is a query such as:
            
               from c in db.Customers
               join o in db.Orders on c.CustomerId equals o.Customer.CustomerId into ords
               join e in db.Employees on c.Address.City equals e.Address.City into emps
               select new { c.ContactName, ords = ords.Count(), emps = emps.Count() };
            
            where the results of the joins are being fully aggregated and hence do not create any form of hierarchy.
            This class takes such expressions and turns them into this form:
            
               from c in db.Customers
               select new
               {
                   c.ContactName,
                   ords = (from o2 in db.Orders where o2.Customer.CustomerId == c.CustomerId select o2).Count(),
                   emps = (from e2 in db.Employees where e2.Address.City == c.Address.City select e2).Count()
               };
            
            </summary>
        </member>
        <member name="T:NHibernate.Linq.ReWriters.ResultOperatorRewriter">
            <summary>
            Removes various result operators from a query so that they can be processed at the same
            tree level as the query itself.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.ReWriters.ResultOperatorRewriter.ResultOperatorExpressionRewriter">
            <summary>
            Rewrites expressions so that they sit in the outermost portion of the query.
            </summary>
        </member>
        <member name="P:NHibernate.Linq.ReWriters.ResultOperatorRewriter.ResultOperatorExpressionRewriter.ResultOperators">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Remotion.Linq.Clauses.ResultOperatorBase"/> that were rewritten.
            </summary>
        </member>
        <member name="P:NHibernate.Linq.ReWriters.ResultOperatorRewriter.ResultOperatorExpressionRewriter.EvaluationType">
            <summary>
            Gets the <see cref="T:Remotion.Linq.Clauses.StreamedData.IStreamedDataInfo"/> representing the type of data that the operator works upon.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.ReWriters.ResultOperatorRewriterResult">
            <summary>
            Result of <see cref="M:NHibernate.Linq.ReWriters.ResultOperatorRewriter.Rewrite(Remotion.Linq.QueryModel)"/>.
            </summary>
        </member>
        <member name="P:NHibernate.Linq.ReWriters.ResultOperatorRewriterResult.RewrittenOperators">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Remotion.Linq.Clauses.ResultOperatorBase"/> implementations that were
            rewritten.
            </summary>
        </member>
        <member name="P:NHibernate.Linq.ReWriters.ResultOperatorRewriterResult.EvaluationType">
            <summary>
            Gets the <see cref="T:Remotion.Linq.Clauses.StreamedData.IStreamedDataInfo"/> representing the type of data that the operator works upon.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.Visitors.EqualityHqlGenerator">
            <summary>
            Builds HQL Equality nodes and used in joins
            </summary>
        </member>
        <member name="T:NHibernate.Linq.Visitors.ExpressionKeyVisitor">
            <summary>
            Performs the equivalent of a ToString() on an expression. Swaps out constants for 
            parameters so that, for example:
            	from c in Customers where c.City = "London"
            generate the same key as 
            	from c in Customers where c.City = "Madrid"
            </summary>
        </member>
        <member name="T:NHibernate.Linq.Visitors.ExpressionParameterVisitor">
            <summary>
            Locates constants in the expression tree and generates parameters for each one
            </summary>
        </member>
        <member name="M:NHibernate.Linq.Visitors.PagingRewriterSelectClauseVisitor.GetSubQuerySelectorOrNull(Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression)">
            <summary>
            If the querySource is a subquery, return the SelectClause's selector if it's
            NewExpression. Otherwise, return null.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.Visitors.PossibleValueSet">
            <summary>
            Represents a possible set of values for a computation.  For example, an expression may
            be null, it may be a non-null value, or we may even have a constant value that is known
            precisely.  This class contains operators that know how to combine these values with
            each other.  This class is intended to be used to provide static analysis of expressions
            before we hit the database.  As an example for future improvement, we could handle
            ranges of numeric values.  We can also improve this by handling operators such as the
            comparison operators and arithmetic operators.  They are currently handled by naive
            null checks.
            </summary>
        </member>
        <member name="M:NHibernate.Linq.Visitors.PossibleValueSet.DetermineBoolType(NHibernate.Linq.Visitors.PossibleValueSet)">
            <summary>
            Verify that ExpressionType of both this and the other set is bool or nullable bool,
            and return the negotiated type (nullable bool if either side is nullable).
            </summary>
        </member>
        <member name="M:NHibernate.Linq.Visitors.PossibleValueSet.DetermineBoolType">
            <summary>
            Verify that ExpressionType is bool or nullable bool.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.Visitors.QuerySourceIdentifier">
            <summary>
            Identifies and names - using <see cref="T:NHibernate.Linq.QuerySourceNamer"/> - all QueryModel query sources
            </summary>
            <remarks>
            It may seem expensive to do this as a separate visitation of the query model, but unfortunately
            trying to identify query sources on the fly (i.e. while parsing the query model to generate
            the HQL expression tree) means a query source may be referenced by a <c>QuerySourceReference</c>
            before it has been identified - and named.
            </remarks>
        </member>
        <member name="T:NHibernate.Linq.Visitors.SelectClauseHqlNominator">
            <summary>
            Analyze the select clause to determine what parts can be translated
            fully to HQL, and some other properties of the clause.
            </summary>
        </member>
        <member name="P:NHibernate.Linq.Visitors.SelectClauseHqlNominator.HqlCandidates">
            <summary>
            The expression parts that can be converted to pure HQL.
            </summary>
        </member>
        <member name="P:NHibernate.Linq.Visitors.SelectClauseHqlNominator.ContainsUntranslatedMethodCalls">
            <summary>
            If true after an expression have been analyzed, the
            expression as a whole contain at least one method call which
            cannot be converted to a registered function, i.e. it must
            be executed client side.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.Visitors.SimplifyConditionalVisitor">
            <summary>
            Some conditional expressions can be redured to just their IfTrue or IfFalse part.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NHibernate.Linq.Visitors.WhereJoinDetector" -->
        <member name="P:NHibernate.Linq.Visitors.WhereJoinDetector.ExpressionValues.Values">
            <summary>
            Possible values of expression if there's set of values for the requested member expression.
            For example, if we have an expression "3" and we request the state for "a.B.C", we'll
            use "3" from Values since it won't exist in MemberExpressionValuesIfEmptyOuterJoined.
            </summary>
        </member>
        <member name="P:NHibernate.Linq.Visitors.WhereJoinDetector.ExpressionValues.MemberExpressionValuesIfEmptyOuterJoined">
            <summary>
            Stores the possible values of an expression that would result if the given member expression
            string was emptily outer joined.  For example a.B.C would result in "null" if we try to
            outer join to B and there are no rows.  Even if an expression tree does contain a particular
            member experssion, it may not appear in this list.  In that case, the emptily outer joined
            value set for that member expression will be whatever's in Values instead.
            </summary>
        </member>
        <member name="M:NHibernate.Linq.ReflectionHelper.GetMethodDefinition``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Extract the <see cref="T:System.Reflection.MethodInfo"/> from a given expression.
            </summary>
            <typeparam name="TSource">The declaring-type of the method.</typeparam>
            <param name="method">The method.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/> of the no-generic method or the generic-definition for a generic-method.</returns>
            <seealso cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition"/>
        </member>
        <member name="M:NHibernate.Linq.ReflectionHelper.GetMethod``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Extract the <see cref="T:System.Reflection.MethodInfo"/> from a given expression.
            </summary>
            <typeparam name="TSource">The declaring-type of the method.</typeparam>
            <param name="method">The method.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/> of the method.</returns>
        </member>
        <member name="M:NHibernate.Linq.ReflectionHelper.GetMethodDefinition(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Extract the <see cref="T:System.Reflection.MethodInfo"/> from a given expression.
            </summary>
            <param name="method">The method.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/> of the no-generic method or the generic-definition for a generic-method.</returns>
            <seealso cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition"/>
        </member>
        <member name="M:NHibernate.Linq.ReflectionHelper.GetMethod(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Extract the <see cref="T:System.Reflection.MethodInfo"/> from a given expression.
            </summary>
            <param name="method">The method.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/> of the method.</returns>
        </member>
        <member name="M:NHibernate.Linq.ReflectionHelper.GetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the field or property to be accessed.
            </summary>
            <typeparam name="TSource">The declaring-type of the property.</typeparam>
            <typeparam name="TResult">The type of the property.</typeparam>
            <param name="property">The expression representing the property getter.</param>
            <returns>The <see cref="T:System.Reflection.MemberInfo"/> of the property.</returns>
        </member>
        <member name="M:NHibernate.Linq.LinqLogging.LogExpression(System.String,System.Linq.Expressions.Expression)">
            <summary>
            If debug logging is enabled, log a string such as "msg: expression.ToString()".
            </summary>
        </member>
        <member name="T:NHibernate.Linq.LinqLogging.ProxyReplacingExpressionTreeVisitor">
            <summary>
            Replace all occurances of ConstantExpression where the value is an NHibernate
            proxy with a ParameterExpression. The name of the parameter will be a string
            representing the proxied entity, without initializing it.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.NhQueryable`1">
            <summary>
            Provides the main entry point to a LINQ query.
            </summary>
        </member>
        <member name="T:NHibernate.Linq.QuerySourceNamer">
            <summary>
            Associate unique names to query sources. The HQL AST parser will rename them anyway, but we need to
            ensure uniqueness that is not provided by IQuerySource.ItemName.
            </summary>
        </member>
        <member name="T:NHibernate.Transform.IResultTransformer">
            <summary>
            Implementors define a strategy for transforming criteria query
            results into the actual application-visible query result list.
            </summary>
            <seealso cref="M:NHibernate.ICriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)"/>
        </member>
        <member name="M:NHibernate.Transform.IResultTransformer.TransformTuple(System.Object[],System.String[])">
            <summary>
            
            </summary>
            <param name="tuple"></param>
            <param name="aliases"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Transform.IResultTransformer.TransformList(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Linq.SqlMethods.Like(System.String,System.String)">
            <summary>
            Use the SqlMethods.Like() method in a Linq2NHibernate expression to generate
            an SQL LIKE expression. (If you want to avoid depending on the NHibernate.Linq namespace,
            you can define your own replica of this method. Any 2-argument method named Like in a class named SqlMethods
            will be translated.) This method can only be used in Linq2NHibernate expression, and will throw
            if called directly.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.BasicCollectionJoinWalker">
            <summary>
            Walker for collections of values and many-to-many associations
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.CollectionJoinWalker">
            <summary>
            Superclass of walkers for collection initializers
            <seealso cref="T:NHibernate.Loader.Collection.CollectionLoader"/>
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyJoinWalker"/>
            <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionJoinWalker"/>
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.AddAssociationToJoinTreeIfNecessary(NHibernate.Type.IAssociationType,System.String[],System.String,System.String,System.Int32,NHibernate.SqlCommand.JoinType)">
            <summary>
            Add on association (one-to-one, many-to-one, or a collection) to a list
            of associations to be fetched by outerjoin (if necessary)
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.AddAssociationToJoinTree(NHibernate.Type.IAssociationType,System.String[],System.String,System.String,System.Int32,NHibernate.SqlCommand.JoinType)">
            <summary>
            Add on association (one-to-one, many-to-one, or a collection) to a list
            of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.AddAssociation(System.String,NHibernate.Loader.OuterJoinableAssociation)">
            <summary>
            Adds an association and extracts the aliases the association's 'with clause' is dependent on
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkEntityTree(NHibernate.Persister.Entity.IOuterJoinLoadable,System.String)">
            <summary>
            For an entity class, return a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkCollectionTree(NHibernate.Persister.Collection.IQueryableCollection,System.String)">
            <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkCollectionTree(NHibernate.Persister.Collection.IQueryableCollection,System.String,System.String,System.Int32)">
            <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkEntityTree(NHibernate.Persister.Entity.IOuterJoinLoadable,System.String,System.String,System.Int32)">
            <summary>
            For an entity class, add to a list of associations to be fetched
            by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkComponentTree(NHibernate.Type.IAbstractComponentType,System.Int32,System.String,System.String,System.Int32,NHibernate.Engine.ILhsAssociationTypeSqlInfo)">
            <summary>
            For a component, add to a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WalkCompositeElementTree(NHibernate.Type.IAbstractComponentType,System.String[],NHibernate.Persister.Collection.IQueryableCollection,System.String,System.String,System.Int32)">
            <summary>
            For a composite element, add to a list of associations to be fetched by outerjoin
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.SubPath(System.String,System.String)">
            <summary>
            Extend the path by the given property name
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.GetJoinType(NHibernate.Type.IAssociationType,NHibernate.FetchMode,System.String,System.String,System.String[],System.Boolean,System.Int32,NHibernate.Engine.CascadeStyle)">
            <summary>
            Get the join type (inner, outer, etc) or -1 if the
            association should not be joined. Override on
            subclasses.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.GetJoinType(System.Boolean,System.Int32)">
            <summary>
            Use an inner join if it is a non-null association and this
            is the "first" join in a series
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsJoinedFetchEnabledInMapping(NHibernate.FetchMode,NHibernate.Type.IAssociationType)">
            <summary>
            Does the mapping, and Hibernate default semantics, specify that
            this association should be fetched by outer joining
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.CascadeStyle)">
            <summary>
            Override on subclasses to enable or suppress joining
            of certain association types
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsDuplicateAssociation(System.String,System.String[])">
            <summary>
            Used to detect circularities in the joined graph, note that
            this method is side-effecty
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsDuplicateAssociation(System.String,System.String[],NHibernate.Type.IAssociationType)">
            <summary>
            Used to detect circularities in the joined graph, note that
            this method is side-effecty
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.IsJoinable(NHibernate.SqlCommand.JoinType,System.Collections.Generic.ISet{NHibernate.Loader.JoinWalker.AssociationKey},System.String,System.String[],NHibernate.Type.IAssociationType,System.Int32)">
            <summary>
            Should we join this association?
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.MergeOuterJoins(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
            <summary>
            Generate a sequence of <c>LEFT OUTER JOIN</c> clauses for the given associations.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.CountEntityPersisters(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
            <summary>
            Count the number of instances of IJoinable which are actually
            also instances of ILoadable, or are one-to-many associations
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.CountCollectionPersisters(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
            <summary>
            Count the number of instances of <see cref="T:NHibernate.Persister.Entity.IJoinable"/> which
            are actually also instances of <see cref="T:NHibernate.Collection.IPersistentCollection"/>
            which are being fetched by outer join
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.OrderBy(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
            <summary>
            Get the order by string required for collection fetching
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.WhereString(System.String,System.String[],System.Int32)">
            <summary>
            Render the where condition for a (batch) load by identifier / collection key
            </summary>
        </member>
        <member name="M:NHibernate.Loader.JoinWalker.SelectString(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
            <summary>
            Generate a select list of columns containing all properties of the entity classes
            </summary>
        </member>
        <member name="T:NHibernate.Loader.JoinWalker.AssociationKey">
            <summary>
            Uniquely identifier a foreign key, so that we don't
            join it more than once, and create circularities
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.BasicCollectionLoader">
            <summary> 
            Loads a collection of values or a many-to-many association.
            </summary>
            <remarks>
            The collection persister must implement <seealso cref="T:NHibernate.Persister.Collection.IQueryableCollection"/>. For
            other collections, create a customized subclass of <seealso cref="T:NHibernate.Loader.Loader"/>
            </remarks>
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
        </member>
        <member name="T:NHibernate.Loader.Collection.CollectionLoader">
            <summary>
            Superclass for loaders that initialize collections
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
            <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader"/>
            </summary>
        </member>
        <member name="T:NHibernate.Loader.OuterJoinLoader">
            <summary>
            Implements logic for walking a tree of associated classes.
            </summary>
            <remarks>
            Generates an SQL select string containing all properties of those classes.
            Tablse are joined using an ANSI-style left outer join.
            </remarks>
        </member>
        <member name="T:NHibernate.Loader.Loader">
            <summary>
            Abstract superclass of object loading (and querying) strategies.
            </summary>
            <remarks>
            <p>
            This class implements useful common functionality that concrete loaders would delegate to.
            It is not intended that this functionality would be directly accessed by client code (Hence,
            all methods of this class are declared <c>protected</c> or <c>private</c>.) This class relies heavily upon the
            <see cref="T:NHibernate.Persister.Entity.ILoadable"/> interface, which is the contract between this class and 
            <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/>s that may be loaded by it.
            </p>
            <p>
            The present implementation is able to load any number of columns of entities and at most 
            one collection role per query.
            </p>
            </remarks>
            <seealso cref="T:NHibernate.Persister.Entity.ILoadable"/>
        </member>
        <member name="F:NHibernate.Loader.Loader._canUseLimits">
            <summary>
            Indicates whether the dialect is able to add limit and/or offset clauses to <see cref="P:NHibernate.Loader.Loader.SqlString"/>.
            Even if a dialect generally supports the addition of limit and/or offset clauses to SQL statements,
            there may (custom) SQL statements where this is not possible, for example in case of SQL Server 
            stored procedure invocations.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetLockModes(System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode})">
            <summary>
            What lock mode does this load entities with?
            </summary>
            <param name="lockModes">A Collection of lock modes specified dynamically via the Query Interface</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.ApplyLocks(NHibernate.SqlCommand.SqlString,System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode},NHibernate.Dialect.Dialect)">
            <summary>
            Append <c>FOR UPDATE OF</c> clause, if necessary. This
            empty superclass implementation merely returns its first
            argument.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.UpgradeLocks">
            <summary>
            Does this query return objects that might be already cached by 
            the session, whose lock mode may need upgrading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.PreprocessSQL(NHibernate.SqlCommand.SqlString,NHibernate.Engine.QueryParameters,NHibernate.Dialect.Dialect)">
            <summary>
            Modify the SQL, adding lock hints and comments, if necessary
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.DoQueryAndInitializeNonLazyCollections(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Boolean)">
            <summary>
            Execute an SQL query and attempt to instantiate instances of the class mapped by the given
            persister from each row of the <c>DataReader</c>. If an object is supplied, will attempt to
            initialize that object. If a collection is supplied, attempt to initialize that collection.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadSingleRow(System.Data.IDataReader,NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Boolean)">
            <summary>
            Loads a single row from the result set.  This is the processing used from the
            ScrollableResults where no collection fetches were encountered.
            </summary>
            <param name="resultSet">The result set from which to do the load.</param>
            <param name="session">The session from which the request originated.</param>
            <param name="queryParameters">The query parameters specified by the user.</param>
            <param name="returnProxies">Should proxies be generated</param>
            <returns>The loaded "row".</returns>
            <exception cref="T:NHibernate.HibernateException"/>
        </member>
        <member name="M:NHibernate.Loader.Loader.ReadCollectionElements(System.Object[],System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read any collection elements contained in a single row of the result set
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.ResolveResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Determine the actual ResultTransformer that will be used to transform query results.
            </summary>
            <param name="resultTransformer">The specified result transformer.</param>
            <returns>The actual result transformer.</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.AreResultSetRowsTransformedImmediately">
            <summary>
            Are rows transformed immediately after being read from the ResultSet?
            </summary>
            <param name="transformer">The specified result transformer.</param>
            <returns>True, if getResultColumnOrRow() transforms the results; false, otherwise</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetResultColumnOrRow(System.Object[],NHibernate.Transform.IResultTransformer,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the actual object that is returned in the user-visible result list.
            </summary>
            <remarks>
            This empty implementation merely returns its first argument. This is
            overridden by some subclasses.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.RegisterNonExists(NHibernate.Engine.EntityKey[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            For missing objects associated by one-to-one with another object in the
            result set, register the fact that the the object is missing with the
            session.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.ReadCollectionElement(System.Object,System.Object,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read one collection element from the current row of the ADO.NET result set
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.HandleEmptyCollections(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            If this is a collection initializer, we need to tell the session that a collection
            is being initilized, to account for the possibility of the collection having
            no elements (hence no rows in the result set).
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetKeyFromResultSet(System.Int32,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read a row of <c>EntityKey</c>s from the <c>IDataReader</c> into the given array.
            </summary>
            <remarks>
            Warning: this method is side-effecty. If an <c>id</c> is given, don't bother going
            to the <c>IDataReader</c>
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.CheckVersion(System.Int32,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Check the version of the object in the <c>IDataReader</c> against
            the object version in the session cache, throwing an exception
            if the version numbers are different.
            </summary>
            <exception cref="T:NHibernate.StaleObjectStateException"></exception>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetRow(System.Data.IDataReader,NHibernate.Persister.Entity.ILoadable[],NHibernate.Engine.EntityKey[],System.Object,NHibernate.Engine.EntityKey,NHibernate.LockMode[],System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Resolve any ids for currently loaded objects, duplications within the <c>IDataReader</c>,
            etc. Instanciate empty objects to be initialized from the <c>IDataReader</c>. Return an
            array of objects (a row of results) and an array of booleans (by side-effect) that determine
            wheter the corresponding object should be initialized
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.InstanceAlreadyLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            The entity instance is already in the session cache
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.InstanceNotYetLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.EntityKey,NHibernate.LockMode,System.String,NHibernate.Engine.EntityKey,System.Object,System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
            <summary>
            The entity instance is not in the session cache
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadFromResultSet(System.Data.IDataReader,System.Int32,System.Object,System.String,NHibernate.Engine.EntityKey,System.String,NHibernate.LockMode,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Hydrate the state of an object from the SQL <c>IDataReader</c>, into
            an array of "hydrated" values (do not resolve associations yet),
            and pass the hydrated state to the session.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetInstanceClass(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.ILoadable,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine the concrete class of an instance for the <c>IDataReader</c>
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.Advance(System.Data.IDataReader,NHibernate.Engine.RowSelection)">
            <summary>
            Advance the cursor to the first required row of the <c>IDataReader</c>
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.UseLimit(NHibernate.Engine.RowSelection,NHibernate.Dialect.Dialect)">
            <summary>
            Should we pre-process the SQL string, adding a dialect-specific
            LIMIT clause.
            </summary>
            <param name="selection"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetOffsetUsingDialect(NHibernate.Engine.RowSelection,NHibernate.Dialect.Dialect)">
            <summary>
            Performs dialect-specific manipulations on the offset value before returning it.
            This method is applicable for use in limit statements only.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetLimitUsingDialect(NHibernate.Engine.RowSelection,NHibernate.Dialect.Dialect)">
            <summary>
            Performs dialect-specific manipulations on the limit value before returning it.
            This method is applicable for use in limit statements only.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.PrepareQueryCommand(NHibernate.Engine.QueryParameters,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Obtain an <c>IDbCommand</c> with all parameters pre-bound. Bind positional parameters,
            named parameters, and limit parameters.
            </summary>
            <remarks>
            Creates an IDbCommand object and populates it with the values necessary to execute it against the 
            database to Load an Entity.
            </remarks>
            <param name="queryParameters">The <see cref="T:NHibernate.Engine.QueryParameters"/> to use for the IDbCommand.</param>
            <param name="scroll">TODO: find out where this is used...</param>
            <param name="session">The SessionImpl this Command is being prepared in.</param>
            <returns>A CommandWrapper wrapping an IDbCommand that is ready to be executed.</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetMaxOrLimit(NHibernate.Dialect.Dialect,NHibernate.Engine.RowSelection)">
            <summary> 
            Some dialect-specific LIMIT clauses require the maximium last row number
            (aka, first_row_number + total_row_count), while others require the maximum
            returned row count (the total maximum number of rows to return). 
            </summary>
            <param name="selection">The selection criteria </param>
            <param name="dialect">The dialect </param>
            <returns> The appropriate value to bind into the limit clause. </returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetResultSet(System.Data.IDbCommand,System.Boolean,System.Boolean,NHibernate.Engine.RowSelection,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Fetch a <c>IDbCommand</c>, call <c>SetMaxRows</c> and then execute it,
            advance to the first result and return an SQL <c>IDataReader</c>
            </summary>
            <param name="st">The <see cref="T:System.Data.IDbCommand"/> to execute.</param>
            <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection"/> to apply to the <see cref="T:System.Data.IDbCommand"/> and <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="autoDiscoverTypes">true if result types need to be auto-discovered by the loader; false otherwise.</param>
            <param name="session">The <see cref="T:NHibernate.ISession"/> to load in.</param>
            <param name="callable"></param>
            <returns>An IDataReader advanced to the first record in RowSelection.</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadEntity(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType,System.Object,System.String,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Called by subclasses that load entities
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadEntityBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType,System.Object,System.String,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
            <summary>
            Called by subclasses that batch load entities
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollection(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType)">
            <summary>
            Called by subclasses that load collections
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollectionBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType)">
            <summary>
            Called by wrappers that batch initialize collections
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollectionSubselect(NHibernate.Engine.ISessionImplementor,System.Object[],System.Object[],NHibernate.Type.IType[],System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue},NHibernate.Type.IType)">
            <summary>
            Called by subclasses that batch initialize collections
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.List(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Collections.Generic.ISet{System.String},NHibernate.Type.IType[])">
            <summary>
            Return the query results, using the query cache, called
            by subclasses that implement cacheable queries
            </summary>
            <param name="session"></param>
            <param name="queryParameters"></param>
            <param name="querySpaces"></param>
            <param name="resultTypes"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.DoList(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters)">
            <summary>
            Actually execute a query, ignoring the query cache
            </summary>
            <param name="session"></param>
            <param name="queryParameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.PostInstantiate">
            <summary>
            Calculate and cache select-clause suffixes. Must be
            called by subclasses after instantiation.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.EntityEagerPropertyFetches">
            <summary> 
            An array indicating whether the entities have eager property fetching
            enabled. 
            </summary>
            <value> Eager property fetching indicators. </value>
        </member>
        <member name="P:NHibernate.Loader.Loader.Owners">
            <summary>
            An array of indexes of the entity that owns a one-to-one association
            to the entity at the given index (-1 if there is no "owner")
            </summary>
            <remarks>
            The indexes contained here are relative to the result of <see cref="P:NHibernate.Loader.Loader.EntityPersisters"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.Loader.OwnerAssociationTypes">
            <summary> 
            An array of the owner types corresponding to the <see cref="P:NHibernate.Loader.Loader.Owners"/>
            returns.  Indices indicating no owner would be null here. 
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.CollectionOwners">
            <summary>
            Get the index of the entity that owns the collection, or -1
            if there is no owner in the query results (i.e. in the case of a 
            collection initializer) or no collection.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.IsSingleRowLoader">
            <summary>
            Return false is this loader is a batch entity loader
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.EntityAliases">
            <summary>
            Get the result set descriptor
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.SqlString">
            <summary>
            The SqlString to be called; implemented by all subclasses
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.EntityPersisters">
            <summary>
            An array of persisters of entity classes contained in each row of results;
            implemented by all subclasses
            </summary>
            <remarks>
            The <c>setter</c> was added so that classes inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.Loader.CollectionPersisters">
            <summary>
            An (optional) persister for a collection to be initialized; only collection loaders
            return a non-null value
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.Aliases">
            <summary>
            Get the SQL table aliases of entities whose
            associations are subselect-loadable, returning
            null if this loader does not support subselect
            loading
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.ResultRowAliases">
            <summary>
            Returns the aliases that correspond to a result row.
            </summary>
            <returns>Returns the aliases that correspond to a result row.</returns>
        </member>
        <member name="P:NHibernate.Loader.Loader.QueryIdentifier">
            <summary> 
            Identifies the query for statistics reporting, if null,
            no statistics will be reported
            </summary>
        </member>
        <member name="M:NHibernate.Loader.BasicLoader.GenerateSuffixes(System.Int32)">
            <summary>
            Utility method that generates 0_, 1_ suffixes. Subclasses don't
            necessarily need to use this algorithm, but it is intended that
            they will in most cases.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.ICollectionInitializer">
            <summary>
            An interface for collection loaders
            </summary>
            <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader"/>
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
        </member>
        <member name="M:NHibernate.Loader.Collection.ICollectionInitializer.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initialize the given collection
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.BatchingCollectionInitializer">
            <summary>
            "Batch" loads collections, using multiple foreign key values in the SQL Where clause
            </summary>
            <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader"/>
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
        </member>
        <member name="T:NHibernate.Loader.Collection.OneToManyJoinWalker">
            <summary>
            Walker for one-to-many associations
            </summary>
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
        </member>
        <member name="T:NHibernate.Loader.Collection.OneToManyLoader">
            <summary>
            Loads one-to-many associations
            </summary>
            <remarks>
            The collection persister must implement <see cref="T:NHibernate.Persister.Collection.IQueryableCollection"/>.
            For other collections, create a customized subclass of <see cref="T:NHibernate.Loader.Loader"/>.
            </remarks>
            <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader"/>
        </member>
        <member name="T:NHibernate.Loader.Collection.SubselectCollectionLoader">
            <summary> Implements subselect fetching for a collection</summary>
        </member>
        <member name="T:NHibernate.Loader.Collection.SubselectOneToManyLoader">
            <summary>
            Implements subselect fetching for a one to many association
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Criteria.CriteriaJoinWalker">
            <summary>
            A <see cref="T:NHibernate.Loader.JoinWalker"/> for <see cref="T:NHibernate.ICriteria"/> queries.
            </summary>
            <seealso cref="T:NHibernate.Loader.Criteria.CriteriaLoader"/>
        </member>
        <member name="M:NHibernate.Loader.AbstractEntityJoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.CascadeStyle)">
            <summary>
            The superclass deliberately excludes collections
            </summary>
        </member>
        <member name="P:NHibernate.Loader.AbstractEntityJoinWalker.WhereFragment">
            <summary>
            Don't bother with the discriminator, unless overridden by subclass
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Criteria.CriteriaJoinWalker.WhereFragment">
            <summary>
            Use the discriminator, to narrow the select to instances
            of the queried subclass, also applying any filters.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Criteria.CriteriaLoader">
            <summary>
            A <c>Loader</c> for <see cref="T:NHibernate.ICriteria"/> queries. 
            </summary>
            <remarks>
            Note that criteria
            queries are more like multi-object <c>Load()</c>s than like HQL queries.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumnsUsingProjection(NHibernate.ICriteria,System.String)">
            <summary>
            Get the names of the columns constrained by this criterion.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetTypedValue(NHibernate.ICriteria,System.String,System.Object)">
            <summary>
            Get the a typed value for the given property value.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumnAliasesUsingProjection(NHibernate.ICriteria,System.String)">
            <summary>
            Get the aliases of the columns constrained
            by this criterion (for use in ORDER BY clause).
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.Sql.SQLCustomQuery">
             <summary> Implements Hibernate's built-in support for native SQL queries. </summary>
            <remarks>This support is built on top of the notion of "custom queries"...</remarks>
        </member>
        <member name="T:NHibernate.Loader.Custom.ICustomQuery">
            <summary> 
            Extension point allowing any SQL query with named and positional parameters
            to be executed by Hibernate, returning managed entities, collections and
            simple scalar values. 
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.ICustomQuery.SQL">
            <summary> The SQL query string to be performed. </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.ICustomQuery.QuerySpaces">
            <summary> 
            Any query spaces to apply to the query execution.  Query spaces are
            used in Hibernate's auto-flushing mechanism to determine which
            entities need to be checked for pending changes. 
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.ICustomQuery.CustomQueryReturns">
            <summary> 
            A collection of <see cref="T:NHibernate.Loader.Custom.IReturn"/> descriptors describing the
            ADO result set to be expected and how to map this result set. 
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Custom.Sql.SQLQueryParser.SubstituteParams(System.String)">
            <summary> 
            Substitues ADO parameter placeholders (?) for all encountered
            parameter specifications.  It also tracks the positions of these
            parameter specifications within the query string.  This accounts for
            ordinal-params, named-params, and ejb3-positional-params.
             </summary>
            <param name="sqlString">The query string. </param>
            <returns> The SQL query with parameter substitution complete. </returns>
        </member>
        <member name="T:NHibernate.Loader.Custom.CollectionFetchReturn">
            <summary> Spefically a fetch return that refers to a collection association. </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.FetchReturn">
            <summary> Represents a return which names a fetched association. </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.NonScalarReturn">
            <summary> Represents some non-scalar (entity/collection) return within the query result. </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.IReturn">
            <summary> Represents a return in a custom query. </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.FetchReturn.Owner">
            <summary> Retrieves the return descriptor for the owner of this fetch. </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.FetchReturn.OwnerProperty">
            <summary> The name of the property on the owner which represents this association. </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.CollectionReturn">
            <summary> 
            Represents a return which names a collection role; it
            is used in defining a custom query for loading an entity's
            collection in non-fetching scenarios (i.e., loading the collection
            itself as the "root" of the result). 
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.CollectionReturn.OwnerEntityName">
            <summary> Returns the class owning the collection. </summary>
        </member>
        <member name="P:NHibernate.Loader.Custom.CollectionReturn.OwnerProperty">
            <summary> Returns the name of the property representing the collection from the <see cref="P:NHibernate.Loader.Custom.CollectionReturn.OwnerEntityName"/>. </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.ColumnCollectionAliases">
            <summary>
            <see cref="T:NHibernate.Loader.ICollectionAliases"/> that uses columnnames instead of generated aliases.
            Aliases can still be overwritten via <c>&lt;return-property&gt;</c>
            </summary>
        </member>
        <member name="T:NHibernate.Loader.ICollectionAliases">
            <summary>
            Type definition of CollectionAliases.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedKeyAliases">
            <summary>
            Returns the suffixed result-set column-aliases for columns making
            up the key for this collection (i.e., its FK to its owner).
            </summary>
            <value>The key result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedIndexAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns
            making up the collection's index (map or list).
            </summary>
            <value>The index result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedElementAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns
            making up the collection's elements.
            </summary>
            <value>The element result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedIdentifierAlias">
            <summary>
            Returns the suffixed result-set column-aliases for the column
            defining the collection's identifier (if any).
            </summary>
            <value>The identifier result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.ICollectionAliases.Suffix">
            <summary>
            Returns the suffix used to unique the column aliases for this
            particular alias set.
            </summary>
            <value>The uniqued column alias suffix.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedKeyAliases">
            <summary>
            Returns the suffixed result-set column-aliases for columns making up the key for this collection (i.e., its FK to
            its owner).
            </summary>
            <value>The key result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedIndexAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's index (map or list).
            </summary>
            <value>The index result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedElementAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's elements.
            </summary>
            <value>The element result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedIdentifierAlias">
            <summary>
            Returns the suffixed result-set column-aliases for the column defining the collection's identifier (if any).
            </summary>
            <value>The identifier result-set column aliases.</value>
        </member>
        <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.Suffix">
            <summary>
            Returns the suffix used to unique the column aliases for this particular alias set.
            </summary>
            <value>The uniqued column alias suffix.</value>
        </member>
        <member name="T:NHibernate.Loader.Custom.ColumnEntityAliases">
            <summary>
            <see cref="T:NHibernate.Loader.IEntityAliases"/> that chooses the column names over the alias names.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.DefaultEntityAliases">
            <summary>
            EntityAliases which handles the logic of selecting user provided aliases (via return-property),
            before using the default aliases.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.IEntityAliases">
            <summary>
            Metadata describing the SQL result set column aliases
            for a particular entity
            </summary>
        </member>
        <member name="M:NHibernate.Loader.IEntityAliases.GetSuffixedPropertyAliases(NHibernate.Persister.Entity.ILoadable)">
            <summary>
            The result set column aliases for the property columns of a subclass
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedKeyAliases">
            <summary>
            The result set column aliases for the primary key columns
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedDiscriminatorAlias">
            <summary>
            The result set column aliases for the discriminator columns
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedVersionAliases">
            <summary>
            The result set column aliases for the version columns
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.RowIdAlias">
            <summary>
            The result set column alias for the Oracle row id
            </summary>
        </member>
        <member name="P:NHibernate.Loader.IEntityAliases.SuffixedPropertyAliases">
            <summary>
            The result set column aliases for the property columns
            </summary>
        </member>
        <member name="M:NHibernate.Loader.DefaultEntityAliases.#ctor(System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.Persister.Entity.ILoadable,System.String)">
            <summary>
            Calculate and cache select-clause suffixes.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.CustomLoader">
            <summary> 
            Extension point for loaders which use a SQL result set with "unexpected" column aliases. 
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Custom.CustomLoader.ResultRowProcessor.BuildResultRow(System.Object[],System.Data.IDataReader,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary> Build a logical result row. </summary>
            <param name="data">
            Entity data defined as "root returns" and already handled by the normal Loader mechanism.
            </param>
            <param name="resultSet">The ADO result set (positioned at the row currently being processed). </param>
            <param name="hasTransformer">Does this query have an associated <see cref="T:NHibernate.Transform.IResultTransformer"/>. </param>
            <param name="session">The session from which the query request originated.</param>
            <returns> The logical result row </returns>
            <remarks>
            At this point, Loader has already processed all non-scalar result data.  We
            just need to account for scalar result data here...
            </remarks>
        </member>
        <member name="T:NHibernate.Loader.Custom.CustomLoader.MetaData">
            <summary>
            Encapsulates the metadata available from the database result set.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.#ctor(System.Data.IDataReader)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Loader.Custom.CustomLoader.MetaData"/> class.
            </summary>
            <param name="resultSet">The result set.</param>
        </member>
        <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetColumnCount">
            <summary>
            Gets the column count in the result set.
            </summary>
            <returns>The column count.</returns>
        </member>
        <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetColumnPosition(System.String)">
            <summary>
            Gets the (zero-based) position of the column with the specified name.
            </summary>
            <param name="columnName">Name of the column.</param>
            <returns>The column position.</returns>
        </member>
        <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetColumnName(System.Int32)">
            <summary>
            Gets the name of the column at the specified position.
            </summary>
            <param name="position">The (zero-based) position.</param>
            <returns>The column name.</returns>
        </member>
        <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetHibernateType(System.Int32)">
            <summary>
            Gets the Hibernate type of the specified column.
            </summary>
            <param name="columnPos">The column position.</param>
            <returns>The Hibernate type.</returns>
        </member>
        <member name="T:NHibernate.Loader.Custom.EntityFetchReturn">
            <summary> Specifically a fetch return that refers to an entity association. </summary>
        </member>
        <member name="T:NHibernate.Loader.Custom.RootReturn">
            <summary> 
            Represents a return which names a "root" entity.
            </summary>
            <remarks>
            A root entity means it is explicitly a "column" in the result, as opposed to
            a fetched association.
            </remarks>
        </member>
        <member name="T:NHibernate.Loader.Custom.ScalarReturn">
            <summary> Represent a scalar (AKA simple value) return within a query result. </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.AbstractEntityLoader">
            <summary>
            Abstract superclass for entity loaders that use outer joins
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.IUniqueEntityLoader">
            <summary>
             Loads entities for a <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/>
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Entity.IUniqueEntityLoader.Load(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an entity instance. If <c>OptionalObject</c> is supplied, load the entity
            state into the given (uninitialized) object
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.BatchingEntityLoader">
            <summary>
            "Batch" loads entities, using multiple primary key values in the
            SQL <c>where</c> clause.
            </summary>
            <seealso cref="T:NHibernate.Loader.Entity.EntityLoader"/>
        </member>
        <member name="T:NHibernate.Loader.Entity.EntityJoinWalker">
            <summary>
            A walker for loaders that fetch entities
            </summary>
            <seealso cref="T:NHibernate.Loader.Entity.EntityLoader"/>
        </member>
        <member name="M:NHibernate.Loader.Entity.EntityJoinWalker.GenerateAliasForColumn(System.String,System.String)">
            <summary>
            Override to use the persister to change the table-alias for columns in join-tables
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Entity.EntityJoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.CascadeStyle)">
            <summary>
            Disable outer join fetching if this loader obtains an
            upgrade lock mode
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Entity.EntityLoader">
            <summary>
            Load an entity using outerjoin fetching to fetch associated entities.
            </summary>
            <remarks>
            The <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/> must implement <see cref="T:NHibernate.Persister.Entity.ILoadable"/>. For other entities,
            create a customized subclass of <see cref="T:NHibernate.Loader.Loader"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Hql.QueryLoader.GetLockModes(System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode})">
            <summary>
            
            </summary>
            <param name="lockModes">a collection of lock modes specified dynamically via the Query interface</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Loader.GeneratedCollectionAliases">
            <summary>
            CollectionAliases which handles the logic of selecting user provided aliases (via return-property),
            before using the default aliases.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedKeyAliases">
            <summary>
            Returns the suffixed result-set column-aliases for columns making up the key for this collection (i.e., its FK to
            its owner).
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedIndexAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's index (map or list).
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedElementAliases">
            <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's elements.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedIdentifierAlias">
            <summary>
            Returns the suffixed result-set column-aliases for the column defining the collection's identifier (if any).
            </summary>
        </member>
        <member name="P:NHibernate.Loader.GeneratedCollectionAliases.Suffix">
            <summary>
            Returns the suffix used to unique the column aliases for this particular alias set.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinableAssociation.GetPosition(System.String,System.Collections.Generic.IEnumerable{NHibernate.Loader.OuterJoinableAssociation})">
            <summary>
            Get the position of the join with the given alias in the
            list of joins
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.IManyToAnyMapper.MetaValue(System.Object,System.Type)">
            <summary>
            Add or modify a value-class pair.
            </summary>
            <param name="value">The value of the DB-field dor a given association instance (should override <see cref="M:System.Object.ToString"/>)</param>
            <param name="entityType">The class associated to the specific <paramref name="value"/>. </param>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.IAnyMapper.MetaValue(System.Object,System.Type)">
            <summary>
            Add or modify a value-class pair.
            </summary>
            <param name="value">The value of the DB-field dor a given association instance (should override <see cref="M:System.Object.ToString"/>)</param>
            <param name="entityType">The class associated to the specific <paramref name="value"/>. </param>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.ICacheMapper.Include(NHibernate.Mapping.ByCode.CacheInclude)">
            <summary>
            
            </summary>
            <param name="cacheInclude"></param>
            <remarks>Not supported in NH3.</remarks>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.IClassMapper.Join(System.String,System.Action{NHibernate.Mapping.ByCode.IJoinMapper})">
            <summary>
            Using the Join, it is possible to split properties of one class to several tables, when there's a 1-to-1 relationship between the table
            </summary>
            <param name="splitGroupId">The split-group identifier. By default it is assigned to the join-table-name</param>
            <param name="splitMapping">The lambda to map the join.</param>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.IComponentAsIdAttributesMapper.Class(System.Type)">
            <summary>
            Force the component to a different type than the one of the property.
            </summary>
            <param name="componentType">Mapped component type.</param>
            <remarks>
            Useful when the property is an interface and you need the mapping to a concrete class mapped as component.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.Impl.ICandidatePersistentMembersProvider.GetEntityMembersForPoid(System.Type)">
            <summary>
            Get all candidate persistent properties, or fields, to be used as Persistent-Object-ID, for a given root-entity class or interface.
            </summary>
            <param name="entityClass">The root-entity class or interface.</param>
            <returns>All candidate properties or fields to be used as Persistent-Object-ID.</returns>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.Impl.ICandidatePersistentMembersProvider.GetRootEntityMembers(System.Type)">
            <summary>
            Get all candidate persistent properties or fields for a given root-entity class or interface.
            </summary>
            <param name="entityClass">The root-entity class or interface.</param>
            <returns>All candidate properties or fields.</returns>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.Impl.ICandidatePersistentMembersProvider.GetSubEntityMembers(System.Type,System.Type)">
            <summary>
            Get all candidate persistent properties or fields for a given entity subclass or interface.
            </summary>
            <param name="entityClass">The entity subclass or interface.</param>
            <param name="entitySuperclass">The superclass (it may be different from <see cref="P:System.Type.BaseType"/>)</param>
            <returns>All candidate properties or fields.</returns>
            <remarks>
            In NHibernate, for a subclass, the method should return only those members not included in
            its super-classes.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.Impl.ICandidatePersistentMembersProvider.GetComponentMembers(System.Type)">
            <summary>
            Get all candidate persistent properties or fields for a given entity subclass or interface.
            </summary>
            <param name="componentClass">The class of the component or an interface.</param>
            <returns>All candidate properties or fields.</returns>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.IManyToOneMapper.Class(System.Type)">
            <summary>
            Force the many-to-one to a different type than the one of the property.
            </summary>
            <param name="entityType">Mapped entity type.</param>
            <remarks>
            Useful when the property is an interface and you need the mapping to a concrete class mapped as entity.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.IKeyMapper.ForeignKey(System.String)">
            <summary>
            Set the Foreign-Key name
            </summary>
            <param name="foreignKeyName">The name of the Foreign-Key</param>
            <remarks>
            Where the <paramref name="foreignKeyName"/> is "none" or <see cref="F:System.String.Empty"/> or all white-spaces the FK won't be created.
            Use null to reset the default NHibernate's behavior.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.ByCode.Impl.KeyPropertyMapper">
            <summary>
            Manage the mapping of a HbmKeyProperty but implementing <see cref="T:NHibernate.Mapping.ByCode.IPropertyMapper"/>
            instead a more limitated KeyProperty.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.ByCode.Cascade">
            <summary>
            Defines behavior of soft-cascade actions.
            </summary>
            <remarks>
            To check the content or to include/exclude values, from cascade, is strongly recommanded the usage of extensions methods defined in <see cref="T:NHibernate.Mapping.ByCode.CascadeExtensions"/>
            </remarks>
            <seealso cref="M:NHibernate.Mapping.ByCode.CascadeExtensions.Has(NHibernate.Mapping.ByCode.Cascade,NHibernate.Mapping.ByCode.Cascade)"/>
            <seealso cref="M:NHibernate.Mapping.ByCode.CascadeExtensions.Include(NHibernate.Mapping.ByCode.Cascade,NHibernate.Mapping.ByCode.Cascade)"/>
            <seealso cref="M:NHibernate.Mapping.ByCode.CascadeExtensions.Exclude(NHibernate.Mapping.ByCode.Cascade,NHibernate.Mapping.ByCode.Cascade)"/>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.BeforeMapClass">
            <summary>
            Occurs before apply pattern-appliers on a root class.
            </summary>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.BeforeMapSubclass">
            <summary>
            Occurs before apply pattern-appliers on a subclass.
            </summary>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.BeforeMapJoinedSubclass">
            <summary>
            Occurs before apply pattern-appliers on a joined-subclass.
            </summary>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.BeforeMapUnionSubclass">
            <summary>
            Occurs before apply pattern-appliers on a union-subclass.
            </summary>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.AfterMapClass">
            <summary>
            Occurs after apply the last customizer on a root class.
            </summary>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.AfterMapSubclass">
            <summary>
            Occurs after apply the last customizer on a subclass.
            </summary>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.AfterMapJoinedSubclass">
            <summary>
            Occurs after apply the last customizer on a joined-subclass..
            </summary>
        </member>
        <member name="E:NHibernate.Mapping.ByCode.ModelMapper.AfterMapUnionSubclass">
            <summary>
            Occurs after apply the last customizer on a union-subclass..
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.ByCode.MappingsExtensions">
            <summary>
            Util extensions to use in your test or where you need to see the XML mappings
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.ByCode.PropertyPath">
            <summary>
            Immutable value class. By-value equality.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.PropertyPathExtensions.InverseProgressivePath(NHibernate.Mapping.ByCode.PropertyPath)">
            <summary>
            Provide the list of progressive-paths
            </summary>
            <param name="source"></param>
            <returns>
            Given a path as : Pl1.Pl2.Pl3.Pl4.Pl5 returns paths-sequence as:
            Pl5
            Pl4.Pl5
            Pl3.Pl4.Pl5
            Pl2.Pl3.Pl4.Pl5
            Pl1.Pl2.Pl3.Pl4.Pl5
            </returns>
        </member>
        <member name="P:NHibernate.Mapping.ByCode.PropertyToField.DefaultStrategies">
            <summary>
            Dictionary containing the embedded strategies to find a field giving a property name.
            The key is the "partial-name" of the strategy used in XML mapping.
            The value is an instance of the strategy.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.ByCode.SimpleModelInspector">
            <summary>
            A <see cref="T:NHibernate.Mapping.ByCode.IModelInspector"/> which allows customization of conditions with explicitly declared members.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.TypeExtensions.DecodeMemberAccessExpressionOf``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Decode a member access expression of a specific ReflectedType
            </summary>
            <typeparam name="TEntity">Type to reflect</typeparam>
            <param name="expression">The expression of the property getter</param>
            <returns>The <see cref="T:System.Reflection.MemberInfo"/> os the ReflectedType. </returns>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.TypeExtensions.DecodeMemberAccessExpressionOf``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Decode a member access expression of a specific ReflectedType
            </summary>
            <typeparam name="TEntity">Type to reflect</typeparam>
            <typeparam name="TProperty">Type of property</typeparam>
            <param name="expression">The expression of the property getter</param>
            <returns>The <see cref="T:System.Reflection.MemberInfo"/> os the ReflectedType. </returns>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.TypeExtensions.GetMemberFromReflectedType(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Given a property or a field try to get the member from a given possible inherited type.
            </summary>
            <param name="member">The member to find.</param>
            <param name="reflectedType">The type where find the member.</param>
            <returns>The member from the reflected-type or the original <paramref name="member"/> where the <paramref name="member"/> is not accessible from <paramref name="reflectedType"/>.</returns>
        </member>
        <member name="M:NHibernate.Mapping.ByCode.TypeExtensions.GetPropertyOrFieldMatchingName(System.Type,System.String)">
            <summary>
            Try to find a property or field from a given type.
            </summary>
            <param name="source">The type</param>
            <param name="memberName">The property or field name.</param>
            <returns>
            A <see cref="T:System.Reflection.PropertyInfo"/> or a <see cref="T:System.Reflection.FieldInfo"/> where the member is found; null otherwise.
            </returns>
            <remarks>
            Where found the member is returned always from the declaring type.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.AbstractAuxiliaryDatabaseObject">
            <summary> 
            Convenience base class for <see cref="T:NHibernate.Mapping.IAuxiliaryDatabaseObject">AuxiliaryDatabaseObjects</see>.
            </summary>
            <remarks>
            This implementation performs dialect scoping checks strictly based on
            dialect name comparisons.  Custom implementations might want to do
            instanceof-type checks. 
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.IAuxiliaryDatabaseObject">
            <summary> 
            Auxiliary database objects (i.e., triggers, stored procedures, etc) defined
            in the mappings.  Allows Hibernate to manage their lifecycle as part of
            creating/dropping the schema. 
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IRelationalModel">
            <summary>
            Operations to create/drop the mapping element in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IRelationalModel.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to create 
            the mapping element in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <param name="defaultCatalog"></param>
            <returns>
            A string that contains the SQL to create an object.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.IRelationalModel.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to drop 
            the mapping element from the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop an object.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.IAuxiliaryDatabaseObject.AddDialectScope(System.String)">
            <summary> 
            Add the given dialect name to the scope of dialects to which
            this database object applies. 
            </summary>
            <param name="dialectName">The name of a dialect. </param>
        </member>
        <member name="M:NHibernate.Mapping.IAuxiliaryDatabaseObject.AppliesToDialect(NHibernate.Dialect.Dialect)">
            <summary> 
            Does this database object apply to the given dialect? 
            </summary>
            <param name="dialect">The dialect to check against. </param>
            <returns> True if this database object does apply to the given dialect. </returns>
        </member>
        <member name="M:NHibernate.Mapping.IAuxiliaryDatabaseObject.SetParameterValues(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Gets called by NHibernate to pass the configured type parameters to the implementation.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Any">
            <summary>
            A NHibernate <c>any</c> type.
            </summary>
            <remarks>
            Polymorphic association to one of several tables.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.SimpleValue">
            <summary>
            Any value that maps to columns.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IKeyValue">
            <summary>
            Represents an identifying key of a table: the value for primary key
            of an entity, or a foreign key of a collection or join table or
            joined subclass table.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IValue">
            <summary>
            A value is anything that is persisted by value, instead of
            by reference. It is essentially a Hibernate IType, together
            with zero or more columns. Values are wrapped by things with 
            higher level semantics, for example properties, collections, 
            classes.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IValue.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IValue.IsValid(NHibernate.Engine.IMapping)">
            <summary>
            Determines if the Value is part of a valid mapping.
            </summary>
            <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> to validate.</param>
            <returns>
            <see langword="true"/> if the Value is part of a valid mapping, <see langword="false"/>
            otherwise.
            </returns>
            <exception cref="T:NHibernate.MappingException"></exception>
            <remarks>
            Mainly used to make sure that Value maps to the correct number
            of columns.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.IValue.ColumnSpan">
            <summary>
            Gets the number of columns that this value spans in the table.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.ColumnIterator">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:NHibernate.Mapping.Column"/> objects
            that this value is stored in.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.Type">
            <summary>
            Gets the <see cref="T:NHibernate.Type.IType"/> to read/write the Values.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.Table">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.IValue.Table"/> this Value is stored in.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsAlternateUniqueKey">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Value is unique.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsNullable">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Value can have
            null values.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsSimpleValue">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this is a SimpleValue
            that does not involve foreign keys.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Any.IdentifierTypeName">
            <summary>
            Get or set the identifier type name
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Any.MetaType">
            <summary>
            Get or set the metatype 
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Any.MetaValues">
            <summary>
            Represent the relation between a meta-value and the related entityName
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Array">
            <summary>
            An array has a primary key consisting of the key columns + index column
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.List">
            <summary>
            A list has a primary key consisting of the key columns + index column
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IndexedCollection">
            <summary>
            Indexed collections include IList, IDictionary, Arrays
            and primitive Arrays.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Collection">
            <summary>
            Base class that stores the mapping information for <c>&lt;array&gt;</c>, <c>&lt;bag&gt;</c>, 
            <c>&lt;id-bag&gt;</c>, <c>&lt;list&gt;</c>, <c>&lt;map&gt;</c>, and <c>&lt;set&gt;</c>
            collections.
            </summary>
            <remarks> 
            Subclasses are responsible for the specialization required for the particular
            collection style.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.IFetchable">
            <summary>
            Any mapping with an outer-join attribute
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IFilterable">
            <summary>
            Defines mapping elements to which filters may be applied.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsGeneric">
            <summary>
            Gets or sets a <see cref="T:System.Boolean"/> indicating if this is a 
            mapping for a generic collection.
            </summary>
            <value>
            <see langword="true"/> if a collection from the System.Collections.Generic namespace
            should be used, <see langword="false"/> if a collection from the System.Collections 
            namespace should be used.
            </value>
            <remarks>
            This has no affect on any versions of the .net framework before .net-2.0.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Collection.GenericArguments">
            <summary>
            Gets or sets an array of <see cref="T:System.Type"/> that contains the arguments
            needed to construct an instance of a closed type.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.List.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.List"/> class.
            </summary>
            <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that contains this list mapping.</param>
        </member>
        <member name="P:NHibernate.Mapping.List.DefaultCollectionType">
            <summary>
            Gets the appropriate <see cref="T:NHibernate.Type.CollectionType"/> that is 
            specialized for this list mapping.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Property">
            <summary>
            Mapping for a property of a .NET class (entity
            or component).
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IMetaAttributable">
            <summary> Common interface for things that can handle meta attributes. </summary>
        </member>
        <member name="M:NHibernate.Mapping.IMetaAttributable.GetMetaAttribute(System.String)">
            <summary>
            Retrieve the <see cref="T:NHibernate.Mapping.MetaAttribute"/>
            </summary>
            <param name="attributeName">The attribute name</param>
            <returns>The <see cref="T:NHibernate.Mapping.MetaAttribute"/> if exists; null otherwise</returns>
        </member>
        <member name="P:NHibernate.Mapping.IMetaAttributable.MetaAttributes">
            <summary>
            Meta-Attribute collection.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.ColumnSpan">
            <summary>
            Gets the number of columns this property uses in the db.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.ColumnIterator">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/>s.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.Name">
            <summary>
            Gets or Sets the name of the Property in the class.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsNullable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Bag">
            <summary>
            A bag permits duplicates, so it has no primary key
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Bag.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            A bag permits duplicates, so it has no primary key.
            </summary>
            <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that contains this bag mapping.</param>
        </member>
        <member name="P:NHibernate.Mapping.Bag.DefaultCollectionType">
            <summary>
            Gets the appropriate <see cref="T:NHibernate.Type.CollectionType"/> that is 
            specialized for this bag mapping.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Column">
            <summary>
            Represents the mapping to a column in a database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Column.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Column"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Column.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Column"/>.
            </summary>
            <param name="columnName">The name of the column.</param>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the name of this Column in quoted form if it is necessary.
            </summary>
            <param name="d">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote
            the column name.
            </param>
            <returns>
            The column name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetAlias(NHibernate.Dialect.Dialect)">
            For any column name, generate an alias that is unique
            to that column name, and also 10 characters or less
            in length.
        </member>
        <member name="M:NHibernate.Mapping.Column.GetSqlType(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping)">
            <summary>
            Gets the name of the data type for the column.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use to get the valid data types.</param>
            <param name="mapping"></param>
            <returns>
            The name of the data type for the column. 
            </returns>
            <remarks>
            If the mapping file contains a value of the attribute <c>sql-type</c> this will
            return the string contained in that attribute.  Otherwise it will use the 
            typename from the <see cref="T:NHibernate.Dialect.Dialect"/> of the <see cref="P:NHibernate.Mapping.Column.SqlType"/> object. 
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Column.Equals(System.Object)">
            <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column"/> and a specified object, 
            which must be a <b>Column</b> can be considered the same.
            </summary>
            <param name="obj">An <see cref="T:System.Object"/> that should be a <see cref="T:NHibernate.Mapping.Column"/>.</param>
            <returns>
            <see langword="true"/> if the name of this Column and the other Column are the same, 
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.Equals(NHibernate.Mapping.Column)">
            <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column"/> and the specified Column 
            can be considered the same.
            </summary>
            <param name="column">A <see cref="T:NHibernate.Mapping.Column"/> to compare to this Column.</param>
            <returns>
            <see langword="true"/> if the name of this Column and the other Column are the same, 
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetQuotedName">
            <summary>returns quoted name as it would be in the mapping file. </summary>
        </member>
        <member name="M:NHibernate.Mapping.Column.Clone">
            <summary> Shallow copy, the value is not copied</summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.Length">
            <summary>
            Gets or sets the length of the datatype in the database.
            </summary>
            <value>The length of the datatype in the database.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Name">
            <summary>
            Gets or sets the name of the column in the database.
            </summary>
            <value>
            The name of the column in the database.  The get does 
            not return a Quoted column name.
            </value>
            <remarks>
            <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the column whenever SQL is generated
            for it.  How the column is quoted depends on the Dialect.
            </p>
            <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)"/>.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsNullable">
            <summary>
            Gets or sets if the column can have null values in it.
            </summary>
            <value><see langword="true" /> if the column can have a null value in it.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.TypeIndex">
            <summary>
            Gets or sets the index of the column in the <see cref="T:NHibernate.Type.IType"/>.
            </summary>
            <value>
            The index of the column in the <see cref="T:NHibernate.Type.IType"/>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsUnique">
            <summary>
            Gets or sets if the column contains unique values.
            </summary>
            <value><see langword="true" /> if the column contains unique values.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.SqlType">
            <summary>
            Gets or sets the sql data type name of the column.
            </summary>
            <value>
            The sql data type name of the column. 
            </value>
            <remarks>
            This is usually read from the <c>sql-type</c> attribute.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsQuoted">
            <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
            <value><see langword="true" /> if the column is quoted.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Unique">
            <summary>
            Gets or sets whether the column is unique.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.CheckConstraint">
            <summary>
            Gets or sets a check constraint on the column
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.HasCheckConstraint">
            <summary>
            Do we have a check constraint?
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.SqlTypeCode">
            <summary> 
            The underlying columns SqlType.
            </summary>
            <remarks>
            If null, it is because the sqltype code is unknown.
            
            Use <see cref="M:NHibernate.Mapping.Column.GetSqlTypeCode(NHibernate.Engine.IMapping)"/> to retreive the sqltypecode used
            for the columns associated Value/Type.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.Component">
            <summary>
            The mapping for a component, composite element, composite identifier,
            etc.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Component.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:NHibernate.Mapping.Component.PropertySpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.PropertyIterator">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ColumnIterator">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.IsEmbedded">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.IsDynamic">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ComponentClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.Owner">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ParentProperty">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Constraint">
            <summary>
            Base class for relational constraints in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the constraint.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Constraint.</param>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <param name="defaultCatalog"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
            <summary>
            Generates the SQL string to create this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <param name="defaultCatalog"></param>
            <returns>
            A string that contains the SQL to create this Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to create the named
            Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <param name="defaultCatalog"></param>
            <returns>
            A string that contains the SQL to create the named Constraint.
            </returns>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.Name">
            <summary>
            Gets or sets the Name used to identify the constraint in the database.
            </summary>
            <value>The Name used to identify the constraint in the database.</value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.ColumnIterator">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are part of the constraint.
            </summary>
            <value>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are part of the constraint.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.ColumnSpan">
            <summary>
            Gets the number of columns that this Constraint contains.
            </summary>
            <value>
            The number of columns that this Constraint contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.Table">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Constraint.Table"/> this Constraint is in.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Constraint.Table"/> this Constraint is in.
            </value>
        </member>
        <member name="T:NHibernate.Mapping.Table">
            <summary>
            Represents a Table in a database that an object gets mapped against.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Table"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
            <summary>
            Generates the SQL string to create this Table in the database.
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Table, Primary Key Constraints
            , and Unique Key Constraints.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to drop this Table in the database.
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> to use for SQL rules.</param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Table and to cascade the drop to 
            the constraints if the database supports it.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the schema qualified name of the Table.
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> that knows how to Quote the Table name.</param>
            <returns>The name of the table qualified with the schema if one is specified.</returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Gets the schema qualified name of the Table using the specified qualifier
            </summary>
            <param name="dialect">The <see cref="N:NHibernate.Dialect"/> that knows how to Quote the Table name.</param>
            <param name="defaultCatalog">The catalog name.</param>
            <param name="defaultSchema">The schema name.</param>
            <returns>A String representing the Qualified name.</returns>
            <remarks>If this were used with MSSQL it would return a dbo.table_name.</remarks>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedName">
            <summary> returns quoted name as it would be in the mapping file.</summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the name of this Table in quoted form if it is necessary.
            </summary>
            <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote the Table name.
            </param>
            <returns>
            The Table name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedSchema">
            <summary> returns quoted name as it is in the mapping file.</summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedSchemaName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the schema for this table in quoted form if it is necessary.
            </summary>
            <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote the table name.
            </param>
            <returns>
            The schema name for this table in a form that is safe to use inside
            of a SQL statement. Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetColumn(System.Int32)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Column"/> at the specified index.
            </summary>
            <param name="n">The index of the Column to get.</param>
            <returns> 
            The <see cref="T:NHibernate.Mapping.Column"/> at the specified index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the Table.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Table.</param>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetOrCreateIndex(System.String)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Index"/> identified by the name.
            </summary>
            <param name="indexName">The name of the <see cref="T:NHibernate.Mapping.Index"/> to get.</param>
            <returns>
            The <see cref="T:NHibernate.Mapping.Index"/> identified by the name.  If the <see cref="T:NHibernate.Mapping.Index"/>
            identified by the name does not exist then it is created.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetOrCreateUniqueKey(System.String)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.UniqueKey"/> identified by the name.
            </summary>
            <param name="keyName">The name of the <see cref="T:NHibernate.Mapping.UniqueKey"/> to get.</param>
            <returns>
            The <see cref="T:NHibernate.Mapping.UniqueKey"/> identified by the name.  If the <see cref="T:NHibernate.Mapping.UniqueKey"/>
            identified by the name does not exist then it is created.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.CreateForeignKey(System.String,System.Collections.Generic.IEnumerable{NHibernate.Mapping.Column},System.String,System.Collections.Generic.IEnumerable{NHibernate.Mapping.Column})">
            <summary>
            Create a <see cref="T:NHibernate.Mapping.ForeignKey"/> for the columns in the Table.
            </summary>
            <param name="keyName"></param>
            <param name="keyColumns">An <see cref="T:System.Collections.IList"/> of <see cref="T:NHibernate.Mapping.Column"/> objects.</param>
            <param name="referencedEntityName"></param>
            <param name="referencedColumns"></param>
            <returns>
            A <see cref="T:NHibernate.Mapping.ForeignKey"/> for the columns in the Table.  
            </returns>
            <remarks>
            This does not necessarily create a <see cref="T:NHibernate.Mapping.ForeignKey"/>, if
            one already exists for the columns then it will return an 
            existing <see cref="T:NHibernate.Mapping.ForeignKey"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Table.UniqueColumnString(System.Collections.IEnumerable)">
            <summary>
            Generates a unique string for an <see cref="T:System.Collections.ICollection"/> of 
            <see cref="T:NHibernate.Mapping.Column"/> objects.
            </summary>
            <param name="uniqueColumns">An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects.</param>
            <returns>
            An unique string for the <see cref="T:NHibernate.Mapping.Column"/> objects.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SetIdentifierValue(NHibernate.Mapping.SimpleValue)">
            <summary>
            Sets the Identifier of the Table.
            </summary>
            <param name="identifierValue">The <see cref="T:NHibernate.Mapping.SimpleValue"/> that represents the Identifier.</param>
        </member>
        <member name="M:NHibernate.Mapping.Table.AddCheckConstraint(System.String)">
            <summary>
            
            </summary>
            <param name="constraint"></param>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetColumn(NHibernate.Mapping.Column)">
            <summary> Return the column which is identified by column provided as argument. </summary>
            <param name="column">column with atleast a name. </param>
            <returns> 
            The underlying column or null if not inside this table.
            Note: the instance *can* be different than the input parameter, but the name will be the same.
            </returns>
        </member>
        <member name="P:NHibernate.Mapping.Table.Name">
            <summary>
            Gets or sets the name of the Table in the database.
            </summary>
            <value>
            The name of the Table in the database.  The get does 
            not return a Quoted Table name.
            </value>
            <remarks>
            <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the Table whenever SQL is generated
            for it.  How the Table is quoted depends on the Dialect.
            </p>
            <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)"/>.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Table.ColumnSpan">
            <summary>
            Gets the number of columns that this Table contains.
            </summary>
            <value>
            The number of columns that this Table contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.ColumnIterator">
            <summary>
            Gets an <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.IndexIterator">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Index"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Index"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.ForeignKeyIterator">
            <summary>
            Gets an <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.ForeignKey"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.ForeignKey"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.UniqueKeyIterator">
            <summary>
            Gets an <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.UniqueKey"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.UniqueKey"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.PrimaryKey">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Table.PrimaryKey"/> of the Table.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.Table.PrimaryKey"/> of the Table.</value>
        </member>
        <member name="P:NHibernate.Mapping.Table.Schema">
            <summary>
            Gets or sets the schema the table is in.
            </summary>
            <value>
            The schema the table is in or <see langword="null" /> if no schema is specified.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.UniqueInteger">
            <summary>
            Gets the unique number of the Table.
            </summary>
            <value>The unique number of the Table.</value>
        </member>
        <member name="P:NHibernate.Mapping.Table.IsQuoted">
            <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
            <value><see langword="true" /> if the column is quoted.</value>
        </member>
        <member name="T:NHibernate.Mapping.DependantValue">
            <summary> 
            A value which is "typed" by reference to some other value 
            (for example, a foreign key is typed by the referenced primary key). 
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.ForeignKey">
            <summary>
            A Foreign Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
            <summary>
            Generates the SQL string to create the named Foreign Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <param name="defaultCatalog"></param>
            <returns>
            A string that contains the SQL to create the named Foreign Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <param name="defaultCatalog"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.AlignColumns">
            <summary> 
            Validates that columnspan of the foreignkey and the primarykey is the same.
             Furthermore it aligns the length of the underlying tables columns.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.ForeignKey.ReferencedTable">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Table"/> that the Foreign Key is referencing.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Table"/> the Foreign Key is referencing.</value>
            <exception cref="T:NHibernate.MappingException">
            Thrown when the number of columns in this Foreign Key is not the same
            amount of columns as the Primary Key in the ReferencedTable.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.ForeignKey.IsReferenceToPrimaryKey">
            <summary>Does this foreignkey reference the primary key of the reference table </summary>
        </member>
        <member name="T:NHibernate.Mapping.Formula">
            <summary>
            A formula is a derived column value.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Formula.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Formula.GetTemplate(NHibernate.Dialect.Dialect,NHibernate.Dialect.Function.SQLFunctionRegistry)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <param name="functionRegistry"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Mapping.Formula.FormulaString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.IdentifierBag">
            <summary>
            An <c>PersistentIdentifierBag</c> has a primary key consistenting of just
            the identifier column.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IdentifierCollection">
            <summary>
            A collection with a synthetic "identifier" column.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.CreatePrimaryKey">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.IdentifierCollection.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.IdentifierCollection.IsIdentified">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Index">
            <summary>
            An Index in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Index.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
            <summary>
            Generates the SQL string to create this Index in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Index.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to drop this Index in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Index.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the Index.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Index.</param>
        </member>
        <member name="P:NHibernate.Mapping.Index.Table">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Index.Table"/> this Index is in.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Index.Table"/> this Index is in.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Index.ColumnIterator">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Index.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Index.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Index.Name">
            <summary>
            Gets or sets the Name used to identify the Index in the database.
            </summary>
            <value>The Name used to identify the Index in the database.</value>
        </member>
        <member name="T:NHibernate.Mapping.Subclass">
            <summary>
            Declaration of a System.Type mapped with the <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c> element.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.PersistentClass">
            <summary>
            Base class for the <see cref="P:NHibernate.Mapping.PersistentClass.RootClazz"/> mapped by <c>&lt;class&gt;</c> and a 
            <see cref="T:NHibernate.Mapping.Subclass"/> that is mapped by <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c>.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PersistentClass.NullDiscriminatorMapping">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Mapping.PersistentClass.NotNullDiscriminatorMapping">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclass(NHibernate.Mapping.Subclass)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass"/> to the class hierarchy.
            </summary>
            <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass"/> to add to the hierarchy.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            Change the property definition or add a new property definition
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> to add.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassProperty(NHibernate.Mapping.Property)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property"/> that is implemented by a subclass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> implemented by a subclass.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassTable(NHibernate.Mapping.Table)">
            <summary>
            Adds a <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> that a subclass is stored in.
            </summary>
            <param name="table">The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> the subclass is stored in.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.CreatePrimaryKey(NHibernate.Dialect.Dialect)">
            <summary>
            Creates the <see cref="T:NHibernate.Mapping.PrimaryKey"/> for the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/>
            this type is persisted in.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> that is used to Alias columns.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.GetReferencedProperty(System.String)">
            <summary>
            Given a property path, locate the appropriate referenceable property reference.
            </summary>
            <remarks>
            A referenceable property is a property  which can be a target of a foreign-key
            mapping (an identifier or explicitly named in a property-ref).
            </remarks>
            <param name="propertyPath">The property path to resolve into a property reference.</param>
            <returns>The property reference (never null).</returns>
            <exception cref="T:NHibernate.MappingException">If the property could not be found.</exception>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.MappedClass">
            <summary>
            Gets the <see cref="T:System.Type"/> that is being mapped.
            </summary>
            <value>The <see cref="T:System.Type"/> that is being mapped.</value>
            <remarks>
            The value of this is set by the <c>name</c> attribute on the <c>&lt;class&gt;</c> 
            element.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.ProxyInterface">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> to use as a Proxy.
            </summary>
            <value>The <see cref="T:System.Type"/> to use as a Proxy.</value>
            <remarks>
            The value of this is set by the <c>proxy</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DynamicInsert">
            <summary>
            Gets or Sets if the Insert Sql is built dynamically.
            </summary>
            <value><see langword="true" /> if the Sql is built at runtime.</value>
            <remarks>
            The value of this is set by the <c>dynamic-insert</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DynamicUpdate">
            <summary>
            Gets or Sets if the Update Sql is built dynamically.
            </summary>
            <value><see langword="true" /> if the Sql is built at runtime.</value>
            <remarks>
            The value of this is set by the <c>dynamic-update</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DiscriminatorValue">
            <summary>
            Gets or Sets the value to use as the discriminator for the Class.
            </summary>
            <value>
            A value that distinguishes this subclass in the database.
            </value>
            <remarks>
            The value of this is set by the <c>discriminator-value</c> attribute.  Each <c>&lt;subclass&gt;</c>
            in a hierarchy must define a unique <c>discriminator-value</c>.  The default value 
            is the class name if no value is supplied.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassSpan">
            <summary>
            Gets the number of subclasses that inherit either directly or indirectly.
            </summary>
            <value>The number of subclasses that inherit from this PersistentClass.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassIterator">
            <summary>
            Iterate over subclasses in a special 'order', most derived subclasses first.
            </summary>
            <value>
            It will recursively go through Subclasses so that if a SubclassType has Subclasses
            it will pick those up also.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DirectSubclasses">
            <summary>
            Gets an <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Subclass"/> objects
            that directly inherit from this PersistentClass.
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Subclass"/> objects
            that directly inherit from this PersistentClass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsInherited">
            <summary>
            When implemented by a class, gets a boolean indicating if this
            mapped class is inherited from another. 
            </summary>
            <value>
            <see langword="true" /> if this class is a <c>subclass</c> or <c>joined-subclass</c>
            that inherited from another <c>class</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsVersioned">
            <summary>
            When implemented by a class, gets a boolean indicating if the mapped class
            has a version property.
            </summary>
            <value><see langword="true" /> if there is a <c>&lt;version&gt;</c> property.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.PropertyClosureIterator">
            <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.IEnumerable"/> 
            of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
            <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.TableClosureIterator">
            <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.IEnumerable"/> 
            of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that this mapped class reads from
            and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassPropertyClosureIterator">
            <summary>
            Gets an <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that
            this mapped class contains and that all of its subclasses contain.
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that
            this mapped class contains and that all of its subclasses contain.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassTableClosureIterator">
            <summary>
            Gets an <see cref="T:System.Collections.IEnumerable"/> of all of the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that the 
            subclass finds its information in.  
            </summary>
            <value>An <see cref="T:System.Collections.IEnumerable"/> of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects.</value>
            <remarks>It adds the TableClosureIterator and the subclassTables into the IEnumerable.</remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.EntityPersisterClass">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:System.Type"/> of the Persister.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.RootTable">
            <summary>
            When implemented by a class, gets the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> of the class that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.BatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SelectBeforeUpdate">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.ReferenceablePropertyIterator">
            <summary>
            Build a collection of properties which are "referenceable".
            </summary>
            <remarks>
            See <see cref="M:NHibernate.Mapping.PersistentClass.GetReferencedProperty(System.String)"/> for a discussion of "referenceable".
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNotNull">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNull">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.PropertyIterator">
            <summary> 
            Build an iterator over the properties defined on this class.  The returned
            iterator only accounts for "normal" properties (i.e. non-identifier
            properties).
            </summary>
            <value>
            An <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NHibernate.Mapping.Property"/> objects.
            </value>
            <remarks>
            Differs from <see cref="P:NHibernate.Mapping.PersistentClass.UnjoinedPropertyIterator"/> in that the iterator
            we return here will include properties defined as part of a join.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.UnjoinedPropertyIterator">
            <summary> 
            Build an enumerable over the properties defined on this class <b>which
            are not defined as part of a join</b>.  
            As with <see cref="P:NHibernate.Mapping.PersistentClass.PropertyIterator"/> the returned iterator only accounts 
            for non-identifier properties.
            </summary>
            <returns> An enumerable over the non-joined "normal" properties.</returns>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasSubclasses">
            <summary>
            Gets a boolean indicating if this PersistentClass has any subclasses.
            </summary>
            <value><see langword="true" /> if this PeristentClass has any subclasses.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Table">
            <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> that this class is stored in.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> this class is stored in.</value>
            <remarks>
            The value of this is set by the <c>table</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsMutable">
            <summary>
            When implemented by a class, gets or set a boolean indicating 
            if the mapped class has properties that can be changed.
            </summary>
            <value><see langword="true" /> if the object is mutable.</value>
            <remarks>
            The value of this is set by the <c>mutable</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasIdentifierProperty">
            <summary>
            When implemented by a class, gets a boolean indicating
            if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><see langword="true" /> if there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IdentifierProperty">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property"/>
            that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Identifier">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Version">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property"/>
            that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Discriminator">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsPolymorphic">
            <summary>
            When implemented by a class, gets or sets if the mapped class has subclasses or is
            a subclass.
            </summary>
            <value>
            <see langword="true" /> if the mapped class has subclasses or is a subclass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.CacheConcurrencyStrategy">
            <summary>
            When implemented by a class, gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The CacheConcurrencyStrategy used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Superclass">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/>
            that this mapped class is extending.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsExplicitPolymorphism">
            <summary>
            When implemented by a class, gets or sets a boolean indicating if 
            explicit polymorphism should be used in Queries.
            </summary>
            <value>
            <see langword="true" /> if only classes queried on should be returned, <see langword="false" />
            if any class in the heirarchy should implicitly be returned.</value>
            <remarks>
            The value of this is set by the <c>polymorphism</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasEmbeddedIdentifier">
            <summary>
            When implemented by a class, gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><see langword="true" /> if the class identifies itself.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.RootClazz">
            <summary>
            When implemented by a class, gets the <see cref="T:NHibernate.Mapping.RootClass"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.RootClass"/> of the class that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Key">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Where">
            <summary>
            When implemented by a class, gets or sets the sql string that should 
            be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
            <remarks>
            The value of this is set by the <c>where</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsForceDiscriminator">
            <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
            <value><see langword="true" /> if the mapped discriminator values should be forced.</value>
            <remarks>
            The value of this is set by the <c>force</c> attribute on the <c>discriminator</c> element. 
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Subclass"/> class.
            </summary>
            <param name="superclass">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that is the superclass.</param>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            Add the <see cref="T:NHibernate.Mapping.Property"/> to this PersistentClass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> to add.</param>
            <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property"/> to the Superclass' collection
            of SubclassType Properties.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddSubclassProperty(NHibernate.Mapping.Property)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property"/> that is implemented by a subclass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> implemented by a subclass.</param>
            <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property"/> to the Superclass' collection
            of SubclassType Properties.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddSubclassTable(NHibernate.Mapping.Table)">
            <summary>
            Adds a <see cref="P:NHibernate.Mapping.Subclass.Table"/> that a subclass is stored in.
            </summary>
            <param name="table">The <see cref="P:NHibernate.Mapping.Subclass.Table"/> the subclass is stored in.</param>
            <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table"/> to the Superclass' collection
            of SubclassType Tables.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsInherited">
            <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
            <value>
            <see langword="true" /> because this is a SubclassType.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.PropertyClosureIterator">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
            <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.TableClosureIterator">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.Subclass.Table"/> objects that this 
            mapped class reads from and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.Subclass.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsVersioned">
            <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
            <value><see langword="true" /> if for the Superclass there is a Property for a <c>version</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.EntityPersisterClass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.RootTable">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.Subclass.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Subclass.Table"/> of the Superclass that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.CacheConcurrencyStrategy">
            <summary>
            Gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The CacheConcurrencyStrategy used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.RootClazz">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.Subclass.RootClazz"/> of the class that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Subclass.RootClazz"/> of the Superclass that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Superclass">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IdentifierProperty">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> from the Superclass that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Identifier">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> from the Superclass that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.HasIdentifierProperty">
            <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><see langword="true" /> if in the Superclass there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Discriminator">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> from the Superclass that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsMutable">
            <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
            <value><see langword="true" /> if the Superclass is mutable.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsPolymorphic">
            <summary>
            Gets or sets if the mapped class is a subclass.
            </summary>
            <value>
            <see langword="true" /> since this mapped class is a subclass.
            </value>
            <remarks>
            The setter should not be used to set the value to anything but <see langword="true" />.  
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Version">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> from the Superclass that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.HasEmbeddedIdentifier">
            <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><see langword="true" /> if the Superclass has an embedded identifier.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Key">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsExplicitPolymorphism">
            <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
            <value>
            The value of the Superclasses <c>IsExplicitPolymorphism</c> property.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Where">
            <summary>
            Gets the sql string that should be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The where clause can not be set on the 
            SubclassType, only the RootClass.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Table">
            <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.Subclass.Table"/> that this class is stored in.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.Subclass.Table"/> this class is stored in.</value>
            <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table"/> to the Superclass' collection
            of SubclassType Tables.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.ManyToOne">
            <summary> A many-to-one association mapping</summary>
        </member>
        <member name="T:NHibernate.Mapping.ToOne">
            <summary>
            A simple-point association (ie. a reference to another entity).
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.ToOne.FetchMode">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.ToOne.ReferencedPropertyName">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.CreateForeignKey">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Map">
            <summary>
            A map has a primary key consisting of the key columns 
            + index columns.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Map.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Map"/> class.
            </summary>
            <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that contains this map mapping.</param>
        </member>
        <member name="P:NHibernate.Mapping.Map.DefaultCollectionType">
            <summary>
            Gets the appropriate <see cref="P:NHibernate.Mapping.Map.CollectionType"/> that is 
            specialized for this list mapping.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.MetaAttribute">
            <summary>
            A meta attribute is a named value or values.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.OneToMany">
            <summary>
            A mapping for a <c>one-to-many</c> association.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToMany.IsValid(NHibernate.Engine.IMapping)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToMany.CreateForeignKey">
            <summary>
            
            </summary>
            <remarks>No foreign key element for a one-to-many</remarks>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.ColumnIterator">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.AssociatedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.Formula">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.Table">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsNullable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsSimpleValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsUnique">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.FetchMode">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.OneToOne">
            <summary>
            A mapping for a <c>one-to-one</c> association.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.#ctor(NHibernate.Mapping.Table,NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="table"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.CreateForeignKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.ConstraintColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.IsConstrained">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.ForeignKeyType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.IsNullable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.PrimaryKey">
            <summary>
            A Primary Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to create the Primary Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the Primary Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
            <summary>
            Generates the SQL string to create the named Primary Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the named Primary Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="T:NHibernate.Mapping.PrimitiveArray">
            <summary>
            A primitive array has a primary key consisting 
            of the key columns + index column.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.PropertyGeneration">
            <summary>
             Indicates whether given properties are generated by the database and, if
            so, at what time(s) they are generated.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PropertyGeneration.Never">
            <summary>
            Values for this property are never generated by the database.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PropertyGeneration.Insert">
            <summary>
            Values for this property are generated by the database on insert.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PropertyGeneration.Always">
            <summary>
            Values for this property are generated by the database on both insert and update.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.RootClass">
            <summary>
            Declaration of a System.Type mapped with the <c>&lt;class&gt;</c> element that
            is the root class of a table-per-subclass, or table-per-concrete-class 
            inheritance heirarchy.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.RootClass.DefaultIdentifierColumnName">
            <summary>
            The default name of the column for the Identifier
            </summary>
            <value><c>id</c> is the default column name for the Identifier.</value>
        </member>
        <member name="F:NHibernate.Mapping.RootClass.DefaultDiscriminatorColumnName">
            <summary>
            The default name of the column for the Discriminator
            </summary>
            <value><c>class</c> is the default column name for the Discriminator.</value>
        </member>
        <member name="M:NHibernate.Mapping.RootClass.AddSubclass(NHibernate.Mapping.Subclass)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass"/> to the class hierarchy.
            </summary>
            <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass"/> to add to the hierarchy.</param>
            <remarks>
            When a <see cref="T:NHibernate.Mapping.Subclass"/> is added this mapped class has the property <see cref="P:NHibernate.Mapping.RootClass.IsPolymorphic"/>
            set to <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.RootClass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsInherited">
            <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
            <value>
            <see langword="false" /> because this is the root mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.PropertyClosureIterator">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.TableClosureIterator">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.RootClass.Table"/> objects that this 
            mapped class reads from and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.RootClass.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            There is only one <see cref="P:NHibernate.Mapping.RootClass.Table"/> in the <see cref="T:System.Collections.ICollection"/> since
            this is the root class.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsVersioned">
            <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
            <value><see langword="true" /> if there is a Property for a <c>version</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.RootTable">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.RootClass.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.RootClass.Table"/> of the class this mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.HasEmbeddedIdentifier">
            <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><see langword="true" /> if the class identifies itself.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.CacheRegionName">
            <summary>
            Gets or sets the cache region name.
            </summary>
            <value>The region name used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IdentifierProperty">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Identifier">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.HasIdentifierProperty">
            <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><see langword="true" /> if there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Discriminator">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsPolymorphic">
            <summary>
            Gets or sets if the mapped class has subclasses.
            </summary>
            <value>
            <see langword="true" /> if the mapped class has subclasses.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.RootClazz">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.RootClass.RootClazz"/> of the class that is mapped in the <c>class</c> element.
            </summary>
            <value>
            <c>this</c> since this is the root mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsExplicitPolymorphism">
            <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
            <value>
            <see langword="true" /> if only classes queried on should be returned, <see langword="false" />
            if any class in the hierarchy should implicitly be returned.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Version">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsMutable">
            <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
            <value><see langword="true" /> if the object is mutable.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Superclass">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </summary>
            <value>
            <see langword="null"/> since this is the root class.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The Superclass can not be set on the 
            RootClass, only the SubclassType can have a Superclass set.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Key">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsForceDiscriminator">
            <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
            <value><see langword="true" /> if the mapped discriminator values should be forced.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Where">
            <summary>
            Gets or sets the sql string that should be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.CacheConcurrencyStrategy">
            <summary>
            Gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The CacheConcurrencyStrategy used with the Cache.</value>
        </member>
        <member name="T:NHibernate.Mapping.Set">
            <summary>
            A Set with no nullable element columns will have a primary
            key consisting of all table columns (ie - key columns + 
            element columns).
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.SimpleAuxiliaryDatabaseObject">
            <summary> 
            A simple implementation of AbstractAuxiliaryDatabaseObject in which the CREATE and DROP strings are
            provided up front.
            </summary>
            <remarks>
            Contains simple facilities for templating the catalog and schema
            names into the provided strings.
            This is the form created when the mapping documents use &lt;create/&gt; and &lt;drop/&gt;.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.TypeDef">
            <summary> Placeholder for typedef information</summary>
        </member>
        <member name="T:NHibernate.Mapping.UniqueKey">
            <summary>
            An Unique Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect)">
            <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <returns> A string that contains the SQL to create the Unique Key Constraint. </returns>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
            <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName"></param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the Unique Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultCatalog"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="T:NHibernate.Metadata.IClassMetadata">
            <summary>
            Exposes entity class metadata to the application
            </summary>
            <seealso cref="M:NHibernate.ISessionFactory.GetClassMetadata(System.Type)"/>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyType(System.String)">
            <summary> Get the type of a particular (named) property </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValuesToInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
            <summary> Return the values of the mapped properties of the object</summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetMappedClass(NHibernate.EntityMode)">
            <summary>
            The persistent class
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.Instantiate(System.Object,NHibernate.EntityMode)">
            <summary>
            Create a class instance initialized with the given identifier
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValue(System.Object,System.String,NHibernate.EntityMode)">
            <summary>
            Get the value of a particular (named) property 
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValues(System.Object,NHibernate.EntityMode)">
            <summary> Extract the property values from the given entity. </summary>
            <param name="entity">The entity from which to extract the property values. </param>
            <param name="entityMode">The entity-mode of the given entity </param>
            <returns> The property values. </returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValue(System.Object,System.String,System.Object,NHibernate.EntityMode)">
            <summary>
            Set the value of a particular (named) property 
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValues(System.Object,System.Object[],NHibernate.EntityMode)">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetIdentifier(System.Object,NHibernate.EntityMode)">
            <summary>
            Get the identifier of an instance (throw an exception if no identifier property)
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetIdentifier(System.Object,System.Object,NHibernate.EntityMode)">
            <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.ImplementsLifecycle(NHibernate.EntityMode)">
            <summary> Does the class implement the <see cref="T:NHibernate.Classic.ILifecycle"/> interface?</summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.ImplementsValidatable(NHibernate.EntityMode)">
            <summary> Does the class implement the <see cref="T:NHibernate.Classic.IValidatable"/> interface?</summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetVersion(System.Object,NHibernate.EntityMode)">
            <summary>
            Get the version number (or timestamp) from the object's version property 
            (or return null if not versioned)
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.EntityName">
            <summary>
            The name of the entity
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierPropertyName">
            <summary>
            The name of the identifier property (or return null)
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNames">
            <summary>
            The names of the class' persistent properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierType">
            <summary>
            The identifier Hibernate type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyTypes">
            <summary>
            The Hibernate types of the classes properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IsMutable">
            <summary>
            Are instances of this class mutable?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IsVersioned">
            <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.VersionProperty">
            <summary>
            Gets the index of the version property
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNullability">
            <summary>
            Get the nullability of the class' persistent properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyLaziness">
            <summary> Get the "laziness" of the properties of this class</summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.NaturalIdentifierProperties">
            <summary> Which properties hold the natural id?</summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IsInherited">
            <summary> Does this entity extend a mapped superclass?</summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasProxy">
            <summary> Does the class support dynamic proxies? </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasIdentifierProperty">
            <summary> Does the class have an identifier property? </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasNaturalIdentifier">
            <summary> Does this entity declare a natural id?</summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasSubclasses">
            <summary> Does this entity have mapped subclasses?</summary>
        </member>
        <member name="T:NHibernate.Metadata.ICollectionMetadata">
            <summary>
            Exposes collection metadata to the application
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.KeyType">
            <summary>
            The collection key type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.ElementType">
            <summary>
            The collection element type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IndexType">
            <summary>
            The collection index type (or null if the collection has no index)
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.HasIndex">
            <summary>
            Is the collection indexed?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.Role">
            <summary>
            The name of this collection role
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsArray">
            <summary>
            Is the collection an array?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsPrimitiveArray">
            <summary>
            Is the collection a primitive array?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsLazy">
            <summary>
            Is the collection lazily initialized?
            </summary>
        </member>
        <member name="T:NHibernate.Param.IPageableParameterSpecification">
            <summary>
            Additional information for potential paging parameters in HQL/LINQ
            </summary>
        </member>
        <member name="T:NHibernate.Param.IExplicitParameterSpecification">
            <summary>
            An additional contract for parameters which originate from parameters explicitly encountered in the source statement
            (HQL or native-SQL).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
        </member>
        <member name="T:NHibernate.Param.IParameterSpecification">
            <summary>
            Maintains information relating to parameters which need to get bound into a <see cref="T:System.Data.IDbCommand"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Param.IParameterSpecification.Bind(System.Data.IDbCommand,System.Collections.Generic.IList{NHibernate.SqlCommand.Parameter},NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind the appropriate value into the given command.
            </summary>
            <param name="command">The command into which the value should be bound.</param>
            <param name="sqlQueryParametersList">The list of Sql query parameter in the exact sequence they are present in the query.</param>
            <param name="queryParameters">The defined values for the current query execution.</param>
            <param name="session">The session against which the current execution is occuring.</param>
        </member>
        <member name="M:NHibernate.Param.IParameterSpecification.Bind(System.Data.IDbCommand,System.Collections.Generic.IList{NHibernate.SqlCommand.Parameter},System.Int32,System.Collections.Generic.IList{NHibernate.SqlCommand.Parameter},NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind the appropriate value into the given command.
            </summary>
            <param name="command">The command into which the value should be bound.</param>
            <param name="multiSqlQueryParametersList">The parameter-list of the whole query of the command.</param>
            <param name="singleSqlParametersOffset">The offset from where start the list of <see cref="T:System.Data.IDataParameter"/> in the given <paramref name="command"/> for the query where this <see cref="T:NHibernate.Param.IParameterSpecification"/> was used. </param>
            <param name="sqlQueryParametersList">The list of Sql query parameter in the exact sequence they are present in the query where this <see cref="T:NHibernate.Param.IParameterSpecification"/> was used.</param>
            <param name="queryParameters">The defined values for the query where this <see cref="T:NHibernate.Param.IParameterSpecification"/> was used.</param>
            <param name="session">The session against which the current execution is occuring.</param>
            <remarks>
            Suppose the <paramref name="command"/> is composed by two queries. The <paramref name="singleSqlParametersOffset"/> for the first query is zero.
            If the first query in <paramref name="command"/> has 12 parameters (size of its SqlType array) the offset to bind all <see cref="T:NHibernate.Param.IParameterSpecification"/>s of the second query in the
            <paramref name="command"/> is 12 (for the first query we are using from 0 to 11).
            </remarks>
        </member>
        <member name="M:NHibernate.Param.IParameterSpecification.RenderDisplayInfo">
            <summary>
            Render this parameter into displayable info (for logging, etc).
            </summary>
            <returns>The displayable info</returns>
        </member>
        <member name="M:NHibernate.Param.IParameterSpecification.GetIdsForBackTrack(NHibernate.Engine.IMapping)">
            <summary>
            An string array to unique identify this parameter-span inside an <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <param name="sessionFactory">The session-factory (used only because required by IType).</param>
            <remarks>
            The each id-for-backtrack is supposed to be unique in the context of a query.
            <para>
            The number of elements returned depend on the column-span of the <see cref="P:NHibernate.Param.IParameterSpecification.ExpectedType"/>.
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Param.IParameterSpecification.ExpectedType">
            <summary>
            Get or set the type which we are expeting for a bind into this parameter based
            on translated contextual information.
            </summary>
        </member>
        <member name="M:NHibernate.Param.IExplicitParameterSpecification.SetEffectiveType(NHibernate.Engine.QueryParameters)">
            <summary>
            Explicit parameters may have no set the <see cref="P:NHibernate.Param.IParameterSpecification.ExpectedType"/> during query parse.
            </summary>
            <param name="queryParameters">The defined values for the current query execution.</param>
            <remarks>
            This method should be removed when the parameter type is inferred during the parse.
            </remarks>
        </member>
        <member name="P:NHibernate.Param.IExplicitParameterSpecification.SourceLine">
            <summary>
            Retrieves the line number on which this parameter occurs in the source query.
            </summary>
        </member>
        <member name="P:NHibernate.Param.IExplicitParameterSpecification.SourceColumn">
            <summary>
            Retrieves the column number (within the {@link #getSourceLine()}) where this parameter occurs.
            </summary>
        </member>
        <member name="M:NHibernate.Param.IPageableParameterSpecification.IsSkipParameter">
            <summary>
            Notifies the parameter that it is a 'skip' parameter, and should calculate its value using the dialect settings
            </summary>
        </member>
        <member name="M:NHibernate.Param.IPageableParameterSpecification.IsTakeParameterWithSkipParameter(NHibernate.Param.IPageableParameterSpecification)">
            <summary>
            Notifies the parameter that it is a 'take' parameter, and should calculate its value using the dialect settings
            and the value of the supplied skipParameter.
            </summary>
            <param name="skipParameter">The associated skip parameter (null if there is none).</param>
        </member>
        <member name="M:NHibernate.Param.IPageableParameterSpecification.GetSkipValue(NHibernate.Engine.QueryParameters)">
            <summary>
            Retrieve the skip/offset value for the query
            </summary>
            <param name="queryParameters">The parameters for the query</param>
            <returns>The paging skip/offset value</returns>
        </member>
        <member name="M:NHibernate.Param.AbstractExplicitParameterSpecification.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an AbstractExplicitParameterSpecification.
            </summary>
            <param name="sourceLine">sourceLine</param>
            <param name="sourceColumn">sourceColumn</param>
        </member>
        <member name="M:NHibernate.Param.CollectionFilterKeyParameterSpecification.#ctor(System.String,NHibernate.Type.IType,System.Int32)">
            <summary>
            Creates a specialized collection-filter collection-key parameter spec.
            </summary>
            <param name="collectionRole">The collection role being filtered.</param>
            <param name="keyType">The mapped collection-key type.</param>
            <param name="queryParameterPosition">The position within QueryParameters where we can find the appropriate param value to bind.</param>
        </member>
        <member name="M:NHibernate.Param.DynamicFilterParameterSpecification.#ctor(System.String,System.String,NHibernate.Type.IType,System.Nullable{System.Int32})">
            <summary>
            Constructs a parameter specification for a particular filter parameter.
            </summary>
            <param name="filterName">The name of the filter</param>
            <param name="parameterName">The name of the parameter</param>
            <param name="expectedDefinedType">The paremeter type specified on the filter metadata</param>
            <param name="collectionSpan"></param>
        </member>
        <member name="T:NHibernate.Type.IType">
            <summary>
			Defines a mapping from a .NET <see cref="T:System.Type"/> to a SQL datatype.
			This interface is intended to be implemented by applications that need custom types.
		</summary><remarks>
			Implementors should usually be immutable and MUST definately be threadsafe.
		</remarks>
        </member>
        <member name="M:NHibernate.Type.IType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType"/>s.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>The number of columns this IType spans.</returns><exception cref="T:NHibernate.MappingException">MappingException</exception> 
        </member>
        <member name="M:NHibernate.Type.IType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, should the parent be considered dirty, 
		given both the old and current field or element value?
		</summary><param name="old">The old value</param><param name="current">The current value</param><param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> </param><returns>true if the field is dirty</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementors should handle possibility of null values.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="name">The name of the column in the <see cref="T:System.Data.IDataReader"/> that contains the 
		value to populate the IType with.</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param><param name="value">The object that contains the values.</param><param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param><param name="session"></param><param name="settable">Indicates which columns are to be set.</param><remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">
			The <see cref="T:System.Data.IDbCommand"/> to put the values into.
		</param><param name="value">The object that contains the values.</param><param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.
		</param><param name="session"></param><remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.DeepCopy(System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><param name="entityMode">The entityMode.</param><param name="factory">The session factory.</param><returns>A deep copy of the object.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, retrieves an instance of the mapped class, 
		or the identifier of an entity or collection from a <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values.</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session">the session</param><param name="owner">The parent Entity</param><returns>An identifier or actual object mapped by this IType.</returns><remarks>
		<para>
		This is useful for 2-phase property initialization - the second phase is a call to
		<c>ResolveIdentifier()</c>
		</para>
		<para>
		Most implementors of this method will just pass the call to <c>NullSafeGet()</c>.
		</para>
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, maps identifiers to Entities or Collections. 
		</summary><param name="value">An identifier or value returned by <c>Hydrate()</c></param><param name="session">The session</param><param name="owner">The parent Entity</param><returns>The Entity or Collection referenced by this Identifier.</returns><remarks>
		This is the second phase of 2-phase property initialization.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.SemiResolve(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Given a hydrated, but unresolved value, return a value that may be used to
            reconstruct property-ref associations.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.Copy&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)">
            <summary> 
            During merge, replace the existing (target) value in the entity we are merging to
            with a new (original) value from the detached entity we are merging. For immutable
            objects, or null values, it is safe to simply return the first parameter. For
            mutable objects, it is safe to return a copy of the first parameter. For objects
            with component values, it might make sense to recursively replace component values. 
            </summary>
            <param name="original">the value from the detached entity being merged </param>
            <param name="target">the value in the managed entity </param>
            <param name="session"></param>
            <param name="owner"></param>
            <param name="copyCache"></param>
            <param name="foreignKeyDirection"></param>
            <returns> the value to be merged </returns>
        </member>
        <member name="M:NHibernate.Type.IType.IsSame(System.Object,System.Object,NHibernate.EntityMode)">
            <summary> 
            Compare two instances of the class mapped by this type for persistence
            "equality" - equality of persistent state - taking a shortcut for
            entity references.
            </summary>
            <param name="x"> </param>
            <param name="y"> </param>
            <param name="entityMode"> </param>
            <returns> boolean </returns>
        </member>
        <member name="M:NHibernate.Type.IType.IsEqual(System.Object,System.Object,NHibernate.EntityMode)">
            <summary> 
            Compare two instances of the class mapped by this type for persistence
            "equality" - equality of persistent state.
            </summary>
            <param name="x"> </param>
            <param name="y"> </param>
            <param name="entityMode"> </param>
            <returns> boolean </returns>
        </member>
        <member name="M:NHibernate.Type.IType.IsEqual(System.Object,System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> 
            Compare two instances of the class mapped by this type for persistence
            "equality" - equality of persistent state.
            </summary>
            <param name="x"> </param>
            <param name="y"> </param>
            <param name="entityMode"> </param>
            <param name="factory"></param>
            <returns> boolean </returns>
        </member>
        <member name="M:NHibernate.Type.IType.GetHashCode(System.Object,NHibernate.EntityMode)">
            <summary> Get a hashcode, consistent with persistence "equality"</summary>
            <param name="x"> </param>
            <param name="entityMode"> </param>
        </member>
        <member name="M:NHibernate.Type.IType.GetHashCode(System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> Get a hashcode, consistent with persistence "equality"</summary>
            <param name="x"> </param>
            <param name="entityMode"> </param>
            <param name="factory"> </param>
        </member>
        <member name="M:NHibernate.Type.IType.Compare(System.Object,System.Object,System.Nullable{NHibernate.EntityMode})">
            <summary> compare two instances of the type</summary>
            <param name="x"> </param>
            <param name="y"> </param>
            <param name="entityMode"> </param>
        </member>
        <member name="M:NHibernate.Type.IType.GetSemiResolvedType(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> Get the type of a semi-resolved value.</summary>
        </member>
        <member name="M:NHibernate.Type.IType.SetToXMLNode(System.Xml.XmlNode,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> A representation of the value to be embedded in an XML element. </summary>
            <param name="node"></param>
            <param name="value"> </param>
            <param name="factory"> </param>
        </member>
        <member name="M:NHibernate.Type.IType.FromXMLNode(System.Xml.XmlNode,NHibernate.Engine.IMapping)">
            <summary> Parse the XML representation of an instance.</summary>
            <param name="xml"> </param>
            <param name="factory"> </param>
            <returns> an instance of the type </returns>
        </member>
        <member name="M:NHibernate.Type.IType.ToColumnNullness(System.Object,NHibernate.Engine.IMapping)">
            <summary> 
            Given an instance of the type, return an array of boolean, indicating
            which mapped columns would be null. 
            </summary>
            <param name="value">an instance of the type </param>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Type.IType.Name">
            <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary><value>The NHibernate type name.</value> 
        </member>
        <member name="P:NHibernate.Type.IType.ReturnedClass">
            <summary>
		When implemented by a class, gets the <see cref="T:System.Type"/> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary><value>
		The <see cref="T:System.Type"/> from the .NET framework.
		</value><remarks>
		This is used to establish the class of an array of this Itype
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsMutable">
            <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary><value>true if the objects mapped by this IType are mutable.</value><remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsAssociationType">
            <summary>
			When implemented by a class, gets a value indicating if the implementor is castable to an an <see cref="T:NHibernate.Type.IAssociationType"/>
		</summary><value>true if this is an Association</value><remarks>This does not necessarily imply that the type actually represents an association.</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsCollectionType">
            <summary>
			When implemented by a class, gets a value indicating if the implementor is a collection type
		</summary><value>true if this is a <see cref="T:NHibernate.Type.CollectionType"/>.</value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsComponentType">
            <summary>
		When implemented by a class, gets a value indicating if the implementor 
		is an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
		</summary><value>true if this is an <see cref="T:NHibernate.Type.IAbstractComponentType"/></value><remarks>
		If true, the implementation must be castable to <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
		A component type may own collections or associations and hence must provide certain extra functionality.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsEntityType">
            <summary>
		When implemented by a class, gets a value indicating if the implementor 
		extends <see cref="T:NHibernate.Type.EntityType"/>
		</summary><value>true if this is an <see cref="T:NHibernate.Type.EntityType"/></value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsAnyType">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;P:IType.IsAnyType&quot;]/*"/> 
        </member>
        <member name="T:NHibernate.Param.NamedParameterSpecification">
            <summary>
            Parameter bind specification for an explicit named parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Param.NamedParameterSpecification.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a named parameter bind specification.
            </summary>
            <param name="sourceLine">sourceLine</param>
            <param name="sourceColumn">sourceColumn</param>
            <param name="name">The named parameter name.</param>
        </member>
        <member name="P:NHibernate.Param.NamedParameterSpecification.Name">
            <summary>
            The user parameter name.
            </summary>
        </member>
        <member name="T:NHibernate.Param.PositionalParameterSpecification">
            <summary>
            Parameter bind specification for an explicit  positional (or ordinal) parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Param.PositionalParameterSpecification.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a position/ordinal parameter bind specification.
            </summary>
            <param name="sourceLine">sourceLine</param>
            <param name="sourceColumn">sourceColumn</param>
            <param name="hqlPosition">The position in the source query, relative to the other source positional parameters.</param>
        </member>
        <member name="P:NHibernate.Param.PositionalParameterSpecification.HqlPosition">
            <summary>
            Getter for property 'hqlPosition'.
            </summary>
        </member>
        <member name="T:NHibernate.Param.QuerySkipParameterSpecification">
            <summary>
            Autogenerated parameter for <see cref="M:NHibernate.IQuery.SetFirstResult(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Param.QueryTakeParameterSpecification">
            <summary>
            Autogenerated parameter for <see cref="M:NHibernate.IQuery.SetMaxResults(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.AbstractCollectionPersister">
            <summary>
            Summary description for AbstractCollectionPersister.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.IQueryableCollection">
            <summary>
            A collection role that may be queried or loaded by outer join.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IJoinable">
            <summary>
            Anything that can be loaded by outer join - namely persisters for classes or collections.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.SelectFragment(NHibernate.Persister.Entity.IJoinable,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            All columns to select, when loading.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.WhereJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the where clause part of any joins (optional operation)
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.FromJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the from clause part of any joins (optional operation)
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.FilterFragment(System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Get the where clause filter, given a query alias and considering enabled session filters
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.ConsumesEntityAlias">
            <summary>
            Very, very, very ugly...
            </summary>
            <value>Does this persister "consume" entity column aliases in the result
            set?</value>
        </member>
        <member name="M:NHibernate.Persister.Entity.IJoinable.ConsumesCollectionAlias">
            <summary>
            Very, very, very ugly...
            </summary>
            <value>Does this persister "consume" collection column aliases in the result
            set?</value>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.Name">
            <summary>
            An identifying name; a class name or collection role name.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.KeyColumnNames">
            <summary>
            The columns to join on.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.IsCollection">
            <summary>
            Is this instance actually a ICollectionPersister?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IJoinable.TableName">
            <summary>
            The table to join to.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.ICollectionPersister">
            <summary>
            A strategy for persisting a collection role.
            </summary>
            <remarks>
            Defines a contract between the persistence strategy and the actual persistent collection framework
            and session. Does not define operations that are required for querying collections, or loading by outer join.
            <para/>
            Implements persistence of a collection instance while the instance is
            referenced in a particular role.
            <para/>
            This class is highly coupled to the <see cref="T:NHibernate.Collection.IPersistentCollection"/>
            hierarchy, since double dispatch is used to load and update collection 
            elements.
            <para/>
            May be considered an immutable view of the mapping object
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initialize the given collection with the given key
            </summary>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadKey(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the key from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadElement(System.Data.IDataReader,System.Object,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the element from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadIndex(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the index from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadIdentifier(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the identifier from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Remove(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Completely remove the persistent state of the collection
            </summary>
            <param name="id"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Recreate(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            (Re)create the collection's persistent state
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.DeleteRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete the persistent state of any elements that were removed from the collection
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.UpdateRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update the persistent state of any elements that were modified
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.InsertRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Insert the persistent state of any new collection elements
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetKeyColumnAliases(System.String)">
            <summary>
            Generates the collection's key column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the key column alias generation.</param>
            <returns>The key column aliases.</returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetIndexColumnAliases(System.String)">
            <summary>
            Generates the collection's index column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the index column alias generation.</param>
            <returns>The index column aliases, or null if not indexed.</returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetElementColumnAliases(System.String)">
            <summary>
            Generates the collection's element column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the element column alias generation.</param>
            <returns>The element column aliases.</returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetIdentifierColumnAlias(System.String)">
            <summary>
            Generates the collection's identifier column aliases, based on the given
            suffix.
            </summary>
            <param name="suffix">The suffix to use in the identifier column alias generation.</param>
            <returns>The identifier column aliases.</returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetElementByIndex(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Try to find an element by a given index.
            </summary>
            <param name="key">The key of the collection (collection-owner identifier)</param>
            <param name="index">The given index.</param>
            <param name="session">The active <see cref="T:NHibernate.ISession"/>.</param>
            <param name="owner">The owner of the collection.</param>
            <returns>The value of the element where available; otherwise <see cref="P:NHibernate.Persister.Collection.ICollectionPersister.NotFoundObject"/>.</returns>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.Cache">
            <summary>
            Get the cache
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CacheEntryStructure">
            <summary> Get the cache structure</summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CollectionType">
            <summary>
            Get the associated <c>IType</c>
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.KeyType">
            <summary>
            Get the "key" type (the type of the foreign key)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IndexType">
            <summary>
            Get the "index" type for a list or map (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.ElementType">
            <summary>
            Get the "element" type
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.ElementClass">
            <summary>
            Return the element class of an array, or null otherwise
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsPrimitiveArray">
            <summary>
            Is this an array or primitive values?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsArray">
            <summary>
            Is this an array?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsOneToMany">
            <summary> Is this a one-to-many association?</summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsManyToMany">
            <summary> 
            Is this a many-to-many association?  Note that this is mainly
            a convenience feature as the single persister does not
            contain all the information needed to handle a many-to-many
            itself, as internally it is looked at as two many-to-ones.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsLazy">
            <summary>
            Is this collection lazily initialized?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsInverse">
            <summary>
            Is this collection "inverse", so state changes are not propogated to the database.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.Role">
            <summary>
            Get the name of this collection role (the fully qualified class name, extended by a "property path")
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.OwnerEntityPersister">
            <summary> Get the persister of the entity that "owns" this collection</summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IdentifierGenerator">
            <summary>
            Get the surrogate key generation strategy (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IdentifierType">
            <summary>
            Get the type of the surrogate key
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CollectionSpaces">
            <summary> Get the "space" that holds the persistent state</summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CascadeDeleteEnabled">
            <summary> 
            Is cascade delete handled by the database-level
            foreign key constraint definition?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsVersioned">
            <summary> 
            Does this collection cause version increment of the owning entity?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsMutable">
            <summary> Can the elements of this collection change?</summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasCache">
            <summary>
            Is this collection role cacheable
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasIndex">
            <summary>
            Is this an "indexed" collection? (list or map)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasOrphanDelete">
            <summary>
            Does this collection implement "orphan delete"?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasOrdering">
            <summary>
            Is this an ordered collection? (An ordered collection is
            ordered by the initialization operation, not by sorting
            that happens in memory, as in the case of a sorted collection.)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.ICollectionPersister.NotFoundObject">
            <summary>
            A place-holder to inform that the data-reader was empty.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.SelectFragment(System.String,System.String)">
            <summary>
            Generate a list of collection index and element columns
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetIndexColumnNames(System.String)">
            <summary> 
            Get the names of the collection index columns if
            this is an indexed collection (optional operation),
            aliased by the given table alias
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetElementColumnNames(System.String)">
            <summary>
            Get the names of the collection element columns (or the primary
            key columns in the case of a one-to-many association),
            aliased by the given table alias
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetSQLWhereString(System.String)">
            <summary>
            Get the extra where clause filter SQL
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetSQLOrderByString(System.String)">
            <summary>
            Get the order by SQL
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetManyToManyOrderByString(System.String)">
            <summary>
            Get the order-by to be applied at the target table of a many to many
            </summary>
            <param name="alias">The alias for the many-to-many target table</param>
            <returns>Appropriate order-by fragment or empty string.</returns>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.IndexFormulas">
            <summary> 
            Get the index formulas if this is an indexed collection 
            (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.ElementPersister">
            <summary>
            Get the persister of the element class, if this is a
            collection of entities (optional operation).  Note that
            for a one-to-many association, the returned persister
            must be <c>OuterJoinLoadable</c>.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.FetchMode">
            <summary>
            Should we load this collection role by outer joining?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.IndexColumnNames">
            <summary>
            Get the names of the collection index columns if this is an indexed collection (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.ElementColumnNames">
            <summary>
            Get the names of the collection element columns (or the primary key columns in the case of a one-to-many association)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.IQueryableCollection.HasWhere">
            <summary>
            Does this collection role have a where clause filter?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.AbstractCollectionPersister.ReadElement(System.Data.IDataReader,System.Object,System.String[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Reads the Element from the IDataReader.  The IDataReader will probably only contain
            the id of the Element.
            </summary>
            <remarks>See ReadElementIdentifier for an explanation of why this method will be depreciated.</remarks>
        </member>
        <member name="M:NHibernate.Persister.Collection.AbstractCollectionPersister.PerformInsert(System.Object,NHibernate.Collection.IPersistentCollection,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform an SQL INSERT, and then retrieve a generated identifier.
            </summary>
            <returns> the id of the collection entry </returns>
            <remarks>
            This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY, select, etc).
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Collection.AbstractCollectionPersister.ElementClass">
            <summary>
            Return the element class of an array, or null otherwise
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Collection.AbstractCollectionPersister.Role">
            <summary>
            Get the name of this collection role (the fully qualified class name,
            extended by a "property path")
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.BasicCollectionPersister">
            <summary>
            Collection persister for collections of values and many-to-many associations.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateDeleteString">
            <summary>
            Generate the SQL DELETE that deletes all rows
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateInsertRowString">
            <summary>
            Generate the SQL INSERT that creates a new row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateUpdateRowString">
            <summary>
            Generate the SQL UPDATE that updates a row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateDeleteRowString">
            <summary>
            Generate the SQL DELETE that deletes a particular row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.CreateCollectionInitializer(System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Create the <see cref="T:NHibernate.Loader.Collection.CollectionLoader"/>
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.CollectionPropertyMapping">
            <summary>
            Summary description for CollectionPropertyMapping.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.CollectionPropertyNames">
            <summary>
            The names of all the collection properties.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.CompositeElementPropertyMapping">
            <summary>
            Summary description for CompositeElementPropertyMapping.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.AbstractPropertyMapping">
            <summary>
            Base implementation of a PropertyMapping.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Collection.ElementPropertyMapping">
            <summary>
            Summary description for ElementPropertyMapping.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateDeleteString">
            <summary>
            Generate the SQL UPDATE that updates all the foreign keys to null
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateInsertRowString">
            <summary>
            Generate the SQL UPDATE that updates a foreign key to a value
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateUpdateRowString">
            <summary>
            Not needed for one-to-many association
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateDeleteRowString">
            <summary>
            Generate the SQL UPDATE that updates a particular row's foreign
            key to null
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Collection.OneToManyPersister.CreateCollectionInitializer(System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Create the <see cref="T:NHibernate.Loader.Collection.OneToManyLoader"/>
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.AbstractEntityPersister">
            <summary>
            Superclass for built-in mapping strategies. Implements functionalty common to both mapping
            strategies
            </summary>
            <remarks>
            May be considered an immutable view of the mapping object
            </remarks>
        </member>
        <member name="T:NHibernate.Persister.Entity.IOuterJoinLoadable">
            <summary>
            A <c>ClassPersister</c> that may be loaded by outer join using
            the <c>OuterJoinLoader</c> hierarchy and may be an element
            of a one-to-many association.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.ILoadable">
            <summary>
            Implemented by <c>ClassPersister</c> that uses <c>Loader</c>. There are several optional
            operations used only by loaders that inherit <c>OuterJoinLoader</c>
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IEntityPersister">
            <summary>
            Concrete <c>IEntityPersister</c>s implement mapping and persistence logic for a particular class.
            </summary>
            <remarks>
            Implementors must be threadsafe (preferably immutable) and must provide a constructor of type
            matching the signature of: (PersistentClass, SessionFactoryImplementor)
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.PostInstantiate">
            <summary>
            Finish the initialization of this object, once all <c>ClassPersisters</c> have been
            instantiated. Called only once, before any other method.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsSubclassEntityName(System.String)">
            <summary> 
            Determine whether the given name represents a subclass entity
            (or this entity itself) of the entity mapped by this persister. 
            </summary>
            <param name="entityName">The entity name to be checked. </param>
            <returns> 
            True if the given entity name represents either the entity mapped by this persister or one of its subclass entities; 
            false otherwise.
            </returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyType(System.String)">
            <summary>
            Get the type of a particular property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.FindDirty(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> Locate the property-indices of all properties considered to be dirty. </summary>
            <param name="currentState">The current state of the entity (the state to be checked). </param>
            <param name="previousState">The previous state of the entity (the state to be checked against). </param>
            <param name="entity">The entity for which we are checking state dirtiness. </param>
            <param name="session">The session in which the check is ccurring. </param>
            <returns> <see langword="null" /> or the indices of the dirty properties </returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.FindModified(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> Locate the property-indices of all properties considered to be dirty. </summary>
            <param name="old">The old state of the entity.</param>
            <param name="current">The current state of the entity. </param>
            <param name="entity">The entity for which we are checking state modification. </param>
            <param name="session">The session in which the check is ccurring. </param>
            <returns>return <see langword="null" /> or the indicies of the modified properties</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetNaturalIdentifierSnapshot(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Retrieve the current state of the natural-id properties from the database. 
            </summary>
            <param name="id">
            The identifier of the entity for which to retrieve the naturak-id values.
            </param>
            <param name="session">
            The session from which the request originated.
            </param>
            <returns> The natural-id snapshot. </returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance of the persistent class.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Lock(System.Object,System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Do a version check (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Insert(System.Object,System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an instance
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Insert(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an instance, using a natively generated identifier (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Delete(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete a persistent instance
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Update(System.Object,System.Object[],System.Int32[],System.Boolean,System.Object[],System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update a persistent instance
            </summary>
            <param name="id">The id.</param>
            <param name="fields">The fields.</param>
            <param name="dirtyFields">The dirty fields.</param>
            <param name="hasDirtyCollection">if set to <see langword="true" /> [has dirty collection].</param>
            <param name="oldFields">The old fields.</param>
            <param name="oldVersion">The old version.</param>
            <param name="obj">The obj.</param>
            <param name="rowId">The rowId</param>
            <param name="session">The session.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetDatabaseSnapshot(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the current database state of the object, in a "hydrated" form, without resolving identifiers
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns><see langword="null" /> if select-before-update is not enabled or not supported</returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the current version of the object, or return null if there is no row for
            the given identifier. In the case of unversioned data, return any object
            if the row exists.
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GuessEntityMode(System.Object)">
            <summary> Try to discover the entity mode from the entity instance</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsInstrumented(NHibernate.EntityMode)">
            <summary> Has the class actually been bytecode instrumented?</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.AfterInitialize(System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary> Called just after the entities properties have been initialized</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.AfterReassociate(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> Called just after the entity has been reassociated with the session</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.CreateProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new proxy instance
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsTransient(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> Is this a new transient instance?</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValuesToInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
            <summary> Return the values of the insertable properties of the object (including backrefs)</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.ProcessInsertGeneratedProperties(System.Object,System.Object,System.Object[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform a select to retrieve the values of any generated properties
            back from the database, injecting these generated values into the
            given entity as well as writing this state to the persistence context.
            </summary>
            <remarks>
            Note, that because we update the persistence context here, callers
            need to take care that they have already written the initial snapshot
            to the persistence context before calling this method. 
            </remarks>
            <param name="id">The entity's id value.</param>
            <param name="entity">The entity for which to get the state.</param>
            <param name="state">The entity state (at the time of Save).</param>
            <param name="session">The session.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.ProcessUpdateGeneratedProperties(System.Object,System.Object,System.Object[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform a select to retrieve the values of any generated properties
            back from the database, injecting these generated values into the
            given entity as well as writing this state to the persistence context.
            </summary>
            <remarks>
            Note, that because we update the persistence context here, callers
            need to take care that they have already written the initial snapshot
            to the persistence context before calling this method. 
            </remarks>
            <param name="id">The entity's id value.</param>
            <param name="entity">The entity for which to get the state.</param>
            <param name="state">The entity state (at the time of Save).</param>
            <param name="session">The session.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetMappedClass(NHibernate.EntityMode)">
            <summary>
            The persistent class, or null
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.ImplementsLifecycle(NHibernate.EntityMode)">
            <summary>
            Does the class implement the <c>ILifecycle</c> inteface?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.ImplementsValidatable(NHibernate.EntityMode)">
            <summary>
            Does the class implement the <c>IValidatable</c> interface?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetConcreteProxyClass(NHibernate.EntityMode)">
            <summary>
            Get the proxy interface that instances of <c>this</c> concrete class will be cast to
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetPropertyValues(System.Object,System.Object[],NHibernate.EntityMode)">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetPropertyValue(System.Object,System.Int32,System.Object,NHibernate.EntityMode)">
            <summary>
            Set the value of a particular property
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValues(System.Object,NHibernate.EntityMode)">
            <summary>
            Return the values of the mapped properties of the object
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValue(System.Object,System.Int32,NHibernate.EntityMode)">
            <summary>
            Get the value of a particular property
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValue(System.Object,System.String,NHibernate.EntityMode)">
            <summary>
            Get the value of a particular property
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetIdentifier(System.Object,NHibernate.EntityMode)">
            <summary>
            Get the identifier of an instance ( throw an exception if no identifier property)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetIdentifier(System.Object,System.Object,NHibernate.EntityMode)">
            <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
            <param name="obj">The object to set the Id property on.</param>
            <param name="id">The value to set the Id property to.</param>
            <param name="entityMode">The EntityMode</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetVersion(System.Object,NHibernate.EntityMode)">
            <summary>
            Get the version number (or timestamp) from the object's version property (or return null if not versioned)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.Instantiate(System.Object,NHibernate.EntityMode)">
            <summary>
            Create a class instance initialized with the given identifier
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsInstance(System.Object,NHibernate.EntityMode)">
            <summary>
            Determines whether the specified entity is an instance of the class
            managed by this persister.
            </summary>
            <param name="entity">The entity.</param>
            <param name="entityMode">The EntityMode</param>
            <returns>
            	<see langword="true"/> if the specified entity is an instance; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.HasUninitializedLazyProperties(System.Object,NHibernate.EntityMode)">
            <summary> Does the given instance have any uninitialized lazy properties?</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.ResetIdentifier(System.Object,System.Object,System.Object,NHibernate.EntityMode)">
            <summary> 
            Set the identifier and version of the given instance back
            to its "unsaved" value, returning the id
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetSubclassEntityPersister(System.Object,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.EntityMode)">
            <summary> Get the persister for an instance of this class or a subclass</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsUnsavedVersion(System.Object)">
            <summary>
            Check the version value trough <see cref="T:NHibernate.Engine.VersionValue"/>.
            </summary>
            <param name="version">The snapshot entity state</param>
            <returns>The result of <see cref="M:NHibernate.Engine.VersionValue.IsUnsaved(System.Object)"/>.</returns>
            <remarks>NHibernate-specific feature, not present in H3.2</remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.Factory">
            <summary>
            The ISessionFactory to which this persister "belongs".
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.RootEntityName">
            <summary> 
            Returns an object that identifies the space in which identifiers of
            this entity hierarchy are unique.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.EntityName">
            <summary>
            The entity name which this persister maps.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.EntityMetamodel">
            <summary> 
            Retrieve the underlying entity metamodel instance... 
            </summary>
            <returns> The metamodel </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertySpaces">
            <summary>
            Returns an array of objects that identify spaces in which properties of
            this entity are persisted, for instances of this class only.
            </summary>
            <returns>The property spaces.</returns>
            <remarks>
            For most implementations, this returns the complete set of table names
            to which instances of the mapped entity are persisted (not accounting
            for superclass entity mappings).
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.QuerySpaces">
            <summary>
            Returns an array of objects that identify spaces in which properties of
            this entity are persisted, for instances of this class and its subclasses.
            </summary>
            <remarks>
            Much like <see cref="P:NHibernate.Persister.Entity.IEntityPersister.PropertySpaces"/>, except that here we include subclass
            entity spaces.
            </remarks>
            <returns> The query spaces. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsMutable">
            <summary>
            Are instances of this class mutable?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsInherited">
            <summary> 
            Determine whether the entity is inherited one or more other entities.
            In other words, is this entity a subclass of other entities. 
            </summary>
            <returns> True if other entities extend this entity; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsIdentifierAssignedByInsert">
            <summary>
            Is the identifier assigned before the insert by an <c>IDGenerator</c> or is it returned
            by the <c>Insert()</c> method?
            </summary>
            <remarks>
            This determines which form of <c>Insert()</c> will be called.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsVersioned">
            <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.VersionType">
            <summary>
            Get the type of versioning (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.VersionProperty">
            <summary>
            Which property holds the version number? (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.NaturalIdentifierProperties">
            <summary> 
            If the entity defines a natural id (<see cref="P:NHibernate.Persister.Entity.IEntityPersister.HasNaturalIdentifier"/>), which
            properties make up the natural id. 
            </summary>
            <returns> 
            The indices of the properties making of the natural id; or
            null, if no natural id is defined.
            </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierGenerator">
            <summary>
            Return the <c>IIdentifierGenerator</c> for the class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyTypes">
            <summary>
            Get the Hibernate types of the class properties
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyNames">
            <summary>
            Get the names of the class properties - doesn't have to be the names of the actual
            .NET properties (used for XML generation only)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyInsertability">
            <summary>
            Gets if the Property is insertable.
            </summary>
            <value><see langword="true" /> if the Property's value can be inserted.</value>
            <remarks>
            This is for formula columns and if the user sets the insert attribute on the &lt;property&gt; element.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyInsertGenerationInclusions">
            <summary> Which of the properties of this class are database generated values on insert?</summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyUpdateGenerationInclusions">
            <summary> Which of the properties of this class are database generated values on update?</summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyCheckability">
            <summary>
            Properties that may be dirty (and thus should be dirty-checked). These
            include all updatable properties and some associations.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyNullability">
            <summary>
            Get the nullability of the properties of this class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyVersionability">
            <summary>
            Get the "versionability" of the properties of this class (is the property optimistic-locked)
            </summary>
            <value><see langword="true" /> if the property is optimistic-locked; otherwise, <see langword="false" />.</value>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyCascadeStyles">
            <summary>
            Get the cascade styles of the properties (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierType">
            <summary>
            Get the identifier type
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierPropertyName">
            <summary>
            Get the name of the indentifier property (or return null) - need not return the
            name of an actual .NET property
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsCacheInvalidationRequired">
            <summary>
            Should we always invalidate the cache instead of recaching updated state
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsLazyPropertiesCacheable">
            <summary>
            Should lazy properties of this entity be cached?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.Cache">
            <summary>
            Get the cache (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.CacheEntryStructure">
            <summary> Get the cache structure</summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.ClassMetadata">
            <summary>
            Get the user-visible metadata for the class (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsBatchLoadable">
            <summary>
            Is batch loading enabled?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsSelectBeforeUpdateRequired">
            <summary> Is select snapshot before update enabled?</summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsVersionPropertyGenerated">
            <summary>
            Does this entity contain a version property that is defined
            to be database generated?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasProxy">
            <summary>
            Does this class support dynamic proxies?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCollections">
            <summary>
            Do instances of this class contain collections?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasMutableProperties">
            <summary> 
            Determine whether any properties of this entity are considered mutable. 
            </summary>
            <returns> 
            True if any properties of the entity are mutable; false otherwise (meaning none are).
            </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasSubselectLoadableCollections">
            <summary> 
            Determine whether this entity contains references to persistent collections
            which are fetchable by subselect? 
            </summary>
            <returns> 
            True if the entity contains collections fetchable by subselect; false otherwise.
            </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCascades">
            <summary>
            Does this class declare any cascading save/update/deletes?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasIdentifierProperty">
            <summary>
            Does the class have a property holding the identifier value?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.CanExtractIdOutOfEntity">
            <summary> 
            Determine whether detahced instances of this entity carry their own
            identifier value.
            </summary>
            <returns> 
            True if either (1) <see cref="P:NHibernate.Persister.Entity.IEntityPersister.HasIdentifierProperty"/> or
            (2) the identifier is an embedded composite identifier; false otherwise.
            </returns>
            <remarks>
            The other option is the deprecated feature where users could supply
            the id during session calls.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasNaturalIdentifier">
            <summary> 
            Determine whether this entity defines a natural identifier. 
            </summary>
            <returns> True if the entity defines a natural id; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasLazyProperties">
            <summary> 
            Determine whether this entity defines any lazy properties (ala
            bytecode instrumentation). 
            </summary>
            <returns> 
            True if the entity has properties mapped as lazy; false otherwise.
            </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyUpdateability">
            <summary>
            Gets if the Property is updatable
            </summary>
            <value><see langword="true" /> if the Property's value can be updated.</value>
            <remarks>
            This is for formula columns and if the user sets the update attribute on the &lt;property&gt; element.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCache">
            <summary>
            Does this class have a cache?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasInsertGeneratedProperties">
            <summary>
            Does this entity define any properties as being database-generated on insert?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasUpdateGeneratedProperties">
            <summary>
            Does this entity define any properties as being database-generated on update?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetSubclassForDiscriminatorValue(System.Object)">
            <summary>
            Get the concrete subclass corresponding to the given discriminator value
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetIdentifierAliases(System.String)">
            <summary>
            Get the result set aliases used for the identifier columns, given a suffix
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetPropertyAliases(System.String,System.Int32)">
            <summary>
            Get the result set aliases used for the property columns, given a suffix (properties of this class, only).
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetPropertyColumnNames(System.Int32)">
            <summary>
            Get the result set column names mapped for this property (properties of this class, only).
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.GetDiscriminatorAlias(System.String)">
            <summary>
            Get the alias used for the discriminator column, given a suffix
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILoadable.Hydrate(System.Data.IDataReader,System.Object,System.Object,NHibernate.Persister.Entity.ILoadable,System.String[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Retrieve property values from one row of a result set
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.DiscriminatorType">
            <summary>
            The discriminator type
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.IdentifierColumnNames">
            <summary>
            Get the names of columns used to persist the identifier
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.DiscriminatorColumnName">
            <summary>
            Get the name of the column used as a discriminator
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.HasSubclasses">
            <summary>
            Does the persistent class have subclasses?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILoadable.HasRowId">
            <summary> Does the result set contain rowids?</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.SelectFragment(System.String,System.String)">
            <summary>
            Generate a list of collection index and element columns
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.CountSubclassProperties">
            <summary>
            How many properties are there, for this class and all subclasses? (optional operation)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetFetchMode(System.Int32)">
            <summary>
            May this property be fetched using an SQL outerjoin?
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetCascadeStyle(System.Int32)">
            <summary>
            Get the cascade style of this (subclass closure) property
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.IsDefinedOnSubclass(System.Int32)">
            <summary>
            Is this property defined on a subclass of the mapped class?
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyType(System.Int32)">
            <summary>
            Get an array of the types of all properties of all subclasses (optional operation)
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyName(System.Int32)">
            <summary>
            Get the name of the numbered property of the class or a subclass
            (optional operation)
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.IsSubclassPropertyNullable(System.Int32)">
            <summary>
            Is the numbered property of the class of subclass nullable?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyColumnNames(System.Int32)">
            <summary>
            Return the column names used to persist all properties of all sublasses of the persistent class
            (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyTableName(System.Int32)">
            <summary>
            Return the table name used to persist the numbered property of 
            the class or a subclass
            (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.ToColumns(System.String,System.Int32)">
            <summary>
            Given the number of a property of a subclass, and a table alias, return the aliased column names
            (optional operation)
            </summary>
            <param name="name"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.FromTableFragment(System.String)">
            <summary>
            Get the main from table fragment, given a query alias (optional operation)
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetPropertyColumnNames(System.String)">
            <summary>
            Get the column names for the given property path
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetPropertyTableName(System.String)">
            <summary>
            Get the table name for the given property path
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.ToIdentifierColumns(System.String)">
            <summary>
            Return the alised identifier column names
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GenerateTableAliasForColumn(System.String,System.String)">
            <summary>
            Get the table alias used for the supplied column
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IQueryable">
            <summary>
            Extends the generic <c>ILoadable</c> contract to add operations required by HQL
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.IdentifierSelectFragment(System.String,System.String)">
            <summary>
            Given a query alias and an identifying suffix, render the identifier select fragment.
            </summary>
            <param name="name"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.PropertySelectFragment(System.String,System.String,System.Boolean)">
            <summary>
            Given a query alias and an identifying suffix, render the property select fragment.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.GetSubclassPropertyTableNumber(System.String)">
            <summary> 
            Given a property name, determine the number of the table which contains the column
            to which this property is mapped.
            </summary>
            <param name="propertyPath">The name of the property. </param>
            <returns> The number of the table to which the property is mapped. </returns>
            <remarks>
            Note that this is <b>not</b> relative to the results from {@link #getConstraintOrderedTableNameClosure()}.
            It is relative to the subclass table name closure maintained internal to the persister (yick!).
            It is also relative to the indexing used to resolve {@link #getSubclassTableName}...
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.GetSubclassPropertyDeclarer(System.String)">
            <summary> Determine whether the given property is declared by our
            mapped class, our super class, or one of our subclasses...
            <p/>
            Note: the method is called 'subclass property...' simply
            for consistency sake (e.g. {@link #getSubclassPropertyTableNumber}
             </summary>
            <param name="propertyPath">The property name. </param>
            <returns> The property declarer </returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.GetSubclassTableName(System.Int32)">
            <summary> 
            Get the name of the table with the given index from the internal array. 
            </summary>
            <param name="number">The index into the internal array. </param>
            <returns> </returns>
        </member>
        <member name="M:NHibernate.Persister.Entity.IQueryable.GenerateFilterConditionAlias(System.String)">
            <summary> 
            The alias used for any filter conditions (mapped where-fragments or
            enabled-filters).
            </summary>
            <param name="rootAlias">The root alias </param>
            <returns> The alias used for "filter conditions" within the where clause. </returns>
            <remarks>
            This may or may not be different from the root alias depending upon the
            inheritance mapping strategy. 
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.IsExplicitPolymorphism">
            <summary>
            Is this class explicit polymorphism only?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.MappedSuperclass">
            <summary>
            The class that this class is mapped as a subclass of - not necessarily the direct superclass
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.DiscriminatorSQLValue">
            <summary>
            The discriminator value for this particular concrete subclass, as a string that may be
            embedded in a select statement
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.DiscriminatorValue">
            <summary>
            The discriminator value for this particular concrete subclass
            </summary>
            <remarks>The DiscriminatorValue is specific of NH since we are using strongly typed parameters for SQL query.</remarks>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.IsMultiTable">
            <summary> 
            Is the inheritance hierarchy described by this persister contained across
            multiple tables? 
            </summary>
            <returns> True if the inheritance hierarchy is spread across multiple tables; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.ConstraintOrderedTableNameClosure">
            <summary> 
            Get the names of all tables used in the hierarchy (up and down) ordered such
            that deletes in the given order would not cause constraint violations. 
            </summary>
            <returns> The ordered array of table names. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.ContraintOrderedTableKeyColumnClosure">
            <summary> 
            For each table specified in <see cref="P:NHibernate.Persister.Entity.IQueryable.ConstraintOrderedTableNameClosure"/>, get
            the columns that define the key between the various hierarchy classes.
            </summary>
            <returns>
            The first dimension here corresponds to the table indexes returned in
            <see cref="P:NHibernate.Persister.Entity.IQueryable.ConstraintOrderedTableNameClosure"/>.
            <para/>
            The second dimension should have the same length across all the elements in
            the first dimension.  If not, that'd be a problem ;) 
            </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.TemporaryIdTableName">
            <summary> 
            Get the name of the temporary table to be used to (potentially) store id values
            when performing bulk update/deletes. 
            </summary>
            <returns> The appropriate temporary table name. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.TemporaryIdTableDDL">
            <summary> 
            Get the appropriate DDL command for generating the temporary table to
            be used to (potentially) store id values when performing bulk update/deletes. 
            </summary>
            <returns> The appropriate temporary table creation command. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.IQueryable.VersionPropertyInsertable">
            <summary> Is the version property included in insert statements?</summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.IUniqueKeyLoadable">
            <summary>
            Describes a class that may be loaded via a unique key.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IUniqueKeyLoadable.LoadByUniqueKey(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance of the persistent class, by a unique key other than the primary key.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.IUniqueKeyLoadable.GetPropertyIndex(System.String)">
            <summary>
            Get the property number of the unique key property
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.ISqlLoadable">
            <summary>
            A class persister that supports queries expressed in the platform native SQL dialect.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ISqlLoadable.GetSubclassPropertyColumnAliases(System.String,System.String)">
            <summary>
            Returns the column alias names used to persist/query the numbered property of the class or a subclass (optional operation).
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ISqlLoadable.GetSubclassPropertyColumnNames(System.String)">
            <summary> 
            Return the column names used to persist/query the named property of the class or a subclass (optional operation).
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.ISqlLoadable.SelectFragment(System.String,System.String)">
            <summary>
            All columns to select, when loading.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ISqlLoadable.Type">
            <summary>
            Get the type
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.ILockable">
            <summary> 
            Contract for things that can be locked via a <see cref="T:NHibernate.Dialect.Lock.ILockingStrategy"/>.
            </summary>
            <remarks>
            Currently only the root table gets locked, except for the case of HQL and Criteria queries
            against dialects which do not support either (1) FOR UPDATE OF or (2) support hint locking
            (in which case *all* queried tables would be locked).
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.ILockable.GetRootTableAlias(System.String)">
            <summary> 
            Get the SQL alias this persister would use for the root table
            given the passed driving alias. 
            </summary>
            <param name="drivingAlias">
            The driving alias; or the alias for the table mapped by this persister in the hierarchy.
            </param>
            <returns> The root table alias. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILockable.RootTableName">
            <summary> 
            Locks are always applied to the "root table".
             </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILockable.RootTableIdentifierColumnNames">
            <summary> 
            Get the names of columns on the root table used to persist the identifier. 
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILockable.VersionColumnName">
            <summary> 
            For versioned entities, get the name of the column (again, expected on the
            root table) used to store the version values. 
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.ILockable.IdAndVersionSqlTypes">
            <summary>
            To build the SQL command in pessimistic lock
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetTableUpdateNeeded(System.Int32[],System.Boolean)">
            <summary>
            Decide which tables need to be updated
            </summary>
            <param name="dirtyProperties">The indices of all the entity properties considered dirty.</param>
            <param name="hasDirtyCollection">Whether any collections owned by the entity which were considered dirty. </param>
            <returns> Array of booleans indicating which table require updating. </returns>
            <remarks>
            The return here is an array of boolean values with each index corresponding
            to a given table in the scope of this persister.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GenerateSelectVersionString">
            <summary>
            Generate the SQL that selects the version number by id
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Retrieve the version number
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetSubclassPropertyTableNumber(System.String)">
            <remarks>
            Warning:
            When there are duplicated property names in the subclasses
            of the class, this method may return the wrong table
            number for the duplicated subclass property (note that
            SingleTableEntityPersister defines an overloaded form
            which takes the entity name.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertyColumnNames(System.Int32)">
            <summary>
            Get the column names for the numbered property of <em>this</em> class
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.InitSubclassPropertyAliasesMap(NHibernate.Mapping.PersistentClass)">
            <summary>
            Must be called by subclasses, at the end of their constructors
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GenerateUpdateString(System.Boolean[],System.Int32,System.Object[],System.Boolean)">
            <summary> Generate the SQL that updates a row by id (and version)</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GenerateInsertString(System.Boolean,System.Boolean[],System.Int32)">
            <summary> Generate the SQL that inserts a row</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Dehydrate(System.Object,System.Object[],System.Object,System.Boolean[],System.Boolean[][],System.Int32,System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor,System.Int32)">
            <summary> Marshall the fields of a persistent instance to a prepared statement</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Hydrate(System.Data.IDataReader,System.Object,System.Object,NHibernate.Persister.Entity.ILoadable,System.String[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Unmarshall the fields of a persistent instance from a result set,
            without resolving associations or collections
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Insert(System.Object[],System.Boolean[],NHibernate.SqlCommand.SqlCommandInfo,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform an SQL INSERT, and then retrieve a generated identifier.
            </summary>
            <remarks>
            This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY, select, etc).
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Insert(System.Object,System.Object[],System.Boolean[],System.Int32,NHibernate.SqlCommand.SqlCommandInfo,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Perform an SQL INSERT.
            </summary>
            <remarks>
            This for is used for all non-root tables as well as the root table
            in cases where the identifier value is known before the insert occurs.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.UpdateOrInsert(System.Object,System.Object[],System.Object[],System.Object,System.Boolean[],System.Int32,System.Object,System.Object,NHibernate.SqlCommand.SqlCommandInfo,NHibernate.Engine.ISessionImplementor)">
            <summary> Perform an SQL UPDATE or SQL INSERT</summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Delete(System.Object,System.Object,System.Int32,System.Object,NHibernate.SqlCommand.SqlCommandInfo,NHibernate.Engine.ISessionImplementor,System.Object[])">
            <summary>
            Perform an SQL DELETE
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance using the appropriate loader (as determined by <see cref="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetAppropriateLoader(NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertiesToUpdate(System.Int32[],System.Boolean)">
            <summary> 
            Transform the array of property indexes to an array of booleans, true when the property is dirty
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertyUpdateability(System.Object,NHibernate.EntityMode)">
            <summary> Which properties appear in the SQL update? (Initialized, updateable ones!) </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.IsInstance(System.Object,NHibernate.EntityMode)">
            <summary>
            Determines whether the specified entity is an instance of the class
            managed by this persister.
            </summary>
            <param name="entity">The entity.</param>
            <param name="entityMode">The entity mode.</param>
            <returns>
            	<see langword="true"/> if the specified entity is an instance; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlDeleteStrings">
            <summary>
            The queries that delete rows by id (and version)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlInsertStrings">
            <summary>
            The queries that insert rows with a given id
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlUpdateStrings">
            <summary>
            The queries that update rows by id (and version)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SQLIdentityInsertString">
            <summary> 
            The query that inserts a row, letting the database generate an id 
            </summary>
            <returns> The IDENTITY-based insertion query. </returns>
        </member>
        <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.IsCacheInvalidationRequired">
            <summary> 
            We can't immediately add to the cache if we have formulas
            which must be evaluated, or if we have the possibility of
            two concurrent updates to the same item being merged on
            the database. This can happen if (a) the item is not
            versioned and either (b) we have dynamic update enabled
            or (c) we have multiple tables holding the state of the
            item.
            </summary>
        </member>
        <member name="F:NHibernate.Persister.Entity.EntityPersister.EntityID">
            <summary> The property name of the "special" identifier property in HQL</summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.JoinedSubclassEntityPersister">
            <summary>
            A <c>IEntityPersister</c> implementing the normalized "table-per-subclass" mapping strategy
            </summary>
        </member>
        <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.#ctor(NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
            <summary>
            Constructs the NormalizedEntityPerister for the PersistentClass.
            </summary>
            <param name="persistentClass">The PersistentClass to create the EntityPersister for.</param>
            <param name="cache">The configured <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>.</param>
            <param name="factory">The SessionFactory that this EntityPersister will be stored in.</param>
            <param name="mapping">The mapping used to retrieve type information.</param>
        </member>
        <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.GetTableId(System.String,System.String[])">
            <summary>
            Find the Index of the table name from a list of table names.
            </summary>
            <param name="tableName">The name of the table to find.</param>
            <param name="tables">The array of table names</param>
            <returns>The Index of the table in the array.</returns>
            <exception cref="T:NHibernate.AssertionFailure">Thrown when the tableName specified can't be found</exception>
        </member>
        <member name="T:NHibernate.Persister.Entity.NamedQueryLoader">
            <summary> 
            Not really a <tt>Loader</tt>, just a wrapper around a named query.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.Entity.SingleTableEntityPersister">
            <summary>
            Default implementation of the <c>ClassPersister</c> interface. Implements the
            "table-per-class hierarchy" mapping strategy for an entity class.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.PersisterFactory">
            <summary>
            Factory for <c>IEntityPersister</c> and <c>ICollectionPersister</c> instances.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.PersisterFactory.CreateClassPersister(NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
            <summary>
            Creates a built in Entity Persister or a custom Persister.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.PersisterFactory.Create(System.Type,NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
            <summary>
            Creates a specific Persister - could be a built in or custom persister.
            </summary>
        </member>
        <member name="T:NHibernate.Properties.IFieldNamingStrategy">
            <summary>
            A Strategy for converting a mapped property name to a Field name.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.IFieldNamingStrategy.GetFieldName(System.String)">
            <summary>
            When implemented by a class, converts the Property's name into a Field name
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field.</returns>
        </member>
        <member name="T:NHibernate.Properties.BackrefPropertyAccessor">
            <summary> Represents a "back-reference" to the id of a collection owner. </summary>
        </member>
        <member name="T:NHibernate.Properties.IPropertyAccessor">
            <summary>
            Abstracts the notion of a "property". Defines a strategy for accessing the
            value of a mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.IPropertyAccessor.GetGetter(System.Type,System.String)">
            <summary>
            When implemented by a class, create a "getter" for the mapped property.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.IGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.IPropertyAccessor.GetSetter(System.Type,System.String)">
            <summary>
            When implemented by a class, create a "setter" for the mapped property.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.ISetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="P:NHibernate.Properties.IPropertyAccessor.CanAccessThroughReflectionOptimizer">
            <summary>
            Allow embedded and custom accessors to define if the ReflectionOptimizer can be used.
            </summary>
        </member>
        <member name="T:NHibernate.Properties.BackrefPropertyAccessor.BackrefSetter">
            <summary> The Setter implementation for id backrefs.</summary>
        </member>
        <member name="T:NHibernate.Properties.ISetter">
            <summary>
            Sets values of a particular mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.ISetter.Set(System.Object,System.Object)">
            <summary>
            When implemented by a class, sets the value of the Property/Field on the object.
            </summary>
            <param name="target">The object to set the Property value in.</param>
            <param name="value">The value to set the Property to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Properties.ISetter.PropertyName">
            <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
            <value>The name of the Property or <see langword="null" />.</value>
            <remarks>
            This is an optional operation - if it is not implemented then 
            <see langword="null" /> is an acceptable value to return.
            </remarks>
        </member>
        <member name="P:NHibernate.Properties.ISetter.Method">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.MethodInfo"/> for the <c>set</c>
            accessor of the property.
            </summary>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Properties.ISetter"/> is not 
            for a property <c>set</c> then <see langword="null"/> is an acceptable value to return.
            It is used by the proxies to determine which setter to intercept for the
            identifier property.
            </remarks>
        </member>
        <member name="T:NHibernate.Properties.BackrefPropertyAccessor.BackrefGetter">
            <summary> The Getter implementation for id backrefs.</summary>
        </member>
        <member name="T:NHibernate.Properties.IGetter">
            <summary>
            Gets values of a particular mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.IGetter.Get(System.Object)">
            <summary>
            When implemented by a class, gets the value of the Property/Field from the object.
            </summary>
            <param name="target">The object to get the Property/Field value from.</param>
            <returns>
            The value of the Property for the target.
            </returns>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem getting the value from the target.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.IGetter.GetForInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
            <summary> Get the property value from the given owner instance. </summary>
            <param name="owner">The instance containing the value to be retrieved. </param>
            <param name="mergeMap">a map of merged persistent instances to detached instances </param>
            <param name="session">The session from which this request originated. </param>
            <returns> The extracted value. </returns>
        </member>
        <member name="P:NHibernate.Properties.IGetter.ReturnType">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Type"/> that the Property/Field returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Property returns.</value>
        </member>
        <member name="P:NHibernate.Properties.IGetter.PropertyName">
            <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
            <value>The name of the Property or <see langword="null"/>.</value>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Properties.IGetter"/> is not 
            for a Property <c>get</c> then <see langword="null"/> is an acceptable value to return.
            </remarks>
        </member>
        <member name="P:NHibernate.Properties.IGetter.Method">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.MethodInfo"/> for the <c>get</c>
            accessor of the property.
            </summary>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Properties.IGetter"/> is not 
            for a property <c>get</c> then <see langword="null"/> is an acceptable value to return.
            It is used by the proxies to determine which getter to intercept for the
            identifier property.
            </remarks>
        </member>
        <member name="T:NHibernate.Properties.BasicPropertyAccessor">
            <summary>
            Accesses mapped property values via a get/set pair, which may be nonpublic.
            The default (and recommended strategy).
            </summary>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/> for the mapped property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter"/> for the mapped property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetGetterOrNull(System.Type,System.String)">
            <summary>
            Helper method to find the Property <c>get</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/> for the Property <c>get</c> or <see langword="null"/>
            if the Property could not be found.
            </returns>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetSetterOrNull(System.Type,System.String)">
            <summary>
            Helper method to find the Property <c>set</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter"/> for the Property <c>set</c> or <see langword="null"/>
            if the Property could not be found.
            </returns>
        </member>
        <member name="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter">
            <summary>
            An <see cref="T:NHibernate.Properties.IGetter"/> for a Property <c>get</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Properties.IOptimizableGetter">
            <summary>
            An <see cref="T:NHibernate.Properties.IGetter"/> that can emit IL to get the property value.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.IOptimizableGetter.Emit(System.Reflection.Emit.ILGenerator)">
            <summary>
            Emit IL to get the property value from the object on top of the stack.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Property <c>get</c>.</param>
            <param name="property">The <see cref="T:System.Reflection.PropertyInfo"/> for reflection.</param>
            <param name="propertyName">The name of the Property.</param>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.Get(System.Object)">
            <summary>
            Gets the value of the Property from the object.
            </summary>
            <param name="target">The object to get the Property value from.</param>
            <returns>
            The value of the Property for the target.
            </returns>
        </member>
        <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.ReturnType">
            <summary>
            Gets the <see cref="T:System.Type"/> that the Property returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Property returns.</value>
        </member>
        <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value>The name of the Property.</value>
        </member>
        <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value>
            The <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </value>
        </member>
        <member name="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter">
            <summary>
            An <see cref="T:NHibernate.Properties.ISetter"/> for a Property <c>set</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Properties.IOptimizableSetter">
            <summary>
            An <see cref="T:NHibernate.Properties.ISetter"/> that can emit IL to set the property value.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.IOptimizableSetter.Emit(System.Reflection.Emit.ILGenerator)">
            <summary>
            Emit IL to set the property of an object to the value. The object
            is loaded onto the stack first, then the value, then this method
            is called.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Property <c>set</c>.</param>
            <param name="property">The <see cref="T:System.Reflection.PropertyInfo"/> for reflection.</param>
            <param name="propertyName">The name of the mapped Property.</param>
        </member>
        <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.Set(System.Object,System.Object)">
            <summary>
            Sets the value of the Property on the object.
            </summary>
            <param name="target">The object to set the Property value in.</param>
            <param name="value">The value to set the Property to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.PropertyName">
            <summary>
            Gets the name of the mapped Property.
            </summary>
            <value>The name of the mapped Property or <see langword="null" />.</value>
        </member>
        <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the mapped Property.
            </summary>
            <value>The <see cref="T:System.Reflection.PropertyInfo"/> for the mapped Property.</value>
        </member>
        <member name="T:NHibernate.Properties.CamelCaseMUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> for fields that are prefixed with
            an <c>m_</c> and the PropertyName is changed to camelCase.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.CamelCaseMUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> lowercase and prefixing it with the letter 'm'
            and an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in CamelCase format prefixed with an 'm' and an underscore.</returns>
        </member>
        <member name="T:NHibernate.Properties.CamelCaseStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> for fields that are the 
            camelCase version of the PropertyName
            </summary>
        </member>
        <member name="M:NHibernate.Properties.CamelCaseStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character
            lower case.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in CamelCase format.</returns>
        </member>
        <member name="T:NHibernate.Properties.CamelCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> for fields that are prefixed with
            an underscore and the PropertyName is changed to camelCase.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.CamelCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in CamelCase format prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Properties.FieldAccessor">
            <summary>
            Access the mapped property by using a Field to <c>get</c> and <c>set</c> the value.
            </summary>
            <remarks>
            The <see cref="T:NHibernate.Properties.FieldAccessor"/> is useful when you expose <c>getter</c> and <c>setters</c>
            for a Property, but they have extra code in them that shouldn't be executed when NHibernate
            is setting or getting the values for loads or saves.
            </remarks>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.#ctor(NHibernate.Properties.IFieldNamingStrategy)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor"/>.
            </summary>
            <param name="namingStrategy">The <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> to use.</param>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Properties.FieldAccessor.FieldGetter"/> to <c>get</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.FieldAccessor.FieldGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter"/> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the mapped Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> could not be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.GetField(System.Type,System.String)">
            <summary>
            Helper method to find the Field.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Field in.</param>
            <param name="fieldName">The name of the Field to find.</param>
            <returns>
            The <see cref="T:System.Reflection.FieldInfo"/> for the field.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a field could not be found.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.GetFieldName(System.String)">
            <summary>
            Converts the mapped property's name into a Field using 
            the <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> if one exists.
            </summary>
            <param name="propertyName">The name of the Property.</param>
            <returns>The name of the Field.</returns>
        </member>
        <member name="P:NHibernate.Properties.FieldAccessor.NamingStrategy">
            <summary>
            Gets the <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> used to convert the name of the
            mapped Property in the hbm.xml file to the name of the field in the class.
            </summary>
            <value>The <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> or <see langword="null"/>.</value>
        </member>
        <member name="T:NHibernate.Properties.FieldAccessor.FieldGetter">
            <summary>
            An <see cref="T:NHibernate.Properties.IGetter"/> that uses a Field instead of the Property <c>get</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.FieldGetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor.FieldGetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the field to use for the Property <c>get</c>.</param>
            <param name="field">The <see cref="T:System.Reflection.FieldInfo"/> for reflection.</param>
            <param name="name">The name of the Field.</param>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.FieldGetter.Get(System.Object)">
            <summary>
            Gets the value of the Field from the object.
            </summary>
            <param name="target">The object to get the Field value from.</param>
            <returns>
            The value of the Field for the target.
            </returns>
        </member>
        <member name="P:NHibernate.Properties.FieldAccessor.FieldGetter.ReturnType">
            <summary>
            Gets the <see cref="T:System.Type"/> that the Field returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Field returns.</value>
        </member>
        <member name="P:NHibernate.Properties.FieldAccessor.FieldGetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value><see langword="null" /> since this is a Field - not a Property.</value>
        </member>
        <member name="P:NHibernate.Properties.FieldAccessor.FieldGetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value><see langword="null"/> since this is a Field - not a Property.</value>
        </member>
        <member name="T:NHibernate.Properties.FieldAccessor.FieldSetter">
            <summary>
            An <see cref="T:NHibernate.Properties.IGetter"/> that uses a Field instead of the Property <c>set</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.FieldSetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Field to use for the Property <c>set</c>.</param>
            <param name="field">The <see cref="T:System.Reflection.FieldInfo"/> for reflection.</param>
            <param name="name">The name of the Field.</param>
        </member>
        <member name="M:NHibernate.Properties.FieldAccessor.FieldSetter.Set(System.Object,System.Object)">
            <summary>
            Sets the value of the Field on the object.
            </summary>
            <param name="target">The object to set the Field value in.</param>
            <param name="value">The value to set the Field to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Properties.FieldAccessor.FieldSetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value><see langword="null" /> since this is a Field - not a Property.</value>
        </member>
        <member name="P:NHibernate.Properties.FieldAccessor.FieldSetter.Method">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value><see langword="null"/> since this is a Field - not a Property.</value>
        </member>
        <member name="T:NHibernate.Properties.IndexPropertyAccessor">
            <summary> Represents a "back-reference" to the index of a collection. </summary>
        </member>
        <member name="M:NHibernate.Properties.IndexPropertyAccessor.#ctor(System.String,System.String)">
            <summary> Constructs a new instance of IndexPropertyAccessor. </summary>
            <param name="collectionRole">The collection role which this back ref references. </param>
            <param name="entityName">The owner entity name.</param>
        </member>
        <member name="T:NHibernate.Properties.IndexPropertyAccessor.IndexSetter">
            <summary> The Setter implementation for index backrefs.</summary>
        </member>
        <member name="T:NHibernate.Properties.IndexPropertyAccessor.IndexGetter">
            <summary> The Getter implementation for index backrefs.</summary>
        </member>
        <member name="T:NHibernate.Properties.LowerCaseStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> for fields that are  
            the PropertyName in all LowerCase characters.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.LowerCaseStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in lowercase.</returns>
        </member>
        <member name="T:NHibernate.Properties.LowerCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> for fields that are prefixed with
            an underscore and the PropertyName is changed to lower case.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.LowerCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in lowercase prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Properties.NoopAccessor">
            <summary> Used to declare properties not represented at the pojo level </summary>
        </member>
        <member name="T:NHibernate.Properties.NoopAccessor.NoopGetter">
            <summary> A Getter which will always return null. It should not be called anyway.</summary>
        </member>
        <member name="T:NHibernate.Properties.NoopAccessor.NoopSetter">
            <summary> A Setter which will just do nothing.</summary>
        </member>
        <member name="T:NHibernate.Properties.NoSetterAccessor">
            <summary>
            Access the mapped property through a Property <c>get</c> to get the value 
            and go directly to the Field to set the value.
            </summary>
            <remarks>
            This is most useful because Classes can provider a get for the Property
            that is the <c>&lt;id&gt;</c> but tell NHibernate there is no setter for the Property
            so the value should be written directly to the field.
            </remarks>
        </member>
        <member name="M:NHibernate.Properties.NoSetterAccessor.#ctor(NHibernate.Properties.IFieldNamingStrategy)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.NoSetterAccessor"/>.
            </summary>
            <param name="namingStrategy">The <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> to use.</param>
        </member>
        <member name="M:NHibernate.Properties.NoSetterAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Creates an <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/> to <c>get</c> the value from the Property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.NoSetterAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter"/> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the mapped Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> could not be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.PascalCaseMStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with the letter 'm'.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an 'm'.</returns>
        </member>
        <member name="T:NHibernate.Properties.PascalCaseMUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> for fields that are prefixed with
            an <c>m_</c> and the first character in PropertyName capitalized.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.PascalCaseMUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with the letter 'm' 
            and an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an 'm' and an underscore.</returns>
        </member>
        <member name="T:NHibernate.Properties.PascalCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy"/> for fields that are prefixed with
            an <c>_</c> and the first character in PropertyName capitalized.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.PascalCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Properties.PropertyAccessorFactory">
            <summary>
            Factory for creating the various PropertyAccessor strategies.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.PropertyAccessorFactory.#cctor">
            <summary>
            Initializes the static members in <see cref="T:NHibernate.Properties.PropertyAccessorFactory"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.PropertyAccessorFactory.GetPropertyAccessor(System.String)">
            <summary>
            Gets or creates the <see cref="T:NHibernate.Properties.IPropertyAccessor"/> specified by the type.
            </summary>
            <param name="type"></param>
            <returns>The <see cref="T:NHibernate.Properties.IPropertyAccessor"/> specified by the type.</returns>
            <remarks>
            <para>
            The built in ways of accessing the values of Properties in your domain class are:
            </para>
            <list type="table">
            	<listheader>
            		<term>Access Method</term>
            		<description>How NHibernate accesses the Mapped Class.</description>
            	</listheader>
            	<item>
            		<term>property</term>
            		<description>
            			The <c>name</c> attribute is the name of the Property.  This is the 
            			default implementation.
            		</description>
            	</item>
            	<item>
            		<term>field</term>
            		<description>
            			The <c>name</c> attribute is the name of the field.  If you have any Properties
            			in the Mapped Class those will be bypassed and NHibernate will go straight to the
            			field.  This is a good option if your setters have business rules attached to them
            			or if you don't want to expose a field through a Getter &amp; Setter.
            		</description>
            	</item>
            	<item>
            		<term>nosetter</term>
            		<description>
            			The <c>name</c> attribute is the name of the Property.  NHibernate will use the 
            			Property's get method to retrieve the value and will use the field
            			to set the value.  This is a good option for &lt;id&gt; Properties because this access method 
            			allows users of the Class to get the value of the Id but not set the value.
            		</description>
            	</item>
                <item>
            		<term>readonly</term>
            		<description>
            			The <c>name</c> attribute is the name of the Property.  NHibernate will use the 
            			Property's get method to retrieve the value but will never set the value back in the domain.
            			This is used for read-only calculated properties with only a get method.
            		</description>
            	</item>
            	<item>
            		<term>Assembly Qualified Name</term>
            		<description>
            			If NHibernate's built in <see cref="T:NHibernate.Properties.IPropertyAccessor"/>s are not what is needed for your 
            			situation then you are free to build your own.  Provide an Assembly Qualified Name so that 
            			NHibernate can call <c>Activator.CreateInstance(AssemblyQualifiedName)</c> to create it.  
            		</description>
            	</item>
            </list>
            <para>
            In order for the <c>nosetter</c> to know the name of the field to access NHibernate needs to know
            what the naming strategy is.  The following naming strategies are built into NHibernate:
            </para>
            <list type="table">
            	<listheader>
            		<term>Naming Strategy</term>
            		<description>How NHibernate converts the value of the <c>name</c> attribute to a field name.</description>
            	</listheader>
            	<item>
            		<term>camelcase</term>
            		<description>
            			The <c>name</c> attribute should be changed to CamelCase to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>fooBar</c>.
            		</description>
            	</item>
            	<item>
            		<term>camelcase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be changed to CamelCase and prefixed with
            			an underscore to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>_fooBar</c>.
            		</description>
            	</item>
            	<item>
            		<term>camelcase-m-underscore</term>
            		<description>
            			The <c>name</c> attribute should be changed to CamelCase and prefixed with
            			an 'm' and underscore to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>m_fooBar</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an underscore
            			to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>_FooBar</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-m-underscore</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an 'm' and underscore
            			to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>m_FooBar</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-m</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an 'm'.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>mFooBar</c>.
            		</description>
            	</item>
            	<item>
            		<term>lowercase</term>
            		<description>
            			The <c>name</c> attribute should be changed to lowercase to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>foobar</c>.
            		</description>
            	</item>
            	<item>
            		<term>lowercase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be changed to lowercase and prefixed with
            			and underscore to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>_foobar</c>.
            		</description>
            	</item>
            </list>
            <para>
            The naming strategy can also be appended at the end of the <c>field</c> access method.  Where
            this could be useful is a scenario where you do expose a get and set method in the Domain Class 
            but NHibernate should only use the fields.  
            </para>
            <para>
            With a naming strategy and a get/set for the Property available the user of the Domain Class 
            could write an Hql statement <c>from Foo as foo where foo.SomeProperty = 'a'</c>.   If no naming 
            strategy was specified the Hql statement would have to be <c>from Foo as foo where foo._someProperty</c>
             (assuming CamelCase with an underscore field naming strategy is used).  
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Properties.PropertyAccessorFactory.GetPropertyAccessor(NHibernate.Mapping.Property,System.Nullable{NHibernate.EntityMode})">
            <summary> Retrieves a PropertyAccessor instance based on the given property definition and entity mode. </summary>
            <param name="property">The property for which to retrieve an accessor. </param>
            <param name="mode">The mode for the resulting entity. </param>
            <returns> An appropriate accessor. </returns>
        </member>
        <member name="T:NHibernate.Properties.ReadOnlyAccessor">
            <summary>
            Access the mapped property through a Property <c>get</c> to get the value 
            and do nothing to set the value.
            </summary>
            <remarks>
            This is useful to allow calculated properties in the domain that will never
            be recovered from the DB but can be used for querying.
            </remarks>
        </member>
        <member name="M:NHibernate.Properties.ReadOnlyAccessor.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.ReadOnlyAccessor"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Properties.ReadOnlyAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Creates an <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/> to <c>get</c> the value from the Property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Properties.ReadOnlyAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Properties.NoopAccessor.NoopSetter"/> to do nothing when trying to
            se the value of the mapped Property
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the mapped Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            An instance of <see cref="T:NHibernate.Properties.NoopAccessor.NoopSetter"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor">
            <summary> 
            Responsible for accessing property values represented as a XmlElement
            or XmlAttribute. 
            </summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.AttributeGetter">
            <summary> For nodes like <tt>"@bar"</tt></summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.XmlGetter">
            <summary> Defines the strategy for getting property values out of a dom4j Node.</summary>
        </member>
        <member name="P:NHibernate.Properties.XmlAccessor.XmlGetter.ReturnType">
            <summary> Get the declared type</summary>
        </member>
        <member name="P:NHibernate.Properties.XmlAccessor.XmlGetter.PropertyName">
            <summary> Optional operation (return null)</summary>
        </member>
        <member name="P:NHibernate.Properties.XmlAccessor.XmlGetter.Method">
            <summary> Optional operation (return null)</summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.AttributeSetter">
            <summary> For nodes like <tt>"@bar"</tt></summary>
        </member>
        <member name="P:NHibernate.Properties.XmlAccessor.XmlSetter.PropertyName">
            <summary> Optional operation (return null)</summary>
        </member>
        <member name="P:NHibernate.Properties.XmlAccessor.XmlSetter.Method">
            <summary> Optional operation (return null)</summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.ElementAttributeGetter">
            <summary> For nodes like <tt>"foo/@bar"</tt></summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.ElementAttributeSetter">
            <summary> For nodes like <tt>"foo/@bar"</tt></summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.ElementGetter">
            <summary> For nodes like <tt>"foo"</tt></summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.ElementSetter">
            <summary> For nodes like <tt>"foo"</tt></summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.TextGetter">
            <summary> For nodes like <tt>"."</tt></summary>
        </member>
        <member name="T:NHibernate.Properties.XmlAccessor.TextSetter">
            <summary> For nodes like <tt>"."</tt></summary>
        </member>
        <member name="T:NHibernate.Proxy.Map.MapLazyInitializer">
            <summary> Lazy initializer for "dynamic-map" entity representations. </summary>
        </member>
        <member name="T:NHibernate.Proxy.AbstractLazyInitializer">
            <summary>
            Provides the base functionality to Handle Member calls into a dynamically
            generated NHibernate Proxy.
            </summary>
            <remarks>
            This could be an extension point later if the .net framework ever gets a Proxy
            class that is similar to the java.lang.reflect.Proxy or if a library similar
            to cglib was made in .net.
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.ILazyInitializer.Initialize">
            <summary>
            Perform an ImmediateLoad of the actual object for the Proxy.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the Proxy has no Session or the Session is closed or disconnected.
            </exception>
        </member>
        <member name="M:NHibernate.Proxy.ILazyInitializer.GetImplementation">
            <summary>
            Return the underlying persistent object, initializing if necessary.
            </summary>
            <returns>The persistent object this proxy is proxying.</returns>
        </member>
        <member name="M:NHibernate.Proxy.ILazyInitializer.GetImplementation(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Return the underlying persistent object in a given <see cref="T:NHibernate.ISession"/>, or null.
            </summary>
            <param name="s">The session to get the object from.</param>
            <returns>The persistent object this proxy is proxying, or <see langword="null"/>.</returns>
        </member>
        <member name="M:NHibernate.Proxy.ILazyInitializer.SetImplementation(System.Object)">
            <summary>
            Initialize the proxy manually by injecting its target.
            </summary>
            <param name="target">The proxy target (the actual entity being proxied).</param>
        </member>
        <member name="M:NHibernate.Proxy.ILazyInitializer.SetSession(NHibernate.Engine.ISessionImplementor)">
             <summary>
             Associate the proxy with the given session.
            
             Care should be given to make certain that the proxy is added to the session's persistence context as well
             to maintain the symmetry of the association.  That must be done separately as this method simply sets an
             internal reference.  We do also check that if there is already an associated session that the proxy
             reference was removed from that previous session's persistence context.
             </summary>
             <param name="s">The session</param>
        </member>
        <member name="M:NHibernate.Proxy.ILazyInitializer.UnsetSession">
             <summary>
             Unset this initializer's reference to session.  It is assumed that the caller is also taking care or
             cleaning up the owning proxy's reference in the persistence context.
            
             Generally speaking this is intended to be called only during <see cref="M:NHibernate.ISession.Evict(System.Object)"/> and
             <see cref="M:NHibernate.ISession.Clear"/> processing; most other use-cases should call <see cref="M:NHibernate.Proxy.ILazyInitializer.SetSession(NHibernate.Engine.ISessionImplementor)"/> instead.
             </summary>
        </member>
        <member name="P:NHibernate.Proxy.ILazyInitializer.Identifier">
            <summary>
            The identifier value for the entity our owning proxy represents.
            </summary>
        </member>
        <member name="P:NHibernate.Proxy.ILazyInitializer.EntityName">
            <summary>
            The entity-name of the entity our owning proxy represents.
            </summary>
        </member>
        <member name="P:NHibernate.Proxy.ILazyInitializer.PersistentClass">
            <summary>
            Get the actual class of the entity.  Generally, <see cref="P:NHibernate.Proxy.ILazyInitializer.EntityName"/> should be used instead.
            </summary>
        </member>
        <member name="P:NHibernate.Proxy.ILazyInitializer.IsUninitialized">
            <summary>
            Is the proxy uninitialzed?
            </summary>
        </member>
        <member name="P:NHibernate.Proxy.ILazyInitializer.Session">
            <summary>
            Get the session to which this proxy is associated, or null if it is not attached.
            </summary>
        </member>
        <member name="P:NHibernate.Proxy.ILazyInitializer.IsReadOnlySettingAvailable">
            <summary>
            Is the read-only setting available?
            </summary>
        </member>
        <member name="P:NHibernate.Proxy.ILazyInitializer.ReadOnly">
            <summary>
            Read-only status
            </summary>
            <remarks>
            <para>
            Not available when the proxy is detached or its associated session is closed.
            </para>
            <para>
            To check if the read-only setting is available, use <see cref="P:NHibernate.Proxy.ILazyInitializer.IsReadOnlySettingAvailable"/>
            </para>
            <para>
            The read-only status of the entity will be made to match the read-only status of the proxy
            upon initialization.
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.Proxy.AbstractLazyInitializer.InvokeImplementation">
            <summary>
            If this is returned by Invoke then the subclass needs to Invoke the
            method call against the object that is being proxied.
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.AbstractLazyInitializer.#ctor(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a LazyInitializer to handle all of the Methods/Properties that are called
            on the Proxy.
            </summary>
            <param name="entityName">The entityName</param>
            <param name="id">The Id of the Object we are Proxying.</param>
            <param name="session">The ISession this Proxy is in.</param>
        </member>
        <member name="M:NHibernate.Proxy.AbstractLazyInitializer.SetSession(NHibernate.Engine.ISessionImplementor)">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Proxy.AbstractLazyInitializer.UnsetSession">
            <inheritdoc />
        </member>
        <member name="M:NHibernate.Proxy.AbstractLazyInitializer.Initialize">
            <summary>
            Perform an ImmediateLoad of the actual object for the Proxy.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the Proxy has no Session or the Session is closed or disconnected.
            </exception>
        </member>
        <member name="M:NHibernate.Proxy.AbstractLazyInitializer.GetImplementation">
            <summary>
            Return the Underlying Persistent Object, initializing if necessary.
            </summary>
            <returns>The Persistent Object this proxy is Proxying.</returns>
        </member>
        <member name="M:NHibernate.Proxy.AbstractLazyInitializer.GetImplementation(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Return the Underlying Persistent Object in a given <see cref="T:NHibernate.ISession"/>, or null.
            </summary>
            <param name="s">The Session to get the object from.</param>
            <returns>The Persistent Object this proxy is Proxying, or <see langword="null"/>.</returns>
        </member>
        <member name="P:NHibernate.Proxy.AbstractLazyInitializer.IsReadOnlySettingAvailable">
            <inheritdoc />
        </member>
        <member name="P:NHibernate.Proxy.AbstractLazyInitializer.ReadOnly">
            <inheritdoc />
        </member>
        <member name="T:NHibernate.Proxy.Map.MapProxy">
            <summary> Proxy for "dynamic-map" entity representations. </summary>
        </member>
        <member name="T:NHibernate.Proxy.INHibernateProxy">
            <summary>
            A marker interface so NHibernate can know if it is dealing with
            an object that is a Proxy. 
            </summary>
            <remarks>
            <para>
            This interface should not be implemented by anything other than
            the Dynamically generated Proxy.  If it is implemented by a class then
            NHibernate will think that class is a Proxy and will not work.
            </para> 
            <para>
            It has to be public scope because
            the Proxies are created in a separate DLL than NHibernate. 
            </para> 
            </remarks>
        </member>
        <member name="P:NHibernate.Proxy.INHibernateProxy.HibernateLazyInitializer">
            <summary> Get the underlying lazy initialization handler. </summary>
        </member>
        <member name="T:NHibernate.Proxy.IProxyFactory">
            <summary> Contract for run-time, proxy-based lazy initialization proxies. </summary>
        </member>
        <member name="M:NHibernate.Proxy.IProxyFactory.PostInstantiate(System.String,System.Type,System.Collections.Generic.ISet{System.Type},System.Reflection.MethodInfo,System.Reflection.MethodInfo,NHibernate.Type.IAbstractComponentType)">
            <summary> Called immediately after instantiation of this factory. </summary>
            <param name="entityName">
            The name of the entity for which this factory should generate proxies. 
            </param>
            <param name="persistentClass">
            The entity class for which to generate proxies; not always the same as the entityName.
            </param>
            <param name="interfaces">
            The interfaces to expose in the generated proxy;
            <see cref="T:NHibernate.Proxy.INHibernateProxy"/> is already included in this collection.
            </param>
            <param name="getIdentifierMethod">
            Reference to the identifier getter method; invocation on this method should not force initialization
            </param>
            <param name="setIdentifierMethod">
            Reference to the identifier setter method; invocation on this method should not force initialization
            </param>
            <param name="componentIdType">
            For composite identifier types, a reference to
            the <see cref="T:NHibernate.Type.ComponentType">type</see> of the identifier
            property; again accessing the id should generally not cause
            initialization - but need to bear in mind key-many-to-one
            mappings.
            </param>
             <exception cref="T:NHibernate.HibernateException"> Indicates a problem completing post </exception>
            <remarks>
            Essentially equivalent to constructor injection, but contracted
            here via interface.
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.IProxyFactory.GetProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new proxy
            </summary>
            <param name="id">The id value for the proxy to be generated.</param>
            <param name="session">The session to which the generated proxy will be associated.</param>
            <returns>The generated proxy.</returns>
            <exception cref="T:NHibernate.HibernateException">Indicates problems generating requested proxy.</exception>
        </member>
        <member name="T:NHibernate.Proxy.Poco.BasicLazyInitializer">
            <summary> Lazy initializer for POCOs</summary>
        </member>
        <member name="M:NHibernate.Proxy.Poco.BasicLazyInitializer.AddSerializationInfo(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Adds all of the information into the SerializationInfo that is needed to
            reconstruct the proxy during deserialization or to replace the proxy
            with the instantiated target.
            </summary>
            <remarks>
            This will only be called if the Dynamic Proxy generator does not handle serialization
            itself or delegates calls to the method GetObjectData to the LazyInitializer.
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.Poco.BasicLazyInitializer.Invoke(System.Reflection.MethodInfo,System.Object[],System.Object)">
            <summary>
            Invokes the method if this is something that the LazyInitializer can handle
            without the underlying proxied object being instantiated.
            </summary>
            <param name="method">The name of the method/property to Invoke.</param>
            <param name="args">The arguments to pass the method/property.</param>
            <param name="proxy">The proxy object that the method is being invoked on.</param>
            <returns>
            The result of the Invoke if the underlying proxied object is not needed.  If the 
            underlying proxied object is needed then it returns the result <see cref="F:NHibernate.Proxy.AbstractLazyInitializer.InvokeImplementation"/>
            which indicates that the Proxy will need to forward to the real implementation.
            </returns>
        </member>
        <member name="T:NHibernate.Proxy.AbstractProxyFactory">
            <summary>
            Convenient common implementation for ProxyFactory
            </summary>
        </member>
        <member name="T:NHibernate.Proxy.IProxyValidator">
            <summary>
            Proxeability validator.
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.IProxyValidator.ValidateType(System.Type)">
            <summary>
            Validates whether <paramref name="type"/> can be specified as the base class
            (or an interface) for a dynamically-generated proxy.
            </summary>
            <param name="type">The type to validate.</param>
            <returns>
            A collection of errors messages, if any, or <see langword="null" /> if none were found.
            </returns>
            <remarks>
            When the configuration property "use_proxy_validator" is set to true(default), the result of this method
            is used to throw a detailed exception about the proxeability of the given <paramref name="type"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.IProxyValidator.IsProxeable(System.Reflection.MethodInfo)">
            <summary>
            Validate if a single method can be intercepted by proxy.
            </summary>
            <param name="method">The given method to check.</param>
            <returns><see langword="true"/> if the method can be intercepted by proxy.
            <see langword="false"/> otherwise.
            </returns>
            <remarks>
            This method can be used internally by the <see cref="M:NHibernate.Proxy.IProxyValidator.ValidateType(System.Type)"/> and is used
            by <see cref="T:NHibernate.Tuple.Entity.PocoEntityTuplizer"/> to log errors when
            a property accessor can't be intercepted by proxy.
            The validation of property accessors is fairly enough if you ecampsulate each property.
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.DynProxyTypeValidator.ValidateType(System.Type)">
            <summary>
            Validates whether <paramref name="type"/> can be specified as the base class
            (or an interface) for a dynamically-generated proxy.
            </summary>
            <param name="type">The type to validate.</param>
            <returns>
            A collection of errors messages, if any, or <see langword="null" /> if none were found.
            </returns>
        </member>
        <member name="T:NHibernate.Proxy.NHibernateProxyHelper">
            <summary>
            NHibernateProxyHelper provides convenience methods for working with
            objects that might be instances of Classes or the Proxied version of 
            the Class.
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GetClassWithoutInitializingProxy(System.Object)">
            <summary> 
            Get the class of an instance or the underlying class of a proxy (without initializing the proxy!). 
            It is almost always better to use the entity name!
            </summary>
            <param name="obj">The object to get the type of.</param>
            <returns>The Underlying Type for the object regardless of if it is a Proxy.</returns>
        </member>
        <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GuessClass(System.Object)">
            <summary>
            Get the true, underlying class of a proxied persistent class. This operation
            will NOT initialize the proxy and thus may return an incorrect result.
            </summary>
            <param name="entity">a persistable object or proxy</param>
            <returns>guessed class of the instance</returns>
            <remarks>
            This method is approximate match for Session.bestGuessEntityName in H3.2
            </remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.Parser.MsSqlSelectParser">
            <summary>
            Represents SQL Server SELECT query parser, primarily intended to support generation of 
            limit queries by SQL Server dialects.
            </summary>
        </member>
        <member name="P:NHibernate.SqlCommand.Parser.MsSqlSelectParser.SelectColumns">
            <summary>
            Column definitions in SELECT clause
            </summary>
        </member>
        <member name="P:NHibernate.SqlCommand.Parser.MsSqlSelectParser.NonSelectColumns">
            <summary>
            Column definitions for columns that appear in ORDER BY clause 
            but do not appear in SELECT clause.
            </summary>
        </member>
        <member name="P:NHibernate.SqlCommand.Parser.MsSqlSelectParser.Orders">
            <summary>
            Sort orders as defined in ORDER BY clause
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Parser.SqlToken">
            <summary>
            A SQL query token as returned by <see cref="T:NHibernate.SqlCommand.Parser.SqlTokenizer"/>
            </summary>
        </member>
        <member name="P:NHibernate.SqlCommand.Parser.SqlToken.SqlIndex">
            <summary>
            Position at which this token occurs in a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
        </member>
        <member name="P:NHibernate.SqlCommand.Parser.SqlToken.Length">
            <summary>
            Number of characters in this token.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Parser.SqlTokenizer">
            <summary>
            Splits a <see cref="T:NHibernate.SqlCommand.SqlString"/> into <see cref="T:NHibernate.SqlCommand.Parser.SqlToken"/>s.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Parser.SqlTokenType">
            <summary>
            <see cref="T:NHibernate.SqlCommand.Parser.SqlToken"/> token types.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.Whitespace">
            <summary>
            Whitespace
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.Comment">
            <summary>
            Single line comment (preceeded by --) or multi-line comment (terminated by /* and */)
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.Text">
            <summary>
            Keywords, operators or undelimited identifiers. 
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.DelimitedText">
            <summary>
            Delimited identifiers or string literals.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.Parameter">
            <summary>
            A query parameter.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.Comma">
            <summary>
            List separator, the ',' character.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.BracketOpen">
            <summary>
            Begin of an expression block, consisting of a '(' character.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.BracketClose">
            <summary>
            End of an expression block, consisting of a ')' character.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.AllBrackets">
            <summary>
            Tokens for begin or end of expression blocks.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.AllExceptWhitespaceOrComment">
            <summary>
            Includes all token types except whitespace or comments
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.AllExceptWhitespace">
            <summary>
            Includes all token types except whitespace
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parser.SqlTokenType.All">
            <summary>
            Includes all token types
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Alias">
            <summary>
            Aliases tables and fields for Sql Statements.
            </summary>
            <remarks>
            Several methods of this class take an additional
            <see cref="T:NHibernate.Dialect.Dialect"/> parameter, while their Java counterparts
            do not. The dialect is used to correctly quote and unquote identifiers.
            Java versions do the quoting and unquoting themselves and fail to
            consider dialect-specific rules, such as escaping closing brackets in
            identifiers on MS SQL 2000.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <param name="suffix"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="suffix"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToAliasString(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifier"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasString(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifier"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifiers"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifiers"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.SqlCommand.ANSICaseFragment">
            <summary>An ANSI SQL CASE expression.
            <code>case when ... then ... end as ...</code>
            </summary>
            <remarks>This class looks StringHelper.SqlParameter safe...</remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.CaseFragment">
            <summary> Abstract SQL case fragment renderer </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ANSIJoinFragment">
            <summary>
            An ANSI-style Join.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.JoinFragment">
            <summary>
            Represents a SQL <c>JOIN</c>
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ConditionalFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetOp(System.String)">
            <summary>
            Sets the op
            </summary>
            <param name="op">The op to set</param>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetTableAlias(System.String)">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.DecodeCaseFragment">
            <summary>An Oracle-style DECODE function. </summary>
            <example>
            <code>decode(pkvalue, key1, 1, key2, 2, ..., 0)</code>
            </example>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ForUpdateFragment">
            <summary>
            Represents an SQL <c>for update of ... nowait</c> statement
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.InformixJoinFragment">
            <summary>
            An Informix-style (theta) Join
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.InFragment">
            <summary>
            Represents an <c>... in (...)</c> expression
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.AddValue(System.Object)">
            <summary>
            Add a value to the value list. Value may be a string,
            a <see cref="T:NHibernate.SqlCommand.Parameter"/>, or one of special values
            <see cref="F:NHibernate.SqlCommand.InFragment.Null"/> or <see cref="F:NHibernate.SqlCommand.InFragment.NotNull"/>.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.JoinType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.OracleJoinFragment">
            <summary>
            An Oracle-style (theta) Join
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddLeftOuterJoinCondition(NHibernate.SqlCommand.SqlString)">
            <summary>
            This method is a bit of a hack, and assumes
            that the column on the "right" side of the
            join appears on the "left" side of the
            operator, which is extremely weird if this
            was a normal join condition, but is natural
            for a filter.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Parameter">
            <summary>
            A placeholder for an ADO.NET parameter in an <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Parameter.parameterPosition">
            <summary>
            We need to know what the position of the parameter was in a query
            before we rearranged the query.
            This is the ADO parameter position that this SqlString parameter is
            bound to.  The SqlString can be safely rearranged once this is set.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.WithIndex(System.Int32)">
            <summary>
            Create a parameter with the specified position
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.GenerateParameters(System.Int32)">
            <summary>
            Generates an array of parameters.
            </summary>
            <param name="count">The number of parameters to generate.</param>
            <returns>An array of <see cref="T:NHibernate.SqlCommand.Parameter"/> objects</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object 
            are of the same type and have the same values.
            </summary>
            <param name="obj">An object to compare to this instance.</param>
            <returns>
            <see langword="true" /> if the object equals the current instance.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.GetHashCode">
            <summary>
            Gets a hash code for the parameter.
            </summary>
            <returns>
            An <see cref="T:System.Int32"/> value for the hash code.
            </returns>
        </member>
        <member name="P:NHibernate.SqlCommand.Parameter.ParameterPosition">
            <summary>
            Used to determine the parameter's name (p0,p1 etc.)
            </summary>
        </member>
        <member name="P:NHibernate.SqlCommand.Parameter.BackTrack">
            <summary>
            Unique identifier of a parameter to be tracked back by its generator.
            </summary>
            <remarks>
            We have various query-systems. Each one, at the end, give us a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            At the same time we have various bad-guys playing the game (hql function implementations, the dialect...).
            A bad guy can rearrange a <see cref="T:NHibernate.SqlCommand.SqlString"/> and the query-system can easly lost organization/sequence of parameters.
            Using the <see cref="P:NHibernate.SqlCommand.Parameter.BackTrack"/> the query-system can easily find where are its parameters.
            </remarks>
        </member>
        <member name="P:NHibernate.SqlCommand.Parameter.Placeholder">
            <summary>
            Used as a placeholder when parsing HQL or SQL queries.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.QueryJoinFragment">
            <summary>
            Summary description for QueryJoinFragment.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.QuerySelect">
            <summary>
            Summary description for QuerySelect.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.QuerySelect.dontSpace">
            <summary>
            Certain databases don't like spaces around these operators.
            </summary>
            <remarks>
            This needs to contain both a plain string and a 
            SqlString version of the operator because the portions in 
            the WHERE clause will come in as SqlStrings since there
            might be parameters, other portions of the clause come in
            as strings since there are no parameters.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectFragmentString(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectColumn(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="columnName"></param>
            <param name="alias"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetWhereTokens(System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetGroupByTokens(System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetOrderByTokens(System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetHavingTokens(System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddOrderBy(System.String)">
            <summary>
            Adds a string containing a valid "order by" sql statement
            to this QuerySelect
            </summary>
            <param name="orderBySql">The "order by" sql statement.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AppendTokens(NHibernate.SqlCommand.SqlStringBuilder,System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="builder"></param>
            <param name="iter"></param>
        </member>
        <member name="P:NHibernate.SqlCommand.QuerySelect.JoinFragment">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.QuerySelect.Distinct">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SelectFragment">
            <summary>
            Represents part of an SQL <c>SELECT</c> clause
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.ToFragmentString">
            <summary>
            Equivalent to ToSqlStringFragment.
            </summary>
            <returns></returns>
            <remarks>
            In H3, it is called ToFragmentString(). It appears to be 
            functionally equivalent as ToSqlStringFragment() here.
            </remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlBaseBuilder">
            <summary>
            The base class for all of the SqlBuilders.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[])">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <returns>A SqlString that contains the WhereFragment</returns>
            <remarks>This just calls the overloaded ToWhereFragment() with the operator as " = " and the tableAlias null.</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[])">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <returns>A SqlString that contains the WhereFragment</returns>
            <remarks>This defaults the op to " = "</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[],System.String)">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
            <returns>A SqlString that contains the WhereFragment</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[],System.String)">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
            <returns>A SqlString that contains the WhereFragment</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ISqlCommand.ResetParametersIndexesForTheCommand(System.Int32)">
            <summary>
            re-set the index of each parameter in the final <see cref="T:System.Data.IDbCommand">command</see>.
            </summary>
            <param name="singleSqlParametersOffset">The offset from where start the list of <see cref="T:System.Data.IDataParameter"/>, in the given command, for the this <see cref="T:NHibernate.SqlCommand.SqlCommandImpl"/>. </param>
            <remarks>
            Suppose the final <see cref="T:System.Data.IDbCommand">command</see> is composed by two queries. The <paramref name="singleSqlParametersOffset"/> for the first query is zero.
            If the first query command has 12 parameters (size of its SqlType array) the offset to bind all <see cref="T:NHibernate.Param.IParameterSpecification"/>s, of the second query in the
            command, is 12 (for the first query we are using from 0 to 11).
            <para>
            This method should be called before call <see cref="M:NHibernate.Engine.IBatcher.PrepareCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.ISqlCommand.Bind(System.Data.IDbCommand,System.Collections.Generic.IList{NHibernate.SqlCommand.Parameter},System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind the appropriate value into the given command.
            </summary>
            <param name="command">The command into which the value should be bound.</param>
            <param name="commandQueryParametersList">The parameter-list of the whole query of the command.</param>
            <param name="singleSqlParametersOffset">The offset from where start the list of <see cref="T:System.Data.IDataParameter"/>, in the given <paramref name="command"/>, for the this <see cref="T:NHibernate.SqlCommand.SqlCommandImpl"/>. </param>
            <param name="session">The session against which the current execution is occuring.</param>
            <remarks>
            Suppose the <paramref name="command"/> is composed by two queries. The <paramref name="singleSqlParametersOffset"/> for the first query is zero.
            If the first query in <paramref name="command"/> has 12 parameters (size of its SqlType array) the offset to bind all <see cref="T:NHibernate.Param.IParameterSpecification"/>s, of the second query in the
            <paramref name="command"/>, is 12 (for the first query we are using from 0 to 11).
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.ISqlCommand.Bind(System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind the appropriate value into the given command.
            </summary>
            <param name="command">The command into which the value should be bound.</param>
            <param name="session">The session against which the current execution is occuring.</param>
            <remarks>
            Use this method when the <paramref name="command"/> contains just 'this' instance of <see cref="T:NHibernate.SqlCommand.ISqlCommand"/>.
            Use the overload <see cref="M:NHibernate.SqlCommand.ISqlCommand.Bind(System.Data.IDbCommand,System.Collections.Generic.IList{NHibernate.SqlCommand.Parameter},System.Int32,NHibernate.Engine.ISessionImplementor)"/> when the <paramref name="command"/> contains more instances of <see cref="T:NHibernate.SqlCommand.ISqlCommand"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlCommandImpl.Bind(System.Data.IDbCommand,System.Collections.Generic.IList{NHibernate.SqlCommand.Parameter},System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind the appropriate value into the given command.
            </summary>
            <param name="command">The command into which the value should be bound.</param>
            <param name="commandQueryParametersList">The parameter-list of the whole query of the command.</param>
            <param name="singleSqlParametersOffset">The offset from where start the list of <see cref="T:System.Data.IDataParameter"/>, in the given <paramref name="command"/>, for the this <see cref="T:NHibernate.SqlCommand.SqlCommandImpl"/>. </param>
            <param name="session">The session against which the current execution is occuring.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlCommandImpl.Bind(System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind the appropriate value into the given command.
            </summary>
            <param name="command">The command into which the value should be bound.</param>
            <param name="session">The session against which the current execution is occuring.</param>
            <remarks>
            Use this method when the <paramref name="command"/> contains just 'this' instance of <see cref="T:NHibernate.SqlCommand.ISqlCommand"/>.
            Use the overload <see cref="M:NHibernate.SqlCommand.SqlCommandImpl.Bind(System.Data.IDbCommand,System.Collections.Generic.IList{NHibernate.SqlCommand.Parameter},System.Int32,NHibernate.Engine.ISessionImplementor)"/> when the <paramref name="command"/> contains more instances of <see cref="T:NHibernate.SqlCommand.ISqlCommand"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlDeleteBuilder">
            <summary>
            A class that builds an <c>DELETE</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>DELETE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlDeleteBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>DELETE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlDeleteBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlDeleteBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String)">
            <summary>
            Adds a string to the WhereFragement
            </summary>
            <param name="whereSql">A well formed sql statement with no parameters.</param>
            <returns>The SqlDeleteBuilder</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlSelectBuilder">
            <summary>
            Builds a <c>SELECT</c> SQL statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String)">
            <summary>
            Sets the text that should appear after the FROM 
            </summary>
            <param name="fromClause">The fromClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String,System.String)">
            <summary>
            Sets the text that should appear after the FROM 
            </summary>
            <param name="tableName">The name of the Table to get the data from</param>
            <param name="alias">The Alias to use for the table name.</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the text that should appear after the FROM
            </summary>
            <param name="fromClause">The fromClause in a SqlString</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOrderByClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the text that should appear after the ORDER BY.
            </summary>
            <param name="orderByClause">The orderByClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetGroupByClause(System.String)">
            <summary>
            Sets the text that should appear after the GROUP BY.
            </summary>
            <param name="groupByClause">The groupByClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOuterJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the SqlString for the OUTER JOINs.  
            </summary>
            <remarks>
            All of the Sql needs to be included in the SELECT.  No OUTER JOINS will automatically be
            added.
            </remarks>
            <param name="outerJoinsAfterFrom">The outerJoinsAfterFrom to set</param>
            <param name="outerJoinsAfterWhere">The outerJoinsAfterWhere to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetSelectClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the text for the SELECT
            </summary>
            <param name="selectClause">The selectClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetSelectClause(System.String)">
            <summary>
            Sets the text for the SELECT
            </summary>
            <param name="selectClause">The selectClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(System.String,System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the criteria to use for the WHERE.  It joins all of the columnNames together with an AND.
            </summary>
            <param name="tableAlias"></param>
            <param name="columnNames">The names of the columns</param>
            <param name="whereType">The Hibernate Type</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the prebuilt SqlString to the Where clause
            </summary>
            <param name="whereSqlString">The SqlString that contains the sql and parameters to add to the WHERE</param>
            <returns>This SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetHavingClause(System.String,System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the criteria to use for the WHERE.  It joins all of the columnNames together with an AND.
            </summary>
            <param name="tableAlias"></param>
            <param name="columnNames">The names of the columns</param>
            <param name="whereType">The Hibernate Type</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetHavingClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the prebuilt SqlString to the Having clause
            </summary>
            <param name="havingSqlString">The SqlString that contains the sql and parameters to add to the HAVING</param>
            <returns>This SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.ToStatementString">
            <summary>
            ToSqlString() is named ToStatementString() in H3
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlSimpleSelectBuilder">
            <summary>
            Summary description for SqlSimpleSelectBuilder.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String)">
            <summary>
            Adds a columnName to the SELECT fragment.
            </summary>
            <param name="columnName">The name of the column to add.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String,System.String)">
            <summary>
            Adds a columnName and its Alias to the SELECT fragment.
            </summary>
            <param name="columnName">The name of the column to add.</param>
            <param name="alias">The alias to use for the column</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[])">
            <summary>
            Adds an array of columnNames to the SELECT fragment.
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[],System.String[])">
            <summary>
            Adds an array of columnNames with their Aliases to the SELECT fragment.
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="aliases">The aliases to use for the columns</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.GetAlias(System.String)">
            <summary>
            Gets the Alias that should be used for the column
            </summary>
            <param name="columnName">The name of the column to get the Alias for.</param>
            <returns>The Alias if one exists, null otherwise</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>SELECT</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlSimpleSelectBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>SELECT</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlSimpleSelectBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetOrderBy(System.String)">
            <summary>
            Set the Order By fragment of the Select Command
            </summary>
            <param name="orderBy">The OrderBy fragment.  It should include the SQL "ORDER BY"</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlString">
            <summary>
            This is a non-modifiable SQL statement that is ready to be prepared 
            and sent to the Database for execution.
            </summary>
            <remarks>
            <para>A <see cref="T:NHibernate.SqlCommand.SqlString"/> represents a (potentially partial) SQL query string 
            that may or may not contain query parameter references. A <see cref="T:NHibernate.SqlCommand.SqlString"/>
            decomposes the underlying SQL query string into a list of parts. Each part is either
            1) a string part, which represents a fragment of the underlying SQL query string that 
            does not contain any parameter references, or 2) a parameter part, which represents
            a single query parameter reference in the underlying SQL query string.
            </para>
            <para>The <see cref="T:NHibernate.SqlCommand.SqlString"/> constructors ensure that the number of string parts 
            in a <see cref="T:NHibernate.SqlCommand.SqlString"/> are kept to an absolute minimum (as compact as possible) 
            by concatenating any adjoining string parts into a single string part.
            </para>
            <para>
            Substring operations on a <see cref="T:NHibernate.SqlCommand.SqlString"/> (such as <see cref="M:NHibernate.SqlCommand.SqlString.Substring(System.Int32,System.Int32)"/>, 
            <see cref="M:NHibernate.SqlCommand.SqlString.Split(System.String)"/>, <see cref="M:NHibernate.SqlCommand.SqlString.Trim"/>) return a <see cref="T:NHibernate.SqlCommand.SqlString"/> that reuses the parts 
            list of the <see cref="T:NHibernate.SqlCommand.SqlString"/> instance on which the operation was performed. 
            Besides a reference to this parts list, the resulting <see cref="T:NHibernate.SqlCommand.SqlString"/> instance 
            also stores the character offset into the original underlying SQL string at which the 
            substring starts and the length of the substring. By avoiding the unnecessary rebuilding 
            of part lists these operations have O(1) behaviour rather than O(n) behaviour.
            </para>
            <para>
            If you need to modify this object pass it to a <see cref="T:NHibernate.SqlCommand.SqlStringBuilder"/> and
            get a new object back from it.
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.SqlCommand.SqlString.Empty">
            <summary>
            Empty <see cref="T:NHibernate.SqlCommand.SqlString"/> instance.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SqlString._parts">
            <summary>
            Immutable list of string and parameter parts that make up this <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            This list may be shared by multiple <see cref="T:NHibernate.SqlCommand.SqlString"/> instances that present 
            different fragments of a common underlying SQL query string.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SqlString._parameters">
            <summary>
            List of SQL query parameter references that occur in this <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SqlString._firstPartIndex">
            <summary>
            Cached index of first part in <see cref="F:NHibernate.SqlCommand.SqlString._parts"/> that contains (part of)
            a SQL fragment that falls within the scope of this <see cref="T:NHibernate.SqlCommand.SqlString"/> instance.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SqlString._lastPartIndex">
            <summary>
            Cached index of last part in <see cref="F:NHibernate.SqlCommand.SqlString._parts"/> that contains (part of)
            a SQL fragment that falls within the scope of this <see cref="T:NHibernate.SqlCommand.SqlString"/> instance.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SqlString._sqlStartIndex">
            <summary>
            Index of first character of the underlying SQL query string that is within scope of
            this <see cref="T:NHibernate.SqlCommand.SqlString"/> instance.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SqlString._length">
            <summary>
            Number of characters of the underlying SQL query string that are within scope of
            this <see cref="T:NHibernate.SqlCommand.SqlString"/> instance from <see cref="F:NHibernate.SqlCommand.SqlString._sqlStartIndex"/> onwards.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.#ctor(NHibernate.SqlCommand.SqlString)">
            <summary>
            Creates copy of other <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.#ctor(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
            <summary>
            Creates substring of other <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <param name="other"></param>
            <param name="sqlStartIndex"></param>
            <param name="length"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.#ctor(System.String)">
            <summary>
            Creates <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of single string part.
            </summary>
            <param name="sql">A SQL fragment</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.#ctor(NHibernate.SqlCommand.Parameter)">
            <summary>
            Creates <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of single parameter part.
            </summary>
            <param name="parameter">A query parameter</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.#ctor(System.Object[])">
            <summary>
            Creates <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of multiple parts.
            </summary>
            <param name="parts">Arbitrary number of parts, which must be 
            either <see cref="T:System.String"/>, <see cref="T:NHibernate.SqlCommand.Parameter"/> or <see cref="T:NHibernate.SqlCommand.SqlString"/>
            values.</param>
            <remarks>The <see cref="T:NHibernate.SqlCommand.SqlString"/> instance is automatically compacted.</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Parse(System.String)">
            <summary>
            Parse SQL in <paramref name="sql" /> and create a SqlString representing it.
            </summary>
            <remarks>
            Parameter marks in single quotes will be correctly skipped, but otherwise the
            lexer is very simple and will not parse double quotes or escape sequences
            correctly, for example.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Append(NHibernate.SqlCommand.SqlString)">
            <summary>
            Appends the SqlString parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
            <param name="sql">The SqlString to append.</param>
            <returns>A new SqlString object.</returns>
            <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Append(System.String)">
            <summary>
            Appends the string parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
            <param name="text">The string to append.</param>
            <returns>A new SqlString object.</returns>
            <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Compact">
            <summary>
            Compacts the SqlString into the fewest parts possible.
            </summary>
            <returns>A new SqlString.</returns>
            <remarks>
            Combines all SqlParts that are strings and next to each other into
            one SqlPart.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Copy">
            <summary>
            Makes a copy of the SqlString, with new parameter references (Placeholders)
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.EndsWith(System.String)">
            <summary>
            Determines whether the end of this instance matches the specified String.
            </summary>
            <param name="value">A string to seek at the end.</param>
            <returns><see langword="true" /> if the end of this instance matches value; otherwise, <see langword="false" /></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.IndexOfCaseInsensitive(System.String)">
            <summary>
            Returns the index of the first occurrence of <paramref name="text"/>, case-insensitive.
            </summary>
            <param name="text">Text to look for in the <see cref="T:NHibernate.SqlCommand.SqlString"/>. Must be in lower
            case.</param>
            <remarks>
            The text must be located entirely in a string part of the <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            Searching for <c>"a ? b"</c> in an <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of
            <c>"a ", Parameter, " b"</c> will result in no matches.
            </remarks>
            <returns>The index of the first occurrence of <paramref name="text"/>, or -1
            if not found.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Returns the index of the first occurrence of <paramref name="text"/>, case-insensitive.
            </summary>
            <param name="text">Text to look for in the <see cref="T:NHibernate.SqlCommand.SqlString"/>. Must be in lower</param>
            <param name="startIndex">The zero-based index of the search starting position.</param>
            <param name="length">The number of character positions to examine.</param>
            <param name="stringComparison">One of the enumeration values that specifies the rules for the search.</param>
            <remarks>
            The text must be located entirely in a string part of the <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            Searching for <c>"a ? b"</c> in an <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of
            <c>"a ", Parameter, " b"</c> will result in no matches.
            </remarks>
            <returns>The index of the first occurrence of <paramref name="text"/>, or -1
            if not found.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.LastIndexOfCaseInsensitive(System.String)">
            <summary>
            Returns the index of the first occurrence of <paramref name="text"/>, case-insensitive.
            </summary>
            <param name="text">Text to look for in the <see cref="T:NHibernate.SqlCommand.SqlString"/>. Must be in lower
            case.</param>
            <remarks>
            The text must be located entirely in a string part of the <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            Searching for <c>"a ? b"</c> in an <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of
            <c>"a ", Parameter, " b"</c> will result in no matches.
            </remarks>
            <returns>The index of the first occurrence of <paramref name="text"/>, or -1
            if not found.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Returns the index of the first occurrence of <paramref name="text"/>, case-insensitive.
            </summary>
            <param name="text">Text to look for in the <see cref="T:NHibernate.SqlCommand.SqlString"/>. Must be in lower case.</param>
            <param name="startIndex">The zero-based index of the search starting position.</param>
            <param name="length">The number of character positions to examine.</param>
            <param name="stringComparison">One of the enumeration values that specifies the rules for the search.</param>
            <remarks>
            The text must be located entirely in a string part of the <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            Searching for <c>"a ? b"</c> in an <see cref="T:NHibernate.SqlCommand.SqlString"/> consisting of
            <c>"a ", Parameter, " b"</c> will result in no matches.
            </remarks>
            <returns>The index of the first occurrence of <paramref name="text"/>, or -1
            if not found.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Replace(System.String,System.String)">
            <summary>
            Replaces all occurrences of a specified <see cref="T:System.String"/> in this instance, 
            with another specified <see cref="T:System.String"/> .
            </summary>
            <param name="oldValue">A String to be replaced.</param>
            <param name="newValue">A String to replace all occurrences of oldValue. </param>
            <returns>
            A new SqlString with oldValue replaced by the newValue.  The new SqlString is 
            in the compacted form.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.StartsWithCaseInsensitive(System.String)">
            <summary>
            Determines whether the beginning of this SqlString matches the specified System.String,
            using case-insensitive comparison.
            </summary>
            <param name="value">The System.String to seek</param>
            <returns>true if the SqlString starts with the value.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Substring(System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position. 
            </summary>
            <param name="startIndex">The starting character position of a substring in this instance.</param>
            <returns>
            A new SqlString to the substring that begins at startIndex in this instance. 
            </returns>
            <remarks>
            If the startIndex is greater than the length of the SqlString then <see cref="F:NHibernate.SqlCommand.SqlString.Empty"/> is returned.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.SubstringStartingWithLast(System.String)">
            <summary>
            Returns substring of this SqlString starting with the specified
            <paramref name="text" />. If the text is not found, returns an
            empty, not-null SqlString.
            </summary>
            <remarks>
            The method performs case-insensitive comparison, so the <paramref name="text" />
            passed should be in lower case.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Trim">
            <summary>
            Removes all occurrences of white space characters from the beginning and end of this instance.
            </summary>
            <returns>
            A new SqlString equivalent to this instance after white space characters 
            are removed from the beginning and end.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.GetPartIndexForSqlIndex(System.Int32)">
            <summary>
            Locate the part that contains the requested character index, and return the
            part's index. Return -1 if the character position isn't found.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.AppendAndResetPendingContent(System.Text.StringBuilder,System.Int32@)">
            <summary>
            It the pendingContent is non-empty, append it as a new part and reset the pendingContent
            to empty. The new part will be given the sqlIndex. After return, the sqlIndex will have
            been updated to the next available index.
            </summary>
            <param name="pendingContent"></param>
            <param name="sqlIndex"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.ToString">
            <summary>
            Returns the SqlString in a string where it looks like
            SELECT col1, col2 FROM table WHERE col1 = ?
            </summary>
            <remarks>
            The question mark is used as the indicator of a parameter because at
            this point we are not using the specific provider so we don't know
            how that provider wants our parameters formatted.
            </remarks>
            <returns>A provider-neutral version of the CommandText</returns>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlString.Count">
            <summary>
            Gets the number of SqlParts contained in this SqlString.
            </summary>
            <value>The number of SqlParts contained in this SqlString.</value>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlStringBuilder">
            <summary>
            The SqlStringBuilder is used to construct a SqlString.
            </summary>
            <remarks>
            <para>
            The SqlString is a nonmutable class so it can't have sql parts added
            to it.  Instead this class should be used to generate a new SqlString.
            The SqlStringBuilder is to SqlString what the StringBuilder is to
            a String.
            </para>
            <para>
            This is different from the original version of SqlString because this does not
            hold the sql string in the form of "column1=@column1" instead it uses an array to
            build the sql statement such that 
            object[0] = "column1="
            object[1] = ref to column1 parameter
            </para>
            <para>
            What this allows us to do is to delay the generating of the parameter for the sql
            until the very end - making testing dialect indifferent.  Right now all of our test
            to make sure the correct sql is getting built are specific to MsSql2000Dialect.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor">
            <summary>
            Create an empty StringBuilder with the default capacity.  
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(System.Int32)">
            <summary>
            Create a StringBuilder with a specific capacity.
            </summary>
            <param name="partsCapacity">The number of parts expected.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(NHibernate.SqlCommand.SqlString)">
            <summary>
            Create a StringBuilder to modify the SqlString
            </summary>
            <param name="sqlString">The SqlString to modify.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(System.String)">
            <summary>
            Adds the preformatted sql to the SqlString that is being built.
            </summary>
            <param name="sql">The string to add.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.Parameter)">
            <summary>
            Adds the Parameter to the SqlString that is being built.
            The correct operator should be added before the Add(Parameter) is called
            because there will be no operator ( such as "=" ) placed between the last Add call
            and this Add call.
            </summary>
            <param name="parameter">The Parameter to add.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.AddObject(System.Object)">
            <summary>
            Attempts to discover what type of object this is and calls the appropriate
            method.
            </summary>
            <param name="part">The part to add when it is not known if it is a Parameter, String, or SqlString.</param>
            <returns>This SqlStringBuilder.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the part is not a Parameter, String, or SqlString.</exception>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString)">
            <summary>
            Adds an existing SqlString to this SqlStringBuilder.  It does NOT add any
            prefix, postfix, operator, or wrap around this.  It is equivalent to just 
            adding a string.
            </summary>
            <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>This calls the overloaded Add(sqlString, null, null, null, false)</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString,System.String,System.String,System.String)">
            <summary>
            Adds an existing SqlString to this SqlStringBuilder
            </summary>
            <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
            <param name="prefix">String to put at the beginning of the combined SqlString.</param>
            <param name="op">How these Statements should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlString.</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>
            This calls the overloaded Add method with an array of SqlStrings and wrapStatment=false
            so it will not be wrapped with a "(" and ")"
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String)">
            <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
            <param name="sqlStrings">The SqlStrings to combine.</param>
            <param name="prefix">String to put at the beginning of the combined SqlString.</param>
            <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlStrings.</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>This calls the overloaded Add method with wrapStatement=true</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String,System.Boolean)">
            <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
            <param name="sqlStrings">The SqlStrings to combine.</param>
            <param name="prefix">String to put at the beginning of the combined SqlStrings.</param>
            <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlStrings.</param>
            <param name="wrapStatement">Wrap each SqlStrings with "(" and ")"</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,System.String)">
            <summary>
            Insert a string containing sql into the SqlStringBuilder at the specified index.
            </summary>
            <param name="index">The zero-based index at which the sql should be inserted.</param>
            <param name="sql">The string containing sql to insert.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,NHibernate.SqlCommand.Parameter)">
            <summary>
            Insert a Parameter into the SqlStringBuilder at the specified index.
            </summary>
            <param name="index">The zero-based index at which the Parameter should be inserted.</param>
            <param name="param">The Parameter to insert.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.RemoveAt(System.Int32)">
            <summary>
            Removes the string or Parameter at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.ToSqlString">
            <summary>
            Converts the mutable SqlStringBuilder into the immutable SqlString.
            </summary>
            <returns>The SqlString that was built.</returns>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Count">
            <summary>
            Gets the number of SqlParts in this SqlStringBuilder.
            </summary>
            <returns>
            The number of SqlParts in this SqlStringBuilder.
            </returns>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Item(System.Int32)">
            <summary>
            Gets or Sets the element at the index
            </summary>
            <value>Returns a string or Parameter.</value>
            <remarks></remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlStringHelper">
            <summary>
            Helper methods for SqlString.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlUpdateBuilder">
            <summary>
            A class that builds an <c>UPDATE</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
            <summary>
            Add a column with a specific value to the UPDATE sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">The value to set for the column.</param>
            <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.String)">
            <summary>
            Add a column with a specific value to the UPDATE sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],System.String)">
            <summary>
            Adds columns with a specific value to the UPDATE sql
            </summary>
            <param name="columnsName">The names of the Columns to add.</param>
            <param name="val">A valid sql string to set as the value of the column.  This value is assigned to each column.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],NHibernate.Type.IType)">
            <summary>
            Adds the Property's columns to the UPDATE sql
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="propertyType">The IType of the property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],System.Boolean[],NHibernate.Type.IType)">
            <summary>
            Adds the Property's updatable columns to the UPDATE sql
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="updateable">An array of updatable column flags.  If this array is <c>null</c>, all supplied columns are considered updatable.</param>
            <param name="propertyType">The IType of the property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>UPDATE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>UPDATE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlUpdateBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String)">
            <summary>
            Adds a string to the WhereFragment
            </summary>
            <param name="whereSql">A well formed sql string with no parameters.</param>
            <returns>The SqlUpdateBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SubselectClauseExtractor">
            <summary>
            Given an SQL SELECT statement, parse it to extract clauses starting with
            <c>FROM</c>, up to and not including <c>ORDER BY</c> (known collectively
            as a subselect clause).
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.SubselectClauseExtractor.builder">
            <summary>
            Contains the subselect clause as it is being built.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.#ctor(NHibernate.SqlCommand.SqlString)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlCommand.SubselectClauseExtractor"/> class.
            </summary>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to extract the subselect clause from.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.ProcessPartBeforeFrom(System.Object)">
            <summary>
            Looks for a <c>FROM</c> clause in the <paramref name="part"/>
            and adds the clause to the result if found.
            </summary>
            <param name="part">A <see cref="T:System.String"/> or a <see cref="T:NHibernate.SqlCommand.Parameter"/>.</param>
            <returns><see langword="true"/> if the part contained a <c>FROM</c> clause,
            <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.GetSqlString">
            <summary>
            Returns the subselect clause of the statement
            being processed.
            </summary>
            <returns>An <see cref="T:NHibernate.SqlCommand.SqlString"/> containing
            the subselect clause of the original <c>SELECT</c>
            statement.</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.WhereBuilder">
            <summary>
            Allows us to construct SQL WHERE fragments
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.SqlType">
            <summary>
            This is the base class that adds information to the <see cref="P:NHibernate.SqlTypes.SqlType.DbType"/> 
            for the <see cref="T:NHibernate.Driver.IDriver"/> and <see cref="T:NHibernate.Dialect.Dialect"/>
            to use.
            </summary>
            <remarks>
            <p>
            The <see cref="T:NHibernate.Driver.IDriver"/> uses the SqlType to get enough
            information to create an <see cref="T:System.Data.IDbDataParameter"/>.  
            </p>
            <p>
            The <see cref="T:NHibernate.Dialect.Dialect"/> use the SqlType to convert the <see cref="P:NHibernate.SqlTypes.SqlType.DbType"/>
            to the appropriate sql type for SchemaExport.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.AnsiStringSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiString"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.BinaryBlobSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary"/> that is stored in
            a BLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </p>
            <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            BinarySqlType would work just fine.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.BinarySqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType"/> class.
            </summary>
            <param name="length">The length of the binary data the <see cref="T:System.Data.IDbDataParameter"/> should hold</param>
        </member>
        <member name="T:NHibernate.SqlTypes.SqlTypeFactory">
            <summary>
            SqlTypeFactory provides Singleton access to the SqlTypes.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.StringClobSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String"/> that is stored in
            a CLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </p>
            <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            StringSqlType would work just fine.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.StringSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.StringFixedLengthSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.StringFixedLength"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.Stat.CategorizedStatistics">
            <summary> 
            Statistics for a particular "category" (a named entity,
            collection role, second level cache region or query). 
            </summary>
        </member>
        <member name="T:NHibernate.Stat.CollectionStatistics">
            <summary> Collection related statistics </summary>
        </member>
        <member name="T:NHibernate.Stat.EntityStatistics">
            <summary> Entity related statistics </summary>
        </member>
        <member name="T:NHibernate.Stat.ISessionStatistics">
            <summary> 
            Information about the first-level (session) cache for a particular session instance
            </summary>
        </member>
        <member name="P:NHibernate.Stat.ISessionStatistics.EntityCount">
            <summary> Get the number of entity instances associated with the session</summary>
        </member>
        <member name="P:NHibernate.Stat.ISessionStatistics.CollectionCount">
            <summary> Get the number of collection instances associated with the session</summary>
        </member>
        <member name="P:NHibernate.Stat.ISessionStatistics.EntityKeys">
            <summary> Get the set of all <see cref="T:NHibernate.Engine.EntityKey">EntityKeys</see>.</summary>
        </member>
        <member name="P:NHibernate.Stat.ISessionStatistics.CollectionKeys">
            <summary> Get the set of all <see cref="T:NHibernate.Engine.CollectionKey">CollectionKeys</see>.</summary>
        </member>
        <member name="T:NHibernate.Stat.IStatistics">
            <summary> 
            Statistics for a particular <see cref="T:NHibernate.ISessionFactory"/>.
            Beware of metrics, they are dependent of the <see cref="T:System.Diagnostics.Stopwatch"/> precision:
            </summary>
        </member>
        <member name="M:NHibernate.Stat.IStatistics.Clear">
            <summary> Reset all statistics</summary>
        </member>
        <member name="M:NHibernate.Stat.IStatistics.GetEntityStatistics(System.String)">
            <summary> Find entity statistics per name </summary>
            <param name="entityName">entity name </param>
            <returns> EntityStatistics object </returns>
        </member>
        <member name="M:NHibernate.Stat.IStatistics.GetCollectionStatistics(System.String)">
            <summary> Get collection statistics per role </summary>
            <param name="role">collection role </param>
            <returns> CollectionStatistics </returns>
        </member>
        <member name="M:NHibernate.Stat.IStatistics.GetSecondLevelCacheStatistics(System.String)">
            <summary> Second level cache statistics per region </summary>
            <param name="regionName">region name </param>
            <returns> SecondLevelCacheStatistics </returns>
        </member>
        <member name="M:NHibernate.Stat.IStatistics.GetQueryStatistics(System.String)">
            <summary> Query statistics from query string (HQL or SQL) </summary>
            <param name="queryString">query string </param>
            <returns> QueryStatistics </returns>
        </member>
        <member name="M:NHibernate.Stat.IStatistics.LogSummary">
            <summary> log in info level the main statistics</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.EntityDeleteCount">
            <summary> Global number of entity deletes</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.EntityInsertCount">
            <summary> Global number of entity inserts</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.EntityLoadCount">
            <summary> Global number of entity loads</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.EntityFetchCount">
            <summary> Global number of entity fetchs</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.EntityUpdateCount">
            <summary> Global number of entity updates</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.QueryExecutionCount">
            <summary> Global number of executed queries</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.QueryExecutionMaxTime">
            <summary> The <see cref="T:System.TimeSpan"/> of the slowest query.</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.QueryExecutionMaxTimeQueryString">
            <summary> The query string for the slowest query.</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.QueryCacheHitCount">
            <summary> The global number of cached queries successfully retrieved from cache</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.QueryCacheMissCount">
            <summary> The global number of cached queries *not* found in cache</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.QueryCachePutCount">
            <summary> The global number of cacheable queries put in cache</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.FlushCount">
            <summary> Get the global number of flush executed by sessions (either implicit or explicit)</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.ConnectCount">
            <summary> 
            Get the global number of connections asked by the sessions
            (the actual number of connections used may be much smaller depending
            whether you use a connection pool or not)
            </summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.SecondLevelCacheHitCount">
            <summary> Global number of cacheable entities/collections successfully retrieved from the cache</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.SecondLevelCacheMissCount">
            <summary> Global number of cacheable entities/collections not found in the cache and loaded from the database.</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.SecondLevelCachePutCount">
            <summary> Global number of cacheable entities/collections put in the cache</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.SessionCloseCount">
            <summary> Global number of sessions closed</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.SessionOpenCount">
            <summary> Global number of sessions opened</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.CollectionLoadCount">
            <summary> Global number of collections loaded</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.CollectionFetchCount">
            <summary> Global number of collections fetched</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.CollectionUpdateCount">
            <summary> Global number of collections updated</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.CollectionRemoveCount">
            <summary> Global number of collections removed</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.CollectionRecreateCount">
            <summary> Global number of collections recreated</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.StartTime">
            <summary> Start time </summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.IsStatisticsEnabled">
            <summary> Enable/Disable statistics logs (this is a dynamic parameter)</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.Queries">
            <summary> All executed query strings</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.EntityNames">
            <summary> The names of all entities</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.CollectionRoleNames">
            <summary> The names of all collection roles</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.SecondLevelCacheRegionNames">
            <summary> Get all second-level cache region names</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.SuccessfulTransactionCount">
            <summary> The number of transactions we know to have been successful</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.TransactionCount">
            <summary> The number of transactions we know to have completed</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.PrepareStatementCount">
            <summary> The number of prepared statements that were acquired</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.CloseStatementCount">
            <summary> The number of prepared statements that were released</summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.OptimisticFailureCount">
            <summary> The number of <tt>StaleObjectStateException</tt>s  that occurred </summary>
        </member>
        <member name="P:NHibernate.Stat.IStatistics.OperationThreshold">
            <summary> 
            The OperationThreshold to a value greater than <see cref="F:System.TimeSpan.MinValue"/> to enable logging of long running operations.
            </summary>
            <remarks>Operations that exceed the level will be logged.</remarks>
        </member>
        <member name="T:NHibernate.Stat.IStatisticsImplementor">
            <summary> Statistics SPI for the NHibernate core </summary>
        </member>
        <member name="T:NHibernate.Stat.QueryStatistics">
            <summary> Query statistics (HQL and SQL) </summary>
            <remarks>Note that for a cached query, the cache miss is equals to the db count</remarks>
        </member>
        <member name="M:NHibernate.Stat.QueryStatistics.Executed(System.Int64,System.TimeSpan)">
            <summary> Add statistics report of a DB query </summary>
            <param name="rows">rows count returned </param>
            <param name="time">time taken </param>
        </member>
        <member name="T:NHibernate.Stat.SecondLevelCacheStatistics">
            <summary> Second level cache statistics of a specific region </summary>
        </member>
        <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.ElementCountInMemory">
            <summary>
            Not ported yet
            </summary>
        </member>
        <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.ElementCountOnDisk">
            <summary>
            Not ported yet
            </summary>
        </member>
        <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.SizeInMemory">
            <summary>
            Not ported yet
            </summary>
        </member>
        <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.Entries">
            <summary>
            Not ported yet
            </summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.IConnectionHelper">
            <summary>
            Contract for delegates responsible for managing connection used by the hbm2ddl tools.
            </summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.IConnectionHelper.Prepare">
            <summary>
             Prepare the helper for use.
            </summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.IConnectionHelper.Release">
            <summary>
            Release any resources held by this helper.
            </summary>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.IConnectionHelper.Connection">
            <summary>
            Get a reference to the connection we are using.
            </summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.ManagedProviderConnectionHelper">
            <summary>
            A <seealso cref="T:NHibernate.Tool.hbm2ddl.IConnectionHelper"/> implementation based on an internally 
            built and managed <seealso cref="T:NHibernate.Connection.ConnectionProvider"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.SchemaExport">
            <summary>
            Generates ddl to export table schema for a configured <c>Configuration</c> to the database
            </summary>
            <remarks>
            This Class can be used directly or the command line wrapper NHibernate.Tool.hbm2ddl.exe can be
            used when a dll can not be directly used.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration)">
            <summary>
            Create a schema exported for a given Configuration
            </summary>
            <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Create a schema exporter for the given Configuration, with the given
            database connection properties
            </summary>
            <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
            <param name="configProperties">The Properties to use when connecting to the Database.</param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetOutputFile(System.String)">
            <summary>
            Set the output filename. The generated script will be written to this file
            </summary>
            <param name="filename">The name of the file to output the ddl to.</param>
            <returns>The SchemaExport object.</returns>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetDelimiter(System.String)">
            <summary>
            Set the end of statement delimiter 
            </summary>
            <param name="delimiter">The end of statement delimiter.</param>
            <returns>The SchemaExport object.</returns>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Create(System.Boolean,System.Boolean)">
            <summary>
            Run the schema creation script
            </summary>
            <param name="useStdOut"><see langword="true"/> if the ddl should be outputted in the Console.</param>
            <param name="execute"><see langword="true"/> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop parameter to false.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Create(System.Action{System.String},System.Boolean)">
            <summary>
            Run the schema creation script
            </summary>
            <param name="scriptAction"> an action that will be called for each line of the generated ddl.</param>
            <param name="execute"><see langword="true"/> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop parameter to false.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Create(System.IO.TextWriter,System.Boolean)">
            <summary>
            Run the schema creation script
            </summary>
            <param name="exportOutput"> if non-null, the ddl will be written to this TextWriter.</param>
            <param name="execute"><see langword="true"/> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop parameter to false.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Drop(System.Boolean,System.Boolean)">
            <summary>
            Run the drop schema script
            </summary>
            <param name="useStdOut"><see langword="true"/> if the ddl should be outputted in the Console.</param>
            <param name="execute"><see langword="true"/> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop parameter to true.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Drop(System.IO.TextWriter,System.Boolean)">
            <summary>
            Run the drop schema script
            </summary>
            <param name="exportOutput"> if non-null, the ddl will be written to this TextWriter.</param>
            <param name="execute"><see langword="true"/> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Action{System.String},System.Boolean,System.Boolean,System.IO.TextWriter)"/> and sets
            the justDrop parameter to true.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Data.IDbConnection,System.IO.TextWriter)">
            <summary>
            Executes the Export of the Schema in the given connection
            </summary>
            <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
            <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
            <param name="justDrop"><see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
            <param name="connection">
            The connection to use when executing the commands when export is <see langword="true" />.
            Must be an opened connection. The method doesn't close the connection.
            </param>
            <param name="exportOutput">The writer used to output the generated schema</param>
            <remarks>
            This method allows for both the drop and create ddl script to be executed.
            This overload is provided mainly to enable use of in memory databases. 
            It does NOT close the given connection!
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Executes the Export of the Schema.
            </summary>
            <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
            <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
            <param name="justDrop"><see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
            <remarks>
            This method allows for both the drop and create ddl script to be executed.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaUpdate.Execute(System.Boolean,System.Boolean)">
            <summary>
            Execute the schema updates
            </summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaUpdate.Execute(System.Action{System.String},System.Boolean)">
            <summary>
            Execute the schema updates
            </summary>
            <param name="scriptAction">The action to write the each schema line.</param>
            <param name="doUpdate">Commit the script to DB</param>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.SchemaUpdate.Exceptions">
            <summary>
             Returns a List of all Exceptions which occured during the export.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaValidator.Validate">
            Perform the validations.
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.ScriptReader.ReadNextSection">
            <summary>
            This acts as a template method. Specific Reader instances 
            override the component methods.
            </summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.SuppliedConnectionHelper">
            <summary>
            A <seealso cref="T:NHibernate.Tool.hbm2ddl.IConnectionHelper"/> implementation based on an explicitly supplied
            connection.
            </summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.SuppliedConnectionProviderConnectionHelper">
            <summary>
            A <seealso cref="T:NHibernate.Tool.hbm2ddl.IConnectionHelper"/> implementation based on a provided
            <seealso cref="T:NHibernate.Connection.IConnectionProvider"/>.  Essentially, ensures that the connection
            gets cleaned up, but that the provider itself remains usable since it
            was externally provided to us.
            </summary>
        </member>
        <member name="T:NHibernate.Transaction.ITransactionFactory">
            <summary>
            An abstract factory for <see cref="T:NHibernate.ITransaction"/> instances.
            Concrete implementations are specified by <c>transaction.factory_class</c> 
            configuration property.
            
            Implementors must be threadsafe and should declare a public default constructor. 
            <seealso cref="T:NHibernate.Transaction.ITransactionContext"/>
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.ITransactionFactory.Configure(System.Collections.IDictionary)">
            <summary>
            Configure from the given properties
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:NHibernate.Transaction.ITransactionFactory.CreateTransaction(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new transaction and return it without starting it.
            </summary>
        </member>
        <member name="T:NHibernate.Transaction.ITransactionContext">
            <summary>
            This is used as a marker interface for the different 
            transaction context required for each session
            </summary>
        </member>
        <member name="T:NHibernate.Transaction.AdoTransaction">
            <summary>
            Wraps an ADO.NET <see cref="T:System.Data.IDbTransaction"/> to implement
            the <see cref="T:NHibernate.ITransaction"/> interface.
            </summary>
        </member>
        <member name="T:NHibernate.ITransaction">
            <summary>
            Allows the application to define units of work, while maintaining abstraction from the
            underlying transaction implementation
            </summary>
            <remarks>
            A transaction is associated with a <c>ISession</c> and is usually instanciated by a call to
            <c>ISession.BeginTransaction()</c>. A single session might span multiple transactions since 
            the notion of a session (a conversation between the application and the datastore) is of
            coarser granularity than the notion of a transaction. However, it is intended that there be
            at most one uncommitted <c>ITransaction</c> associated with a particular <c>ISession</c>
            at a time. Implementors are not intended to be threadsafe.
            </remarks>
        </member>
        <member name="M:NHibernate.ITransaction.Begin">
            <summary>
            Begin the transaction with the default isolation level.
            </summary>
        </member>
        <member name="M:NHibernate.ITransaction.Begin(System.Data.IsolationLevel)">
            <summary>
            Begin the transaction with the specified isolation level.
            </summary>
            <param name="isolationLevel">Isolation level of the transaction</param>
        </member>
        <member name="M:NHibernate.ITransaction.Commit">
            <summary>
            Flush the associated <c>ISession</c> and end the unit of work.
            </summary>
            <remarks>
            This method will commit the underlying transaction if and only if the transaction
            was initiated by this object.
            </remarks>
        </member>
        <member name="M:NHibernate.ITransaction.Rollback">
            <summary>
            Force the underlying transaction to roll back.
            </summary>
        </member>
        <member name="M:NHibernate.ITransaction.Enlist(System.Data.IDbCommand)">
            <summary>
            Enlist the <see cref="T:System.Data.IDbCommand"/> in the current Transaction.
            </summary>
            <param name="command">The <see cref="T:System.Data.IDbCommand"/> to enlist.</param>
            <remarks>
            It is okay for this to be a no op implementation.
            </remarks>
        </member>
        <member name="M:NHibernate.ITransaction.RegisterSynchronization(NHibernate.Transaction.ISynchronization)">
            <summary>
            Register a user synchronization callback for this transaction.
            </summary>
            <param name="synchronization">The <see cref="T:NHibernate.Transaction.ISynchronization"/> callback to register.</param>
        </member>
        <member name="P:NHibernate.ITransaction.IsActive">
            <summary>
            Is the transaction in progress
            </summary>
        </member>
        <member name="P:NHibernate.ITransaction.WasRolledBack">
            <summary>
            Was the transaction rolled back or set to rollback only?
            </summary>
        </member>
        <member name="P:NHibernate.ITransaction.WasCommitted">
            <summary>
            Was the transaction successfully committed?
            </summary>
            <remarks>
            This method could return <see langword="false" /> even after successful invocation of <c>Commit()</c>
            </remarks>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Transaction.AdoTransaction"/> class.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the Transaction is for.</param>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Enlist(System.Data.IDbCommand)">
            <summary>
            Enlist the <see cref="T:System.Data.IDbCommand"/> in the current <see cref="T:NHibernate.ITransaction"/>.
            </summary>
            <param name="command">The <see cref="T:System.Data.IDbCommand"/> to enlist in this Transaction.</param>
            <remarks>
            <para>
            This takes care of making sure the <see cref="T:System.Data.IDbCommand"/>'s Transaction property 
            contains the correct <see cref="T:System.Data.IDbTransaction"/> or <see langword="null"/> if there is no
            Transaction for the ISession - ie <c>BeginTransaction()</c> not called.
            </para>
            <para>
            This method may be called even when the transaction is disposed.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Begin(System.Data.IsolationLevel)">
            <summary>
            Begins the <see cref="T:System.Data.IDbTransaction"/> on the <see cref="T:System.Data.IDbConnection"/>
            used by the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any problems encountered while trying to create
            the <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Commit">
            <summary>
            Commits the <see cref="T:NHibernate.ITransaction"/> by flushing the <see cref="T:NHibernate.ISession"/>
            and committing the <see cref="T:System.Data.IDbTransaction"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Commit()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Rollback">
            <summary>
            Rolls back the <see cref="T:NHibernate.ITransaction"/> by calling the method <c>Rollback</c> 
            on the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Rollback()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="F:NHibernate.Transaction.AdoTransaction._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this AdoTransaction is being Disposed of or Finalized.</param>
            <remarks>
            If this AdoTransaction is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this AdoTransaction back to life.
            </remarks>
        </member>
        <member name="P:NHibernate.Transaction.AdoTransaction.WasRolledBack">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the transaction was rolled back.
            </summary>
            <value>
            <see langword="true"/> if the <see cref="T:System.Data.IDbTransaction"/> had <c>Rollback</c> called
            without any exceptions.
            </value>
        </member>
        <member name="P:NHibernate.Transaction.AdoTransaction.WasCommitted">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the transaction was committed.
            </summary>
            <value>
            <see langword="true"/> if the <see cref="T:System.Data.IDbTransaction"/> had <c>Commit</c> called
            without any exceptions.
            </value>
        </member>
        <member name="T:NHibernate.Transaction.ISynchronization">
            <summary>
            A mimic to the javax.transaction.Synchronization callback to enable <see cref="M:NHibernate.ITransaction.RegisterSynchronization(NHibernate.Transaction.ISynchronization)"/> 
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AfterTransactionCompletes.#ctor(System.Action{System.Boolean})">
            <summary>
            Create an AfterTransactionCompletes that will execute the given delegate
            when the transaction is completed. The action delegate will receive
            the value 'true' if the transaction was completed successfully.
            </summary>
            <param name="whenCompleted"></param>
        </member>
        <member name="T:NHibernate.Transform.AliasedTupleSubsetResultTransformer">
            <summary>
            An implementation of TupleSubsetResultTransformer that ignores a
            tuple element if its corresponding alias is null.
            </summary>
            @author Gail Badner
        </member>
        <member name="T:NHibernate.Transform.ITupleSubsetResultTransformer">
            <summary>
            A ResultTransformer that operates on "well-defined" and consistent
            subset of a tuple's elements.
            </summary>
            <remarks> "Well-defined" means that:
            <ol>
               <li>
                   the indexes of tuple elements accessed by an
                   ITupleSubsetResultTransformer depends only on the aliases
                   and the number of elements in the tuple; i.e, it does
                   not depend on the value of the tuple being transformed;
               </li>
               <li>
                   any tuple elements included in the transformed value are
                   unmodified by the transformation;
               </li>
               <li>
                   transforming equivalent tuples with the same aliases multiple
                   times results in transformed values that are equivalent;
               </li>
               <li>
                   the result of transforming the tuple subset (only those
                   elements accessed by the transformer) using only the
                   corresponding aliases is equivalent to transforming the
                   full tuple with the full array of aliases;
               </li>
               <li>
                   the result of transforming a tuple with non-accessed tuple
                   elements and corresponding aliases set to null
                   is equivalent to transforming the full tuple with the
                   full array of aliases;
               </li>
            </ol>
            </remarks>
            
            @author Gail Badner
        </member>
        <member name="M:NHibernate.Transform.ITupleSubsetResultTransformer.IsTransformedValueATupleElement(System.String[],System.Int32)">
            <summary>
            When a tuple is transformed, is the result a single element of the tuple?
            </summary>
            <param name="aliases">The aliases that correspond to the tuple.</param>
            <param name="tupleLength">The number of elements in the tuple.</param>
            <returns>True, if the transformed value is a single element of the tuple;
                   false, otherwise.</returns>
        </member>
        <member name="M:NHibernate.Transform.ITupleSubsetResultTransformer.IncludeInTransform(System.String[],System.Int32)">
            <summary>
            Returns an array with the i-th element indicating whether the i-th
            element of the tuple is included in the transformed value.
            </summary>
            <param name="aliases">The aliases that correspond to the tuple.</param>
            <param name="tupleLength">The number of elements in the tuple.</param>
            <returns>Array with the i-th element indicating whether the i-th
                   element of the tuple is included in the transformed value.</returns>
        </member>
        <member name="T:NHibernate.Transform.AliasToBeanResultTransformer">
            <summary>
            Result transformer that allows to transform a result to 
            a user specified class which will be populated via setter  
            methods or fields matching the alias names. 
            </summary>
            <example>
            <code>
            IList resultWithAliasedBean = s.CreateCriteria(typeof(Enrollment))
            			.CreateAlias("Student", "st")
            			.CreateAlias("Course", "co")
            			.SetProjection( Projections.ProjectionList()
            					.Add( Projections.Property("co.Description"), "CourseDescription" )
            			)
            			.SetResultTransformer( new AliasToBeanResultTransformer(typeof(StudentDTO)) )
            			.List();
            
            StudentDTO dto = (StudentDTO)resultWithAliasedBean[0];
            </code>
            </example>
        </member>
        <member name="T:NHibernate.Transform.CacheableResultTransformer">
            <summary>
            A ResultTransformer that is used to transform tuples to a value(s) that can be cached.
            </summary>
            @author Gail Badner
        </member>
        <member name="F:NHibernate.Transform.CacheableResultTransformer._includeInTuple">
            <summary>
            Array with the i-th element indicating whether the i-th
            expression returned by a query is included in the tuple.
            </summary>
            IMPLEMENTATION NOTE:
            "joined" and "fetched" associations may use the same SQL,
            but result in different tuple and cached values. This is
            because "fetched" associations are excluded from the tuple.
             includeInTuple provides a way to distinguish these 2 cases.
        </member>
        <member name="F:NHibernate.Transform.CacheableResultTransformer._includeInTransformIndex">
            <summary>
            Indexes for tuple that are included in the transformation.
            Set to null if all elements in the tuple are included.
            </summary>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.Create(NHibernate.Transform.IResultTransformer,System.String[],System.Boolean[])">
            <summary>
            Returns a CacheableResultTransformer that is used to transform
            tuples to a value(s) that can be cached.
            </summary>
            <param name="transformer">result transformer that will ultimately be used (after caching results)</param>
            <param name="aliases">the aliases that correspond to the tuple;
              if it is non-null, its length must equal the number
              of true elements in includeInTuple[]</param>
            <param name="includeInTuple">array with the i-th element indicating
              whether the i-th expression returned by a query is
              included in the tuple; the number of true values equals
              the length of the tuple that will be transformed;
              must be non-null</param>
            <returns>a CacheableResultTransformer that is used to transform
               tuples to a value(s) that can be cached.</returns>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.Create(NHibernate.Transform.ITupleSubsetResultTransformer,System.String[],System.Boolean[])">
            <summary>
            Returns a CacheableResultTransformer that is used to transform
            tuples to a value(s) that can be cached.
            </summary>
            <param name="transformer">a tuple subset result transformer;
              must be non-null;</param>
            <param name="aliases">the aliases that correspond to the tuple;
              if it is non-null, its length must equal the number
              of true elements in includeInTuple[]</param>
            <param name="includeInTuple">array with the i-th element indicating
              whether the i-th expression returned by a query is
              included in the tuple; the number of true values equals
              the length of the tuple that will be transformed;
              must be non-null</param>
            <returns>a CacheableResultTransformer that is used to transform
               tuples to a value(s) that can be cached.</returns>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.Create(System.Boolean[])">
            <summary>
            Returns a CacheableResultTransformer that is used to transform
            tuples to a value(s) that can be cached.
            </summary>
            <param name="includeInTuple">array with the i-th element indicating
              whether the i-th expression returned by a query is
              included in the tuple; the number of true values equals
              the length of the tuple that will be transformed;
              must be non-null</param>
            <returns>a CacheableResultTransformer that is used to transform
               tuples to a value(s) that can be cached.</returns>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.RetransformResults(System.Collections.IList,System.String[],NHibernate.Transform.IResultTransformer,System.Boolean[])">
            <summary>
            Re-transforms, if necessary, a List of values previously
            transformed by this (or an equivalent) CacheableResultTransformer.
            Each element of the list is re-transformed in place (i.e, List
            elements are replaced with re-transformed values) and the original
            List is returned. If re-transformation is unnecessary, the original List is returned
            unchanged.
            </summary>
            <param name="transformedResults">Results that were previously transformed.</param>
            <param name="aliases">The aliases that correspond to the untransformed tuple.</param>
            <param name="transformer">The transformer for the re-transformation.</param>
            <param name="includeInTuple"></param>
            <returns>transformedResults, with each element re-transformed (if nececessary).</returns>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.UntransformToTuples(System.Collections.IList)">
            <summary>
            Untransforms, if necessary, a List of values previously
            transformed by this (or an equivalent) CacheableResultTransformer.
            Each element of the list is untransformed in place (i.e, List
            elements are replaced with untransformed values) and the original
            List is returned.
            <para>
            If not unnecessary, the original List is returned
            unchanged.
            </para>
            </summary>
            <remarks>
            NOTE: If transformed values are a subset of the original
            tuple, then, on return, elements corresponding to
            excluded tuple elements will be null.
            </remarks>
            <param name="results">Results that were previously transformed.</param>
            <returns>results, with each element untransformed (if nececessary).</returns>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.GetCachedResultTypes(NHibernate.Type.IType[])">
            <summary>
            Returns the result types for the transformed value.
            </summary>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.Index``1(``0[])">
            <summary>
            "Compact" the given array by picking only the elements identified by
            the _includeInTransformIndex array. The picked elements are returned
            in a new array.
            </summary>
        </member>
        <member name="M:NHibernate.Transform.CacheableResultTransformer.Unindex``1(``0[])">
            <summary>
            Expand the given array by putting each of its elements at the
            position identified by the _includeInTransformIndex array. The
            elements are placed in a new array - the original array will
            not be modified.
            </summary>
        </member>
        <member name="T:NHibernate.Transform.ToListResultTransformer">
            <summary> 
            Tranforms each result row from a tuple into a <see cref="T:System.Collections.IList"/>, such that what
            you end up with is a <see cref="T:System.Collections.IList"/> of <see cref="T:System.Collections.IList"/>.
            </summary>
        </member>
        <member name="F:NHibernate.Transform.Transformers.AliasToEntityMap">
            <summary>
            Each row of results is a map (<see cref="T:System.Collections.IDictionary"/>) from alias to values/entities
            </summary>
        </member>
        <member name="F:NHibernate.Transform.Transformers.ToList">
            <summary> Each row of results is a <see cref="T:System.Collections.IList"/></summary>
        </member>
        <member name="M:NHibernate.Transform.Transformers.AliasToBean(System.Type)">
            <summary>
            Creates a resulttransformer that will inject aliased values into instances
            of <paramref name="target"/> via property methods or fields.
            </summary>
        </member>
        <member name="T:NHibernate.Tuple.Component.AbstractComponentTuplizer">
            <summary> Support for tuplizers relating to components. </summary>
        </member>
        <member name="T:NHibernate.Tuple.Component.IComponentTuplizer">
            <summary> 
            Defines further responsibilities regarding tuplization based on
            a mapped components.
            </summary>
            <remarks>
            ComponentTuplizer implementations should have the following constructor signature:
            (org.hibernate.mapping.Component)
            </remarks>
        </member>
        <member name="T:NHibernate.Tuple.ITuplizer">
            <summary> 
            A tuplizer defines the contract for things which know how to manage
            a particular representation of a piece of data, given that
            representation's <see cref="T:NHibernate.EntityMode"/> (the entity-mode
            essentially defining which representation).
            </summary>
            <remarks>
            If that given piece of data is thought of as a data structure, then a tuplizer
            is the thing which knows how to:
            <list type="bullet">
            <item><description>create such a data structure appropriately</description></item>
            <item><description>extract values from and inject values into such a data structure</description></item>
            </list>
            <para/>
            For example, a given piece of data might be represented as a POCO class.
            Here, it's representation and entity-mode is POCO.  Well a tuplizer for POCO
            entity-modes would know how to:
            <list type="bullet">
            <item><description>create the data structure by calling the POCO's constructor</description></item>
            <item><description>extract and inject values through getters/setter, or by direct field access, etc</description></item>
            </list>
            <para/>
            That same piece of data might also be represented as a DOM structure, using
            the tuplizer associated with the XML entity-mode, which would generate instances
            of <see cref="T:System.Xml.XmlElement"/> as the data structure and know how to access the
            values as either nested <see cref="T:System.Xml.XmlElement"/>s or as <see cref="T:System.Xml.XmlAttribute"/>s.
            </remarks>
            <seealso cref="T:NHibernate.Tuple.Entity.IEntityTuplizer"/>
            <seealso cref="T:NHibernate.Tuple.Component.IComponentTuplizer"/>
        </member>
        <member name="M:NHibernate.Tuple.ITuplizer.GetPropertyValues(System.Object)">
            <summary> 
            Extract the current values contained on the given entity. 
            </summary>
            <param name="entity">The entity from which to extract values. </param>
            <returns> The current property values. </returns>
            <throws>  HibernateException </throws>
        </member>
        <member name="M:NHibernate.Tuple.ITuplizer.SetPropertyValues(System.Object,System.Object[])">
            <summary> Inject the given values into the given entity. </summary>
            <param name="entity">The entity. </param>
            <param name="values">The values to be injected. </param>
        </member>
        <member name="M:NHibernate.Tuple.ITuplizer.GetPropertyValue(System.Object,System.Int32)">
            <summary> Extract the value of a particular property from the given entity. </summary>
            <param name="entity">The entity from which to extract the property value. </param>
            <param name="i">The index of the property for which to extract the value. </param>
            <returns> The current value of the given property on the given entity. </returns>
        </member>
        <member name="M:NHibernate.Tuple.ITuplizer.Instantiate">
            <summary> Generate a new, empty entity. </summary>
            <returns> The new, empty entity instance. </returns>
        </member>
        <member name="M:NHibernate.Tuple.ITuplizer.IsInstance(System.Object)">
            <summary> 
            Is the given object considered an instance of the the entity (acconting
            for entity-mode) managed by this tuplizer. 
            </summary>
            <param name="obj">The object to be checked. </param>
            <returns> True if the object is considered as an instance of this entity within the given mode. </returns>
        </member>
        <member name="P:NHibernate.Tuple.ITuplizer.MappedClass">
            <summary> 
            Return the pojo class managed by this tuplizer.
            </summary>
            <returns> The persistent class. </returns>
            <remarks>
            Need to determine how to best handle this for the Tuplizers for EntityModes
            other than POCO.
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.Component.IComponentTuplizer.GetParent(System.Object)">
            <summary> Retrieve the current value of the parent property. </summary>
            <param name="component">
            The component instance from which to extract the parent property value. 
            </param>
            <returns> The current value of the parent property. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Component.IComponentTuplizer.SetParent(System.Object,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> Set the value of the parent property. </summary>
            <param name="component">The component instance on which to set the parent. </param>
            <param name="parent">The parent to be set on the component. </param>
            <param name="factory">The current session factory. </param>
        </member>
        <member name="P:NHibernate.Tuple.Component.IComponentTuplizer.HasParentProperty">
            <summary> Does the component managed by this tuuplizer contain a parent property? </summary>
            <returns> True if the component does contain a parent property; false otherwise. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Component.AbstractComponentTuplizer.Instantiate">
            <summary> This method does not populate the component parent</summary>
        </member>
        <member name="T:NHibernate.Tuple.Component.ComponentEntityModeToTuplizerMapping">
            <summary> 
            Handles mapping <see cref="T:NHibernate.EntityMode"/>s to <see cref="T:NHibernate.Tuple.Component.IComponentTuplizer">ComponentTuplizers</see>.
            <p/>
            Most of the handling is really in the super class; here we just create
            the tuplizers and add them to the superclass
            </summary>
        </member>
        <member name="T:NHibernate.Tuple.EntityModeToTuplizerMapping">
            <summary> Centralizes handling of <see cref="T:NHibernate.EntityMode"/> to <see cref="T:NHibernate.Tuple.ITuplizer"/> mappings. </summary>
        </member>
        <member name="M:NHibernate.Tuple.EntityModeToTuplizerMapping.GuessEntityMode(System.Object)">
            <summary> Given a supposed instance of an entity/component, guess its entity mode. </summary>
            <param name="obj">The supposed instance of the entity/component.</param>
            <returns> The guessed entity mode. </returns>
        </member>
        <member name="M:NHibernate.Tuple.EntityModeToTuplizerMapping.GetTuplizerOrNull(NHibernate.EntityMode)">
            <summary> 
            Locate the contained tuplizer responsible for the given entity-mode.  If
            no such tuplizer is defined on this mapping, then return null. 
            </summary>
            <param name="entityMode">The entity-mode for which the caller wants a tuplizer. </param>
            <returns> The tuplizer, or null if not found. </returns>
        </member>
        <member name="M:NHibernate.Tuple.EntityModeToTuplizerMapping.GetTuplizer(NHibernate.EntityMode)">
            <summary> Locate the tuplizer contained within this mapping which is responsible
            for the given entity-mode.  If no such tuplizer is defined on this
            mapping, then an exception is thrown.
            
            </summary>
            <param name="entityMode">The entity-mode for which the caller wants a tuplizer.
            </param>
            <returns> The tuplizer.
            </returns>
            <throws>  HibernateException Unable to locate the requested tuplizer. </throws>
        </member>
        <member name="T:NHibernate.Tuple.Component.ComponentMetamodel">
            <summary> Centralizes metamodel information about a component. </summary>
        </member>
        <member name="T:NHibernate.Tuple.Component.DynamicMapComponentTuplizer">
            <summary> 
            A <see cref="T:NHibernate.Tuple.Component.IComponentTuplizer"/> specific to the dynamic-map entity mode. 
            </summary>
        </member>
        <member name="T:NHibernate.Tuple.Component.PocoComponentTuplizer">
            <summary> 
            A <see cref="T:NHibernate.Tuple.Component.IComponentTuplizer"/> specific to the POCO entity mode. 
            </summary>
        </member>
        <member name="T:NHibernate.Tuple.Entity.AbstractEntityTuplizer">
            <summary> Support for tuplizers relating to entities. </summary>
        </member>
        <member name="T:NHibernate.Tuple.Entity.IEntityTuplizer">
            <summary> 
            Defines further responsibilities regarding tuplization based on a mapped entity.
            </summary>
            <remarks>
            EntityTuplizer implementations should have the following constructor signature:
            (<see cref="T:NHibernate.Tuple.Entity.EntityMetamodel"/>, <see cref="T:NHibernate.Mapping.PersistentClass"/>)
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.Instantiate(System.Object)">
            <summary> Create an entity instance initialized with the given identifier. </summary>
            <param name="id">The identifier value for the entity to be instantiated. </param>
            <returns> The instantiated entity. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetIdentifier(System.Object)">
            <summary> Extract the identifier value from the given entity. </summary>
            <param name="entity">The entity from which to extract the identifier value. </param>
            <returns> The identifier value. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.SetIdentifier(System.Object,System.Object)">
            <summary> 
            Inject the identifier value into the given entity.
            </summary>
            <param name="entity">The entity to inject with the identifier value.</param>
            <param name="id">The value to be injected as the identifier. </param>
            <remarks>Has no effect if the entity does not define an identifier property</remarks>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.ResetIdentifier(System.Object,System.Object,System.Object)">
            <summary> 
            Inject the given identifier and version into the entity, in order to
            "roll back" to their original values. 
            </summary>
            <param name="entity"></param>
            <param name="currentId">The identifier value to inject into the entity. </param>
            <param name="currentVersion">The version value to inject into the entity. </param>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetVersion(System.Object)">
            <summary> Extract the value of the version property from the given entity. </summary>
            <param name="entity">The entity from which to extract the version value. </param>
            <returns> The value of the version property, or null if not versioned. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary> Inject the value of a particular property. </summary>
            <param name="entity">The entity into which to inject the value. </param>
            <param name="i">The property's index. </param>
            <param name="value">The property value to inject. </param>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary> Inject the value of a particular property. </summary>
            <param name="entity">The entity into which to inject the value. </param>
            <param name="propertyName">The name of the property. </param>
            <param name="value">The property value to inject. </param>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetPropertyValuesToInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
            <summary> Extract the values of the insertable properties of the entity (including backrefs) </summary>
            <param name="entity">The entity from which to extract. </param>
            <param name="mergeMap">a map of instances being merged to merged instances </param>
            <param name="session">The session in which the resuest is being made. </param>
            <returns> The insertable property values. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetPropertyValue(System.Object,System.String)">
            <summary> Extract the value of a particular property from the given entity. </summary>
            <param name="entity">The entity from which to extract the property value. </param>
            <param name="propertyName">The name of the property for which to extract the value. </param>
            <returns> The current value of the given property on the given entity. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.AfterInitialize(System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary> Called just after the entities properties have been initialized. </summary>
            <param name="entity">The entity being initialized. </param>
            <param name="lazyPropertiesAreUnfetched">Are defined lazy properties currently unfecthed </param>
            <param name="session">The session initializing this entity. </param>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.CreateProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Generates an appropriate proxy representation of this entity for this entity-mode.
             </summary>
            <param name="id">The id of the instance for which to generate a proxy. </param>
            <param name="session">The session to which the proxy should be bound. </param>
            <returns> The generate proxies. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.HasUninitializedLazyProperties(System.Object)">
            <summary> Does the given entity instance have any currently uninitialized lazy properties? </summary>
            <param name="entity">The entity to be check for uninitialized lazy properties. </param>
            <returns> True if uninitialized lazy properties were found; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.IsLifecycleImplementor">
            <summary> 
            Does the <see cref="P:NHibernate.Tuple.ITuplizer.MappedClass">class</see> managed by this tuplizer implement
            the <see cref="T:NHibernate.Classic.ILifecycle"/> interface. 
            </summary>
            <returns> True if the ILifecycle interface is implemented; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.IsValidatableImplementor">
            <summary> 
            Does the <see cref="P:NHibernate.Tuple.ITuplizer.MappedClass">class</see> managed by this tuplizer implement
            the <see cref="T:NHibernate.Classic.IValidatable"/> interface. 
            </summary>
            <returns> True if the IValidatable interface is implemented; false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.ConcreteProxyClass">
            <summary> Returns the java class to which generated proxies will be typed. </summary>
            <returns> The .NET class to which generated proxies will be typed </returns>
        </member>
        <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.IsInstrumented">
            <summary> Is it an instrumented POCO?</summary>
        </member>
        <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.HasProxy">
            <summary> Does this entity, for this mode, present a possibility for proxying? </summary>
            <value> True if this tuplizer can generate proxies for this entity. </value>
        </member>
        <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.#ctor(NHibernate.Tuple.Entity.EntityMetamodel,NHibernate.Mapping.PersistentClass)">
            <summary> Constructs a new AbstractEntityTuplizer instance. </summary>
            <param name="entityMetamodel">The "interpreted" information relating to the mapped entity. </param>
            <param name="mappingInfo">The parsed "raw" mapping data relating to the given entity. </param>
        </member>
        <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildPropertyGetter(NHibernate.Mapping.Property,NHibernate.Mapping.PersistentClass)">
            <summary> Build an appropriate Getter for the given property. </summary>
            <param name="mappedProperty">The property to be accessed via the built Getter. </param>
            <param name="mappedEntity">The entity information regarding the mapped entity owning this property. </param>
            <returns> An appropriate Getter instance. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildPropertySetter(NHibernate.Mapping.Property,NHibernate.Mapping.PersistentClass)">
            <summary> Build an appropriate Setter for the given property. </summary>
            <param name="mappedProperty">The property to be accessed via the built Setter. </param>
            <param name="mappedEntity">The entity information regarding the mapped entity owning this property. </param>
            <returns> An appropriate Setter instance. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildInstantiator(NHibernate.Mapping.PersistentClass)">
            <summary> Build an appropriate Instantiator for the given mapped entity. </summary>
            <param name="mappingInfo">The mapping information regarding the mapped entity. </param>
            <returns> An appropriate Instantiator instance. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildProxyFactory(NHibernate.Mapping.PersistentClass,NHibernate.Properties.IGetter,NHibernate.Properties.ISetter)">
            <summary> Build an appropriate ProxyFactory for the given mapped entity. </summary>
            <param name="mappingInfo">The mapping information regarding the mapped entity. </param>
            <param name="idGetter">The constructed Getter relating to the entity's id property. </param>
            <param name="idSetter">The constructed Setter relating to the entity's id property. </param>
            <returns> An appropriate ProxyFactory instance. </returns>
        </member>
        <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.GetComponentValue(NHibernate.Type.ComponentType,System.Object,System.String)">
            <summary> Extract a component property value. </summary>
            <param name="type">The component property types. </param>
            <param name="component">The component instance itself. </param>
            <param name="propertyPath">The property path for the property to be extracted. </param>
            <returns> The property value extracted. </returns>
        </member>
        <member name="P:NHibernate.Tuple.Entity.AbstractEntityTuplizer.EntityMode">
            <summary> Return the entity-mode handled by this tuplizer instance. </summary>
        </member>
        <member name="P:NHibernate.Tuple.Entity.AbstractEntityTuplizer.EntityName">
            <summary>Retrieves the defined entity-name for the tuplized entity. </summary>
        </member>
        <member name="P:NHibernate.Tuple.Entity.AbstractEntityTuplizer.SubclassEntityNames">
            <summary> 
            Retrieves the defined entity-names for any subclasses defined for this entity. 
            </summary>
        </member>
        <member name="T:NHibernate.Tuple.Entity.EntityEntityModeToTuplizerMapping">
            <summary> 
            Handles mapping <see cref="T:NHibernate.EntityMode"/>s to <see cref="T:NHibernate.Tuple.Entity.IEntityTuplizer"/>s.
            </summary>
            <remarks>
            Most of the handling is really in the super class; here we just create
            the tuplizers and add them to the superclass
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.Entity.EntityEntityModeToTuplizerMapping.#ctor(NHibernate.Mapping.PersistentClass,NHibernate.Tuple.Entity.EntityMetamodel)">
            <summary> 
            Instantiates a EntityEntityModeToTuplizerMapping based on the given
            entity mapping and metamodel definitions. 
            </summary>
            <param name="mappedEntity">The entity mapping definition. </param>
            <param name="em">The entity metamodel definition. </param>
        </member>
        <member name="T:NHibernate.Tuple.Entity.PocoEntityTuplizer">
            <summary> An <see cref="T:NHibernate.Tuple.Entity.IEntityTuplizer"/> specific to the POCO entity mode. </summary>
        </member>
        <member name="T:NHibernate.Tuple.IInstantiator">
            <summary> Contract for implementors responsible for instantiating entity/component instances. </summary>
        </member>
        <member name="M:NHibernate.Tuple.IInstantiator.Instantiate(System.Object)">
            <summary> Perform the requested entity instantiation. </summary>
            <param name="id">The id of the entity to be instantiated. </param>
            <returns> An appropriately instantiated entity. </returns>
            <remarks>This form is never called for component instantiation, only entity instantiation.</remarks>
        </member>
        <member name="M:NHibernate.Tuple.IInstantiator.Instantiate">
            <summary> Perform the requested instantiation. </summary>
            <returns> The instantiated data structure.  </returns>
        </member>
        <member name="M:NHibernate.Tuple.IInstantiator.IsInstance(System.Object)">
            <summary> 
            Performs check to see if the given object is an instance of the entity
            or component which this Instantiator instantiates. 
            </summary>
            <param name="obj">The object to be checked. </param>
            <returns> True is the object does represent an instance of the underlying entity/component. </returns>
        </member>
        <member name="T:NHibernate.Tuple.IdentifierProperty">
            <summary>
            Represents a defined entity identifier property within the Hibernate
            runtime-metamodel.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="T:NHibernate.Tuple.Property">
            <summary>
            Defines the basic contract of a Property within the runtime metamodel.
            </summary>
        </member>
        <member name="M:NHibernate.Tuple.Property.#ctor(System.String,System.String,NHibernate.Type.IType)">
            <summary>
            Constructor for Property instances.
            </summary>
            <param name="name">The name by which the property can be referenced within its owner.</param>
            <param name="node">The node name to use for XML-based representation of this property.</param>
            <param name="type">The Hibernate Type of this property.</param>
        </member>
        <member name="M:NHibernate.Tuple.IdentifierProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,NHibernate.Engine.IdentifierValue,NHibernate.Id.IIdentifierGenerator)">
            <summary>
            Construct a non-virtual identifier property. 
            </summary>
            <param name="name">The name of the property representing the identifier within
            its owning entity.</param>
            <param name="node">The node name to use for XML-based representation of this
            property.</param>
            <param name="type">The Hibernate Type for the identifier property.</param>
            <param name="embedded">Is this an embedded identifier.</param>
            <param name="unsavedValue">The value which, if found as the value on the identifier
            property, represents new (i.e., un-saved) instances of the owning entity.</param>
            <param name="identifierGenerator">The generator to use for id value generation.</param>
        </member>
        <member name="M:NHibernate.Tuple.IdentifierProperty.#ctor(NHibernate.Type.IType,System.Boolean,System.Boolean,NHibernate.Engine.IdentifierValue,NHibernate.Id.IIdentifierGenerator)">
            <summary>
            Construct a virtual IdentifierProperty. 
            </summary>
            <param name="type">The Hibernate Type for the identifier property.</param>
            <param name="embedded">Is this an embedded identifier.</param>
            <param name="unsavedValue">The value which, if found as the value on the identifier
            property, represents new (i.e., un-saved) instances of the owning entity.</param>
            <param name="identifierGenerator">The generator to use for id value generation.</param>
            <param name="hasIdentifierMapper"></param>
        </member>
        <member name="T:NHibernate.Tuple.PocoInstantiator">
            <summary> Defines a POCO-based instantiator for use from the tuplizers.</summary>
        </member>
        <member name="T:NHibernate.Tuple.PropertyFactory">
            <summary>
            Responsible for generation of runtime metamodel <see cref="T:NHibernate.Tuple.Property"/> representations.
            Makes distinction between identifier, version, and other (standard) properties.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.PropertyFactory.BuildIdentifierProperty(NHibernate.Mapping.PersistentClass,NHibernate.Id.IIdentifierGenerator)">
            <summary>
            Generates an IdentifierProperty representation of the for a given entity mapping.
            </summary>
            <param name="mappedEntity">The mapping definition of the entity.</param>
            <param name="generator">The identifier value generator to use for this identifier.</param>
            <returns>The appropriate IdentifierProperty definition.</returns>
        </member>
        <member name="M:NHibernate.Tuple.PropertyFactory.BuildVersionProperty(NHibernate.Mapping.Property,System.Boolean)">
            <summary>
            Generates a VersionProperty representation for an entity mapping given its
            version mapping Property.
            </summary>
            <param name="property">The version mapping Property.</param>
            <param name="lazyAvailable">Is property lazy loading currently available.</param>
            <returns>The appropriate VersionProperty definition.</returns>
        </member>
        <member name="M:NHibernate.Tuple.PropertyFactory.BuildStandardProperty(NHibernate.Mapping.Property,System.Boolean)">
            <summary>
            Generate a "standard" (i.e., non-identifier and non-version) based on the given
            mapped property.
            </summary>
            <param name="property">The mapped property.</param>
            <param name="lazyAvailable">Is property lazy loading currently available.</param>
            <returns>The appropriate StandardProperty definition.</returns>
        </member>
        <member name="T:NHibernate.Tuple.StandardProperty">
            <summary>
            Represents a basic property within the Hibernate runtime-metamodel.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.StandardProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,NHibernate.Engine.CascadeStyle,System.Nullable{NHibernate.FetchMode})">
            <summary>
            Constructs StandardProperty instances.
            </summary>
            <param name="name">The name by which the property can be referenced within
            its owner.</param>
            <param name="node">The node name to use for XML-based representation of this
            property.</param>
            <param name="type">The Hibernate Type of this property.</param>
            <param name="lazy">Should this property be handled lazily?</param>
            <param name="insertable">Is this property an insertable value?</param>
            <param name="updateable">Is this property an updateable value?</param>
            <param name="insertGenerated">Is this property generated in the database on insert?</param>
            <param name="updateGenerated">Is this property generated in the database on update?</param>
            <param name="nullable">Is this property a nullable value?</param>
            <param name="checkable">Is this property a checkable value?</param>
            <param name="versionable">Is this property a versionable value?</param>
            <param name="cascadeStyle">The cascade style for this property's value.</param>
            <param name="fetchMode">Any fetch mode defined for this property </param>
        </member>
        <member name="T:NHibernate.Tuple.VersionProperty">
            <summary>
            Represents a version property within the Hibernate runtime-metamodel.
            </summary>
            <remarks>
            Author: Steve Ebersole
            </remarks>
        </member>
        <member name="M:NHibernate.Tuple.VersionProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,NHibernate.Engine.CascadeStyle,NHibernate.Engine.VersionValue)">
            <summary>
            Constructs VersionProperty instances.
            </summary>
            <param name="name">The name by which the property can be referenced within
            its owner.</param>
            <param name="node">The node name to use for XML-based representation of this
            property.</param>
            <param name="type">The Hibernate Type of this property.</param>
            <param name="lazy">Should this property be handled lazily?</param>
            <param name="insertable">Is this property an insertable value?</param>
            <param name="updateable">Is this property an updateable value?</param>
            <param name="insertGenerated">Is this property generated in the database on insert?</param>
            <param name="updateGenerated">Is this property generated in the database on update?</param>
            <param name="nullable">Is this property a nullable value?</param>
            <param name="checkable">Is this property a checkable value?</param>
            <param name="versionable">Is this property a versionable value?</param>
            <param name="cascadeStyle">The cascade style for this property's value.</param>
            <param name="unsavedValue">The value which, if found as the value of
            this (i.e., the version) property, represents new (i.e., un-saved)
            instances of the owning entity.</param>
        </member>
        <member name="T:NHibernate.Type.AbstractBinaryType">
            <summary> Logic to bind stream of byte into a VARBINARY </summary>
        </member>
        <member name="T:NHibernate.Type.MutableType">
            <summary>
            Superclass for mutable nullable types.
            </summary>
        </member>
        <member name="T:NHibernate.Type.NullableType">
            <summary>
            Superclass of single-column nullable types.
            </summary>
            <remarks>
            Maps the Property to a single column that is capable of storing nulls in it. If a .net Struct is
            used it will be created with its unitialized value and then on Update the uninitialized value of
            the Struct will be written to the column - not <see langword="null" />. 
            </remarks>
        </member>
        <member name="T:NHibernate.Type.AbstractType">
            <summary>
            The base implementation of the <see cref="T:NHibernate.Type.IType"/> interface.
            Mapping of the built in Type hierarchy.
            </summary>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Disassembles the object into a cacheable representation.
            </summary>
            <param name="value">The value to disassemble.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <param name="owner">optional parent entity object (needed for collections) </param>
            <returns>The disassembled, deep cloned state of the object</returns>
            <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Reconstructs the object from its cached "disassembled" state.
            </summary>
            <param name="cached">The disassembled state from the cache</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <param name="owner">The parent Entity object is not used by this method</param>
            <returns>The assembled object.</returns>
            <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Should the parent be considered dirty, given both the old and current 
            field or element value?
            </summary>
            <param name="old">The old value</param>
            <param name="current">The current value</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <returns>true if the field is dirty</returns>
            <remarks>This method uses <c>IType.Equals(object, object)</c> to determine the value of IsDirty.</remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Retrives an instance of the mapped class, or the identifier of an entity 
            or collection from a <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values.</param>
            <param name="names">
            The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
            value to populate the IType with.
            </param>
            <param name="session">the session</param>
            <param name="owner">The parent Entity</param>
            <returns>An identifier or actual object mapped by this IType.</returns>
            <remarks>
            This method uses the <c>IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)</c> method
            to Hydrate this <see cref="T:NHibernate.Type.AbstractType"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Maps identifiers to Entities or Collections. 
            </summary>
            <param name="value">An identifier or value returned by <c>Hydrate()</c></param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <param name="owner">The parent Entity is not used by this method.</param>
            <returns>The value.</returns>
            <remarks>
            There is nothing done in this method other than return the value parameter passed in.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.IsModified(System.Object,System.Object,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Says whether the value has been modified
            </summary>
        </member>
        <member name="M:NHibernate.Type.AbstractType.DeepCopy(System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><param name="entityMode">The entityMode.</param><param name="factory">The session factory.</param><returns>A deep copy of the object.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType"/>s.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>The number of columns this IType spans.</returns><exception cref="T:NHibernate.MappingException">MappingException</exception> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string, ISessionImplementor, object)&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param><param name="value">The object that contains the values.</param><param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param><param name="session"></param><param name="settable">Indicates which columns are to be set.</param><remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">
			The <see cref="T:System.Data.IDbCommand"/> to put the values into.
		</param><param name="value">The object that contains the values.</param><param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.
		</param><param name="session"></param><remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsAssociationType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is an <see cref="T:NHibernate.Type.IAssociationType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not an <see cref="T:NHibernate.Type.IAssociationType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsCollectionType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is a <see cref="T:NHibernate.Type.CollectionType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a <see cref="T:NHibernate.Type.CollectionType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsComponentType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsEntityType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is a <see cref="T:NHibernate.Type.EntityType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a <see cref="T:NHibernate.Type.EntityType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsAnyType">
             <summary>
            Gets a value indicating if the implementation is an "object" type
             </summary>
             <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a "object" type.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsMutable">
            <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary><value>true if the objects mapped by this IType are mutable.</value><remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.Name">
            <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary><value>The NHibernate type name.</value> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.ReturnedClass">
            <summary>
		When implemented by a class, gets the <see cref="T:System.Type"/> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary><value>
		The <see cref="T:System.Type"/> from the .NET framework.
		</value><remarks>
		This is used to establish the class of an array of this Itype
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.NullableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the NullableType class using a 
            <see cref="P:NHibernate.Type.NullableType.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/>.</param>
            <remarks>This is used when the Property is mapped to a single column.</remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            When implemented by a class, put the value from the mapped 
            Property into to the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the value into.</param>
            <param name="value">The object that contains the value.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param>
            <remarks>
            Implementors do not need to handle possibility of null values because this will
            only be called from <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/> after 
            it has checked for nulls.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="index">The index of the field to get the value from.</param>
            <returns>An object with the value from the database.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.String)">
            <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>An object with the value from the database.</returns>
            <remarks>
            Most implementors just call the <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)"/> 
            overload of this method.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="val">The object that contains the values.
            </param>
            <returns>An Xml formatted string.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)"/> if the parameter 
            value is not null.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.FromStringValue(System.String)">
            <summary>
            Parse the XML representation of an instance
            </summary>
            <param name="xml">XML string to parse, guaranteed to be non-empty</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">
			The <see cref="T:System.Data.IDbCommand"/> to put the values into.
		</param><param name="value">The object that contains the values.</param><param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.
		</param><param name="session"></param><remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index"/>.
		</remarks> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Puts the value from the mapped class into the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param>
            <param name="value">The object that contains the values.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to write the value to.</param>
            <remarks>
            <para>
            This method checks to see if value is null, if it is then the value of 
            <see cref="T:System.DBNull"/> is written to the <see cref="T:System.Data.IDbCommand"/>.
            </para>
            <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)"/> 
            is called and that method is responsible for setting the value.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementors should handle possibility of null values.
		</remarks> 
            <remarks>
            This has been sealed because no other class should override it.  This 
            method calls <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/> for a single value.  
            It only takes the first name from the string[] names parameter - that is a 
            safe thing to do because a Nullable Type only has one field.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[])">
            <summary>
            Extracts the values of the fields from the DataReader
            </summary>
            <param name="rs">The DataReader positioned on the correct record</param>
            <param name="names">An array of field names.</param>
            <returns>The value off the field from the DataReader</returns>
            <remarks>
            In this class this just ends up passing the first name to the NullSafeGet method
            that takes a string, not a string[].
            
            I don't know why this method is in here - it doesn't look like anybody that inherits
            from NullableType overrides this...
            
            TODO: determine if this is needed
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)">
            <summary>
            Gets the value of the field from the <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> positioned on the correct record.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para>
            This method checks to see if value is null, if it is then the null is returned
            from this method.
            </para>
            <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)"/> 
            is called and that method is responsible for retrieving the value.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="name">The name of the column in the <see cref="T:System.Data.IDataReader"/> that contains the 
		value to populate the IType with.</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="P:NHibernate.Type.NullableType.SqlType"/>s.</returns> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="P:NHibernate.Type.NullableType.SqlType"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method because they map to a single
            column.  All of their implementation should be in <see cref="P:NHibernate.Type.NullableType.SqlType"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            Returns the number of columns spanned by this <see cref="T:NHibernate.Type.NullableType"/>
            </summary>
            <returns>A <see cref="T:NHibernate.Type.NullableType"/> always returns 1.</returns>
            <remarks>
            This has the hard coding of 1 in there because, by definition of this class, 
            a NullableType can only map to one column in a table.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this
            <see cref="T:NHibernate.Type.NullableType"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this NullableType.</param>
            <returns>true if the SqlType and Name properties are the same.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:NHibernate.Type.NullableType"/>, 
            suitable for use in hashing algorithms and data structures like a hash table.
            </summary>
            <returns>
            A hash code that is based on the <see cref="P:NHibernate.Type.NullableType.SqlType"/>'s 
            hash code and the <see cref="P:NHibernate.Type.AbstractType.Name"/>'s hash code.</returns>
        </member>
        <member name="P:NHibernate.Type.NullableType.SqlType">
            <summary>
            Gets the underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/> for 
            the column mapped by this <see cref="T:NHibernate.Type.NullableType"/>.
            </summary>
            <value>The underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/>.</value>
            <remarks>
            This implementation should be suitable for all subclasses unless they need to
            do some special things to get the value.  There are no built in <see cref="T:NHibernate.Type.NullableType"/>s
            that override this Property.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.MutableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the MutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="P:NHibernate.Type.MutableType.IsMutable">
            <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
            <value>true - a <see cref="T:NHibernate.Type.MutableType"/> is mutable.</value>
            <remarks>
            This has been "sealed" because any subclasses are expected to be mutable.  If
            the type is immutable then they should inherit from <see cref="T:NHibernate.Type.ImmutableType"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.IVersionType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may be used to version data.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IVersionType.Next(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            When implemented by a class, increments the version.
            </summary>
            <param name="current">The current version</param>
            <param name="session">The current session, if available.</param>
            <returns>an instance of the <see cref="T:NHibernate.Type.IType"/> that has been incremented.</returns>
        </member>
        <member name="M:NHibernate.Type.IVersionType.Seed(NHibernate.Engine.ISessionImplementor)">
            <summary>
            When implemented by a class, gets an initial version.
            </summary>
            <param name="session">The current session, if available.</param>
            <returns>An instance of the type.</returns>
        </member>
        <member name="M:NHibernate.Type.IVersionType.IsEqual(System.Object,System.Object)">
            <summary> 
            Are the two version values considered equal? 
            </summary>
            <param name="x">One value to check. </param>
            <param name="y">The other value to check. </param>
            <returns> true if the values are equal, false otherwise. </returns>
        </member>
        <member name="P:NHibernate.Type.IVersionType.Comparator">
            <summary>
            Get a comparator for the version numbers
            </summary>
        </member>
        <member name="M:NHibernate.Type.AbstractBinaryType.ToExternalFormat(System.Byte[])">
            <summary> Convert the byte[] into the expected object type</summary>
        </member>
        <member name="M:NHibernate.Type.AbstractBinaryType.ToInternalFormat(System.Object)">
            <summary> Convert the object into the internal byte[] representation</summary>
        </member>
        <member name="T:NHibernate.Type.AbstractCharType">
            <summary>
            Common base class for <see cref="T:NHibernate.Type.CharType"/> and <see cref="T:NHibernate.Type.AnsiCharType"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Type.PrimitiveType">
            <summary>
            Superclass of <see cref="T:System.ValueType"/> types.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ImmutableType">
            <summary>
            Superclass of nullable immutable types.
            </summary>
        </member>
        <member name="M:NHibernate.Type.ImmutableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the ImmutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="P:NHibernate.Type.ImmutableType.IsMutable">
            <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
            <value>false - an <see cref="T:NHibernate.Type.ImmutableType"/> is not mutable.</value>
            <remarks>
            This has been "sealed" because any subclasses are expected to be immutable.  If
            the type is mutable then they should inherit from <see cref="T:NHibernate.Type.MutableType"/>.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ILiteralType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may appear as an SQL literal
            </summary>
        </member>
        <member name="M:NHibernate.Type.ILiteralType.ObjectToSQLString(System.Object,NHibernate.Dialect.Dialect)">
            <summary>
            When implemented by a class, return a <see cref="T:System.String"/> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
            <param name="value">The object to convert to a string for the SQL statement.</param>
            <param name="dialect"></param>
            <returns>A string that contains a well formed SQL Statement.</returns>
        </member>
        <member name="M:NHibernate.Type.PrimitiveType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the PrimitiveType class using a <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.PrimitiveType.ObjectToSQLString(System.Object,NHibernate.Dialect.Dialect)">
            <summary>
            When implemented by a class, return a <see cref="T:System.String"/> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
            <param name="value">The object to convert to a string for the SQL statement.</param>
            <param name="dialect"></param>
            <returns>A string that containts a well formed SQL Statement.</returns>
        </member>
        <member name="M:NHibernate.Type.PrimitiveType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="val">The object that contains the values.
            </param>
            <returns>An Xml formatted string.</returns>
            <remarks>
            This just calls <see cref="M:System.Object.ToString"/> so if there is 
            a possibility of this PrimitiveType having any characters
            that need to be encoded then this method should be overridden.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.IDiscriminatorType">
            <summary>
            An IType that may be used for a discriminator column.
            </summary>
            <remarks>
            This interface contains no new methods but does require that an
            <see cref="T:NHibernate.Type.IType"/> that will be used in a discriminator column must implement
            both the <see cref="T:NHibernate.Type.IIdentifierType"/> and <see cref="T:NHibernate.Type.ILiteralType"/> interfaces.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.IIdentifierType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may be used as an identifier.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IIdentifierType.StringToObject(System.String)">
            <summary>
            When implemented by a class, converts the xml string from the 
            mapping file to the .NET object.
            </summary>
            <param name="xml">The value of <c>discriminator-value</c> or <c>unsaved-value</c> attribute.</param>
            <returns>The string converted to the object.</returns>
            <remarks>
            This method needs to be able to handle any string.  It should not just 
            call System.Type.Parse without verifying that it is a parsable value
            for the System.Type.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.DateTimeType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to a <see cref="F:System.Data.DbType.DateTime"/> column that 
            stores date &amp; time down to the accuracy of a second.
            </summary>
            <remarks>
            This only stores down to a second, so if you are looking for the most accurate
            date and time storage your provider can give you use the <see cref="T:NHibernate.Type.TimestampType"/>. 
            or the <see cref="T:NHibernate.Type.TicksType"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.AbstractEnumType">
            <summary>
            Base class for enum types.
            </summary>
        </member>
        <member name="T:NHibernate.Type.AnsiCharType">
            <summary>
            Maps a <see cref="T:System.Char"/> Property 
            to a <c>DbType.AnsiStringFixedLength</c> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.AnsiStringType">
            <summary>
            Maps a <see cref="T:System.String"/> Property 
            to a <see cref="F:System.Data.DbType.AnsiString"/> column.
            </summary>
        </member>
        <member name="P:NHibernate.Type.AnsiStringType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.AnyType">
            <summary>
            	Handles "any" mappings and the old deprecated "object" type.
            </summary>
            <remarks>
            	The identifierType is any NHibernate IType that can be serailized by default.
            	For example, you can specify the identifierType as an Int32 or a custom identifier
            	type that you built.  The identifierType matches to one or many columns.
            	
            	The metaType maps to a single column.  By default it stores the name of the Type
            	that the Identifier identifies.  
            	
            	For example, we can store a link to any table.  It will have the results
            	class_name					id_col1
            	========================================
            	Simple, AssemblyName			5
            	DiffClass, AssemblyName			5
            	Simple, AssemblyName			4
            	
            	You can also provide you own type that might map the name of the class to a table
            	with a giant switch statemet or a good naming convention for your class->table.  The
            	data stored might look like
            	class_name					id_col1
            	========================================
            	simple_table					5
            	diff_table						5
            	simple_table					4
            	
            </remarks>
        </member>
        <member name="T:NHibernate.Type.IAbstractComponentType">
            <summary>
            Enables other Component-like types to hold collections and have cascades, etc.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the values of the component properties of 
            a component instance
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object,NHibernate.EntityMode)">
            <summary>
            Optional Operation
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.SetPropertyValues(System.Object,System.Object[],NHibernate.EntityMode)">
            <summary>
            Optional operation
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.Subtypes">
            <summary>Get the types of the component properties</summary>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.PropertyNames">
            <summary>Get the names of the component properties</summary>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.PropertyNullability">
            <summary>
            Optional operation
            </summary>
            <value>nullability of component properties</value>
        </member>
        <member name="T:NHibernate.Type.IAssociationType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that represents some kind of association between entities.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetAssociatedJoinable(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Get the "persister" for this association - a class or collection persister
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetAssociatedEntityName(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> Get the entity name of the associated entity</summary>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetOnCondition(System.String,NHibernate.Engine.ISessionFactoryImplementor,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Get the "filtering" SQL fragment that is applied in the
            SQL on clause, in addition to the usual join condition.
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.ForeignKeyDirection">
            <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
            <value>The <see cref="P:NHibernate.Type.IAssociationType.ForeignKeyDirection"/> of this association.</value>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.UseLHSPrimaryKey">
            <summary>
            Is the primary key of the owning entity table
            to be used in the join?
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.LHSPropertyName">
            <summary>
            Get the name of the property in the owning entity
            that provides the join key (null if the identifier)
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.RHSUniqueKeyPropertyName">
            <summary>
            The name of a unique property of the associated entity 
            that provides the join key (null if the identifier of
            an entity, or key of a collection)
            </summary>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.IsAlwaysDirtyChecked">
            <summary>
            Do we dirty check this association, even when there are
            no columns to be updated.
            </summary>
        </member>
        <member name="M:NHibernate.Type.AnyType.#ctor(NHibernate.Type.IType,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="metaType"></param>
            <param name="identifierType"></param>
        </member>
        <member name="M:NHibernate.Type.AnyType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.AnyType.UseLHSPrimaryKey">
            <summary>
            Not really relevant to AnyType, since it cannot be "joined"
            </summary>
        </member>
        <member name="T:NHibernate.Type.ArrayType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Array"/> collection
            to the database.
            </summary>
        </member>
        <member name="T:NHibernate.Type.CollectionType">
            <summary>
            The base class for an <see cref="T:NHibernate.Type.IType"/> that maps collections
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.CollectionType.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.CollectionType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="foreignKeyPropertyName">
            The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.
            </param>
            <param name="isEmbeddedInXML"></param>
        </member>
        <member name="M:NHibernate.Type.CollectionType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary> 
            Instantiate an uninitialized collection wrapper or holder. Callers MUST add the holder to the
            persistence context! 
            </summary>
            <param name="session">The session from which the request is originating. </param>
            <param name="persister">The underlying collection persister (metadata) </param>
            <param name="key">The owner key. </param>
            <returns> The instantiated collection. </returns>
        </member>
        <member name="M:NHibernate.Type.CollectionType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary> 
            Wrap the naked collection instance in a wrapper, or instantiate a
            holder. Callers <b>MUST</b> add the holder to the persistence context!
             </summary>
            <param name="session">The session from which the request is originating. </param>
            <param name="collection">The bare collection to be wrapped. </param>
            <returns>
            A subclass of <see cref="T:NHibernate.Collection.IPersistentCollection"/> that wraps the non NHibernate collection.
            </returns>
        </member>
        <member name="M:NHibernate.Type.CollectionType.GetKeyOfOwner(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the key value from the owning entity instance, usually the identifier, but might be some
            other unique key, in the case of property-ref
            </summary>
        </member>
        <member name="M:NHibernate.Type.CollectionType.GetIdOfOwnerOrNull(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Get the id value from the owning entity key, usually the same as the key, but might be some
            other property, in the case of property-ref 
            </summary>
            <param name="key">The collection owner key </param>
            <param name="session">The session from which the request is originating. </param>
            <returns> 
            The collection owner's id, if it can be obtained from the key;
            otherwise, null is returned
            </returns>
        </member>
        <member name="M:NHibernate.Type.CollectionType.Instantiate(System.Int32)">
            <summary> 
            Instantiate an empty instance of the "underlying" collection (not a wrapper),
            but with the given anticipated size (i.e. accounting for initial capacity
            and perhaps load factor).
            </summary>
            <param name="anticipatedSize">
            The anticipated size of the instantiated collection after we are done populating it.
            </param>
            <returns> A newly instantiated collection to be wrapped. </returns>
        </member>
        <member name="M:NHibernate.Type.CollectionType.GetElementsIterator(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Get an iterator over the element set of the collection, which may not yet be wrapped 
            </summary>
            <param name="collection">The collection to be iterated </param>
            <param name="session">The session from which the request is originating. </param>
            <returns> The iterator. </returns>
        </member>
        <member name="M:NHibernate.Type.CollectionType.GetElementsIterator(System.Object)">
            <summary> 
            Get an iterator over the element set of the collection in POCO mode 
            </summary>
            <param name="collection">The collection to be iterated </param>
            <returns> The iterator. </returns>
        </member>
        <member name="P:NHibernate.Type.CollectionType.IsAlwaysDirtyChecked">
            <summary>
            We always need to dirty check the collection because we sometimes 
            need to increment version number of owner and also because of 
            how assemble/disassemble is implemented for uks
            </summary>
        </member>
        <member name="M:NHibernate.Type.ArrayType.#ctor(System.String,System.String,System.Type,System.Boolean)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.ArrayType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="elementClass">The <see cref="T:System.Type"/> of the element contained in the array.</param>
            <param name="isEmbeddedInXML"></param>
            <remarks>
            This creates a bag that is non-generic.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ArrayType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps a <see cref="T:System.Array"/> in a <see cref="T:NHibernate.Collection.PersistentArrayHolder"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="array">The unwrapped array.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.PersistentArrayHolder"/> that wraps the non NHibernate <see cref="T:System.Array"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.ArrayType.ReturnedClass">
            <summary>
            The <see cref="T:System.Array"/> for the element.
            </summary>
        </member>
        <member name="P:NHibernate.Type.ArrayType.IsArrayType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BinaryBlobType">
            <summary>
            Maps a System.Byte[] Property to an column that can store a BLOB.
            </summary>
            <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a BinaryType
            would work just fine.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.BinaryType">
            <summary>
            BinaryType.
            </summary>
        </member>
        <member name="P:NHibernate.Type.BinaryBlobType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BooleanType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> Property 
            to a <see cref="F:System.Data.DbType.Boolean"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.BooleanType.#ctor">
            <summary>
            Initialize a new instance of the BooleanType
            </summary>
            <remarks>This is used when the Property is mapped to a native boolean type.</remarks>
        </member>
        <member name="M:NHibernate.Type.BooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
            <summary>
            Initialize a new instance of the BooleanType class using a
            <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/>.
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
            <remarks>
            This is used when the Property is mapped to a string column
            that stores true or false as a string.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ByteType">
            <summary>
            Maps a <see cref="T:System.Byte"/> property 
            to a <see cref="F:System.Data.DbType.Byte"/> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.CharBooleanType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> Property 
            to a <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CharBooleanType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CharBooleanType.FalseString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CharType">
            <summary>
            Maps a <see cref="T:System.Char"/> Property 
            to a <c>DbType.StringFixedLength</c> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ClassMetaType">
            <summary>
            ClassMetaType is a NH specific type to support "any" with meta-type="class"
            </summary>
            <remarks>
            It work like a MetaType where the key is the entity-name it self
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ComponentType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="begin"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.ComponentType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Instantiate(NHibernate.EntityMode)">
            <summary> This method does not populate the component parent</summary>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetCascadeStyle(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsCollectionType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsComponentType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsEntityType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.Subtypes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.PropertyNames">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsMutable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CultureInfoType">
            <summary>
            Maps a <see cref="T:System.Globalization.CultureInfo"/> Property 
            to a <see cref="F:System.Data.DbType.String"/> column.
            </summary>
            <remarks>
            CultureInfoType stores the culture name (not the Culture ID) of the 
            <see cref="T:System.Globalization.CultureInfo"/> in the DB.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CultureInfoType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CultureInfoType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DecimalType">
            <summary>
            Maps a <see cref="T:System.Decimal"/> Property 
            to a <see cref="F:System.Data.DbType.Decimal"/> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.CustomCollectionType">
            <summary>
            A custom type for mapping user-written classes that implement
            <see cref="T:NHibernate.Collection.IPersistentCollection"/>.
            </summary>
            <seealso cref="T:NHibernate.Collection.IPersistentCollection"/>
            <seealso cref="T:NHibernate.UserTypes.IUserCollectionType"/>
        </member>
        <member name="T:NHibernate.Type.CustomType">
            <summary>
            Adapts IUserType to the generic IType interface.
            <seealso cref="T:NHibernate.UserTypes.IUserType"/>
            </summary>
        </member>
        <member name="M:NHibernate.Type.CustomType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CustomType.UserType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.IsMutable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DateTime2Type">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to a <see cref="F:System.Data.DbType.DateTime"/>
            </summary>
        </member>
        <member name="M:NHibernate.Type.DateTime2Type.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DateTimeOffsetType">
            <summary>
            Maps a <see cref="T:System.DateTimeOffset"/> Property to a <see cref="F:System.Data.DbType.DateTimeOffset"/>
            </summary>
        </member>
        <member name="M:NHibernate.Type.DateTimeOffsetType.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DateType">
            <summary>
            Maps the Year, Month, and Day of a <see cref="T:System.DateTime"/> Property to a 
            <see cref="F:System.Data.DbType.Date"/> column
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.IParameterizedType">
            <summary>
            Support for parameterizable types. A UserType or CustomUserType may be
            made parameterizable by implementing this interface. Parameters for a
            type may be set by using a nested type element for the property element
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IParameterizedType.SetParameterValues(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Gets called by Hibernate to pass the configured type parameters to 
            the implementation.
            </summary>
        </member>
        <member name="M:NHibernate.Type.DateType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DbTimestampType">
            <summary> An extension of <see cref="T:NHibernate.Type.TimestampType"/> which
            maps to the database's current timestamp, rather than the vm's
            current timestamp.
            </summary>
            <remarks>
            Note: May/may-not cause issues on dialects which do not properly support
            a true notion of timestamp
            </remarks>
        </member>
        <member name="T:NHibernate.Type.TimestampType">
            <summary>
            This is almost the exact same type as the DateTime except it can be used
            in the version column, stores it to the accuracy the database supports, 
            and will default to the value of DateTime.Now if the value is null.
            </summary>
            <remarks>
            <p>
            The value stored in the database depends on what your data provider is capable
            of storing.  So there is a possibility that the DateTime you save will not be
            the same DateTime you get back when you check DateTime.Equals(DateTime) because
            they will have their milliseconds off.
            </p>  
            <p>
            For example - SQL Server 2000 is only accurate to 3.33 milliseconds.  So if 
            NHibernate writes a value of <c>01/01/98 23:59:59.995</c> to the Prepared Command, MsSql
            will store it as <c>1998-01-01 23:59:59.997</c>.
            </p>
            <p>
            Please review the documentation of your Database server.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TimestampType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Sets the value of this Type in the IDbCommand.
            </summary>
            <param name="st">The IDbCommand to add the Type's value to.</param>
            <param name="value">The value of the Type.</param>
            <param name="index">The index of the IDataParameter in the IDbCommand.</param>
            <remarks>
            No null values will be written to the IDbCommand for this Type. 
            </remarks>
        </member>
        <member name="T:NHibernate.Type.DoubleType">
            <summary>
            Maps a <see cref="T:System.Double"/> Property 
            to a <see cref="F:System.Data.DbType.Double"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.DoubleType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="P:NHibernate.Type.DoubleType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DoubleType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.EntityType">
            <summary>
            A reference to an entity class
            </summary>
        </member>
        <member name="M:NHibernate.Type.EntityType.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary> Constructs the requested entity type mapping. </summary>
            <param name="entityName">The name of the associated entity. </param>
            <param name="uniqueKeyPropertyName">
            The property-ref name, or null if we
            reference the PK of the associated entity.
            </param>
            <param name="eager">Is eager fetching enabled. </param>
            <param name="isEmbeddedInXML">Should values of this mapping be embedded in XML modes? </param>
            <param name="unwrapProxy">
            Is unwrapping of proxies allowed for this association; unwrapping
            says to return the "implementation target" of lazy prooxies; typically only possible
            with lazy="no-proxy".
            </param>
        </member>
        <member name="M:NHibernate.Type.EntityType.IsSame(System.Object,System.Object,NHibernate.EntityMode)">
            <summary> Two entities are considered the same when their instances are the same. </summary>
            <param name="x">One entity instance </param>
            <param name="y">Another entity instance </param>
            <param name="entityMode">The entity mode. </param>
            <returns> True if x == y; false otherwise. </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetIdentifier(System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.EntityMode)">
            <summary> 
            Get the identifier value of an instance or proxy.
            <p/>
            Intended only for loggin purposes!!!
            </summary>
            <param name="obj">The object from which to extract the identifier.</param>
            <param name="persister">The entity persister </param>
            <param name="entityMode">The entity mode </param>
            <returns> The extracted identifier. </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Converts the id contained in the <see cref="T:System.Data.IDataReader"/> to an object.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the query results.</param>
            <param name="names">A string array of column names that contain the id.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this is occurring in.</param>
            <param name="owner">The object that this Entity will be a part of.</param>
            <returns>
            An instance of the object or <see langword="null"/> if the identifer was null.
            </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetAssociatedJoinable(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> Retrieves the {@link Joinable} defining the associated entity. </summary>
            <param name="factory">The session factory. </param>
            <returns> The associated joinable </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetIdentifierOrUniqueKeyType(NHibernate.Engine.IMapping)">
            <summary> 
            Determine the type of either (1) the identifier if we reference the
            associated entity's PK or (2) the unique key to which we refer (i.e.
            the property-ref). 
            </summary>
            <param name="factory">The mappings... </param>
            <returns> The appropriate type. </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetIdentifierOrUniqueKeyPropertyName(NHibernate.Engine.IMapping)">
            <summary> 
            The name of the property on the associated entity to which our FK refers 
            </summary>
            <param name="factory">The mappings... </param>
            <returns> The appropriate property name. </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetIdentifierType(NHibernate.Engine.IMapping)">
            <summary> Convenience method to locate the identifier type of the associated entity. </summary>
            <param name="factory">The mappings... </param>
            <returns> The identifier type </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetIdentifierType(NHibernate.Engine.ISessionImplementor)">
            <summary> Convenience method to locate the identifier type of the associated entity. </summary>
            <param name="session">The originating session </param>
            <returns> The identifier type </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Resolves the identifier to the actual object.
            </summary>
        </member>
        <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Resolve an identifier or unique key value
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetAssociatedEntityName(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> The name of the associated entity. </summary>
            <param name="factory">The session factory, for resolution. </param>
            <returns> The associated entity name. </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.GetAssociatedEntityName">
            <summary> The name of the associated entity. </summary>
            <returns> The associated entity name.</returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.LoadByUniqueKey(System.String,System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary> 
            Load an instance by a unique key that is not the primary key. 
            </summary>
            <param name="entityName">The name of the entity to load </param>
            <param name="uniqueKeyPropertyName">The name of the property defining the uniqie key. </param>
            <param name="key">The unique key property value. </param>
            <param name="session">The originating session. </param>
            <returns> The loaded entity </returns>
        </member>
        <member name="P:NHibernate.Type.EntityType.IsEntityType">
            <summary> Explicitly, an entity type is an entity type </summary>
            <value> True. </value>
        </member>
        <member name="P:NHibernate.Type.EntityType.ReturnedClass">
            <summary> 
            This returns the wrong class for an entity with a proxy, or for a named
            entity.  Theoretically it should return the proxy class, but it doesn't.
            <p/>
            The problem here is that we do not necessarily have a ref to the associated
            entity persister (nor to the session factory, to look it up) which is really
            needed to "do the right thing" here...
             </summary>
        </member>
        <member name="P:NHibernate.Type.EntityType.ForeignKeyDirection">
            <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
            <value>The <see cref="P:NHibernate.Type.EntityType.ForeignKeyDirection"/> of this association.</value>
        </member>
        <member name="P:NHibernate.Type.EntityType.UseLHSPrimaryKey">
            <summary>
            Is the foreign key the primary key of the table?
            </summary>
        </member>
        <member name="M:NHibernate.Type.EnumCharType`1.GetValue(System.Object)">
            <summary>
            Converts the given enum instance into a basic type.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Type.EnumStringType">
            <summary>
            Maps a <see cref="T:System.Enum"/> to a 
            <see cref="F:System.Data.DbType.String">DbType.String</see>.
            </summary>
            <remarks>
            If your database should store the <see cref="T:System.Enum"/>
            using the named values in the enum instead of the underlying values
            then subclass this <see cref="T:NHibernate.Type.IType"/>.
            
            <para>
            All that needs to be done is to provide a default constructor that
            NHibernate can use to create the specific type.  For example, if 
            you had an enum defined as.
            </para>
            
            <code>
            public enum MyEnum 
            {
            	On,
            	Off,
            	Dimmed
            }
            </code>
            
            <para>
            all that needs to be written for your enum string type is:
            </para>
            
            <code>
            public class MyEnumStringType : NHibernate.Type.EnumStringType
            {
            	public MyEnumStringType()
            		: base( typeof( MyEnum ) )
            	{
            	}
            }
            </code>
            
            <para>
            The mapping would look like:
            </para>
            
            <code>
            ...
            	&lt;property name="Status" type="MyEnumStringType, AssemblyContaining" /&gt;
            ...
            </code>
            
            <para>
            The TestFixture that shows the working code can be seen
            in <c>NHibernate.Test.TypesTest.EnumStringTypeFixture.cs</c>
            , <c>NHibernate.Test.TypesTest.EnumStringClass.cs</c>
            , and <c>NHibernate.Test.TypesTest.EnumStringClass.hbm.xml</c>
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.Type.EnumStringType.MaxLengthForEnumString">
            <summary>
            Hardcoding of <c>255</c> for the maximum length
            of the Enum name that will be saved to the db.
            </summary>
            <value>
            <c>255</c> because that matches the default length that hbm2ddl will
            use to create the column.
            </value>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType"/>.
            </summary>
            <param name="enumClass">The <see cref="T:System.Type"/> of the Enum.</param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType"/>.
            </summary>
            <param name="enumClass">The <see cref="T:System.Type"/> of the Enum.</param>
            <param name="length">The length of the string that can be written to the column.</param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.GetInstance(System.Object)">
            <summary>
            
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.GetValue(System.Object)">
            <summary>
            
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cached"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.EnumStringType.Name">
            <summary>
            
            </summary>
            <remarks>
            This appends <c>enumstring - </c> to the beginning of the underlying
            enums name so that <see cref="T:System.Enum"/> could still be stored
            using the underlying value through the <see cref="T:NHibernate.Type.PersistentEnumType"/>
            also.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ForeignKeyDirection">
            <summary>
            Represents directionality of the foreign key constraint
            </summary>
        </member>
        <member name="F:NHibernate.Type.ForeignKeyDirection.ForeignKeyFromParent">
            <summary>
            A foreign key from parent to child
            </summary>
        </member>
        <member name="F:NHibernate.Type.ForeignKeyDirection.ForeignKeyToParent">
            <summary>
            A foreign key from child to parent
            </summary>
        </member>
        <member name="M:NHibernate.Type.ForeignKeyDirection.CascadeNow(NHibernate.Engine.CascadePoint)">
            <summary>
            Should we cascade at this cascade point?
            </summary>
        </member>
        <member name="T:NHibernate.Type.GenericBagType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.IList`1"/> collection
            to the database using bag semantics.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericBagType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericBagType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericBagType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the bag.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the bag.</param>
            <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the bag.</param>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Type.GenericBagType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1"/> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.GenericIdentifierBagType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.IList`1"/> collection
            using bag semantics with an identifier to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericIdentifierBagType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.CollectionType"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericIdentifierBagType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the identifier bag.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the identifier bag.</param>
            <param name="persister"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GenericIdentifierBagType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentIdentifierBag`1"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentIdentifierBag`1"/> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Type.GenericIdentifierBagType`1.Instantiate(System.Int32)">
            <summary> 
            Instantiate an empty instance of the "underlying" collection (not a wrapper),
            but with the given anticipated size (i.e. accounting for initial capacity
            and perhaps load factor).
            </summary>
            <param name="anticipatedSize">
            The anticipated size of the instantiated collection after we are done populating it.
            </param>
            <returns> A newly instantiated collection to be wrapped. </returns>
        </member>
        <member name="P:NHibernate.Type.GenericIdentifierBagType`1.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.GenericListType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.IList`1"/> collection
            to the database using list semantics.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericListType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericListType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericListType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the list.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the list.</param>
            <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the list.</param>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Type.GenericListType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1"/> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.GenericMapType`2">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.IDictionary`2"/> collection
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericMapType`2.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericMapType`2"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericMapType`2.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the map.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the map.</param>
            <param name="persister"></param>
            <param name="key">Not used.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GenericMapType`2.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IDictionary`2"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2"/> that wraps the 
            non NHibernate <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.GenericOrderedSetType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps a sorted <see cref="T:System.Collections.Generic.ISet`1"/> collection
            to the database.
            </summary>
        </member>
        <member name="T:NHibernate.Type.GenericSetType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps an <see cref="T:System.Collections.Generic.ISet`1"/> collection
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericSetType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericSetType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="M:NHibernate.Type.GenericSetType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
            <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection"/> for the set.
            </summary>
            <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the set.</param>
            <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister"/> for the set.</param>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Type.GenericSetType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericSet`1"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericSet`1"/> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Type.GenericOrderedSetType`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericOrderedSetType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
        </member>
        <member name="T:NHibernate.Type.GenericSortedSetType`1">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that maps a sorted <see cref="T:System.Collections.Generic.ISet`1"/> collection
            to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GenericSortedSetType`1.#ctor(System.String,System.String,System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericSortedSetType`1"/> class for
            a specific role.
            </summary>
            <param name="role">The role the persistent collection is in.</param>
            <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null"/> if it is
            the primary key.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use to compare
            set elements.</param>
        </member>
        <member name="T:NHibernate.Type.GuidType">
            <summary>
            Maps a <see cref="T:System.Guid"/> Property 
            to a <see cref="F:System.Data.DbType.Guid"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GuidType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.GuidType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.GuidType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int16Type">
            <summary>
            Maps a <see cref="T:System.Int16"/> Property 
            to a <see cref="F:System.Data.DbType.Int16"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int16Type.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int16Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int32Type">
            <summary>
            Maps a <see cref="T:System.Int32"/> Property 
            to a <see cref="F:System.Data.DbType.Int32"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int32Type.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int32Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int64Type">
            <summary>
            Maps a <see cref="T:System.Int64"/> Property 
            to a <see cref="F:System.Data.DbType.Int64"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int64Type.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int64Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ManyToOneType">
            <summary>
            A many-to-one association to an entity
            </summary>
        </member>
        <member name="M:NHibernate.Type.ManyToOneType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Hydrates the Identifier from <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the query results.</param>
            <param name="names">A string array of column names to read from.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this is occurring in.</param>
            <param name="owner">The object that this Entity will be a part of.</param>
            <returns>
            An instantiated object that used as the identifier of the type.
            </returns>
        </member>
        <member name="T:NHibernate.Type.OneToOneType">
            <summary>
            A one-to-one association to an entity
            </summary>
        </member>
        <member name="P:NHibernate.Type.OneToOneType.IsAlwaysDirtyChecked">
            <summary>
            We don't need to dirty check one-to-one because of how 
            assemble/disassemble is implemented and because a one-to-one 
            association is never dirty
            </summary>
        </member>
        <member name="T:NHibernate.Type.PersistentEnumType">
            <summary>
            PersistentEnumType
            </summary>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetInstance(System.Object)">
            <summary>
            Gets an instance of the Enum
            </summary>
            <param name="code">The underlying value of an item in the Enum.</param>
            <returns>
            An instance of the Enum set to the <c>code</c> value.
            </returns>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetValue(System.Object)">
            <summary>
            Gets the correct value for the Enum.
            </summary>
            <param name="code">The value to convert (an enum instance).</param>
            <returns>A boxed version of the code, converted to the correct type.</returns>
            <remarks>
            This handles situations where the DataProvider returns the value of the Enum
            from the db in the wrong underlying type.  It uses <see cref="T:System.Convert"/> to 
            convert it to the correct type.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.SByteType">
            <summary>
            Maps a <see cref="T:System.SByte"/> Property 
            to a <see cref="F:System.Data.DbType.SByte"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SByteType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.SByteType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SerializableType">
            <summary>
            Maps an instance of a <see cref="T:System.Object"/> that has the <see cref="T:System.SerializableAttribute"/>
            to a <see cref="F:System.Data.DbType.Binary"/> column.  
            </summary>
            <remarks>
            <para>
            For performance reasons, the SerializableType should be used when you know that Bytes are 
            not going to be greater than 8,000. Implementing a custom type is recommended for larger
            types.
            </para>
            <para>
            The base class is <see cref="T:NHibernate.Type.MutableType"/> because the data is stored in 
            a byte[].  The System.Array does not have a nice "equals" method so we must
            do a custom implementation.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.SerializableType.DeepCopyNotNull(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.FromBytes(System.Byte[])">
            <summary>
            
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SerializableType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SerializationException">
            <summary>
            Thrown when a property cannot be serialized/deserialized
            </summary>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Type.SingleType">
            <summary>
            Maps a <see cref="T:System.Single"/> Property to an 
            <see cref="F:System.Data.DbType.Single"/> column.
            </summary>
            <remarks>
            Verify through your database's documentation if there is a column type that
            matches up with the capabilities of <see cref="T:System.Single"/>  
            </remarks>
        </member>
        <member name="M:NHibernate.Type.SingleType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.SingleType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SpecialOneToOneType">
            <summary> 
            A one-to-one association that maps to specific formula(s)
            instead of the primary key column of the owning entity. 
            </summary>
        </member>
        <member name="T:NHibernate.Type.StringClobType">
            <summary>
            Maps a <see cref="T:System.String"/> Property to an 
            <see cref="T:System.String"/> column that can store a CLOB.
            </summary>
            <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a StringType
            would work just fine.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.StringType">
            <summary>
            Maps a <see cref="T:System.String"/> to a <see cref="F:System.Data.DbType.String"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.StringClobType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.StringClobType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="P:NHibernate.Type.StringClobType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TicksType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to an <see cref="F:System.Data.DbType.Int64"/> column 
            that stores the DateTime using the Ticks property.
            </summary>
            <remarks>
            This is the recommended way to "timestamp" a column.  
            The System.DateTime.Ticks is accurate to 100-nanosecond intervals. 
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TicksType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="P:NHibernate.Type.TicksType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TicksType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TimeAsTimeSpanType">
            <summary>
            Maps a <see cref="T:System.TimeSpan"/> Property to an <see cref="F:System.Data.DbType.Time"/> column 
            This is an extra way to map a <see cref="F:System.Data.DbType.Time"/>. You already have <see cref="T:NHibernate.Type.TimeType"/>
            but mapping against a <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Type.TimeSpanType">
            <summary>
            Maps a <see cref="T:System.TimeSpan"/> Property to an <see cref="F:System.Data.DbType.Int64"/> column 
            </summary>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Seed(NHibernate.Engine.ISessionImplementor)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TimeType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to an DateTime column that only stores the 
            Hours, Minutes, and Seconds of the DateTime as significant.
            Also you have for <see cref="F:System.Data.DbType.Time"/> handling, the NHibernate Type <see cref="T:NHibernate.Type.TimeAsTimeSpanType"/>,
            the which maps to a <see cref="T:System.TimeSpan"/>.
            </summary>
            <remarks>
            <para>
            This defaults the Date to "1753-01-01" - that should not matter because
            using this Type indicates that you don't care about the Date portion of the DateTime.
            </para>
            <para>
            A more appropriate choice to store the duration/time is the <see cref="T:NHibernate.Type.TimeSpanType"/>.
            The underlying <see cref="F:System.Data.DbType.Time"/> tends to be handled differently by different
            DataProviders.
            </para>
            </remarks>
        </member>
        <member name="T:NHibernate.Type.TrueFalseType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column 
            that stores a <code>'T'/'F'</code> to indicate <code>true/false</code>.
            </summary>
            <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TrueFalseType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.FalseString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TypeFactory">
            <summary>
            Used internally to obtain instances of IType.
            </summary>
            <remarks>
            Applications should use static methods and constants on NHibernate.NHibernateUtil if the default
            IType is good enough.  For example, the TypeFactory should only be used when the String needs
            to have a length of 300 instead of 255.  At this point NHibernateUtil.String does not get you the
            correct IType.  Instead use TypeFactory.GetString(300) and keep a local variable that holds
            a reference to the IType.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.RegisterDefaultNetTypes">
            <summary>
            Register other Default .NET type
            </summary>
            <remarks>
            These type will be used, as default, even when the "type" attribute was NOT specified in the mapping
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.RegisterBuiltInTypes">
            <summary>
            Register other NO Default .NET type
            </summary>
            <remarks>
            These type will be used only when the "type" attribute was is specified in the mapping.
            These are in here because needed to NO override default CLR types and be available in mappings
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetTypeClassification(System.String)">
            <summary>
            Gets the classification of the Type based on the string.
            </summary>
            <param name="typeName">The name of the Type to get the classification for.</param>
            <returns>The Type of Classification</returns>
            <remarks>
            This parses through the string and makes the assumption that no class
            name and no assembly name will contain the <c>"("</c>.
            <para>
            If it finds
            the <c>"("</c> and then finds a <c>","</c> afterwards then it is a
            <c>TypeClassification.PrecisionScale</c>.
            </para>
            <para>
            If it finds the <c>"("</c>
            and doesn't find a <c>","</c> afterwards, then it is a
            <c>TypeClassification.Length</c>.
            </para>
            <para>
            If it doesn't find the <c>"("</c> then it assumes that it is a
            <c>TypeClassification.Plain</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Basic(System.String)">
            <summary>
            Given the name of a Hibernate type such as Decimal, Decimal(19,0)
            , Int32, or even NHibernate.Type.DecimalType, NHibernate.Type.DecimalType(19,0),
            NHibernate.Type.Int32Type, then return an instance of NHibernate.Type.IType
            </summary>
            <param name="name">The name of the type.</param>
            <returns>The instance of the IType that the string represents.</returns>
            <remarks>
            This method will return null if the name is not found in the basicNameMap.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String)">
            <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the
            type.
            </summary>
            <param name="typeName"></param>
            <returns>An instance of <c>NHibernate.Type.IType</c></returns>
            <remarks>
            When looking for the NHibernate type it will look in the cache of the Basic types first.
            If it doesn't find it in the cache then it uses the typeName to get a reference to the
            Class (Type in .NET).  Once we get the reference to the .NET class we check to see if it
            implements IType, ICompositeUserType, IUserType, ILifecycle (Association), or
            IPersistentEnum.  If none of those are implemented then we will serialize the Type to the
            database using NHibernate.Type.SerializableType(typeName)
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the type.
            </summary>
            <param name="typeName">the type name</param>
            <param name="parameters">parameters for the type</param>
            <returns>An instance of <c>NHibernate.Type.IType</c></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Nullable{System.Int32})">
            <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the type.
            </summary>
            <param name="typeName">the type name</param>
            <param name="parameters">parameters for the type</param>
            <param name="length">optionally, the size of the type</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetBinaryType(System.Int32)">
            <summary>
            Gets the BinaryType with the specified length.
            </summary>
            <param name="length">The length of the data to store in the database.</param>
            <returns>A BinaryType</returns>
            <remarks>
            In addition to returning the BinaryType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Byte[](length)</c> and
            <c>NHibernate.Type.BinaryType(length)</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type)">
            <summary>
            Gets the SerializableType for the specified Type
            </summary>
            <param name="serializableType">The Type that will be Serialized to the database.</param>
            <returns>A SerializableType</returns>
            <remarks>
            <para>
            In addition to returning the SerializableType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Type.FullName</c> (the result
            of <c>IType.Name</c> and <c>Type.AssemblyQualifiedName</c>.  This is different
            from the other items put in the basicNameMap because it is uses the AQN and the
            FQN as opposed to the short name used in the maps and the FQN.
            </para>
            <para>
            Since this method calls the method
            <see cref="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type,System.Int32)">GetSerializableType(System.Type, Int32)</see>
            with the default length, those keys will also be added.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.OneToOne(System.String,NHibernate.Type.ForeignKeyDirection,System.String,System.Boolean,System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            A one-to-one association type for the given class and cascade style.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.String)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.String,System.Boolean)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
        </member>
        <member name="T:NHibernate.Type.TypeHelper">
            <summary>
            Collection of convenience methods relating to operations across arrays of types...
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.DeepCopy(System.Object[],NHibernate.Type.IType[],System.Boolean[],System.Object[],NHibernate.Engine.ISessionImplementor)">
            <summary>Deep copy a series of values from one array to another</summary>
            <param name="values">The values to copy (the source)</param>
            <param name="types">The value types</param>
            <param name="copy">An array indicating which values to include in the copy</param>
            <param name="target">The array into which to copy the values</param>
            <param name="session">The originating session</param>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.BeforeAssemble(System.Object[],NHibernate.Type.ICacheAssembler[],NHibernate.Engine.ISessionImplementor)">
            <summary>Apply the <see cref="M:NHibernate.Type.ICacheAssembler.BeforeAssemble(System.Object,NHibernate.Engine.ISessionImplementor)"/> operation across a series of values.</summary>
            <param name="row">The values</param>
            <param name="types">The value types</param>
            <param name="session">The originating session</param>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.Assemble(System.Object[],NHibernate.Type.ICacheAssembler[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Apply the <see cref="M:NHibernate.Type.ICacheAssembler.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)"/> operation across a series of values.
            </summary>
            <param name="row">The values</param>
            <param name="types">The value types</param>
            <param name="session">The originating session</param>
            <param name="owner">The entity "owning" the values</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.Disassemble(System.Object[],NHibernate.Type.ICacheAssembler[],System.Boolean[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>Apply the <see cref="M:NHibernate.Type.ICacheAssembler.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)"/> operation across a series of values.</summary>
            <param name="row">The values</param>
            <param name="types">The value types</param>
            <param name="nonCacheable">An array indicating which values to include in the disassembled state</param>
            <param name="session">The originating session</param>
            <param name="owner">The entity "owning" the values</param>
            <returns> The disassembled state</returns>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.Replace(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <summary>
            Apply the <see cref="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)"/> operation across a series of values.
            </summary>
            <param name="original">The source of the state</param>
            <param name="target">The target into which to replace the source values.</param>
            <param name="types">The value types</param>
            <param name="session">The originating session</param>
            <param name="owner">The entity "owning" the values</param>
            <param name="copiedAlready">Represent a cache of already replaced state</param>
            <returns> The replaced state</returns>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.Replace(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)">
            <summary>
            Apply the <see cref="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)"/>
            operation across a series of values.
            </summary>
            <param name="original">The source of the state</param>
            <param name="target">The target into which to replace the source values.</param>
            <param name="types">The value types</param>
            <param name="session">The originating session</param>
            <param name="owner">The entity "owning" the values</param>
            <param name="copyCache">A map representing a cache of already replaced state</param>
            <param name="foreignKeyDirection">FK directionality to be applied to the replacement</param>
            <returns> The replaced state</returns>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.ReplaceAssociations(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)">
            <summary>
            Apply the <see cref="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)"/>
            operation across a series of values, as long as the corresponding <see cref="T:NHibernate.Type.IType"/> is an association.
            </summary>
            <param name="original">The source of the state</param>
            <param name="target">The target into which to replace the source values.</param>
            <param name="types">The value types</param>
            <param name="session">The originating session</param>
            <param name="owner">The entity "owning" the values</param>
            <param name="copyCache">A map representing a cache of already replaced state</param>
            <param name="foreignKeyDirection">FK directionality to be applied to the replacement</param>
            <returns> The replaced state</returns>
            <remarks>
            If the corresponding type is a component type, then apply <see cref="M:NHibernate.Type.TypeHelper.ReplaceAssociations(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)"/>
            across the component subtypes but do not replace the component value itself.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.FindDirty(NHibernate.Tuple.StandardProperty[],System.Object[],System.Object[],System.Boolean[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            <para>Determine if any of the given field values are dirty, returning an array containing
            indices of the dirty fields.</para>
            <para>If it is determined that no fields are dirty, null is returned.</para>
            </summary>
            <param name="properties">The property definitions</param>
            <param name="currentState">The current state of the entity</param>
            <param name="previousState">The baseline state of the entity</param>
            <param name="includeColumns">Columns to be included in the dirty checking, per property</param>
            <param name="anyUninitializedProperties">Does the entity currently hold any uninitialized property values?</param>
            <param name="session">The session from which the dirty check request originated.</param>
            <returns>Array containing indices of the dirty properties, or null if no properties considered dirty.</returns>
        </member>
        <member name="M:NHibernate.Type.TypeHelper.FindModified(NHibernate.Tuple.StandardProperty[],System.Object[],System.Object[],System.Boolean[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            <para>Determine if any of the given field values are modified, returning an array containing
            indices of the modified fields.</para>
            <para>If it is determined that no fields are dirty, null is returned.</para>
            </summary>
            <param name="properties">The property definitions</param>
            <param name="currentState">The current state of the entity</param>
            <param name="previousState">The baseline state of the entity</param>
            <param name="includeColumns">Columns to be included in the mod checking, per property</param>
            <param name="anyUninitializedProperties">Does the entity currently hold any uninitialized property values?</param>
            <param name="session">The session from which the dirty check request originated.</param>
            <returns>Array containing indices of the modified properties, or null if no properties considered modified.</returns>
        </member>
        <member name="T:NHibernate.Type.TypeType">
            <summary>
            Maps the Assembly Qualified Name of a <see cref="T:System.Type"/> to a 
            <see cref="F:System.Data.DbType.String"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TypeType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            Initialize a new instance of the TypeType class using a 
            <see cref="P:NHibernate.Type.TypeType.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="P:NHibernate.Type.TypeType.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            Gets the <see cref="T:System.Type"/> in the <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="index">The index of the field to get the value from.</param>
            <returns>The <see cref="T:System.Type"/> from the database.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type"/>
            </exception>
        </member>
        <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.String)">
            <summary>
            Gets the <see cref="T:System.Type"/> in the <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>The <see cref="T:System.Type"/> from the database.</returns>
            <remarks>
            This just calls gets the index of the name in the IDataReader
            and calls the overloaded version <see cref="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)"/>
            (IDataReader, Int32). 
            </remarks>
            <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type"/>
            </exception>
        </member>
        <member name="M:NHibernate.Type.TypeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Puts the Assembly Qualified Name of the <see cref="T:System.Type"/> 
            Property into to the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the value into.</param>
            <param name="value">The <see cref="T:System.Type"/> that contains the value.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the value to.</param>
            <remarks>
            This uses the <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)"/> method of the 
            <see cref="F:NHibernate.NHibernateUtil.String"/> object to do the work.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="value">The <see cref="T:System.Type"/> that contains the values.
            </param>
            <returns>An Xml formatted string that contains the Assembly Qualified Name.</returns>
        </member>
        <member name="P:NHibernate.Type.TypeType.ReturnedClass">
            <summary>
            Gets the <see cref="T:System.Type"/> that will be returned 
            by the <c>NullSafeGet()</c> methods.
            </summary>
            <value>
            A <see cref="T:System.Type"/> from the .NET framework.
            </value>
        </member>
        <member name="P:NHibernate.Type.TypeType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt16Type">
            <summary>
            Maps a <see cref="T:System.UInt16"/> Property 
            to a <see cref="F:System.Data.DbType.UInt16"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt16Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt32Type">
            <summary>
            Maps a <see cref="T:System.UInt32"/> Property 
            to a <see cref="F:System.Data.DbType.UInt32"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt32Type.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt64Type">
            <summary>
            Maps a <see cref="T:System.UInt64"/> Property 
            to a <see cref="F:System.Data.DbType.UInt64"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.YesNoType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column 
            that stores a <code>'Y'/'N'</code> to indicate <code>true/false</code>.
            </summary>
            <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.YesNoType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.FalseString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.UserTypes.ICompositeUserType">
             <summary>
             A UserType that may be dereferenced in a query.
             This interface allows a custom type to define "properties".
             These need not necessarily correspond to physical .NET style properties.
            
             A ICompositeUserType may be used in almost every way
             that a component may be used. It may even contain many-to-one
             associations.
            
             Implementors must be immutable and must declare a public
             default constructor.
            
             Unlike UserType, cacheability does not depend upon
             serializability. Instead, Assemble() and
             Disassemble() provide conversion to/from a cacheable
             representation.
             </summary>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            Get the value of a property
            </summary>
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <returns>the property value</returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            Set the value of a property
            </summary>
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <param name="value">the value to set</param>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this type for persistence
            "equality", ie. equality of persistent state.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.GetHashCode(System.Object)">
            <summary>
            Get a hashcode for the instance, consistent with persistence "equality"
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Retrieve an instance of the mapped class from a IDataReader. Implementors
            should handle possibility of null values.
            </summary>
            <param name="dr">IDataReader</param>
            <param name="names">the column names</param>
            <param name="session"></param>
            <param name="owner">the containing entity</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            If a property is not settable, skip it and don't increment the index.
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="settable"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.DeepCopy(System.Object)">
            <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
            <param name="value">generally a collection element or entity field</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Transform the object into its cacheable representation.
            At the very least this method should perform a deep copy.
            That may not be enough for some implementations, method should perform a deep copy. That may not be enough for some implementations, however; for example, associations must be cached as identifier values. (optional operation)
            </summary>
            <param name="value">the object to be cached</param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Reconstruct an object from the cacheable representation.
            At the very least this method should perform a deep copy. (optional operation)
            </summary>
            <param name="cached">the object to be cached</param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.ICompositeUserType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            During merge, replace the existing (target) value in the entity we are merging to
            with a new (original) value from the detached entity we are merging. For immutable
            objects, or null values, it is safe to simply return the first parameter. For
            mutable objects, it is safe to return a copy of the first parameter. However, since
            composite user types often define component values, it might make sense to recursively
            replace component values in the target object.
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.PropertyNames">
            <summary>
            Get the "property names" that may be used in a query.
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.PropertyTypes">
            <summary>
            Get the corresponding "property types"
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.ReturnedClass">
            <summary>
            The class returned by NullSafeGet().
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.ICompositeUserType.IsMutable">
            <summary>
            Are objects of this type mutable?
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.IEnhancedUserType">
            <summary>
            A custom type that may function as an identifier or discriminator
            type, or may be marshalled to and from an XML document.
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.IUserType">
            <summary>
            The interface to be implemented by user-defined types.
            </summary>
            <remarks>
            <para>
            The interface abstracts user code from future changes to the <see cref="T:NHibernate.Type.IType"/> interface,
            simplifies the implementation of custom types and hides certain "internal interfaces from
            user code.
            </para>
            <para>
            Implementers must be immutable and must declare a public default constructor.
            </para>
            <para>
            The actual class mapped by a <c>IUserType</c> may be just about anything. However, if it is to
            be cacheble by a persistent cache, it must be serializable.
            </para>
            <para>
            Alternatively, custom types could implement <see cref="T:NHibernate.Type.IType"/> directly or extend one of the
            abstract classes in <c>NHibernate.Type</c>. This approach risks future incompatible changes
            to classes or interfaces in the package.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this type for persistent "equality"
            ie. equality of persistent state
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.GetHashCode(System.Object)">
            <summary>
            Get a hashcode for the instance, consistent with persistence "equality"
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.NullSafeGet(System.Data.IDataReader,System.String[],System.Object)">
            <summary>
            Retrieve an instance of the mapped class from a JDBC resultset.
            Implementors should handle possibility of null values.
            </summary>
            <param name="rs">a IDataReader</param>
            <param name="names">column names</param>
            <param name="owner">the containing entity</param>
            <returns></returns>
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            </summary>
            <param name="cmd">a IDbCommand</param>
            <param name="value">the object to write</param>
            <param name="index">command parameter index</param>
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.DeepCopy(System.Object)">
            <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
            <param name="value">generally a collection element or entity field</param>
            <returns>a copy</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Replace(System.Object,System.Object,System.Object)">
            <summary>
            During merge, replace the existing (<paramref name="target" />) value in the entity
            we are merging to with a new (<paramref name="original" />) value from the detached
            entity we are merging. For immutable objects, or null values, it is safe to simply
            return the first parameter. For mutable objects, it is safe to return a copy of the
            first parameter. For objects with component values, it might make sense to
            recursively replace component values.
            </summary>
            <param name="original">the value from the detached entity being merged</param>
            <param name="target">the value in the managed entity</param>
            <param name="owner">the managed entity</param>
            <returns>the value to be merged</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Assemble(System.Object,System.Object)">
            <summary>
            Reconstruct an object from the cacheable representation. At the very least this
            method should perform a deep copy if the type is mutable. (optional operation)
            </summary>
            <param name="cached">the object to be cached</param>
            <param name="owner">the owner of the cached object</param>
            <returns>a reconstructed object from the cachable representation</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserType.Disassemble(System.Object)">
            <summary>
            Transform the object into its cacheable representation. At the very least this
            method should perform a deep copy if the type is mutable. That may not be enough
            for some implementations, however; for example, associations must be cached as
            identifier values. (optional operation)
            </summary>
            <param name="value">the object to be cached</param>
            <returns>a cacheable representation of the object</returns>
        </member>
        <member name="P:NHibernate.UserTypes.IUserType.SqlTypes">
            <summary>
            The SQL types for the columns mapped by this type. 
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.IUserType.ReturnedType">
            <summary>
            The type returned by <c>NullSafeGet()</c>
            </summary>
        </member>
        <member name="P:NHibernate.UserTypes.IUserType.IsMutable">
            <summary>
            Are objects of this type mutable?
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IEnhancedUserType.FromXMLString(System.String)">
            <summary>
            Parse a string representation of this value, as it appears
            in an XML document.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IEnhancedUserType.ObjectToSQLString(System.Object)">
            <summary>
            Return an SQL literal representation of the value
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IEnhancedUserType.ToXMLString(System.Object)">
            <summary> 
            Return a string representation of this value, as it
            should appear in an XML document
            </summary>
        </member>
        <member name="T:NHibernate.UserTypes.ILoggableUserType">
            <summary> 
            Marker interface for user types which want to perform custom
            logging of their corresponding values 
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.ILoggableUserType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary> Generate a loggable string representation of the collection (value). </summary>
            <param name="value">The collection to be logged; guaranteed to be non-null and initialized. </param>
            <param name="factory">The factory. </param>
            <returns> The loggable string representation. </returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
            <summary>
            Instantiate an uninitialized instance of the collection wrapper
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wrap an instance of a collection
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.GetElements(System.Object)">
            <summary>
            Return an <see cref="T:System.Collections.IEnumerable"/> over the elements of this collection - the passed collection
            instance may or may not be a wrapper
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Contains(System.Object,System.Object)">
            <summary>
            Optional operation. Does the collection contain the entity instance?
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.IndexOf(System.Object,System.Object)">
            <summary>
            Optional operation. Return the index of the entity in the collection.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.ReplaceElements(System.Object,System.Object,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Replace the elements of a collection with the elements of another collection
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserCollectionType.Instantiate(System.Int32)">
            <summary> 
            Instantiate an empty instance of the "underlying" collection (not a wrapper),
            but with the given anticipated size (i.e. accounting for initial size
            and perhaps load factor).
             </summary>
            <param name="anticipatedSize">
            The anticipated size of the instantiated collection
            after we are done populating it.  Note, may be negative to indicate that
            we not yet know anything about the anticipated size (i.e., when initializing
            from a result set row by row).
            </param>		
        </member>
        <member name="T:NHibernate.UserTypes.IUserVersionType">
            <summary>
            A user type that may be used for a version property.
            </summary>
        </member>
        <member name="M:NHibernate.UserTypes.IUserVersionType.Seed(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Generate an initial version.
            </summary>
            <param name="session">The session from which this request originates.  May be
            null; currently this only happens during startup when trying to determine
            the "unsaved value" of entities.</param>
            <returns>an instance of the type</returns>
        </member>
        <member name="M:NHibernate.UserTypes.IUserVersionType.Next(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Increment the version.
            </summary>
            <param name="current">The session from which this request originates.</param>
            <param name="session">the current version</param>
            <returns>an instance of the type</returns>
        </member>
        <member name="T:NHibernate.Util.ArrayHelper">
            <summary>
            Helper class that contains common array functions and 
            data structures used through out NHibernate.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.AddAll(System.Collections.IList,System.Collections.IList)">
            <summary>
            Append all elements in the 'from' list to the 'to' list.
            </summary>
            <param name="to"></param>
            <param name="from"></param>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.ArrayGetHashCode``1(``0[])">
            <summary>
            Calculate a hash code based on the length and contents of the array.
            The algorithm is such that if ArrayHelper.ArrayEquals(a,b) returns true,
            then ArrayGetHashCode(a) == ArrayGetHashCode(b).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.CollectionHelper.GetHashCode(System.Collections.IEnumerable)">
            <summary>
            Computes a hash code for <paramref name="coll"/>.
            </summary>
            <remarks>The hash code is computed as the sum of hash codes of
            individual elements, so that the value is independent of the
            collection iteration order.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.CollectionHelper.CreateCaseInsensitiveHashtable``1">
            <summary>
            Creates a <see cref="T:System.Collections.Hashtable"/> that uses case-insensitive string comparison
            associated with invariant culture.
            </summary>
            <remarks>
            This is different from the method in <see cref="T:System.Collections.Specialized.CollectionsUtil"/>
            in that the latter uses the current culture and is thus vulnerable to the "Turkish I" problem.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.CollectionHelper.CreateCaseInsensitiveHashtable``1(System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Hashtable"/> that uses case-insensitive string comparison
            associated with invariant culture.
            </summary>
            <remarks>
            This is different from the method in <see cref="T:System.Collections.Specialized.CollectionsUtil"/>
            in that the latter uses the current culture and is thus vulnerable to the "Turkish I" problem.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.CollectionHelper.GetHashCode``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Computes a hash code for <paramref name="coll"/>.
            </summary>
            <remarks>The hash code is computed as the sum of hash codes of
            individual elements, so that the value is independent of the
            collection iteration order.
            </remarks>
        </member>
        <member name="T:NHibernate.Util.CollectionHelper.EmptyMapClass">
            <summary>
            A read-only dictionary that is always empty and permits lookup by <see langword="null" /> key.
            </summary>
        </member>
        <member name="T:NHibernate.Util.CollectionHelper.EmptyMapClass`2">
            <summary>
            A read-only dictionary that is always empty and permits lookup by <see langword="null" /> key.
            </summary>
        </member>
        <member name="T:NHibernate.Util.CollectionPrinter">
            <summary>
            Utility class implementing ToString for collections. All <c>ToString</c>
            overloads call <c>element.ToString()</c>.
            </summary>
            <remarks>
            To print collections of entities or typed values, use
            <see cref="T:NHibernate.Impl.Printer"/>.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NHibernate.Util.EnumeratorAdapter`1" -->
        <member name="T:NHibernate.Util.FilterHelper">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.FilterHelper.GetEnabledForManyToOne(System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
            <summary>
            Get only filters enabled for many-to-one association.
            </summary>
            <param name="enabledFilters">All enabled filters</param>
            <returns>A new <see cref="T:System.Collections.Generic.IDictionary`2"/> for filters enabled for many to one.</returns>
        </member>
        <member name="T:NHibernate.Util.IdentityMap">
            <summary>
            An <see cref="T:System.Collections.IDictionary"/> where keys are compared by object identity, rather than <c>equals</c>.
            
            All external users of this class need to have no knowledge of the IdentityKey - it is all
            hidden by this class.
            </summary>
            <remarks>
            <para>
            Do NOT use a System.Value type as the key for this Hashtable - only classes.  See
            the <a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;threadm=bds2rm%24ruc%241%40charly.heeg.de&amp;rnum=1&amp;prev=/groups%3Fhl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26q%3DSystem.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%26sa%3DN%26tab%3Dwg">google thread</a>
            about why using System.Value is a bad thing.
            </para>
            <para>
            If I understand it correctly, the first call to get an object defined by a DateTime("2003-01-01")
            would box the DateTime and return the identity key for the box.  If you were to get that Key and
            unbox it into a DateTime struct, then the next time you passed it in as the Key the IdentityMap
            would box it again (into a different box) and it would have a different IdentityKey - so you would
            not get the same value for the same DateTime value. 
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Instantiate(System.Int32)">
            <summary>
            Create a new instance of the IdentityMap that has no 
            iteration order.
            </summary>
            <returns>A new IdentityMap based on a Hashtable.</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.InstantiateSequenced(System.Int32)">
            <summary>
            Create a new instance of the IdentityMap that has an 
            iteration order of the order the objects were added
            to the Map.
            </summary>
            <returns>A new IdentityMap based on ListDictionary.</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.ConcurrentEntries(System.Collections.IDictionary)">
            <summary>
            Return the Dictionary Entries (as instances of <c>DictionaryEntry</c> in a collection
            that is safe from concurrent modification).  Ie - we may safely add new instances
            to the underlying <c>IDictionary</c> during enumeration of the <c>Values</c>.
            </summary>
            <param name="map">The IDictionary to get the enumeration safe list.</param>
            <returns>A Collection of DictionaryEntries</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.#ctor(System.Collections.IDictionary)">
            <summary>
            Create the IdentityMap class with the correct class for the IDictionary.
            Unsorted = Hashtable
            Sorted = ListDictionary
            </summary>
            <param name="underlyingMap">A class that implements the IDictionary for storing the objects.</param>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Add(System.Object,System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Clear">
            <summary>
            <see cref="M:System.Collections.IDictionary.Clear"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Contains(System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IDictionary.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Remove(System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Remove(System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <param name="array"></param>
            <param name="i"></param>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.VerifyValidKey(System.Object)">
            <summary>
            Verifies that we are not using a System.ValueType as the Key in the Dictionary
            </summary>
            <param name="obj">The object that will be the key.</param>
            <returns>An object that is safe to be a key.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the obj is a System.ValueType</exception>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Count">
            <summary>
            <see cref="P:System.Collections.ICollection.Count"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsFixedSize">
            <summary>
            <see cref="P:System.Collections.IDictionary.IsFixedSize"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsReadOnly">
            <summary>
            <see cref="P:System.Collections.IDictionary.IsReadOnly"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Keys">
            <summary>
            Returns the Keys used in this IdentityMap
            <see cref="P:System.Collections.IDictionary.IsReadOnly"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Item(System.Object)">
            <summary>
            <see cref="P:System.Collections.IDictionary.Item(System.Object)"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Values">
            <summary>
            <see cref="P:System.Collections.IDictionary.Values"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.EntryList">
            <summary>
            Provides a snapshot VIEW in the form of a List of the contents of the IdentityMap.
            You can safely iterate over this VIEW and modify the actual IdentityMap because the
            VIEW is a copy of the contents, not a reference to the existing Map.
            
            Contains a copy (not that actual instance stored) of the DictionaryEntries in a List.
            </summary>
        </member>
        <member name="T:NHibernate.Util.IdentitySet">
            <summary> 
            Set implementation that use reference equals instead of Equals() as its comparison mechanism.
            </summary>
        </member>
        <member name="T:NHibernate.Util.JoinedEnumerable">
            <summary>
            Concatenates multiple objects implementing <see cref="T:System.Collections.IEnumerable"/> into one.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.#ctor(System.Collections.IEnumerable[])">
            <summary>
            Creates an IEnumerable object from multiple IEnumerables.
            </summary>
            <param name="enumerables">The IEnumerables to join together.</param>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.GetEnumerator">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.JoinedEnumerable.JoinedEnumerator._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.JoinedEnumerator.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.JoinedEnumerator.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.JoinedEnumerator.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this JoinedEnumerable is being Disposed of or Finalized.</param>
            <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
        </member>
        <member name="T:NHibernate.Util.LinkedHashMap`2">
            <summary>
            A map of objects whose mapping entries are sequenced based on the order in which they were
            added. This data structure has fast <c>O(1)</c> search time, deletion time, and insertion time
            </summary>
            <remarks>
            This class is not thread safe.
            This class is not a really replication of JDK LinkedHashMap{K, V}, 
            this class is an adaptation of SequencedHashMap with generics.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2"/> class that is empty, 
            has the default initial capacity, and uses the default equality comparer for the key type.
            </summary>
        </member>
        <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2"/> class that is empty, 
            has the specified initial capacity, and uses the default equality comparer for the key type.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:NHibernate.Util.LinkedHashMap`2"/> can contain.</param>
        </member>
        <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2"/> class that is empty, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <param name="equalityComparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or null to use the default EqualityComparer for the type of the key.</param>
        </member>
        <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2"/> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:NHibernate.Util.LinkedHashMap`2"/> can contain.</param>
            <param name="equalityComparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or null to use the default EqualityComparer for the type of the key.</param>
        </member>
        <member name="T:NHibernate.Util.LRUMap">
            <summary>
            An implementation of a Map which has a maximum size and uses a Least Recently Used
            algorithm to remove items from the Map when the maximum size is reached and new items are added.
            </summary> 	
        </member>
        <member name="T:NHibernate.Util.SequencedHashMap">
            <summary>
            A map of objects whose mapping entries are sequenced based on the order in which they were
            added. This data structure has fast <c>O(1)</c> search time, deletion time, and insertion time
            </summary>
            <remarks>
            This class is not thread safe.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.CreateSentinel">
            <summary>
            Construct an empty sentinel used to hold the head (sentinel.next) and the tail (sentinal.prev)
            of the list. The sentinal has a <see langword="null" /> key and value
            </summary>
            <returns></returns>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._sentinel">
            <summary>
            Sentinel used to hold the head and tail of the list of entries
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._entries">
            <summary>
            Map of keys to entries
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._modCount">
            <summary>
            Holds the number of modifications that have occurred to the map, excluding modifications
            made through a collection view's iterator.
            </summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor">
            <summary>
            Construct a new sequenced hash map with default initial size and load factor
            </summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32)">
            <summary>
            Construct a new sequenced hash map with the specified initial size and default load factor
            </summary>
            <param name="capacity">the initial size for the hash table</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single)">
            <summary>
            Construct a new sequenced hash map with the specified initial size and load factor
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="loadFactor">the load factor for the hash table</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Collections.IEqualityComparer)">
            <summary>
            Construct a new sequenced hash map with the specified initial size, hash code provider
            and comparer
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Collections.IEqualityComparer)">
            <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
            <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="loadFactor">the load factor for the hash table</param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.RemoveEntry(NHibernate.Util.SequencedHashMap.Entry)">
            <summary>
            Removes an internal entry from the linked list. THis does not remove it from the underlying
            map.
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.InsertEntry(NHibernate.Util.SequencedHashMap.Entry)">
            <summary>
            Inserts a new internal entry to the tail of the linked list. This does not add the 
            entry to the underlying map.
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Add(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Contains(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.System#Collections#IEnumerable#GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ContainsKey(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ContainsValue(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.RemoveImpl(System.Object)">
            <summary>
            Remove the Entry identified by the Key if it exists.
            </summary>
            <param name="key">The Key to remove.</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsFixedSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsReadOnly">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Item(System.Object)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Keys">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Values">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Count">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsSynchronized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.SyncRoot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.FirstKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.FirstValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.LastKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.LastValue">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnKey">
            <summary>
            Return only the Key of the DictionaryEntry
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnValue">
            <summary>
            Return only the Value of the DictionaryEntry
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnEntry">
            <summary>
            Return the full DictionaryEntry
            </summary>
        </member>
        <member name="T:NHibernate.Util.ObjectHelpers">
            <summary>
            Various small helper methods.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ObjectHelpers.IdentityToString(System.Object)">
            <summary>
            Return an identifying string representation for the object, taking
            NHibernate proxies into account. The returned string will be "null",
            "classname@hashcode(hash)", or "entityname#identifier". If the object
            is an uninitialized NHibernate proxy, take care not to initialize it.
            </summary>
        </member>
        <member name="T:NHibernate.Util.PropertiesHelper">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Util.ReflectHelper">
            <summary>
            Helper class for Reflection related code.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.OverridesEquals(System.Type)">
            <summary>
            Determine if the specified <see cref="T:System.Type"/> overrides the
            implementation of Equals from <see cref="T:System.Object"/>
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to reflect.</param>
            <returns><see langword="true"/> if any type in the hierarchy overrides Equals(object).</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.OverridesGetHashCode(System.Type)">
            <summary>
            Determine if the specified <see cref="T:System.Type"/> overrides the
            implementation of GetHashCode from <see cref="T:System.Object"/>
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to reflect.</param>
            <returns><see langword="true"/> if any type in the hierarchy overrides GetHashCode().</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetGetter(System.Type,System.String,System.String)">
            <summary>
            Finds the <see cref="T:NHibernate.Properties.IGetter"/> for the property in the <see cref="T:System.Type"/>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the property in.</param>
            <param name="propertyName">The name of the Property to find.</param>
            <param name="propertyAccessorName">The name of the property access strategy.</param>
            <returns>The <see cref="T:NHibernate.Properties.IGetter"/> to get the value of the Property.</returns>
            <remarks>
            This one takes a propertyAccessor name as we might know the correct strategy by now so we avoid Exceptions which are costly
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyType(System.Type,System.String,System.String)">
            <summary>
            Get the NHibernate <see cref="T:NHibernate.Type.IType"/> for the named property of the <see cref="T:System.Type"/>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="name">The name of the property/field to find in the class.</param>
            <param name="access">The name of the property accessor for the property.</param>
            <returns>
            The NHibernate <see cref="T:NHibernate.Type.IType"/> for the named property.
            </returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyClass(System.Type,System.String,System.String)">
            <summary>
            Get the <see cref="T:System.Type"/> for the named property of a type.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the property in.</param>
            <param name="name">The name of the property/field to find in the class.</param>
            <param name="access">The name of the property accessor for the property.</param>
            <returns>The <see cref="T:System.Type"/> for the named property.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyClass(System.String,System.String,System.String)">
            <summary>
            Get the <see cref="T:System.Type"/> for the named property of a type.
            </summary>
            <param name="className">The FullName to find the property in.</param>
            <param name="name">The name of the property/field to find in the class.</param>
            <param name="accessorName">The name of the property accessor for the property.</param>
            <returns>The <see cref="T:System.Type"/> for the named property.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ClassForName(System.String)">
            <summary>
            Returns a reference to the Type.
            </summary>
            <param name="name">The name of the class or a fully qualified name.</param>
            <returns>The Type for the Class.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ClassForFullName(System.String)">
            <summary>
            Load a System.Type given is't name.
            </summary>
            <param name="classFullName">The class FullName or AssemblyQualifiedName</param>
            <returns>The System.Type</returns>
            <remarks>
            If the <paramref name="classFullName"/> don't represent an <see cref="P:System.Type.AssemblyQualifiedName"/>
            the method try to find the System.Type scanning all Assemblies of the <see cref="P:System.AppDomain.CurrentDomain"/>.
            </remarks>
            <exception cref="T:System.TypeLoadException">If no System.Type was found for <paramref name="classFullName"/>.</exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ClassForFullNameOrNull(System.String)">
            <summary>
            Load a System.Type given is't name.
            </summary>
            <param name="classFullName">The class FullName or AssemblyQualifiedName</param>
            <returns>The System.Type or null</returns>
            <remarks>
            If the <paramref name="classFullName"/> don't represent an <see cref="P:System.Type.AssemblyQualifiedName"/>
            the method try to find the System.Type scanning all Assemblies of the <see cref="P:System.AppDomain.CurrentDomain"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.TypeFromAssembly(NHibernate.Util.AssemblyQualifiedTypeName,System.Boolean)">
            <summary>
            Returns a <see cref="T:System.Type"/> from an already loaded Assembly or an
            Assembly that is loaded with a partial name.
            </summary>
            <param name="name">An <see cref="T:NHibernate.Util.AssemblyQualifiedTypeName"/>.</param>
            <param name="throwOnError"><see langword="true"/> if an exception should be thrown
            in case of an error, <see langword="false"/> otherwise.</param>
            <returns>
            A <see cref="T:System.Type"/> object that represents the specified type,
            or <see langword="null"/> if the type cannot be loaded.
            </returns>
            <remarks>
            Attempts to get a reference to the type from an already loaded assembly.  If the 
            type cannot be found then the assembly is loaded using
            <see cref="M:System.Reflection.Assembly.Load(System.String)"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetConstantValue(System.Type,System.String)">
            <summary>
            Returns the value of the static field <paramref name="fieldName"/> of <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> .</param>
            <param name="fieldName">The name of the field in the <paramref name="type"/>.</param>
            <returns>The value contained in the field, or <see langword="null"/> if the type or the field does not exist.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetDefaultConstructor(System.Type)">
            <summary>
            Gets the default no arg constructor for the <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the constructor for.</param>
            <returns>
            The <see cref="T:System.Reflection.ConstructorInfo"/> for the no argument constructor, or <see langword="null"/> if the
            <c>type</c> is an abstract class.
            </returns>
            <exception cref="T:NHibernate.InstantiationException">
            Thrown when there is a problem calling the method GetConstructor on <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetConstructor(System.Type,NHibernate.Type.IType[])">
            <summary>
            Finds the constructor that takes the parameters.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the constructor in.</param>
            <param name="types">The <see cref="T:NHibernate.Type.IType"/> objects to use to find the appropriate constructor.</param>
            <returns>
            An <see cref="T:System.Reflection.ConstructorInfo"/> that can be used to create the type with
            the specified parameters.
            </returns>
            <exception cref="T:NHibernate.InstantiationException">
            Thrown when no constructor with the correct signature can be found.
            </exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.IsAbstractClass(System.Type)">
            <summary>
            Determines if the <see cref="T:System.Type"/> is a non creatable class.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to check.</param>
            <returns><see langword="true"/> if the <see cref="T:System.Type"/> is an Abstract Class or an Interface.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.UnwrapTargetInvocationException(System.Reflection.TargetInvocationException)">
            <summary>
            Unwraps the supplied <see cref="T:System.Reflection.TargetInvocationException"/> 
            and returns the inner exception preserving the stack trace.
            </summary>
            <param name="ex">
            The <see cref="T:System.Reflection.TargetInvocationException"/> to unwrap.
            </param>
            <returns>The unwrapped exception.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.TryGetMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Try to find a method in a given type.
            </summary>
            <param name="type">The given type.</param>
            <param name="method">The method info.</param>
            <returns>The found method or null.</returns>
            <remarks>
            The <paramref name="method"/>, in general, become from another <see cref="N:NHibernate.Type"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.HasProperty(System.Type,System.String)">
            <summary>
            Try to find a property, that can be managed by NHibernate, from a given type.
            </summary>
            <param name="source">The given <see cref="T:System.Type"/>. </param>
            <param name="propertyName">The name of the property to find.</param>
            <returns>true if the property exists; otherwise false.</returns>
            <remarks>
            When the user defines a field.xxxxx access strategy should be because both the property and the field exists.
            NHibernate can work even when the property does not exist but in this case the user should use the appropiate accessor.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.IsMethodOf(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Check if a method is declared in a given <see cref="T:System.Type"/>.
            </summary>
            <param name="source">The method to check.</param>
            <param name="realDeclaringType">The where the method is really declared.</param>
            <returns>True if the method is an implementation of the method declared in <paramref name="realDeclaringType"/>; false otherwise. </returns>
        </member>
        <member name="T:NHibernate.Util.SafetyEnumerable`1">
            <summary>
            Used to ensure a collection filtering a given IEnumerable by a certain type.
            </summary>
            <typeparam name="T">The type used like filter.</typeparam>
        </member>
        <member name="T:NHibernate.Util.SimpleMRUCache">
            <summary> 
            Cache following a "Most Recently Used" (MRU) algorithm for maintaining a
            bounded in-memory size; the "Least Recently Used" (LRU) entry is the first
            available for removal from the cache.
            </summary>
            <remarks>
            This implementation uses a bounded MRU Map to limit the in-memory size of
            the cache.  Thus the size of this cache never grows beyond the stated size. 
            </remarks>
        </member>
        <member name="T:NHibernate.Util.SoftLimitMRUCache">
            <summary> 
            Cache following a "Most Recently Used" (MRY) algorithm for maintaining a
            bounded in-memory size; the "Least Recently Used" (LRU) entry is the first
            available for removal from the cache.
            </summary>
            <remarks>
            This implementation uses a "soft limit" to the in-memory size of the cache,
            meaning that all cache entries are kept within a completely
            {@link java.lang.ref.SoftReference}-based map with the most recently utilized
            entries additionally kept in a hard-reference manner to prevent those cache
            entries soft references from becoming enqueued by the garbage collector.
            Thus the actual size of this cache impl can actually grow beyond the stated
            max size bound as long as GC is not actively seeking soft references for
            enqueuement.
            </remarks>
        </member>
        <member name="T:NHibernate.Util.StringHelper">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Dot">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Underscore">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.CommaSpace">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Comma">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.OpenParen">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.ClosedParen">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.SingleQuote">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.SqlParameter">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.LineSeparators">
            <summary>
            This allows for both CRLF and lone LF line separators.
            </summary>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Repeat(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.ReplaceOnce(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="placeholder"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String)">
            <summary>
            Just a façade for calling string.Split()
            We don't use our StringTokenizer because string.Split() is
            more efficient (but it only works when we don't want to retrieve the delimiters)
            </summary>
            <param name="separators">separators for the tokens of the list</param>
            <param name="list">the string that will be broken into tokens</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String,System.Boolean)">
            <summary>
            Splits the String using the StringTokenizer.  
            </summary>
            <param name="separators">separators for the tokens of the list</param>
            <param name="list">the string that will be broken into tokens</param>
            <param name="include">true to include the separators in the tokens.</param>
            <returns></returns>
            <remarks>
            This is more powerful than Split because you have the option of including or 
            not including the separators in the tokens.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <param name="seperator"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GetFullClassname(System.String)">
            <summary>
            Takes a fully qualified type name and returns the full name of the 
            Class - includes namespaces.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GetClassname(System.String)">
            <summary>
            Takes a fully qualified type name (can include the assembly) and just returns
            the name of the Class.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Qualifier(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Suffix(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="columns"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Suffix(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Prefix(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="columns"></param>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Root(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.BooleanValue(System.String)">
            <summary>
            Converts a <see cref="T:System.String"/> in the format of "true", "t", "false", or "f" to
            a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="value">The string to convert.</param>
            <returns>
            The <c>value</c> converted to a <see cref="T:System.Boolean"/> .
            </returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.ToString(System.Object[])">
            <summary>
            
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Multiply(System.String,System.Collections.IEnumerator,System.Collections.IEnumerator)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="placeholders"></param>
            <param name="replacements"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Multiply(System.String[],System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="strings"></param>
            <param name="placeholder"></param>
            <param name="replacements"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.CountUnquoted(System.String,System.Char)">
            <summary>
            Counts the unquoted instances of the character.
            </summary>
            <param name="str"></param>
            <param name="character"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Qualify(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="prefix"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GenerateAlias(System.String,System.Int32)">
            <summary>
            Generate a nice alias for the given class name or collection role
            name and unique integer. Subclasses do <em>not</em> have to use
            aliases of this form.
            </summary>
            <returns>an alias of the form <c>foo1_</c></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.InternedIfPossible(System.String)">
            <summary>
            Returns the interned string equal to <paramref name="str"/> if there is one, or <paramref name="str"/>
            otherwise.
            </summary>
            <param name="str">A <see cref="T:System.String"/></param>
            <returns>A <see cref="T:System.String"/></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.IndexOfAnyNewLine(System.String,System.Int32,System.Int32@)">
            <summary>
            Return the index of the next line separator, starting at startIndex. If will match
            the first CRLF or LF line separator. If there is no match, -1 will be returned. When
            returning, newLineLength will be set to the number of characters in the matched line
            separator (1 if LF was found, 2 if CRLF was found).
            </summary>
        </member>
        <member name="M:NHibernate.Util.StringHelper.IsAnyNewLine(System.String,System.Int32,System.Int32@)">
            <summary>
            Check if the given index points to a line separator in the string. Both CRLF and LF
            line separators are handled. When returning, newLineLength will be set to the number
            of characters matched in the line separator. It will be 2 if a CRLF matched, 1 if LF
            matched, and 0 if the index doesn't indicate (the start of) a line separator.
            </summary>
        </member>
        <member name="T:NHibernate.Util.StringTokenizer">
            <summary>
            A StringTokenizer java like object 
            </summary>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="delim"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="delim"></param>
            <param name="returnDelims"></param>
        </member>
        <member name="T:NHibernate.Util.UnmodifiableDictionary`2">
            <summary>
            Returns an unmodifiable view of the specified IDictionary. 
            This method allows modules to provide users with "read-only" access to internal dictionary. 
            Query operations on the returned dictionary "read through" to the specified dictionary, 
            and attempts to modify the returned dictionary, 
            whether direct or via its collection views, result in an <see cref="T:System.NotSupportedException"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
        </member>
        <member name="M:NHibernate.Util.UnmodifiableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the UnmodifiableDictionary class that contains elements wrapped
            from the specified IDictionary. 
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"/>  whose elements are wrapped.</param>
        </member>
        <member name="P:NHibernate.Util.WeakHashtable.Count">
            <summary>
            Count of elements in the collection. Unreliable!
            </summary>
        </member>
        <member name="T:NHibernate.AssertionFailure">
            <summary>
            Indicates failure of an assertion: a possible bug in NHibernate
            </summary>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.CacheMode">
            <summary>
            Controls how the session interacts with the second-level
            cache and query cache.
            </summary>
        </member>
        <member name="F:NHibernate.CacheMode.Ignore">
            <summary> 
            The session will never interact with the cache, except to invalidate
            cache items when updates occur
            </summary>
        </member>
        <member name="F:NHibernate.CacheMode.Put">
            <summary> 
            The session will never read items from the cache, but will add items
            to the cache as it reads them from the database.
            </summary>
        </member>
        <member name="F:NHibernate.CacheMode.Get">
            <summary> 
            The session may read items from the cache, but will not add items, 
            except to invalidate items when updates occur
            </summary>
        </member>
        <member name="F:NHibernate.CacheMode.Normal">
            <summary> The session may read items from the cache, and add items to the cache</summary>
        </member>
        <member name="F:NHibernate.CacheMode.Refresh">
            <summary> 
            The session will never read items from the cache, but will add items
            to the cache as it reads them from the database. In this mode, the
            effect of <tt>hibernate.cache.use_minimal_puts</tt> is bypassed, in
            order to <em>force</em> a cache refresh
            </summary>
        </member>
        <member name="T:NHibernate.CallbackException">
            <summary></summary>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.CriteriaTransformer">
            <summary>
            Transforms Criteria queries
            </summary>
        </member>
        <member name="M:NHibernate.CriteriaTransformer.TransformToRowCount(NHibernate.Criterion.DetachedCriteria)">
            <summary>
             Returns a clone of the original criteria, which will return the count 
             of rows that are returned by the original criteria query.
            </summary>
        </member>
        <member name="M:NHibernate.CriteriaTransformer.TransformToRowCount(NHibernate.ICriteria)">
            <summary>
             Returns a clone of the original criteria, which will return the count 
             of rows that are returned by the original criteria query.
            </summary>
        </member>
        <member name="M:NHibernate.CriteriaTransformer.Clone(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Creates an exact clone of the criteria
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.CriteriaTransformer.Clone(NHibernate.ICriteria)">
            <summary>
            Creates an exact clone of the criteria
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.DuplicateMappingException.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="customMessage">The message that describes the error. </param>
            <param name="name">The name of the duplicate object</param>
            <param name="type">The type of the duplicate object</param>
        </member>
        <member name="M:NHibernate.DuplicateMappingException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="name">The name of the duplicate object</param>
            <param name="type">The type of the duplicate object</param>
        </member>
        <member name="M:NHibernate.DuplicateMappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.DuplicateMappingException.Type">
            <summary>
            The type of the duplicated object
            </summary>
        </member>
        <member name="P:NHibernate.DuplicateMappingException.Name">
            <summary>
            The name of the duplicated object
            </summary>
        </member>
        <member name="T:NHibernate.IInterceptor">
            <summary>
            Allows user code to inspect and/or change property values before they are written and after they
            are read from the database
            </summary>
            <remarks>
            <para>
            There might be a single instance of <c>IInterceptor</c> for a <c>SessionFactory</c>, or a new
            instance might be specified for each <c>ISession</c>. Whichever approach is used, the interceptor
            must be serializable if the <c>ISession</c> is to be serializable. This means that <c>SessionFactory</c>
            -scoped interceptors should implement <c>ReadResolve()</c>.
            </para>
            <para>
            The <c>ISession</c> may not be invoked from a callback (nor may a callback cause a collection or
            proxy to be lazily initialized).
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IInterceptor.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called just before an object is initialized
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
            <returns><see langword="true" /> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
            <param name="currentState"></param>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
            <returns><see langword="true" /> if the user modified the <c>currentState</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is saved
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
            <returns><see langword="true" /> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is deleted
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.IInterceptor.OnCollectionRecreate(System.Object,System.Object)">
            <summary> Called before a collection is (re)created.</summary>
        </member>
        <member name="M:NHibernate.IInterceptor.OnCollectionRemove(System.Object,System.Object)">
            <summary> Called before a collection is deleted.</summary>
        </member>
        <member name="M:NHibernate.IInterceptor.OnCollectionUpdate(System.Object,System.Object)">
            <summary> Called before a collection is updated.</summary>
        </member>
        <member name="M:NHibernate.IInterceptor.PreFlush(System.Collections.ICollection)">
            <summary>
            Called before a flush
            </summary>
            <param name="entities">The entities</param>
        </member>
        <member name="M:NHibernate.IInterceptor.PostFlush(System.Collections.ICollection)">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
            <param name="entities">The entitites</param>
        </member>
        <member name="M:NHibernate.IInterceptor.IsTransient(System.Object)">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><see langword="true" /> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><see langword="false" /> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><see langword="null" /> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <param name="entity">A transient entity</param>
            <returns>Boolean or <see langword="null" /> to choose default behaviour</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><see langword="null" /> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="entity">A persistent entity</param>
            <param name="currentState"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <see langword="null" /> to choose default behavior</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.Instantiate(System.String,NHibernate.EntityMode,System.Object)">
            <summary>
            Instantiate the entity class. Return <see langword="null" /> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
            <param name="entityName">the name of the entity </param>
            <param name="entityMode">The type of entity instance to be returned. </param>
            <param name="id">the identifier of the new instance </param>
            <returns>An instance of the class, or <see langword="null" /> to choose default behaviour</returns>
            <remarks>
            The identifier property of the returned instance
            should be initialized with the given identifier.
            </remarks>
        </member>
        <member name="M:NHibernate.IInterceptor.GetEntityName(System.Object)">
            <summary> Get the entity name for a persistent or transient instance</summary>
            <param name="entity">an entity instance </param>
            <returns> the name of the entity </returns>
        </member>
        <member name="M:NHibernate.IInterceptor.GetEntity(System.String,System.Object)">
            <summary> Get a fully loaded entity instance that is cached externally</summary>
            <param name="entityName">the name of the entity </param>
            <param name="id">the instance identifier </param>
            <returns> a fully initialized entity </returns>
        </member>
        <member name="M:NHibernate.IInterceptor.AfterTransactionBegin(NHibernate.ITransaction)">
            <summary>
            Called when a NHibernate transaction is begun via the NHibernate <see cref="T:NHibernate.ITransaction"/>
            API. Will not be called if transactions are being controlled via some other mechanism.
            </summary>
        </member>
        <member name="M:NHibernate.IInterceptor.BeforeTransactionCompletion(NHibernate.ITransaction)">
            <summary>
            Called before a transaction is committed (but not before rollback).
            </summary>
        </member>
        <member name="M:NHibernate.IInterceptor.AfterTransactionCompletion(NHibernate.ITransaction)">
            <summary>
            Called after a transaction is committed or rolled back.
            </summary>
        </member>
        <member name="M:NHibernate.IInterceptor.OnPrepareStatement(NHibernate.SqlCommand.SqlString)">
            <summary> Called when sql string is being prepared. </summary>
            <param name="sql">sql to be prepared </param>
            <returns> original or modified sql </returns>
        </member>
        <member name="M:NHibernate.IInterceptor.SetSession(NHibernate.ISession)">
            <summary>
            Called when a session-scoped (and <b>only</b> session scoped) interceptor is attached
            to a session
            </summary>
            <remarks>
            session-scoped-interceptor is an instance of the interceptor used only for one session.
            The use of singleton-interceptor may cause problems in multi-thread scenario. 
            </remarks>
            <seealso cref="M:NHibernate.ISessionFactory.OpenSession(NHibernate.IInterceptor)"/>
            <seealso cref="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection,NHibernate.IInterceptor)"/>
        </member>
        <member name="T:NHibernate.EntityMode">
            <summary> Defines the representation modes available for entities. </summary>
        </member>
        <member name="T:NHibernate.FetchMode">
            <summary>
            Represents a fetching strategy.
            </summary>
            <remarks>
            This is used together with the <see cref="T:NHibernate.ICriteria"/> API to specify
            runtime fetching strategies.
            <para>
            For Hql queries, use the <c>FETCH</c> keyword instead.
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.FetchMode.Default">
            <summary>
            Default to the setting configured in the mapping file.
            </summary>
        </member>
        <member name="F:NHibernate.FetchMode.Select">
            <summary>
            Fetch eagerly, using a separate select. Equivalent to
            <c>fetch="select"</c> (and <c>outer-join="false"</c>)
            </summary>
        </member>
        <member name="F:NHibernate.FetchMode.Join">
            <summary>
            Fetch using an outer join.  Equivalent to
            <c>fetch="join"</c> (and <c>outer-join="true"</c>)
            </summary>
        </member>
        <member name="T:NHibernate.FKUnmatchingColumnsException">
            <summary>
            Indicates that an expected getter or setter method could not be found on a class
            </summary>
        </member>
        <member name="M:NHibernate.FKUnmatchingColumnsException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.FKUnmatchingColumnsException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.FKUnmatchingColumnsException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.FlushMode">
            <summary>
            Represents a flushing strategy.
            </summary>
            <remarks>
            The flush process synchronizes database state with session state by detecting state
            changes and executing SQL statements
            </remarks>
        </member>
        <member name="F:NHibernate.FlushMode.Unspecified">
            <summary>
            Special value for unspecified flush mode (like <see langword="null" /> in Java).
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Never">
            <summary>
            The <c>ISession</c> is never flushed unless <c>Flush()</c> is explicitly
            called by the application. This mode is very efficient for read only
            transactions
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Commit">
            <summary>
            The <c>ISession</c> is flushed when <c>Transaction.Commit()</c> is called
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Auto">
            <summary>
            The <c>ISession</c> is sometimes flushed before query execution in order to
            ensure that queries never return stale state. This is the default flush mode.
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Always">
            <summary> 
            The <see cref="T:NHibernate.ISession"/> is flushed before every query. This is
            almost always unnecessary and inefficient.
            </summary>
        </member>
        <member name="T:NHibernate.IDatabinder">
            <summary>
            Provides XML marshalling for classes registered with a <c>SessionFactory</c>
            </summary>
            <remarks>
            <para>
            Hibernate defines a generic XML format that may be used to represent any class
            (<c>hibernate-generic.dtd</c>). The user configures an XSLT stylesheet for marshalling
            data from this generic format to an application and/or user readable format. By default,
            Hibernate will use <c>hibernate-default.xslt</c> which maps data to a useful human-
            readable format.
            </para>
            <para>
            The property <c>xml.output_stylesheet</c> specifies a user-written stylesheet.
            Hibernate will attempt to load the stylesheet from the classpath first and if not found,
            will attempt to load it as a file
            </para>
            <para>
            It is not intended that implementors be threadsafe
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IDatabinder.Bind(System.Object)">
            <summary>
            Add an object to the output document.
            </summary>
            <param name="obj">A transient or persistent instance</param>
            <returns>Databinder</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.BindAll(System.Collections.ICollection)">
            <summary>
            Add a collection of objects to the output document
            </summary>
            <param name="objs">A collection of transient or persistent instance</param>
            <returns>Databinder</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToGenericXml">
            <summary>
            Output the generic XML representation of the bound objects
            </summary>
            <returns>Generic Xml representation</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToGenericXmlDocument">
            <summary>
            Output the generic XML Representation of the bound objects
            to a <c>XmlDocument</c>
            </summary>
            <returns>A generic Xml tree</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToXML">
            <summary>
            Output the custom XML representation of the bound objects
            </summary>
            <returns>Custom Xml representation</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToXmlDocument">
            <summary>
            Output the custom XML representation of the bound objects as
            an <c>XmlDocument</c>
            </summary>
            <returns>A custom Xml Tree</returns>
        </member>
        <member name="P:NHibernate.IDatabinder.InitializeLazy">
            <summary>
            Controls whether bound objects (and their associated objects) that are lazily instanciated
            are explicityl initialized or left as they are
            </summary>
            <value>True to explicitly initilize lazy objects, false to leave them in the state they are in</value>
        </member>
        <member name="M:NHibernate.IdentityEqualityComparer.Equals(System.Object,System.Object)">
             <summary>
             Performs a null safe comparison using "==" instead of Object.Equals()
             </summary>
             <param name="x">First object to compare.</param>
             <param name="y">Second object to compare.</param>
             <returns>
             true if x is the same instance as y or if both are null references; otherwise, false.
            </returns>
             <remarks>
             This is Lazy collection safe since it uses <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>, 
             unlike <c>Object.Equals()</c> which currently causes NHibernate to load up the collection.
             This behaivior of Collections is likely to change because Java's collections override Equals() and 
             .net's collections don't. So in .net there is no need to override Equals() and 
             GetHashCode() on the NHibernate Collection implementations.
             </remarks>
        </member>
        <member name="T:NHibernate.InstantiationException">
            <summary>
            Thrown if Hibernate can't instantiate an entity or component class at runtime.
            </summary>
        </member>
        <member name="M:NHibernate.InstantiationException.#ctor(System.String,System.Exception,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was trying to instantiate.</param>
        </member>
        <member name="M:NHibernate.InstantiationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.InstantiationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.InstantiationException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying to instantiate.
            </summary>
        </member>
        <member name="P:NHibernate.InstantiationException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.InstantiationException"/>.
            </summary>
            <value>
            The error message that explains the reason for this exception and the Type that
            was trying to be instantiated.
            </value>
        </member>
        <member name="T:NHibernate.InvalidProxyTypeException">
            <summary>
            Thrown when an invalid type is specified as a proxy for a class.
            The exception is also thrown when a class is specified as lazy,
            but cannot be used as a proxy for itself.
            </summary>
        </member>
        <member name="T:NHibernate.LazyInitializationException">
            <summary>
            A problem occurred trying to lazily initialize a collection or proxy (for example the session
            was closed) or iterate query results.
            </summary>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.String,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="entityName">The name of the entity where the exception was thrown</param>
            <param name="entityId">The id of the entity where the exception was thrown</param>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.LockMode">
            <summary>
            Instances represent a lock mode for a row of a relational database table.
            </summary>
            <remarks>
            It is not intended that users spend much time worrying about locking since Hibernate
            usually obtains exactly the right lock level automatically. Some "advanced" users may
            wish to explicitly specify lock levels.
            </remarks>
        </member>
        <member name="M:NHibernate.LockMode.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.LockMode.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.LockMode.GreaterThan(NHibernate.LockMode)">
            <summary>
            Is this lock mode more restrictive than the given lock mode?
            </summary>
            <param name="mode"></param>
        </member>
        <member name="M:NHibernate.LockMode.LessThan(NHibernate.LockMode)">
            <summary>
            Is this lock mode less restrictive than the given lock mode?
            </summary>
            <param name="mode"></param>
        </member>
        <member name="F:NHibernate.LockMode.None">
            <summary>
            No lock required. 
            </summary>
            <remarks>
            If an object is requested with this lock mode, a <c>Read</c> lock
            might be obtained if necessary.
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Read">
            <summary>
            A shared lock. 
            </summary>
            <remarks>
            Objects are loaded in <c>Read</c> mode by default
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Upgrade">
            <summary>
            An upgrade lock. 
            </summary>
            <remarks>
            Objects loaded in this lock mode are materialized using an
            SQL <c>SELECT ... FOR UPDATE</c>
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.UpgradeNoWait">
            <summary>
            Attempt to obtain an upgrade lock, using an Oracle-style
            <c>SELECT ... FOR UPGRADE NOWAIT</c>. 
            </summary>
            <remarks>
            The semantics of this lock mode, once obtained, are the same as <c>Upgrade</c>
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Write">
            <summary>
            A <c>Write</c> lock is obtained when an object is updated or inserted.
            </summary>
            <remarks>
            This is not a valid mode for <c>Load()</c> or <c>Lock()</c>.
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Force">
            <summary> 
            Similar to <see cref="F:NHibernate.LockMode.Upgrade"/> except that, for versioned entities,
            it results in a forced version increment.
            </summary>
        </member>
        <member name="T:NHibernate.NHibernateUtil">
            <summary>
            Provides access to the full range of NHibernate built-in types.
            IType instances may be used to bind values to query parameters.
            Also a factory for new Blobs and Clobs.
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GuessType(System.Object)">
            <summary>
            Guesses the IType of this object
            </summary>
            <param name="obj">The obj.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GuessType(System.Type)">
            <summary>
            Guesses the IType by the type
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="F:NHibernate.NHibernateUtil.AnsiString">
            <summary>
            NHibernate Ansi String type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Binary">
            <summary>
            NHibernate binary type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.BinaryBlob">
            <summary>
            NHibernate binary blob type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Boolean">
            <summary>
            NHibernate boolean type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Byte">
            <summary>
            NHibernate byte type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Character">
            <summary>
            NHibernate character type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.CultureInfo">
            <summary>
            NHibernate Culture Info type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.DateTime">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.DateTime2">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.LocalDateTime">
            <summary>
            NHibernate local date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UtcDateTime">
            <summary>
            NHibernate utc date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.DateTimeOffset">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Date">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Decimal">
            <summary>
            NHibernate decimal type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Double">
            <summary>
            NHibernate double type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Currency">
            <summary>
            NHibernate Currency type (System.Decimal - DbType.Currency)
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Guid">
            <summary>
            NHibernate Guid type.
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int16">
            <summary>
            NHibernate System.Int16 (short in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int32">
            <summary>
            NHibernate System.Int32 (int in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int64">
            <summary>
            NHibernate System.Int64 (long in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.SByte">
            <summary>
            NHibernate System.SByte type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt16">
            <summary>
            NHibernate System.UInt16 (ushort in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt32">
            <summary>
            NHibernate System.UInt32 (uint in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt64">
            <summary>
            NHibernate System.UInt64 (ulong in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Single">
            <summary>
            NHibernate System.Single (float in C#) Type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.String">
            <summary>
            NHibernate String type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.StringClob">
            <summary>
            NHibernate string clob type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Time">
            <summary>
            NHibernate Time type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Ticks">
            <summary>
            NHibernate Ticks type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.TimeAsTimeSpan">
            <summary>
            NHibernate Ticks type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.TimeSpan">
            <summary>
            NHibernate Ticks type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Timestamp">
            <summary>
            NHibernate Timestamp type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.TrueFalse">
            <summary>
            NHibernate TrueFalse type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.YesNo">
            <summary>
            NHibernate YesNo type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Class">
            <summary>
            NHibernate class type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.ClassMetaType">
            <summary>
            NHibernate class meta type for association of kind <code>any</code>.
            </summary>
            <seealso cref="T:NHibernate.Type.AnyType"/>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Serializable">
            <summary>
            NHibernate serializable type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Object">
            <summary>
            NHibernate System.Object type
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Enum(System.Type)">
            <summary>
            A NHibernate persistent enum type
            </summary>
            <param name="enumClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GetSerializable(System.Type)">
            <summary>
            A NHibernate serializable type
            </summary>
            <param name="serializableClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Any(NHibernate.Type.IType,NHibernate.Type.IType)">
            <summary>
            A NHibernate serializable type
            </summary>
            <param name="metaType">a type mapping <see cref="T:NHibernate.Type.IType"/> to a single column</param>
            <param name="identifierType">the entity identifier type</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Entity(System.Type)">
            <summary>
            A NHibernate persistent object (entity) type
            </summary>
            <param name="persistentClass">a mapped entity class</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Entity(System.String)">
            <summary> A Hibernate persistent object (entity) type. </summary>
            <param name="entityName">a mapped entity class </param>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Custom(System.Type)">
            <summary>
            A NHibernate custom type
            </summary>
            <param name="userTypeClass">a class that implements UserType</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Initialize(System.Object)">
            <summary>
            Force initialization of a proxy or persistent collection.
            </summary>
            <param name="proxy">a persistable object, proxy, persistent collection or null</param>
            <exception cref="T:NHibernate.HibernateException">if we can't initialize the proxy at this time, eg. the Session was closed</exception>
        </member>
        <member name="M:NHibernate.NHibernateUtil.IsInitialized(System.Object)">
            <summary>
            Is the proxy or persistent collection initialized?
            </summary>
            <param name="proxy">a persistable object, proxy, persistent collection or null</param>
            <returns>true if the argument is already initialized, or is not a proxy or collection</returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GetClass(System.Object)">
            <summary>
            Get the true, underlying class of a proxied persistent class. This operation
            will initialize a proxy by side-effect.
            </summary>
            <param name="proxy">a persistable object or proxy</param>
            <returns>the true class of the instance</returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Close(System.Collections.IEnumerator)">
            <summary>
            Close an <see cref="T:System.Collections.IEnumerator"/> obtained from an <see cref="T:System.Collections.IEnumerable"/>
            returned by NHibernate immediately, instead of waiting until the session is
            closed or disconnected.
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Close(System.Collections.IEnumerable)">
            <summary>
            Close an <see cref="T:System.Collections.IEnumerable"/> returned by NHibernate immediately,
            instead of waiting until the session is closed or disconnected.
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.IsPropertyInitialized(System.Object,System.String)">
            <summary> 
            Check if the property is initialized. If the named property does not exist
            or is not persistent, this method always returns <tt>true</tt>. 
            </summary>
            <param name="proxy">The potential proxy </param>
            <param name="propertyName">the name of a persistent attribute of the object </param>
            <returns> 
            true if the named property of the object is not listed as uninitialized;
            false if the object is an uninitialized proxy, or the named property is uninitialized 
            </returns>
        </member>
        <member name="T:NHibernate.NonUniqueObjectException">
            <summary>
            This exception is thrown when an operation would
            break session-scoped identity. This occurs if the
            user tries to associate two different instances of
            the same class with a particular identifier,
            in the scope of a single <see cref="T:NHibernate.ISession"/>.
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.String,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="id">The identifier of the object that caused the exception.</param>
            <param name="entityName">The EntityName of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
            <param name="id">The identifier of the object that caused the exception.</param>
            <param name="entityName">The EntityName of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.NonUniqueResultException">
            <summary>
            Thrown when the application calls <see cref="M:NHibernate.IQuery.UniqueResult">IQuery.UniqueResult()</see> 
            and the query returned more than one result. Unlike all other NHibernate 
            exceptions, this one is recoverable!
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException"/> class.
            </summary>
            <param name="resultCount">The number of items in the result.</param>
        </member>
        <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ObjectDeletedException">
            <summary>
            Thrown when the user tries to pass a deleted object to the <c>ISession</c>.
            </summary>
        </member>
        <member name="T:NHibernate.UnresolvableObjectException">
            <summary>
            Thrown when Hibernate could not resolve an object by id, especially when
            loading an association.
            </summary>
        </member>
        <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException"/> class.
            </summary>
            <param name="identifier">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="identifier">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.ObjectDeletedException.#ctor(System.String,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.ObjectDeletedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ObjectNotFoundException">
            <summary>
            Thrown when <c>ISession.Load()</c> fails to select a row with
            the given primary key (identifier value). This exception might not
            be thrown when <c>Load()</c> is called, even if there was no
            row on the database, because <c>Load()</c> returns a proxy if
            possible. Applications should use <c>ISession.Get()</c> to test if 
            a row exists in the database.
            </summary>
        </member>
        <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException"/> class.
            </summary>
            <param name="identifier">The identifier of the object that was attempting to be loaded.</param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was trying to find a row for in the database.</param>
        </member>
        <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.PersistentObjectException">
            <summary>
            Thrown when the user passes a persistent instance to a <c>ISession</c> method that expects a
            transient instance
            </summary>
        </member>
        <member name="M:NHibernate.PersistentObjectException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.PersistentObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.PropertyAccessException">
            <summary>
            A problem occurred accessing a property of an instance of a persistent class by reflection
            </summary>
        </member>
        <member name="M:NHibernate.PropertyAccessException.#ctor(System.Exception,System.String,System.Boolean,System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
            <param name="wasSetter">A <see cref="T:System.Boolean"/> indicating if this was a "setter" operation.</param>
            <param name="persistentType">The <see cref="T:System.Type"/> that NHibernate was trying find the Property or Field in.</param>
            <param name="propertyName">The mapped property name that was trying to be accessed.</param>
        </member>
        <member name="M:NHibernate.PropertyAccessException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyAccessException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyAccessException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.PropertyAccessException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying find the Property or Field in.
            </summary>
        </member>
        <member name="P:NHibernate.PropertyAccessException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.PropertyAccessException"/>.
            </summary>
            <value>
            The error message that explains the reason for this exception and 
            information about the mapped property and its usage.
            </value>
        </member>
        <member name="T:NHibernate.PropertyNotFoundException">
            <summary>
            Indicates that an expected getter or setter method could not be found on a class
            </summary>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class,
            used when a property get/set accessor is missing.
            </summary>
            <param name="targetType">The <see cref="T:System.Type"/> that is missing the property</param>
            <param name="propertyName">The name of the missing property</param>
            <param name="accessorType">The type of the missing accessor
            ("getter" or "setter")</param>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class,
            used when a field is missing.
            </summary>
            <param name="targetType">The <see cref="T:System.Type"/> that is missing the field</param>
            <param name="propertyName">The name of the missing property</param>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyValueException.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="entityName">The <see cref="T:System.Type"/> that NHibernate was trying to access.</param>
            <param name="propertyName">The name of the Property that was being get/set.</param>
        </member>
        <member name="M:NHibernate.PropertyValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyValueException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyValueException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ReplicationMode">
            <summary> 
            Represents a replication strategy. 
            </summary>
            <seealso cref="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)"/>
        </member>
        <member name="M:NHibernate.ReplicationMode.ExceptionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Throw an exception when a row already exists
            </summary>
        </member>
        <member name="M:NHibernate.ReplicationMode.IgnoreReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Ignore replicated entities when a row already exists
            </summary>
        </member>
        <member name="M:NHibernate.ReplicationMode.LatestVersionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            When a row already exists, choose the latest version
            </summary>
        </member>
        <member name="M:NHibernate.ReplicationMode.OverwriteReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Overwrite existing rows when a row already exists
            </summary>
        </member>
        <member name="T:NHibernate.StaleObjectStateException">
            <summary>
            Thrown when a version number check failed, indicating that the 
            <see cref="T:NHibernate.ISession"/> contained stale data (when using long transactions with
            versioning).
            </summary>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException"/> class.
            </summary>
            <param name="entityName">The EntityName that NHibernate was trying to update in the database.</param>
            <param name="identifier">The identifier of the object that is stale.</param>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.StaleObjectStateException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.EntityName">
            <summary>
            Gets the EntityName that NHibernate was trying to update in the database.
            </summary>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.Identifier">
            <summary>
            Gets the identifier of the object that is stale.
            </summary>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.StaleObjectStateException"/>.
            </summary>
            <value>The error message that explains the reason for this exception.</value>
        </member>
        <member name="T:NHibernate.TransactionException">
            <summary>
            Indicated that a transaction could not be begun, committed, or rolled back
            </summary>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.TransientObjectException">
            <summary>
            Throw when the user passes a transient instance to a <c>ISession</c> method that expects
            a persistent instance
            </summary>
        </member>
        <member name="M:NHibernate.TransientObjectException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.TransientObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.TypeMismatchException">
            <summary> 
            Used when a user provided type does not match the expected one 
            </summary>
        </member>
        <member name="T:NHibernate.WrongClassException">
            <summary>
            Thrown when <c>ISession.Load()</c> selects a row with the given primary key (identifier value)
            but the row's discriminator value specifies a different subclass from the one requested
            </summary>
        </member>
        <member name="M:NHibernate.WrongClassException.#ctor(System.String,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="identifier">The identifier of the object that was being loaded.</param>
            <param name="entityName">The name of entity that NHibernate was told to load.</param>
        </member>
        <member name="M:NHibernate.WrongClassException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.WrongClassException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.WrongClassException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.WrongClassException.Identifier">
            <summary>
            Gets the identifier of the object that was being loaded.
            </summary>
        </member>
        <member name="P:NHibernate.WrongClassException.EntityName">
            <summary>
            Gets the name of entity that NHibernate was told to load.
            </summary>
        </member>
        <member name="P:NHibernate.WrongClassException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.WrongClassException"/>.
            </summary>
            <value>The error message that explains the reason for this exception.</value>
        </member>
    </members>
</doc>
