/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	function Calendars() {
		this.regionalOptions = [];
		this.regionalOptions[''] = {
			invalidCalendar: 'Calendar {0} not found',
			invalidDate: 'Invalid {0} date',
			invalidMonth: 'Invalid {0} month',
			invalidYear: 'Invalid {0} year',
			differentCalendars: 'Cannot mix {0} and {1} dates'
		};
		this.local = this.regionalOptions[''];
		this.calendars = {};
		this._localCals = {};
	}

	/** Create the calendars plugin.
		<p>Provides support for various world calendars in a consistent manner.</p>
	 	@class Calendars
		@example $.calendars.instance('julian').newDate(2014, 12, 25) */
	$.extend(Calendars.prototype, {

		/** Obtain a calendar implementation and localisation.
			@memberof Calendars
			@param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
			@param [language=''] {string} The language code to use for localisation (default is English).
			@return {Calendar} The calendar and localisation.
			@throws Error if calendar not found. */
		instance: function(name, language) {
			name = (name || 'gregorian').toLowerCase();
			language = language || '';
			var cal = this._localCals[name + '-' + language];
			if (!cal && this.calendars[name]) {
				cal = new this.calendars[name](language);
				this._localCals[name + '-' + language] = cal;
			}
			if (!cal) {
				throw (this.local.invalidCalendar || this.regionalOptions[''].invalidCalendar).
					replace(/\{0\}/, name);
			}
			return cal;
		},

		/** Create a new date - for today if no other parameters given.
			@memberof Calendars
			@param year {CDate|number} The date to copy or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
			@param [language=''] {string} The language to use for localisation (default English).
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day, calendar, language) {
			calendar = (year != null && year.year ? year.calendar() : (typeof calendar === 'string' ?
				this.instance(calendar, language) : calendar)) || this.instance();
			return calendar.newDate(year, month, day);
		}
	});

	/** Generic date, based on a particular calendar.
		@class CDate
		@param calendar {BaseCalendar} The underlying calendar implementation.
		@param year {number} The year for this date.
		@param month {number} The month for this date.
		@param day {number} The day for this date.
		@return {CDate} The date object.
		@throws Error if an invalid date. */
	function CDate(calendar, year, month, day) {
		this._calendar = calendar;
		this._year = year;
		this._month = month;
		this._day = day;
		if (this._calendar._validateLevel === 0 &&
				!this._calendar.isValid(this._year, this._month, this._day)) {
			throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
				replace(/\{0\}/, this._calendar.local.name);
		}
	}

	/** Pad a numeric value with leading zeroes.
		@private
		@param value {number} The number to format.
		@param length {number} The minimum length.
		@return {string} The formatted number. */
	function pad(value, length) {
		value = '' + value;
		return '000000'.substring(0, length - value.length) + value;
	}

	$.extend(CDate.prototype, {

		/** Create a new date.
			@memberof CDate
			@param [year] {CDate|number} The date to copy or the year for the date (default this date).
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day) {
			return this._calendar.newDate((year == null ? this : year), month, day);
		},

		/** Set or retrieve the year for this date.
			@memberof CDate
			@param [year] {number} The year for the date.
			@return {number|CDate} The date's year (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		year: function(year) {
			return (arguments.length === 0 ? this._year : this.set(year, 'y'));
		},

		/** Set or retrieve the month for this date.
			@memberof CDate
			@param [month] {number} The month for the date.
			@return {number|CDate} The date's month (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		month: function(month) {
			return (arguments.length === 0 ? this._month : this.set(month, 'm'));
		},

		/** Set or retrieve the day for this date.
			@memberof CDate
			@param [day] {number} The day for the date.
			@return {number|CData} The date's day (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		day: function(day) {
			return (arguments.length === 0 ? this._day : this.set(day, 'd'));
		},

		/** Set new values for this date.
			@memberof CDate
			@param year {number} The year for the date.
			@param month {number} The month for the date.
			@param day {number} The day for the date.
			@return {CDate} The updated date.
			@throws Error if an invalid date. */
		date: function(year, month, day) {
			if (!this._calendar.isValid(year, month, day)) {
				throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
					replace(/\{0\}/, this._calendar.local.name);
			}
			this._year = year;
			this._month = month;
			this._day = day;
			return this;
		},

		/** Determine whether this date is in a leap year.
			@memberof CDate
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
		leapYear: function() {
			return this._calendar.leapYear(this);
		},

		/** Retrieve the epoch designator for this date, e.g. BCE or CE.
			@memberof CDate
			@return {string} The current epoch. */
		epoch: function() {
			return this._calendar.epoch(this);
		},

		/** Format the year, if not a simple sequential number.
			@memberof CDate
			@return {string} The formatted year. */
		formatYear: function() {
			return this._calendar.formatYear(this);
		},

		/** Retrieve the month of the year for this date,
			i.e. the month's position within a numbered year.
			@memberof CDate
			@return {number} The month of the year: <code>minMonth</code> to months per year. */
		monthOfYear: function() {
			return this._calendar.monthOfYear(this);
		},

		/** Retrieve the week of the year for this date.
			@memberof CDate
			@return {number} The week of the year: 1 to weeks per year. */
		weekOfYear: function() {
			return this._calendar.weekOfYear(this);
		},

		/** Retrieve the number of days in the year for this date.
			@memberof CDate
			@return {number} The number of days in this year. */
		daysInYear: function() {
			return this._calendar.daysInYear(this);
		},

		/** Retrieve the day of the year for this date.
			@memberof CDate
			@return {number} The day of the year: 1 to days per year. */
		dayOfYear: function() {
			return this._calendar.dayOfYear(this);
		},

		/** Retrieve the number of days in the month for this date.
			@memberof CDate
			@return {number} The number of days. */
		daysInMonth: function() {
			return this._calendar.daysInMonth(this);
		},

		/** Retrieve the day of the week for this date.
			@memberof CDate
			@return {number} The day of the week: 0 to number of days - 1. */
		dayOfWeek: function() {
			return this._calendar.dayOfWeek(this);
		},

		/** Determine whether this date is a week day.
			@memberof CDate
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
		weekDay: function() {
			return this._calendar.weekDay(this);
		},

		/** Retrieve additional information about this date.
			@memberof CDate
			@return {object} Additional information - contents depends on calendar. */
		extraInfo: function() {
			return this._calendar.extraInfo(this);
		},

		/** Add period(s) to a date.
			@memberof CDate
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		add: function(offset, period) {
			return this._calendar.add(this, offset, period);
		},

		/** Set a portion of the date.
			@memberof CDate
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if not a valid date. */
		set: function(value, period) {
			return this._calendar.set(this, value, period);
		},

		/** Compare this date to another date.
			@memberof CDate
			@param date {CDate} The other date.
			@return {number} -1 if this date is before the other date,
					0 if they are equal, or +1 if this date is after the other date. */
		compareTo: function(date) {
			if (this._calendar.name !== date._calendar.name) {
				throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
					replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
			}
			var c = (this._year !== date._year ? this._year - date._year :
				this._month !== date._month ? this.monthOfYear() - date.monthOfYear() :
				this._day - date._day);
			return (c === 0 ? 0 : (c < 0 ? -1 : +1));
		},

		/** Retrieve the calendar backing this date.
			@memberof CDate
			@return {BaseCalendar} The calendar implementation. */
		calendar: function() {
			return this._calendar;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof CDate
			@return {number} The equivalent Julian date. */
		toJD: function() {
			return this._calendar.toJD(this);
		},

		/** Create a new date from a Julian date.
			@memberof CDate
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			return this._calendar.fromJD(jd);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@return {Date} The equivalent JavaScript date. */
		toJSDate: function() {
			return this._calendar.toJSDate(this);
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this._calendar.fromJSDate(jsd);
		},

		/** Convert to a string for display.
			@memberof CDate
			@return {string} This date as a string. */
		toString: function() {
			return (this.year() < 0 ? '-' : '') + pad(Math.abs(this.year()), 4) +
				'-' + pad(this.month(), 2) + '-' + pad(this.day(), 2);
		}
	});

	/** Basic functionality for all calendars.
		Other calendars should extend this:
		<pre>OtherCalendar.prototype = new BaseCalendar;</pre>
		@class BaseCalendar */
	function BaseCalendar() {
		this.shortYearCutoff = '+10';
	}

	$.extend(BaseCalendar.prototype, {
		_validateLevel: 0, // "Stack" to turn validation on/off

		/** Create a new date within this calendar - today if no parameters given.
			@memberof BaseCalendar
			@param year {CDate|number} The date to duplicate or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if not a valid date or a different calendar used. */
		newDate: function(year, month, day) {
			if (year == null) {
				return this.today();
			}
			if (year.year) {
				this._validate(year, month, day,
					$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
				day = year.day();
				month = year.month();
				year = year.year();
			}
			return new CDate(this, year, month, day);
		},

		/** Create a new date for today.
			@memberof BaseCalendar
			@return {CDate} Today's date. */
		today: function() {
			return this.fromJSDate(new Date());
		},

		/** Retrieve the epoch designator for this date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {string} The current epoch.
			@throws Error if an invalid year or a different calendar used. */
		epoch: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1]);
		},

		/** Format the year, if not a simple sequential number
			@memberof BaseCalendar
			@param year {CDate|number} The date to format or the year to format.
			@return {string} The formatted year.
			@throws Error if an invalid year or a different calendar used. */
		formatYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? '-' : '') + pad(Math.abs(date.year()), 4)
		},

		/** Retrieve the number of months in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of months.
			@throws Error if an invalid year or a different calendar used. */
		monthsInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return 12;
		},

		/** Calculate the month's ordinal position within the year -
			for those calendars that don't start at month 1!
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param month {number} The month to examine.
			@return {number} The ordinal position, starting from <code>minMonth</code>.
			@throws Error if an invalid year/month or a different calendar used. */
		monthOfYear: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return (date.month() + this.monthsInYear(date) - this.firstMonth) %
				this.monthsInYear(date) + this.minMonth;
		},

		/** Calculate actual month from ordinal position, starting from minMonth.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param ord {number} The month's ordinal position.
			@return {number} The month's number.
			@throws Error if an invalid year/month. */
		fromMonthOfYear: function(year, ord) {
			var m = (ord + this.firstMonth - 2 * this.minMonth) %
				this.monthsInYear(year) + this.minMonth;
			this._validate(year, m, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return m;
		},

		/** Retrieve the number of days in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of days.
			@throws Error if an invalid year or a different calendar used. */
		daysInYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (this.leapYear(date) ? 366 : 365);
		},

		/** Retrieve the day of the year for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The day of the year.
			@throws Error if an invalid date or a different calendar used. */
		dayOfYear: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return date.toJD() - this.newDate(date.year(),
				this.fromMonthOfYear(date.year(), this.minMonth), this.minDay).toJD() + 1;
		},

		/** Retrieve the number of days in a week.
			@memberof BaseCalendar
			@return {number} The number of days. */
		daysInWeek: function() {
			return 7;
		},

		/** Retrieve the day of the week for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The day of the week: 0 to number of days - 1.
			@throws Error if an invalid date or a different calendar used. */
		dayOfWeek: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
		},

		/** Retrieve additional information about a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {object} Additional information - contents depends on calendar.
			@throws Error if an invalid date or a different calendar used. */
		extraInfo: function(year, month, day) {
			this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return {};
		},

		/** Add period(s) to a date.
			Cater for no year zero.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if a different calendar used. */
		add: function(date, offset, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return this._correctAdd(date, this._add(date, offset, period), offset, period);
		},

		/** Add period(s) to a date.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_add: function(date, offset, period) {
			this._validateLevel++;
			if (period === 'd' || period === 'w') {
				var jd = date.toJD() + offset * (period === 'w' ? this.daysInWeek() : 1);
				var d = date.calendar().fromJD(jd);
				this._validateLevel--;
				return [d.year(), d.month(), d.day()];
			}
			try {
				var y = date.year() + (period === 'y' ? offset : 0);
				var m = date.monthOfYear() + (period === 'm' ? offset : 0);
				var d = date.day();// + (period === 'd' ? offset : 0) +
					//(period === 'w' ? offset * this.daysInWeek() : 0);
				var resyncYearMonth = function(calendar) {
					while (m < calendar.minMonth) {
						y--;
						m += calendar.monthsInYear(y);
					}
					var yearMonths = calendar.monthsInYear(y);
					while (m > yearMonths - 1 + calendar.minMonth) {
						y++;
						m -= yearMonths;
						yearMonths = calendar.monthsInYear(y);
					}
				};
				if (period === 'y') {
					if (date.month() !== this.fromMonthOfYear(y, m)) { // Hebrew
						m = this.newDate(y, date.month(), this.minDay).monthOfYear();
					}
					m = Math.min(m, this.monthsInYear(y));
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				else if (period === 'm') {
					resyncYearMonth(this);
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				var ymd = [y, this.fromMonthOfYear(y, m), d];
				this._validateLevel--;
				return ymd;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		},

		/** Correct a candidate date after adding period(s) to a date.
			Handle no year zero if necessary.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param ymd {number[]} The added date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_correctAdd: function(date, ymd, offset, period) {
			if (!this.hasYearZero && (period === 'y' || period === 'm')) {
				if (ymd[0] === 0 || // In year zero
						(date.year() > 0) !== (ymd[0] > 0)) { // Crossed year zero
					var adj = {y: [1, 1, 'y'], m: [1, this.monthsInYear(-1), 'm'],
						w: [this.daysInWeek(), this.daysInYear(-1), 'd'],
						d: [1, this.daysInYear(-1), 'd']}[period];
					var dir = (offset < 0 ? -1 : +1);
					ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
				}
			}
			return date.date(ymd[0], ymd[1], ymd[2]);
		},

		/** Set a portion of the date.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if an invalid date or a different calendar used. */
		set: function(date, value, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var y = (period === 'y' ? value : date.year());
			var m = (period === 'm' ? value : date.month());
			var d = (period === 'd' ? value : date.day());
			if (period === 'y' || period === 'm') {
				d = Math.min(d, this.daysInMonth(y, m));
			}
			return date.date(y, m, d);
		},

		/** Determine whether a date is valid for this calendar.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param month {number} The month to examine.
			@param day {number} The day to examine.
			@return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
		isValid: function(year, month, day) {
			this._validateLevel++;
			var valid = (this.hasYearZero || year !== 0);
			if (valid) {
				var date = this.newDate(year, month, this.minDay);
				valid = (month >= this.minMonth && month - this.minMonth < this.monthsInYear(date)) &&
					(day >= this.minDay && day - this.minDay < this.daysInMonth(date));
			}
			this._validateLevel--;
			return valid;
		},

		/** Convert the date to a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return $.calendars.instance().fromJD(this.toJD(date)).toJSDate();
		},

		/** Convert the date from a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param jsd {Date} The JavaScript date.
			@return {CDate} The equivalent calendar date. */
		fromJSDate: function(jsd) {
			return this.fromJD($.calendars.instance().fromJSDate(jsd).toJD());
		},

		/** Check that a candidate date is from the same calendar and is valid.
			@memberof BaseCalendar
			@private
			@param year {CDate|number} The date to validate or the year to validate.
			@param [month] {number} The month to validate.
			@param [day] {number} The day to validate.
			@param error {string} Rrror message if invalid.
			@throws Error if different calendars used or invalid date. */
		_validate: function(year, month, day, error) {
			if (year.year) {
				if (this._validateLevel === 0 && this.name !== year.calendar().name) {
					throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
						replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
				}
				return year;
			}
			try {
				this._validateLevel++;
				if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
					throw error.replace(/\{0\}/, this.local.name);
				}
				var date = this.newDate(year, month, day);
				this._validateLevel--;
				return date;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		}
	});

	/** Implementation of the Proleptic Gregorian Calendar.
		See <a href=":http://en.wikipedia.org/wiki/Gregorian_calendar">http://en.wikipedia.org/wiki/Gregorian_calendar</a>
		and <a href="http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar</a>.
		@class GregorianCalendar
		@augments BaseCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function GregorianCalendar(language) {
		this.local = this.regionalOptions[language] || this.regionalOptions[''];
	}

	GregorianCalendar.prototype = new BaseCalendar;

	$.extend(GregorianCalendar.prototype, {
		/** The calendar name.
			@memberof GregorianCalendar */
		name: 'Gregorian',
		 /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
			@memberof GregorianCalendar */
		jdEpoch: 1721425.5,
		 /** Days per month in a common year.
			@memberof GregorianCalendar */
		daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		 /** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof GregorianCalendar */
		hasYearZero: false,
		/** The minimum month number.
			@memberof GregorianCalendar */
		minMonth: 1,
		/** The first month in the year.
			@memberof GregorianCalendar */
		firstMonth: 1,
		 /** The minimum day number.
			@memberof GregorianCalendar */
		minDay: 1,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof GregorianCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
		regionalOptions: { // Localisations
			'': {
				name: 'Gregorian',
				epochs: ['BCE', 'CE'],
				monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
				'July', 'August', 'September', 'October', 'November', 'December'],
				monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
				dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
				dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
				dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
				dateFormat: 'mm/dd/yyyy',
				firstDay: 0,
				isRTL: false
			}
		},
		
		/** Determine whether this date is in a leap year.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			var year = date.year() + (date.year() < 0 ? 1 : 0); // No year zero
			return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
		},

		/** Determine the week of the year for a date - ISO 8601.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year, starting from 1.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			// Find Thursday of this week starting on Monday
			var checkDate = this.newDate(year, month, day);
			checkDate.add(4 - (checkDate.dayOfWeek() || 7), 'd');
			return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
		},

		/** Retrieve the number of days in a month.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return this.daysPerMonth[date.month() - 1] +
				(date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
		},

		/** Determine whether this date is a week day.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			return (this.dayOfWeek(year, month, day) || 7) < 6;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			year = date.year();
			month = date.month();
			day = date.day();
			if (year < 0) { year++; } // No year zero
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			if (month < 3) {
				month += 12;
				year--;
			}
			var a = Math.floor(year / 100);
			var b = 2 - a + Math.floor(a / 4);
			return Math.floor(365.25 * (year + 4716)) +
				Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
		},

		/** Create a new date from a Julian date.
			@memberof GregorianCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			var z = Math.floor(jd + 0.5);
			var a = Math.floor((z - 1867216.25) / 36524.25);
			a = z + 1 + a - Math.floor(a / 4);
			var b = a + 1524;
			var c = Math.floor((b - 122.1) / 365.25);
			var d = Math.floor(365.25 * c);
			var e = Math.floor((b - d) / 30.6001);
			var day = b - d - Math.floor(e * 30.6001);
			var month = e - (e > 13.5 ? 13 : 1);
			var year = c - (month > 2.5 ? 4716 : 4715);
			if (year <= 0) { year--; } // No year zero
			return this.newDate(year, month, day);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var jsd = new Date(date.year(), date.month() - 1, date.day());
			jsd.setHours(0);
			jsd.setMinutes(0);
			jsd.setSeconds(0);
			jsd.setMilliseconds(0);
			// Hours may be non-zero on daylight saving cut-over:
			// > 12 when midnight changeover, but then cannot generate
			// midnight datetime, so jump to 1AM, otherwise reset.
			jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
			return jsd;
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
		}
	});

	// Singleton manager
	$.calendars = new Calendars();

	// Date template
	$.calendars.cdate = CDate;

	// Base calendar template
	$.calendars.baseCalendar = BaseCalendar;

	// Gregorian calendar implementation
	$.calendars.calendars.gregorian = GregorianCalendar;

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS5jYWxlbmRhcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXHJcbiAgIENhbGVuZGFycyBmb3IgalF1ZXJ5IHYyLjAuMS5cclxuICAgV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSBBdWd1c3QgMjAwOS5cclxuICAgQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvbGljZW5jZS5odG1sKSBsaWNlbnNlLiBcclxuICAgUGxlYXNlIGF0dHJpYnV0ZSB0aGUgYXV0aG9yIGlmIHlvdSB1c2UgaXQuICovXHJcblxyXG4oZnVuY3Rpb24oJCkgeyAvLyBIaWRlIHNjb3BlLCBubyAkIGNvbmZsaWN0XHJcblxyXG5cdGZ1bmN0aW9uIENhbGVuZGFycygpIHtcclxuXHRcdHRoaXMucmVnaW9uYWxPcHRpb25zID0gW107XHJcblx0XHR0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ10gPSB7XHJcblx0XHRcdGludmFsaWRDYWxlbmRhcjogJ0NhbGVuZGFyIHswfSBub3QgZm91bmQnLFxyXG5cdFx0XHRpbnZhbGlkRGF0ZTogJ0ludmFsaWQgezB9IGRhdGUnLFxyXG5cdFx0XHRpbnZhbGlkTW9udGg6ICdJbnZhbGlkIHswfSBtb250aCcsXHJcblx0XHRcdGludmFsaWRZZWFyOiAnSW52YWxpZCB7MH0geWVhcicsXHJcblx0XHRcdGRpZmZlcmVudENhbGVuZGFyczogJ0Nhbm5vdCBtaXggezB9IGFuZCB7MX0gZGF0ZXMnXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5sb2NhbCA9IHRoaXMucmVnaW9uYWxPcHRpb25zWycnXTtcclxuXHRcdHRoaXMuY2FsZW5kYXJzID0ge307XHJcblx0XHR0aGlzLl9sb2NhbENhbHMgPSB7fTtcclxuXHR9XHJcblxyXG5cdC8qKiBDcmVhdGUgdGhlIGNhbGVuZGFycyBwbHVnaW4uXHJcblx0XHQ8cD5Qcm92aWRlcyBzdXBwb3J0IGZvciB2YXJpb3VzIHdvcmxkIGNhbGVuZGFycyBpbiBhIGNvbnNpc3RlbnQgbWFubmVyLjwvcD5cclxuXHQgXHRAY2xhc3MgQ2FsZW5kYXJzXHJcblx0XHRAZXhhbXBsZSAkLmNhbGVuZGFycy5pbnN0YW5jZSgnanVsaWFuJykubmV3RGF0ZSgyMDE0LCAxMiwgMjUpICovXHJcblx0JC5leHRlbmQoQ2FsZW5kYXJzLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8qKiBPYnRhaW4gYSBjYWxlbmRhciBpbXBsZW1lbnRhdGlvbiBhbmQgbG9jYWxpc2F0aW9uLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzXHJcblx0XHRcdEBwYXJhbSBbbmFtZT0nZ3JlZ29yaWFuJ10ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLCBlLmcuICdncmVnb3JpYW4nLCAncGVyc2lhbicsICdpc2xhbWljJy5cclxuXHRcdFx0QHBhcmFtIFtsYW5ndWFnZT0nJ10ge3N0cmluZ30gVGhlIGxhbmd1YWdlIGNvZGUgdG8gdXNlIGZvciBsb2NhbGlzYXRpb24gKGRlZmF1bHQgaXMgRW5nbGlzaCkuXHJcblx0XHRcdEByZXR1cm4ge0NhbGVuZGFyfSBUaGUgY2FsZW5kYXIgYW5kIGxvY2FsaXNhdGlvbi5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBjYWxlbmRhciBub3QgZm91bmQuICovXHJcblx0XHRpbnN0YW5jZTogZnVuY3Rpb24obmFtZSwgbGFuZ3VhZ2UpIHtcclxuXHRcdFx0bmFtZSA9IChuYW1lIHx8ICdncmVnb3JpYW4nKS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRsYW5ndWFnZSA9IGxhbmd1YWdlIHx8ICcnO1xyXG5cdFx0XHR2YXIgY2FsID0gdGhpcy5fbG9jYWxDYWxzW25hbWUgKyAnLScgKyBsYW5ndWFnZV07XHJcblx0XHRcdGlmICghY2FsICYmIHRoaXMuY2FsZW5kYXJzW25hbWVdKSB7XHJcblx0XHRcdFx0Y2FsID0gbmV3IHRoaXMuY2FsZW5kYXJzW25hbWVdKGxhbmd1YWdlKTtcclxuXHRcdFx0XHR0aGlzLl9sb2NhbENhbHNbbmFtZSArICctJyArIGxhbmd1YWdlXSA9IGNhbDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNhbCkge1xyXG5cdFx0XHRcdHRocm93ICh0aGlzLmxvY2FsLmludmFsaWRDYWxlbmRhciB8fCB0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZENhbGVuZGFyKS5cclxuXHRcdFx0XHRcdHJlcGxhY2UoL1xcezBcXH0vLCBuYW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY2FsO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgLSBmb3IgdG9kYXkgaWYgbm8gb3RoZXIgcGFyYW1ldGVycyBnaXZlbi5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1xyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb3B5IG9yIHRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gW2NhbGVuZGFyPSdncmVnb3JpYW4nXSB7QmFzZUNhbGVuZGFyfHN0cmluZ30gVGhlIHVuZGVybHlpbmcgY2FsZW5kYXIgb3IgdGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLlxyXG5cdFx0XHRAcGFyYW0gW2xhbmd1YWdlPScnXSB7c3RyaW5nfSBUaGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciBsb2NhbGlzYXRpb24gKGRlZmF1bHQgRW5nbGlzaCkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgbmV3IGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xyXG5cdFx0bmV3RGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgY2FsZW5kYXIsIGxhbmd1YWdlKSB7XHJcblx0XHRcdGNhbGVuZGFyID0gKHllYXIgIT0gbnVsbCAmJiB5ZWFyLnllYXIgPyB5ZWFyLmNhbGVuZGFyKCkgOiAodHlwZW9mIGNhbGVuZGFyID09PSAnc3RyaW5nJyA/XHJcblx0XHRcdFx0dGhpcy5pbnN0YW5jZShjYWxlbmRhciwgbGFuZ3VhZ2UpIDogY2FsZW5kYXIpKSB8fCB0aGlzLmluc3RhbmNlKCk7XHJcblx0XHRcdHJldHVybiBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvKiogR2VuZXJpYyBkYXRlLCBiYXNlZCBvbiBhIHBhcnRpY3VsYXIgY2FsZW5kYXIuXHJcblx0XHRAY2xhc3MgQ0RhdGVcclxuXHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgdW5kZXJseWluZyBjYWxlbmRhciBpbXBsZW1lbnRhdGlvbi5cclxuXHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXHJcblx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXHJcblx0XHRAcGFyYW0gZGF5IHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoaXMgZGF0ZS5cclxuXHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZGF0ZSBvYmplY3QuXHJcblx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cclxuXHRmdW5jdGlvbiBDRGF0ZShjYWxlbmRhciwgeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0dGhpcy5fY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuXHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xyXG5cdFx0dGhpcy5fbW9udGggPSBtb250aDtcclxuXHRcdHRoaXMuX2RheSA9IGRheTtcclxuXHRcdGlmICh0aGlzLl9jYWxlbmRhci5fdmFsaWRhdGVMZXZlbCA9PT0gMCAmJlxyXG5cdFx0XHRcdCF0aGlzLl9jYWxlbmRhci5pc1ZhbGlkKHRoaXMuX3llYXIsIHRoaXMuX21vbnRoLCB0aGlzLl9kYXkpKSB7XHJcblx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKS5cclxuXHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogUGFkIGEgbnVtZXJpYyB2YWx1ZSB3aXRoIGxlYWRpbmcgemVyb2VzLlxyXG5cdFx0QHByaXZhdGVcclxuXHRcdEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBUaGUgbnVtYmVyIHRvIGZvcm1hdC5cclxuXHRcdEBwYXJhbSBsZW5ndGgge251bWJlcn0gVGhlIG1pbmltdW0gbGVuZ3RoLlxyXG5cdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIG51bWJlci4gKi9cclxuXHRmdW5jdGlvbiBwYWQodmFsdWUsIGxlbmd0aCkge1xyXG5cdFx0dmFsdWUgPSAnJyArIHZhbHVlO1xyXG5cdFx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZygwLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpICsgdmFsdWU7XHJcblx0fVxyXG5cclxuXHQkLmV4dGVuZChDRGF0ZS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvcHkgb3IgdGhlIHllYXIgZm9yIHRoZSBkYXRlIChkZWZhdWx0IHRoaXMgZGF0ZSkuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXHJcblx0XHRuZXdEYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5uZXdEYXRlKCh5ZWFyID09IG51bGwgPyB0aGlzIDogeWVhciksIG1vbnRoLCBkYXkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IG9yIHJldHJpZXZlIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtudW1iZXJ9IFRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfENEYXRlfSBUaGUgZGF0ZSdzIHllYXIgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXHJcblx0XHR5ZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHRoaXMuX3llYXIgOiB0aGlzLnNldCh5ZWFyLCAneScpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgbW9udGggZm9yIHRoaXMgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0ZX0gVGhlIGRhdGUncyBtb250aCAoaWYgbm8gcGFyYW1ldGVyKSBvciB0aGUgdXBkYXRlZCBkYXRlLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cclxuXHRcdG1vbnRoOiBmdW5jdGlvbihtb250aCkge1xyXG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9tb250aCA6IHRoaXMuc2V0KG1vbnRoLCAnbScpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgZGF5IGZvciB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0YX0gVGhlIGRhdGUncyBkYXkgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXHJcblx0XHRkYXk6IGZ1bmN0aW9uKGRheSkge1xyXG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9kYXkgOiB0aGlzLnNldChkYXksICdkJykpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IG5ldyB2YWx1ZXMgZm9yIHRoaXMgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEBwYXJhbSBkYXkge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cclxuXHRcdGRhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9jYWxlbmRhci5pc1ZhbGlkKHllYXIsIG1vbnRoLCBkYXkpKSB7XHJcblx0XHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpLlxyXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIHRoaXMuX2NhbGVuZGFyLmxvY2FsLm5hbWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xyXG5cdFx0XHR0aGlzLl9tb250aCA9IG1vbnRoO1xyXG5cdFx0XHR0aGlzLl9kYXkgPSBkYXk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBpcyBhIGxlYXAgeWVhciwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cclxuXHRcdGxlYXBZZWFyOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmxlYXBZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGVwb2NoIGRlc2lnbmF0b3IgZm9yIHRoaXMgZGF0ZSwgZS5nLiBCQ0Ugb3IgQ0UuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IGVwb2NoLiAqL1xyXG5cdFx0ZXBvY2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZXBvY2godGhpcyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBGb3JtYXQgdGhlIHllYXIsIGlmIG5vdCBhIHNpbXBsZSBzZXF1ZW50aWFsIG51bWJlci5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB5ZWFyLiAqL1xyXG5cdFx0Zm9ybWF0WWVhcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mb3JtYXRZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG1vbnRoIG9mIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUsXHJcblx0XHRcdGkuZS4gdGhlIG1vbnRoJ3MgcG9zaXRpb24gd2l0aGluIGEgbnVtYmVyZWQgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG1vbnRoIG9mIHRoZSB5ZWFyOiA8Y29kZT5taW5Nb250aDwvY29kZT4gdG8gbW9udGhzIHBlciB5ZWFyLiAqL1xyXG5cdFx0bW9udGhPZlllYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIubW9udGhPZlllYXIodGhpcyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgd2VlayBvZiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgd2VlayBvZiB0aGUgeWVhcjogMSB0byB3ZWVrcyBwZXIgeWVhci4gKi9cclxuXHRcdHdlZWtPZlllYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIud2Vla09mWWVhcih0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyB5ZWFyLiAqL1xyXG5cdFx0ZGF5c0luWWVhcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlzSW5ZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGRheSBvZiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyOiAxIHRvIGRheXMgcGVyIHllYXIuICovXHJcblx0XHRkYXlPZlllYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZGF5T2ZZZWFyKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBmb3IgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMuICovXHJcblx0XHRkYXlzSW5Nb250aDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlzSW5Nb250aCh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIHRoaXMgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGRheSBvZiB0aGUgd2VlazogMCB0byBudW1iZXIgb2YgZGF5cyAtIDEuICovXHJcblx0XHRkYXlPZldlZWs6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZGF5T2ZXZWVrKHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGEgd2VlayBkYXkuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xyXG5cdFx0d2Vla0RheTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci53ZWVrRGF5KHRoaXMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gLSBjb250ZW50cyBkZXBlbmRzIG9uIGNhbGVuZGFyLiAqL1xyXG5cdFx0ZXh0cmFJbmZvOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmV4dHJhSW5mbyh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxyXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xyXG5cdFx0YWRkOiBmdW5jdGlvbihvZmZzZXQsIHBlcmlvZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuYWRkKHRoaXMsIG9mZnNldCwgcGVyaW9kKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCBhIHBvcnRpb24gb2YgdGhlIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gdmFsdWUge251bWJlcn0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHBlcmlvZC5cclxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAnZCcgZm9yIGRheS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgbm90IGEgdmFsaWQgZGF0ZS4gKi9cclxuXHRcdHNldDogZnVuY3Rpb24odmFsdWUsIHBlcmlvZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuc2V0KHRoaXMsIHZhbHVlLCBwZXJpb2QpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29tcGFyZSB0aGlzIGRhdGUgdG8gYW5vdGhlciBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgb3RoZXIgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSAtMSBpZiB0aGlzIGRhdGUgaXMgYmVmb3JlIHRoZSBvdGhlciBkYXRlLFxyXG5cdFx0XHRcdFx0MCBpZiB0aGV5IGFyZSBlcXVhbCwgb3IgKzEgaWYgdGhpcyBkYXRlIGlzIGFmdGVyIHRoZSBvdGhlciBkYXRlLiAqL1xyXG5cdFx0Y29tcGFyZVRvOiBmdW5jdGlvbihkYXRlKSB7XHJcblx0XHRcdGlmICh0aGlzLl9jYWxlbmRhci5uYW1lICE9PSBkYXRlLl9jYWxlbmRhci5uYW1lKSB7XHJcblx0XHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmRpZmZlcmVudENhbGVuZGFycyB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmRpZmZlcmVudENhbGVuZGFycykuXHJcblx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSkucmVwbGFjZSgvXFx7MVxcfS8sIGRhdGUuX2NhbGVuZGFyLmxvY2FsLm5hbWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBjID0gKHRoaXMuX3llYXIgIT09IGRhdGUuX3llYXIgPyB0aGlzLl95ZWFyIC0gZGF0ZS5feWVhciA6XHJcblx0XHRcdFx0dGhpcy5fbW9udGggIT09IGRhdGUuX21vbnRoID8gdGhpcy5tb250aE9mWWVhcigpIC0gZGF0ZS5tb250aE9mWWVhcigpIDpcclxuXHRcdFx0XHR0aGlzLl9kYXkgLSBkYXRlLl9kYXkpO1xyXG5cdFx0XHRyZXR1cm4gKGMgPT09IDAgPyAwIDogKGMgPCAwID8gLTEgOiArMSkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGNhbGVuZGFyIGJhY2tpbmcgdGhpcyBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7QmFzZUNhbGVuZGFyfSBUaGUgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24uICovXHJcblx0XHRjYWxlbmRhcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhcjtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBKdWxpYW4gZGF0ZSBlcXVpdmFsZW50IGZvciB0aGlzIGRhdGUsXHJcblx0XHRcdGkuZS4gZGF5cyBzaW5jZSBKYW51YXJ5IDEsIDQ3MTMgQkNFIEdyZWVud2ljaCBub29uLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBKdWxpYW4gZGF0ZS4gKi9cclxuXHRcdHRvSkQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIudG9KRCh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIGZyb20gYSBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXHJcblx0XHRcdEBwYXJhbSBqZCB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUgdG8gY29udmVydC5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXHJcblx0XHRmcm9tSkQ6IGZ1bmN0aW9uKGpkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mcm9tSkQoamQpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29udmVydCB0aGlzIGRhdGUgdG8gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuICovXHJcblx0XHR0b0pTRGF0ZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci50b0pTRGF0ZSh0aGlzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIGZyb20gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0ganNkIHtEYXRlfSBUaGUgSmF2YVNjcmlwdCBkYXRlIHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZXF1aXZhbGVudCBkYXRlLiAqL1xyXG5cdFx0ZnJvbUpTRGF0ZTogZnVuY3Rpb24oanNkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mcm9tSlNEYXRlKGpzZCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb252ZXJ0IHRvIGEgc3RyaW5nIGZvciBkaXNwbGF5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGlzIGRhdGUgYXMgYSBzdHJpbmcuICovXHJcblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAodGhpcy55ZWFyKCkgPCAwID8gJy0nIDogJycpICsgcGFkKE1hdGguYWJzKHRoaXMueWVhcigpKSwgNCkgK1xyXG5cdFx0XHRcdCctJyArIHBhZCh0aGlzLm1vbnRoKCksIDIpICsgJy0nICsgcGFkKHRoaXMuZGF5KCksIDIpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvKiogQmFzaWMgZnVuY3Rpb25hbGl0eSBmb3IgYWxsIGNhbGVuZGFycy5cclxuXHRcdE90aGVyIGNhbGVuZGFycyBzaG91bGQgZXh0ZW5kIHRoaXM6XHJcblx0XHQ8cHJlPk90aGVyQ2FsZW5kYXIucHJvdG90eXBlID0gbmV3IEJhc2VDYWxlbmRhcjs8L3ByZT5cclxuXHRcdEBjbGFzcyBCYXNlQ2FsZW5kYXIgKi9cclxuXHRmdW5jdGlvbiBCYXNlQ2FsZW5kYXIoKSB7XHJcblx0XHR0aGlzLnNob3J0WWVhckN1dG9mZiA9ICcrMTAnO1xyXG5cdH1cclxuXHJcblx0JC5leHRlbmQoQmFzZUNhbGVuZGFyLnByb3RvdHlwZSwge1xyXG5cdFx0X3ZhbGlkYXRlTGV2ZWw6IDAsIC8vIFwiU3RhY2tcIiB0byB0dXJuIHZhbGlkYXRpb24gb24vb2ZmXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIHdpdGhpbiB0aGlzIGNhbGVuZGFyIC0gdG9kYXkgaWYgbm8gcGFyYW1ldGVycyBnaXZlbi5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBkdXBsaWNhdGUgb3IgdGhlIHllYXIgZm9yIHRoZSBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggZm9yIHRoZSBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgbmV3IGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgbm90IGEgdmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0bmV3RGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHRpZiAoeWVhciA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudG9kYXkoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeWVhci55ZWFyKSB7XHJcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpO1xyXG5cdFx0XHRcdGRheSA9IHllYXIuZGF5KCk7XHJcblx0XHRcdFx0bW9udGggPSB5ZWFyLm1vbnRoKCk7XHJcblx0XHRcdFx0eWVhciA9IHllYXIueWVhcigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgQ0RhdGUodGhpcywgeWVhciwgbW9udGgsIGRheSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmb3IgdG9kYXkuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRvZGF5J3MgZGF0ZS4gKi9cclxuXHRcdHRvZGF5OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbUpTRGF0ZShuZXcgRGF0ZSgpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBlcG9jaCBkZXNpZ25hdG9yIGZvciB0aGlzIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IGVwb2NoLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZXBvY2g6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkWWVhciB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRZZWFyKTtcclxuXHRcdFx0cmV0dXJuIChkYXRlLnllYXIoKSA8IDAgPyB0aGlzLmxvY2FsLmVwb2Noc1swXSA6IHRoaXMubG9jYWwuZXBvY2hzWzFdKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEZvcm1hdCB0aGUgeWVhciwgaWYgbm90IGEgc2ltcGxlIHNlcXVlbnRpYWwgbnVtYmVyXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZm9ybWF0IG9yIHRoZSB5ZWFyIHRvIGZvcm1hdC5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHllYXIuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRmb3JtYXRZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XHJcblx0XHRcdHJldHVybiAoZGF0ZS55ZWFyKCkgPCAwID8gJy0nIDogJycpICsgcGFkKE1hdGguYWJzKGRhdGUueWVhcigpKSwgNClcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgbW9udGhzIGluIGEgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBtb250aHMuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRtb250aHNJblllYXI6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XHJcblx0XHRcdHJldHVybiAxMjtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENhbGN1bGF0ZSB0aGUgbW9udGgncyBvcmRpbmFsIHBvc2l0aW9uIHdpdGhpbiB0aGUgeWVhciAtXHJcblx0XHRcdGZvciB0aG9zZSBjYWxlbmRhcnMgdGhhdCBkb24ndCBzdGFydCBhdCBtb250aCAxIVxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBvcmRpbmFsIHBvc2l0aW9uLCBzdGFydGluZyBmcm9tIDxjb2RlPm1pbk1vbnRoPC9jb2RlPi5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIvbW9udGggb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdG1vbnRoT2ZZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xyXG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkTW9udGggfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkTW9udGgpO1xyXG5cdFx0XHRyZXR1cm4gKGRhdGUubW9udGgoKSArIHRoaXMubW9udGhzSW5ZZWFyKGRhdGUpIC0gdGhpcy5maXJzdE1vbnRoKSAlXHJcblx0XHRcdFx0dGhpcy5tb250aHNJblllYXIoZGF0ZSkgKyB0aGlzLm1pbk1vbnRoO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ2FsY3VsYXRlIGFjdHVhbCBtb250aCBmcm9tIG9yZGluYWwgcG9zaXRpb24sIHN0YXJ0aW5nIGZyb20gbWluTW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIG9yZCB7bnVtYmVyfSBUaGUgbW9udGgncyBvcmRpbmFsIHBvc2l0aW9uLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBtb250aCdzIG51bWJlci5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIvbW9udGguICovXHJcblx0XHRmcm9tTW9udGhPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG9yZCkge1xyXG5cdFx0XHR2YXIgbSA9IChvcmQgKyB0aGlzLmZpcnN0TW9udGggLSAyICogdGhpcy5taW5Nb250aCkgJVxyXG5cdFx0XHRcdHRoaXMubW9udGhzSW5ZZWFyKHllYXIpICsgdGhpcy5taW5Nb250aDtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbSwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZE1vbnRoIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZE1vbnRoKTtcclxuXHRcdFx0cmV0dXJuIG07XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRkYXlzSW5ZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XHJcblx0XHRcdHJldHVybiAodGhpcy5sZWFwWWVhcihkYXRlKSA/IDM2NiA6IDM2NSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgZGF5IG9mIHRoZSB5ZWFyIGZvciBhIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gY29udmVydC5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZGF5T2ZZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0cmV0dXJuIGRhdGUudG9KRCgpIC0gdGhpcy5uZXdEYXRlKGRhdGUueWVhcigpLFxyXG5cdFx0XHRcdHRoaXMuZnJvbU1vbnRoT2ZZZWFyKGRhdGUueWVhcigpLCB0aGlzLm1pbk1vbnRoKSwgdGhpcy5taW5EYXkpLnRvSkQoKSArIDE7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB3ZWVrLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzLiAqL1xyXG5cdFx0ZGF5c0luV2VlazogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiA3O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGRheSBvZiB0aGUgd2VlayBmb3IgYSBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGRheSBvZiB0aGUgd2VlazogMCB0byBudW1iZXIgb2YgZGF5cyAtIDEuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRkYXlPZldlZWs6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxyXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpO1xyXG5cdFx0XHRyZXR1cm4gKE1hdGguZmxvb3IodGhpcy50b0pEKGRhdGUpKSArIDIpICUgdGhpcy5kYXlzSW5XZWVrKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGEgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gLSBjb250ZW50cyBkZXBlbmRzIG9uIGNhbGVuZGFyLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZXh0cmFJbmZvOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHJldHVybiB7fTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxyXG5cdFx0XHRDYXRlciBmb3Igbm8geWVhciB6ZXJvLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXHJcblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIG51bWJlciBvZiBwZXJpb2RzIHRvIGFkanVzdCBieS5cclxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAndycgZm9yIHdlZWssICdkJyBmb3IgZGF5LlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0YWRkOiBmdW5jdGlvbihkYXRlLCBvZmZzZXQsIHBlcmlvZCkge1xyXG5cdFx0XHR0aGlzLl92YWxpZGF0ZShkYXRlLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvcnJlY3RBZGQoZGF0ZSwgdGhpcy5fYWRkKGRhdGUsIG9mZnNldCwgcGVyaW9kKSwgb2Zmc2V0LCBwZXJpb2QpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQWRkIHBlcmlvZChzKSB0byBhIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgc3RhcnRpbmcgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxyXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xyXG5cdFx0X2FkZDogZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0LCBwZXJpb2QpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbCsrO1xyXG5cdFx0XHRpZiAocGVyaW9kID09PSAnZCcgfHwgcGVyaW9kID09PSAndycpIHtcclxuXHRcdFx0XHR2YXIgamQgPSBkYXRlLnRvSkQoKSArIG9mZnNldCAqIChwZXJpb2QgPT09ICd3JyA/IHRoaXMuZGF5c0luV2VlaygpIDogMSk7XHJcblx0XHRcdFx0dmFyIGQgPSBkYXRlLmNhbGVuZGFyKCkuZnJvbUpEKGpkKTtcclxuXHRcdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsLS07XHJcblx0XHRcdFx0cmV0dXJuIFtkLnllYXIoKSwgZC5tb250aCgpLCBkLmRheSgpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHZhciB5ID0gZGF0ZS55ZWFyKCkgKyAocGVyaW9kID09PSAneScgPyBvZmZzZXQgOiAwKTtcclxuXHRcdFx0XHR2YXIgbSA9IGRhdGUubW9udGhPZlllYXIoKSArIChwZXJpb2QgPT09ICdtJyA/IG9mZnNldCA6IDApO1xyXG5cdFx0XHRcdHZhciBkID0gZGF0ZS5kYXkoKTsvLyArIChwZXJpb2QgPT09ICdkJyA/IG9mZnNldCA6IDApICtcclxuXHRcdFx0XHRcdC8vKHBlcmlvZCA9PT0gJ3cnID8gb2Zmc2V0ICogdGhpcy5kYXlzSW5XZWVrKCkgOiAwKTtcclxuXHRcdFx0XHR2YXIgcmVzeW5jWWVhck1vbnRoID0gZnVuY3Rpb24oY2FsZW5kYXIpIHtcclxuXHRcdFx0XHRcdHdoaWxlIChtIDwgY2FsZW5kYXIubWluTW9udGgpIHtcclxuXHRcdFx0XHRcdFx0eS0tO1xyXG5cdFx0XHRcdFx0XHRtICs9IGNhbGVuZGFyLm1vbnRoc0luWWVhcih5KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciB5ZWFyTW9udGhzID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHkpO1xyXG5cdFx0XHRcdFx0d2hpbGUgKG0gPiB5ZWFyTW9udGhzIC0gMSArIGNhbGVuZGFyLm1pbk1vbnRoKSB7XHJcblx0XHRcdFx0XHRcdHkrKztcclxuXHRcdFx0XHRcdFx0bSAtPSB5ZWFyTW9udGhzO1xyXG5cdFx0XHRcdFx0XHR5ZWFyTW9udGhzID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0aWYgKHBlcmlvZCA9PT0gJ3knKSB7XHJcblx0XHRcdFx0XHRpZiAoZGF0ZS5tb250aCgpICE9PSB0aGlzLmZyb21Nb250aE9mWWVhcih5LCBtKSkgeyAvLyBIZWJyZXdcclxuXHRcdFx0XHRcdFx0bSA9IHRoaXMubmV3RGF0ZSh5LCBkYXRlLm1vbnRoKCksIHRoaXMubWluRGF5KS5tb250aE9mWWVhcigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bSA9IE1hdGgubWluKG0sIHRoaXMubW9udGhzSW5ZZWFyKHkpKTtcclxuXHRcdFx0XHRcdGQgPSBNYXRoLm1pbihkLCB0aGlzLmRheXNJbk1vbnRoKHksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHBlcmlvZCA9PT0gJ20nKSB7XHJcblx0XHRcdFx0XHRyZXN5bmNZZWFyTW9udGgodGhpcyk7XHJcblx0XHRcdFx0XHRkID0gTWF0aC5taW4oZCwgdGhpcy5kYXlzSW5Nb250aCh5LCB0aGlzLmZyb21Nb250aE9mWWVhcih5LCBtKSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgeW1kID0gW3ksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pLCBkXTtcclxuXHRcdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsLS07XHJcblx0XHRcdFx0cmV0dXJuIHltZDtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcclxuXHRcdFx0XHR0aHJvdyBlO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb3JyZWN0IGEgY2FuZGlkYXRlIGRhdGUgYWZ0ZXIgYWRkaW5nIHBlcmlvZChzKSB0byBhIGRhdGUuXHJcblx0XHRcdEhhbmRsZSBubyB5ZWFyIHplcm8gaWYgbmVjZXNzYXJ5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXHJcblx0XHRcdEBwYXJhbSB5bWQge251bWJlcltdfSBUaGUgYWRkZWQgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxyXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xyXG5cdFx0X2NvcnJlY3RBZGQ6IGZ1bmN0aW9uKGRhdGUsIHltZCwgb2Zmc2V0LCBwZXJpb2QpIHtcclxuXHRcdFx0aWYgKCF0aGlzLmhhc1llYXJaZXJvICYmIChwZXJpb2QgPT09ICd5JyB8fCBwZXJpb2QgPT09ICdtJykpIHtcclxuXHRcdFx0XHRpZiAoeW1kWzBdID09PSAwIHx8IC8vIEluIHllYXIgemVyb1xyXG5cdFx0XHRcdFx0XHQoZGF0ZS55ZWFyKCkgPiAwKSAhPT0gKHltZFswXSA+IDApKSB7IC8vIENyb3NzZWQgeWVhciB6ZXJvXHJcblx0XHRcdFx0XHR2YXIgYWRqID0ge3k6IFsxLCAxLCAneSddLCBtOiBbMSwgdGhpcy5tb250aHNJblllYXIoLTEpLCAnbSddLFxyXG5cdFx0XHRcdFx0XHR3OiBbdGhpcy5kYXlzSW5XZWVrKCksIHRoaXMuZGF5c0luWWVhcigtMSksICdkJ10sXHJcblx0XHRcdFx0XHRcdGQ6IFsxLCB0aGlzLmRheXNJblllYXIoLTEpLCAnZCddfVtwZXJpb2RdO1xyXG5cdFx0XHRcdFx0dmFyIGRpciA9IChvZmZzZXQgPCAwID8gLTEgOiArMSk7XHJcblx0XHRcdFx0XHR5bWQgPSB0aGlzLl9hZGQoZGF0ZSwgb2Zmc2V0ICogYWRqWzBdICsgZGlyICogYWRqWzFdLCBhZGpbMl0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXRlKHltZFswXSwgeW1kWzFdLCB5bWRbMl0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IGEgcG9ydGlvbiBvZiB0aGUgZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBzdGFydGluZyBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gdmFsdWUge251bWJlcn0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHBlcmlvZC5cclxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAnZCcgZm9yIGRheS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRzZXQ6IGZ1bmN0aW9uKGRhdGUsIHZhbHVlLCBwZXJpb2QpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoZGF0ZSwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHZhciB5ID0gKHBlcmlvZCA9PT0gJ3knID8gdmFsdWUgOiBkYXRlLnllYXIoKSk7XHJcblx0XHRcdHZhciBtID0gKHBlcmlvZCA9PT0gJ20nID8gdmFsdWUgOiBkYXRlLm1vbnRoKCkpO1xyXG5cdFx0XHR2YXIgZCA9IChwZXJpb2QgPT09ICdkJyA/IHZhbHVlIDogZGF0ZS5kYXkoKSk7XHJcblx0XHRcdGlmIChwZXJpb2QgPT09ICd5JyB8fCBwZXJpb2QgPT09ICdtJykge1xyXG5cdFx0XHRcdGQgPSBNYXRoLm1pbihkLCB0aGlzLmRheXNJbk1vbnRoKHksIG0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXRlKHksIG0sIGQpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgYSBkYXRlIGlzIHZhbGlkIGZvciB0aGlzIGNhbGVuZGFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBtb250aCB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIGRheSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGEgdmFsaWQgZGF0ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cclxuXHRcdGlzVmFsaWQ6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbCsrO1xyXG5cdFx0XHR2YXIgdmFsaWQgPSAodGhpcy5oYXNZZWFyWmVybyB8fCB5ZWFyICE9PSAwKTtcclxuXHRcdFx0aWYgKHZhbGlkKSB7XHJcblx0XHRcdFx0dmFyIGRhdGUgPSB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5KTtcclxuXHRcdFx0XHR2YWxpZCA9IChtb250aCA+PSB0aGlzLm1pbk1vbnRoICYmIG1vbnRoIC0gdGhpcy5taW5Nb250aCA8IHRoaXMubW9udGhzSW5ZZWFyKGRhdGUpKSAmJlxyXG5cdFx0XHRcdFx0KGRheSA+PSB0aGlzLm1pbkRheSAmJiBkYXkgLSB0aGlzLm1pbkRheSA8IHRoaXMuZGF5c0luTW9udGgoZGF0ZSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcclxuXHRcdFx0cmV0dXJuIHZhbGlkO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29udmVydCB0aGUgZGF0ZSB0byBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb252ZXJ0IG9yIHRoZSB5ZWFyIHRvIGNvbnZlcnQuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHR0b0pTRGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksXHJcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHJldHVybiAkLmNhbGVuZGFycy5pbnN0YW5jZSgpLmZyb21KRCh0aGlzLnRvSkQoZGF0ZSkpLnRvSlNEYXRlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb252ZXJ0IHRoZSBkYXRlIGZyb20gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGNhbGVuZGFyIGRhdGUuICovXHJcblx0XHRmcm9tSlNEYXRlOiBmdW5jdGlvbihqc2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbUpEKCQuY2FsZW5kYXJzLmluc3RhbmNlKCkuZnJvbUpTRGF0ZShqc2QpLnRvSkQoKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDaGVjayB0aGF0IGEgY2FuZGlkYXRlIGRhdGUgaXMgZnJvbSB0aGUgc2FtZSBjYWxlbmRhciBhbmQgaXMgdmFsaWQuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gdmFsaWRhdGUgb3IgdGhlIHllYXIgdG8gdmFsaWRhdGUuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byB2YWxpZGF0ZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gdmFsaWRhdGUuXHJcblx0XHRcdEBwYXJhbSBlcnJvciB7c3RyaW5nfSBScnJvciBtZXNzYWdlIGlmIGludmFsaWQuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgZGlmZmVyZW50IGNhbGVuZGFycyB1c2VkIG9yIGludmFsaWQgZGF0ZS4gKi9cclxuXHRcdF92YWxpZGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgZXJyb3IpIHtcclxuXHRcdFx0aWYgKHllYXIueWVhcikge1xyXG5cdFx0XHRcdGlmICh0aGlzLl92YWxpZGF0ZUxldmVsID09PSAwICYmIHRoaXMubmFtZSAhPT0geWVhci5jYWxlbmRhcigpLm5hbWUpIHtcclxuXHRcdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5kaWZmZXJlbnRDYWxlbmRhcnMgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5kaWZmZXJlbnRDYWxlbmRhcnMpLlxyXG5cdFx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5sb2NhbC5uYW1lKS5yZXBsYWNlKC9cXHsxXFx9LywgeWVhci5jYWxlbmRhcigpLmxvY2FsLm5hbWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4geWVhcjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwrKztcclxuXHRcdFx0XHRpZiAodGhpcy5fdmFsaWRhdGVMZXZlbCA9PT0gMSAmJiAhdGhpcy5pc1ZhbGlkKHllYXIsIG1vbnRoLCBkYXkpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvci5yZXBsYWNlKC9cXHswXFx9LywgdGhpcy5sb2NhbC5uYW1lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGRhdGUgPSB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSk7XHJcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xyXG5cdFx0XHRcdHJldHVybiBkYXRlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xyXG5cdFx0XHRcdHRocm93IGU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0LyoqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyLlxyXG5cdFx0U2VlIDxhIGhyZWY9XCI6aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmVnb3JpYW5fY2FsZW5kYXJcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyZWdvcmlhbl9jYWxlbmRhcjwvYT5cclxuXHRcdGFuZCA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9sZXB0aWNfR3JlZ29yaWFuX2NhbGVuZGFyXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9sZXB0aWNfR3JlZ29yaWFuX2NhbGVuZGFyPC9hPi5cclxuXHRcdEBjbGFzcyBHcmVnb3JpYW5DYWxlbmRhclxyXG5cdFx0QGF1Z21lbnRzIEJhc2VDYWxlbmRhclxyXG5cdFx0QHBhcmFtIFtsYW5ndWFnZT0nJ10ge3N0cmluZ30gVGhlIGxhbmd1YWdlIGNvZGUgKGRlZmF1bHQgRW5nbGlzaCkgZm9yIGxvY2FsaXNhdGlvbi4gKi9cclxuXHRmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhcihsYW5ndWFnZSkge1xyXG5cdFx0dGhpcy5sb2NhbCA9IHRoaXMucmVnaW9uYWxPcHRpb25zW2xhbmd1YWdlXSB8fCB0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ107XHJcblx0fVxyXG5cclxuXHRHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUgPSBuZXcgQmFzZUNhbGVuZGFyO1xyXG5cclxuXHQkLmV4dGVuZChHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUsIHtcclxuXHRcdC8qKiBUaGUgY2FsZW5kYXIgbmFtZS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRuYW1lOiAnR3JlZ29yaWFuJyxcclxuXHRcdCAvKiogSnVsaWFuIGRhdGUgb2Ygc3RhcnQgb2YgR3JlZ29yaWFuIGVwb2NoOiAxIEphbnVhcnkgMDAwMSBDRS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRqZEVwb2NoOiAxNzIxNDI1LjUsXHJcblx0XHQgLyoqIERheXMgcGVyIG1vbnRoIGluIGEgY29tbW9uIHllYXIuXHJcblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhciAqL1xyXG5cdFx0ZGF5c1Blck1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXHJcblx0XHQgLyoqIDxjb2RlPnRydWU8L2NvZGU+IGlmIGhhcyBhIHllYXIgemVybywgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRoYXNZZWFyWmVybzogZmFsc2UsXHJcblx0XHQvKiogVGhlIG1pbmltdW0gbW9udGggbnVtYmVyLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cclxuXHRcdG1pbk1vbnRoOiAxLFxyXG5cdFx0LyoqIFRoZSBmaXJzdCBtb250aCBpbiB0aGUgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXHJcblx0XHRmaXJzdE1vbnRoOiAxLFxyXG5cdFx0IC8qKiBUaGUgbWluaW11bSBkYXkgbnVtYmVyLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cclxuXHRcdG1pbkRheTogMSxcclxuXHJcblx0XHQvKiogTG9jYWxpc2F0aW9ucyBmb3IgdGhlIHBsdWdpbi5cclxuXHRcdFx0RW50cmllcyBhcmUgb2JqZWN0cyBpbmRleGVkIGJ5IHRoZSBsYW5ndWFnZSBjb2RlICgnJyBiZWluZyB0aGUgZGVmYXVsdCBVUy9FbmdsaXNoKS5cclxuXHRcdFx0RWFjaCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcy5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwcm9wZXJ0eSBuYW1lIHtzdHJpbmd9IFRoZSBjYWxlbmRhciBuYW1lLlxyXG5cdFx0XHRAcHJvcGVydHkgZXBvY2hzIHtzdHJpbmdbXX0gVGhlIGVwb2NoIG5hbWVzLlxyXG5cdFx0XHRAcHJvcGVydHkgbW9udGhOYW1lcyB7c3RyaW5nW119IFRoZSBsb25nIG5hbWVzIG9mIHRoZSBtb250aHMgb2YgdGhlIHllYXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cclxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzIHtzdHJpbmdbXX0gVGhlIGxvbmcgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lc1Nob3J0IHtzdHJpbmdbXX0gVGhlIHNob3J0IG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXNNaW4ge3N0cmluZ1tdfSBUaGUgbWluaW1hbCBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cclxuXHRcdFx0QHByb3BlcnR5IGRhdGVGb3JtYXQge3N0cmluZ30gVGhlIGRhdGUgZm9ybWF0IGZvciB0aGlzIGNhbGVuZGFyLlxyXG5cdFx0XHRcdFx0U2VlIHRoZSBvcHRpb25zIG9uIDxhIGhyZWY9XCJCYXNlQ2FsZW5kYXIuaHRtbCNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+IGZvciBkZXRhaWxzLlxyXG5cdFx0XHRAcHJvcGVydHkgZmlyc3REYXkge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBzdGFydGluZyBhdCAwLlxyXG5cdFx0XHRAcHJvcGVydHkgaXNSVEwge251bWJlcn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBsb2NhbGlzYXRpb24gcmVhZHMgcmlnaHQtdG8tbGVmdC4gKi9cclxuXHRcdHJlZ2lvbmFsT3B0aW9uczogeyAvLyBMb2NhbGlzYXRpb25zXHJcblx0XHRcdCcnOiB7XHJcblx0XHRcdFx0bmFtZTogJ0dyZWdvcmlhbicsXHJcblx0XHRcdFx0ZXBvY2hzOiBbJ0JDRScsICdDRSddLFxyXG5cdFx0XHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsXHJcblx0XHRcdFx0J0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXHJcblx0XHRcdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXHJcblx0XHRcdFx0ZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcclxuXHRcdFx0XHRkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxyXG5cdFx0XHRcdGRheU5hbWVzTWluOiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RoJywgJ0ZyJywgJ1NhJ10sXHJcblx0XHRcdFx0ZGF0ZUZvcm1hdDogJ21tL2RkL3l5eXknLFxyXG5cdFx0XHRcdGZpcnN0RGF5OiAwLFxyXG5cdFx0XHRcdGlzUlRMOiBmYWxzZVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGlzIGEgbGVhcCB5ZWFyLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0bGVhcFllYXI6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkWWVhciB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRZZWFyKTtcclxuXHRcdFx0dmFyIHllYXIgPSBkYXRlLnllYXIoKSArIChkYXRlLnllYXIoKSA8IDAgPyAxIDogMCk7IC8vIE5vIHllYXIgemVyb1xyXG5cdFx0XHRyZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBEZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZSAtIElTTyA4NjAxLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgd2VlayBvZiB0aGUgeWVhciwgc3RhcnRpbmcgZnJvbSAxLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0d2Vla09mWWVhcjogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcclxuXHRcdFx0dmFyIGNoZWNrRGF0ZSA9IHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcclxuXHRcdFx0Y2hlY2tEYXRlLmFkZCg0IC0gKGNoZWNrRGF0ZS5kYXlPZldlZWsoKSB8fCA3KSwgJ2QnKTtcclxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoKGNoZWNrRGF0ZS5kYXlPZlllYXIoKSAtIDEpIC8gNykgKyAxO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIG9mIHRoZSBtb250aC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIG1vbnRoLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgbW9udGgveWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZGF5c0luTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5LFxyXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRNb250aCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRNb250aCk7XHJcblx0XHRcdHJldHVybiB0aGlzLmRheXNQZXJNb250aFtkYXRlLm1vbnRoKCkgLSAxXSArXHJcblx0XHRcdFx0KGRhdGUubW9udGgoKSA9PT0gMiAmJiB0aGlzLmxlYXBZZWFyKGRhdGUueWVhcigpKSA/IDEgOiAwKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBhIHdlZWsgZGF5LlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYSB3ZWVrIGRheSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdHdlZWtEYXk6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0cmV0dXJuICh0aGlzLmRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB8fCA3KSA8IDY7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgSnVsaWFuIGRhdGUgZXF1aXZhbGVudCBmb3IgdGhpcyBkYXRlLFxyXG5cdFx0XHRpLmUuIGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbi5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvbnZlcnQgb3IgdGhlIHllYXIgdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGVxdWl2YWxlbnQgSnVsaWFuIGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHR0b0pEOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0eWVhciA9IGRhdGUueWVhcigpO1xyXG5cdFx0XHRtb250aCA9IGRhdGUubW9udGgoKTtcclxuXHRcdFx0ZGF5ID0gZGF0ZS5kYXkoKTtcclxuXHRcdFx0aWYgKHllYXIgPCAwKSB7IHllYXIrKzsgfSAvLyBObyB5ZWFyIHplcm9cclxuXHRcdFx0Ly8gSmVhbiBNZWV1cyBhbGdvcml0aG0sIFwiQXN0cm9ub21pY2FsIEFsZ29yaXRobXNcIiwgMTk5MVxyXG5cdFx0XHRpZiAobW9udGggPCAzKSB7XHJcblx0XHRcdFx0bW9udGggKz0gMTI7XHJcblx0XHRcdFx0eWVhci0tO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBhID0gTWF0aC5mbG9vcih5ZWFyIC8gMTAwKTtcclxuXHRcdFx0dmFyIGIgPSAyIC0gYSArIE1hdGguZmxvb3IoYSAvIDQpO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigzNjUuMjUgKiAoeWVhciArIDQ3MTYpKSArXHJcblx0XHRcdFx0TWF0aC5mbG9vcigzMC42MDAxICogKG1vbnRoICsgMSkpICsgZGF5ICsgYiAtIDE1MjQuNTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIGZyb20gYSBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSBqZCB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUgdG8gY29udmVydC5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXHJcblx0XHRmcm9tSkQ6IGZ1bmN0aW9uKGpkKSB7XHJcblx0XHRcdC8vIEplYW4gTWVldXMgYWxnb3JpdGhtLCBcIkFzdHJvbm9taWNhbCBBbGdvcml0aG1zXCIsIDE5OTFcclxuXHRcdFx0dmFyIHogPSBNYXRoLmZsb29yKGpkICsgMC41KTtcclxuXHRcdFx0dmFyIGEgPSBNYXRoLmZsb29yKCh6IC0gMTg2NzIxNi4yNSkgLyAzNjUyNC4yNSk7XHJcblx0XHRcdGEgPSB6ICsgMSArIGEgLSBNYXRoLmZsb29yKGEgLyA0KTtcclxuXHRcdFx0dmFyIGIgPSBhICsgMTUyNDtcclxuXHRcdFx0dmFyIGMgPSBNYXRoLmZsb29yKChiIC0gMTIyLjEpIC8gMzY1LjI1KTtcclxuXHRcdFx0dmFyIGQgPSBNYXRoLmZsb29yKDM2NS4yNSAqIGMpO1xyXG5cdFx0XHR2YXIgZSA9IE1hdGguZmxvb3IoKGIgLSBkKSAvIDMwLjYwMDEpO1xyXG5cdFx0XHR2YXIgZGF5ID0gYiAtIGQgLSBNYXRoLmZsb29yKGUgKiAzMC42MDAxKTtcclxuXHRcdFx0dmFyIG1vbnRoID0gZSAtIChlID4gMTMuNSA/IDEzIDogMSk7XHJcblx0XHRcdHZhciB5ZWFyID0gYyAtIChtb250aCA+IDIuNSA/IDQ3MTYgOiA0NzE1KTtcclxuXHRcdFx0aWYgKHllYXIgPD0gMCkgeyB5ZWFyLS07IH0gLy8gTm8geWVhciB6ZXJvXHJcblx0XHRcdHJldHVybiB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDb252ZXJ0IHRoaXMgZGF0ZSB0byBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvbnZlcnQgb3IgdGhlIHllYXIgdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge0RhdGV9IFRoZSBlcXVpdmFsZW50IEphdmFTY3JpcHQgZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdHRvSlNEYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcclxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcclxuXHRcdFx0dmFyIGpzZCA9IG5ldyBEYXRlKGRhdGUueWVhcigpLCBkYXRlLm1vbnRoKCkgLSAxLCBkYXRlLmRheSgpKTtcclxuXHRcdFx0anNkLnNldEhvdXJzKDApO1xyXG5cdFx0XHRqc2Quc2V0TWludXRlcygwKTtcclxuXHRcdFx0anNkLnNldFNlY29uZHMoMCk7XHJcblx0XHRcdGpzZC5zZXRNaWxsaXNlY29uZHMoMCk7XHJcblx0XHRcdC8vIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XHJcblx0XHRcdC8vID4gMTIgd2hlbiBtaWRuaWdodCBjaGFuZ2VvdmVyLCBidXQgdGhlbiBjYW5ub3QgZ2VuZXJhdGVcclxuXHRcdFx0Ly8gbWlkbmlnaHQgZGF0ZXRpbWUsIHNvIGp1bXAgdG8gMUFNLCBvdGhlcndpc2UgcmVzZXQuXHJcblx0XHRcdGpzZC5zZXRIb3Vycyhqc2QuZ2V0SG91cnMoKSA+IDEyID8ganNkLmdldEhvdXJzKCkgKyAyIDogMCk7XHJcblx0XHRcdHJldHVybiBqc2Q7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmcm9tIGEgc3RhbmRhcmQgKEdyZWdvcmlhbikgSmF2YVNjcmlwdCBEYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGVxdWl2YWxlbnQgZGF0ZS4gKi9cclxuXHRcdGZyb21KU0RhdGU6IGZ1bmN0aW9uKGpzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5uZXdEYXRlKGpzZC5nZXRGdWxsWWVhcigpLCBqc2QuZ2V0TW9udGgoKSArIDEsIGpzZC5nZXREYXRlKCkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBTaW5nbGV0b24gbWFuYWdlclxyXG5cdCQuY2FsZW5kYXJzID0gbmV3IENhbGVuZGFycygpO1xyXG5cclxuXHQvLyBEYXRlIHRlbXBsYXRlXHJcblx0JC5jYWxlbmRhcnMuY2RhdGUgPSBDRGF0ZTtcclxuXHJcblx0Ly8gQmFzZSBjYWxlbmRhciB0ZW1wbGF0ZVxyXG5cdCQuY2FsZW5kYXJzLmJhc2VDYWxlbmRhciA9IEJhc2VDYWxlbmRhcjtcclxuXHJcblx0Ly8gR3JlZ29yaWFuIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uXHJcblx0JC5jYWxlbmRhcnMuY2FsZW5kYXJzLmdyZWdvcmlhbiA9IEdyZWdvcmlhbkNhbGVuZGFyO1xyXG5cclxufSkoalF1ZXJ5KTtcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
