/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	function Calendars() {
		this.regionalOptions = [];
		this.regionalOptions[''] = {
			invalidCalendar: 'Calendar {0} not found',
			invalidDate: 'Invalid {0} date',
			invalidMonth: 'Invalid {0} month',
			invalidYear: 'Invalid {0} year',
			differentCalendars: 'Cannot mix {0} and {1} dates'
		};
		this.local = this.regionalOptions[''];
		this.calendars = {};
		this._localCals = {};
	}

	/** Create the calendars plugin.
		<p>Provides support for various world calendars in a consistent manner.</p>
	 	@class Calendars
		@example $.calendars.instance('julian').newDate(2014, 12, 25) */
	$.extend(Calendars.prototype, {

		/** Obtain a calendar implementation and localisation.
			@memberof Calendars
			@param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
			@param [language=''] {string} The language code to use for localisation (default is English).
			@return {Calendar} The calendar and localisation.
			@throws Error if calendar not found. */
		instance: function(name, language) {
			name = (name || 'gregorian').toLowerCase();
			language = language || '';
			var cal = this._localCals[name + '-' + language];
			if (!cal && this.calendars[name]) {
				cal = new this.calendars[name](language);
				this._localCals[name + '-' + language] = cal;
			}
			if (!cal) {
				throw (this.local.invalidCalendar || this.regionalOptions[''].invalidCalendar).
					replace(/\{0\}/, name);
			}
			return cal;
		},

		/** Create a new date - for today if no other parameters given.
			@memberof Calendars
			@param year {CDate|number} The date to copy or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
			@param [language=''] {string} The language to use for localisation (default English).
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day, calendar, language) {
			calendar = (year != null && year.year ? year.calendar() : (typeof calendar === 'string' ?
				this.instance(calendar, language) : calendar)) || this.instance();
			return calendar.newDate(year, month, day);
		}
	});

	/** Generic date, based on a particular calendar.
		@class CDate
		@param calendar {BaseCalendar} The underlying calendar implementation.
		@param year {number} The year for this date.
		@param month {number} The month for this date.
		@param day {number} The day for this date.
		@return {CDate} The date object.
		@throws Error if an invalid date. */
	function CDate(calendar, year, month, day) {
		this._calendar = calendar;
		this._year = year;
		this._month = month;
		this._day = day;
		if (this._calendar._validateLevel === 0 &&
				!this._calendar.isValid(this._year, this._month, this._day)) {
			throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
				replace(/\{0\}/, this._calendar.local.name);
		}
	}

	/** Pad a numeric value with leading zeroes.
		@private
		@param value {number} The number to format.
		@param length {number} The minimum length.
		@return {string} The formatted number. */
	function pad(value, length) {
		value = '' + value;
		return '000000'.substring(0, length - value.length) + value;
	}

	$.extend(CDate.prototype, {

		/** Create a new date.
			@memberof CDate
			@param [year] {CDate|number} The date to copy or the year for the date (default this date).
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day) {
			return this._calendar.newDate((year == null ? this : year), month, day);
		},

		/** Set or retrieve the year for this date.
			@memberof CDate
			@param [year] {number} The year for the date.
			@return {number|CDate} The date's year (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		year: function(year) {
			return (arguments.length === 0 ? this._year : this.set(year, 'y'));
		},

		/** Set or retrieve the month for this date.
			@memberof CDate
			@param [month] {number} The month for the date.
			@return {number|CDate} The date's month (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		month: function(month) {
			return (arguments.length === 0 ? this._month : this.set(month, 'm'));
		},

		/** Set or retrieve the day for this date.
			@memberof CDate
			@param [day] {number} The day for the date.
			@return {number|CData} The date's day (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		day: function(day) {
			return (arguments.length === 0 ? this._day : this.set(day, 'd'));
		},

		/** Set new values for this date.
			@memberof CDate
			@param year {number} The year for the date.
			@param month {number} The month for the date.
			@param day {number} The day for the date.
			@return {CDate} The updated date.
			@throws Error if an invalid date. */
		date: function(year, month, day) {
			if (!this._calendar.isValid(year, month, day)) {
				throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
					replace(/\{0\}/, this._calendar.local.name);
			}
			this._year = year;
			this._month = month;
			this._day = day;
			return this;
		},

		/** Determine whether this date is in a leap year.
			@memberof CDate
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
		leapYear: function() {
			return this._calendar.leapYear(this);
		},

		/** Retrieve the epoch designator for this date, e.g. BCE or CE.
			@memberof CDate
			@return {string} The current epoch. */
		epoch: function() {
			return this._calendar.epoch(this);
		},

		/** Format the year, if not a simple sequential number.
			@memberof CDate
			@return {string} The formatted year. */
		formatYear: function() {
			return this._calendar.formatYear(this);
		},

		/** Retrieve the month of the year for this date,
			i.e. the month's position within a numbered year.
			@memberof CDate
			@return {number} The month of the year: <code>minMonth</code> to months per year. */
		monthOfYear: function() {
			return this._calendar.monthOfYear(this);
		},

		/** Retrieve the week of the year for this date.
			@memberof CDate
			@return {number} The week of the year: 1 to weeks per year. */
		weekOfYear: function() {
			return this._calendar.weekOfYear(this);
		},

		/** Retrieve the number of days in the year for this date.
			@memberof CDate
			@return {number} The number of days in this year. */
		daysInYear: function() {
			return this._calendar.daysInYear(this);
		},

		/** Retrieve the day of the year for this date.
			@memberof CDate
			@return {number} The day of the year: 1 to days per year. */
		dayOfYear: function() {
			return this._calendar.dayOfYear(this);
		},

		/** Retrieve the number of days in the month for this date.
			@memberof CDate
			@return {number} The number of days. */
		daysInMonth: function() {
			return this._calendar.daysInMonth(this);
		},

		/** Retrieve the day of the week for this date.
			@memberof CDate
			@return {number} The day of the week: 0 to number of days - 1. */
		dayOfWeek: function() {
			return this._calendar.dayOfWeek(this);
		},

		/** Determine whether this date is a week day.
			@memberof CDate
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
		weekDay: function() {
			return this._calendar.weekDay(this);
		},

		/** Retrieve additional information about this date.
			@memberof CDate
			@return {object} Additional information - contents depends on calendar. */
		extraInfo: function() {
			return this._calendar.extraInfo(this);
		},

		/** Add period(s) to a date.
			@memberof CDate
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		add: function(offset, period) {
			return this._calendar.add(this, offset, period);
		},

		/** Set a portion of the date.
			@memberof CDate
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if not a valid date. */
		set: function(value, period) {
			return this._calendar.set(this, value, period);
		},

		/** Compare this date to another date.
			@memberof CDate
			@param date {CDate} The other date.
			@return {number} -1 if this date is before the other date,
					0 if they are equal, or +1 if this date is after the other date. */
		compareTo: function(date) {
			if (this._calendar.name !== date._calendar.name) {
				throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
					replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
			}
			var c = (this._year !== date._year ? this._year - date._year :
				this._month !== date._month ? this.monthOfYear() - date.monthOfYear() :
				this._day - date._day);
			return (c === 0 ? 0 : (c < 0 ? -1 : +1));
		},

		/** Retrieve the calendar backing this date.
			@memberof CDate
			@return {BaseCalendar} The calendar implementation. */
		calendar: function() {
			return this._calendar;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof CDate
			@return {number} The equivalent Julian date. */
		toJD: function() {
			return this._calendar.toJD(this);
		},

		/** Create a new date from a Julian date.
			@memberof CDate
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			return this._calendar.fromJD(jd);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@return {Date} The equivalent JavaScript date. */
		toJSDate: function() {
			return this._calendar.toJSDate(this);
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this._calendar.fromJSDate(jsd);
		},

		/** Convert to a string for display.
			@memberof CDate
			@return {string} This date as a string. */
		toString: function() {
			return (this.year() < 0 ? '-' : '') + pad(Math.abs(this.year()), 4) +
				'-' + pad(this.month(), 2) + '-' + pad(this.day(), 2);
		}
	});

	/** Basic functionality for all calendars.
		Other calendars should extend this:
		<pre>OtherCalendar.prototype = new BaseCalendar;</pre>
		@class BaseCalendar */
	function BaseCalendar() {
		this.shortYearCutoff = '+10';
	}

	$.extend(BaseCalendar.prototype, {
		_validateLevel: 0, // "Stack" to turn validation on/off

		/** Create a new date within this calendar - today if no parameters given.
			@memberof BaseCalendar
			@param year {CDate|number} The date to duplicate or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if not a valid date or a different calendar used. */
		newDate: function(year, month, day) {
			if (year == null) {
				return this.today();
			}
			if (year.year) {
				this._validate(year, month, day,
					$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
				day = year.day();
				month = year.month();
				year = year.year();
			}
			return new CDate(this, year, month, day);
		},

		/** Create a new date for today.
			@memberof BaseCalendar
			@return {CDate} Today's date. */
		today: function() {
			return this.fromJSDate(new Date());
		},

		/** Retrieve the epoch designator for this date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {string} The current epoch.
			@throws Error if an invalid year or a different calendar used. */
		epoch: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1]);
		},

		/** Format the year, if not a simple sequential number
			@memberof BaseCalendar
			@param year {CDate|number} The date to format or the year to format.
			@return {string} The formatted year.
			@throws Error if an invalid year or a different calendar used. */
		formatYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? '-' : '') + pad(Math.abs(date.year()), 4)
		},

		/** Retrieve the number of months in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of months.
			@throws Error if an invalid year or a different calendar used. */
		monthsInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return 12;
		},

		/** Calculate the month's ordinal position within the year -
			for those calendars that don't start at month 1!
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param month {number} The month to examine.
			@return {number} The ordinal position, starting from <code>minMonth</code>.
			@throws Error if an invalid year/month or a different calendar used. */
		monthOfYear: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return (date.month() + this.monthsInYear(date) - this.firstMonth) %
				this.monthsInYear(date) + this.minMonth;
		},

		/** Calculate actual month from ordinal position, starting from minMonth.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param ord {number} The month's ordinal position.
			@return {number} The month's number.
			@throws Error if an invalid year/month. */
		fromMonthOfYear: function(year, ord) {
			var m = (ord + this.firstMonth - 2 * this.minMonth) %
				this.monthsInYear(year) + this.minMonth;
			this._validate(year, m, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return m;
		},

		/** Retrieve the number of days in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of days.
			@throws Error if an invalid year or a different calendar used. */
		daysInYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (this.leapYear(date) ? 366 : 365);
		},

		/** Retrieve the day of the year for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The day of the year.
			@throws Error if an invalid date or a different calendar used. */
		dayOfYear: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return date.toJD() - this.newDate(date.year(),
				this.fromMonthOfYear(date.year(), this.minMonth), this.minDay).toJD() + 1;
		},

		/** Retrieve the number of days in a week.
			@memberof BaseCalendar
			@return {number} The number of days. */
		daysInWeek: function() {
			return 7;
		},

		/** Retrieve the day of the week for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The day of the week: 0 to number of days - 1.
			@throws Error if an invalid date or a different calendar used. */
		dayOfWeek: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
		},

		/** Retrieve additional information about a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {object} Additional information - contents depends on calendar.
			@throws Error if an invalid date or a different calendar used. */
		extraInfo: function(year, month, day) {
			this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return {};
		},

		/** Add period(s) to a date.
			Cater for no year zero.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if a different calendar used. */
		add: function(date, offset, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return this._correctAdd(date, this._add(date, offset, period), offset, period);
		},

		/** Add period(s) to a date.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_add: function(date, offset, period) {
			this._validateLevel++;
			if (period === 'd' || period === 'w') {
				var jd = date.toJD() + offset * (period === 'w' ? this.daysInWeek() : 1);
				var d = date.calendar().fromJD(jd);
				this._validateLevel--;
				return [d.year(), d.month(), d.day()];
			}
			try {
				var y = date.year() + (period === 'y' ? offset : 0);
				var m = date.monthOfYear() + (period === 'm' ? offset : 0);
				var d = date.day();// + (period === 'd' ? offset : 0) +
					//(period === 'w' ? offset * this.daysInWeek() : 0);
				var resyncYearMonth = function(calendar) {
					while (m < calendar.minMonth) {
						y--;
						m += calendar.monthsInYear(y);
					}
					var yearMonths = calendar.monthsInYear(y);
					while (m > yearMonths - 1 + calendar.minMonth) {
						y++;
						m -= yearMonths;
						yearMonths = calendar.monthsInYear(y);
					}
				};
				if (period === 'y') {
					if (date.month() !== this.fromMonthOfYear(y, m)) { // Hebrew
						m = this.newDate(y, date.month(), this.minDay).monthOfYear();
					}
					m = Math.min(m, this.monthsInYear(y));
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				else if (period === 'm') {
					resyncYearMonth(this);
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				var ymd = [y, this.fromMonthOfYear(y, m), d];
				this._validateLevel--;
				return ymd;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		},

		/** Correct a candidate date after adding period(s) to a date.
			Handle no year zero if necessary.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param ymd {number[]} The added date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_correctAdd: function(date, ymd, offset, period) {
			if (!this.hasYearZero && (period === 'y' || period === 'm')) {
				if (ymd[0] === 0 || // In year zero
						(date.year() > 0) !== (ymd[0] > 0)) { // Crossed year zero
					var adj = {y: [1, 1, 'y'], m: [1, this.monthsInYear(-1), 'm'],
						w: [this.daysInWeek(), this.daysInYear(-1), 'd'],
						d: [1, this.daysInYear(-1), 'd']}[period];
					var dir = (offset < 0 ? -1 : +1);
					ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
				}
			}
			return date.date(ymd[0], ymd[1], ymd[2]);
		},

		/** Set a portion of the date.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if an invalid date or a different calendar used. */
		set: function(date, value, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var y = (period === 'y' ? value : date.year());
			var m = (period === 'm' ? value : date.month());
			var d = (period === 'd' ? value : date.day());
			if (period === 'y' || period === 'm') {
				d = Math.min(d, this.daysInMonth(y, m));
			}
			return date.date(y, m, d);
		},

		/** Determine whether a date is valid for this calendar.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param month {number} The month to examine.
			@param day {number} The day to examine.
			@return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
		isValid: function(year, month, day) {
			this._validateLevel++;
			var valid = (this.hasYearZero || year !== 0);
			if (valid) {
				var date = this.newDate(year, month, this.minDay);
				valid = (month >= this.minMonth && month - this.minMonth < this.monthsInYear(date)) &&
					(day >= this.minDay && day - this.minDay < this.daysInMonth(date));
			}
			this._validateLevel--;
			return valid;
		},

		/** Convert the date to a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return $.calendars.instance().fromJD(this.toJD(date)).toJSDate();
		},

		/** Convert the date from a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param jsd {Date} The JavaScript date.
			@return {CDate} The equivalent calendar date. */
		fromJSDate: function(jsd) {
			return this.fromJD($.calendars.instance().fromJSDate(jsd).toJD());
		},

		/** Check that a candidate date is from the same calendar and is valid.
			@memberof BaseCalendar
			@private
			@param year {CDate|number} The date to validate or the year to validate.
			@param [month] {number} The month to validate.
			@param [day] {number} The day to validate.
			@param error {string} Rrror message if invalid.
			@throws Error if different calendars used or invalid date. */
		_validate: function(year, month, day, error) {
			if (year.year) {
				if (this._validateLevel === 0 && this.name !== year.calendar().name) {
					throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
						replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
				}
				return year;
			}
			try {
				this._validateLevel++;
				if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
					throw error.replace(/\{0\}/, this.local.name);
				}
				var date = this.newDate(year, month, day);
				this._validateLevel--;
				return date;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		}
	});

	/** Implementation of the Proleptic Gregorian Calendar.
		See <a href=":http://en.wikipedia.org/wiki/Gregorian_calendar">http://en.wikipedia.org/wiki/Gregorian_calendar</a>
		and <a href="http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar</a>.
		@class GregorianCalendar
		@augments BaseCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function GregorianCalendar(language) {
		this.local = this.regionalOptions[language] || this.regionalOptions[''];
	}

	GregorianCalendar.prototype = new BaseCalendar;

	$.extend(GregorianCalendar.prototype, {
		/** The calendar name.
			@memberof GregorianCalendar */
		name: 'Gregorian',
		 /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
			@memberof GregorianCalendar */
		jdEpoch: 1721425.5,
		 /** Days per month in a common year.
			@memberof GregorianCalendar */
		daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		 /** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof GregorianCalendar */
		hasYearZero: false,
		/** The minimum month number.
			@memberof GregorianCalendar */
		minMonth: 1,
		/** The first month in the year.
			@memberof GregorianCalendar */
		firstMonth: 1,
		 /** The minimum day number.
			@memberof GregorianCalendar */
		minDay: 1,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof GregorianCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
		regionalOptions: { // Localisations
			'': {
				name: 'Gregorian',
				epochs: ['BCE', 'CE'],
				monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
				'July', 'August', 'September', 'October', 'November', 'December'],
				monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
				dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
				dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
				dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
				dateFormat: 'mm/dd/yyyy',
				firstDay: 0,
				isRTL: false
			}
		},
		
		/** Determine whether this date is in a leap year.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			var year = date.year() + (date.year() < 0 ? 1 : 0); // No year zero
			return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
		},

		/** Determine the week of the year for a date - ISO 8601.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year, starting from 1.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			// Find Thursday of this week starting on Monday
			var checkDate = this.newDate(year, month, day);
			checkDate.add(4 - (checkDate.dayOfWeek() || 7), 'd');
			return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
		},

		/** Retrieve the number of days in a month.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return this.daysPerMonth[date.month() - 1] +
				(date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
		},

		/** Determine whether this date is a week day.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			return (this.dayOfWeek(year, month, day) || 7) < 6;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			year = date.year();
			month = date.month();
			day = date.day();
			if (year < 0) { year++; } // No year zero
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			if (month < 3) {
				month += 12;
				year--;
			}
			var a = Math.floor(year / 100);
			var b = 2 - a + Math.floor(a / 4);
			return Math.floor(365.25 * (year + 4716)) +
				Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
		},

		/** Create a new date from a Julian date.
			@memberof GregorianCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			var z = Math.floor(jd + 0.5);
			var a = Math.floor((z - 1867216.25) / 36524.25);
			a = z + 1 + a - Math.floor(a / 4);
			var b = a + 1524;
			var c = Math.floor((b - 122.1) / 365.25);
			var d = Math.floor(365.25 * c);
			var e = Math.floor((b - d) / 30.6001);
			var day = b - d - Math.floor(e * 30.6001);
			var month = e - (e > 13.5 ? 13 : 1);
			var year = c - (month > 2.5 ? 4716 : 4715);
			if (year <= 0) { year--; } // No year zero
			return this.newDate(year, month, day);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var jsd = new Date(date.year(), date.month() - 1, date.day());
			jsd.setHours(0);
			jsd.setMinutes(0);
			jsd.setSeconds(0);
			jsd.setMilliseconds(0);
			// Hours may be non-zero on daylight saving cut-over:
			// > 12 when midnight changeover, but then cannot generate
			// midnight datetime, so jump to 1AM, otherwise reset.
			jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
			return jsd;
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
		}
	});

	// Singleton manager
	$.calendars = new Calendars();

	// Date template
	$.calendars.cdate = CDate;

	// Base calendar template
	$.calendars.baseCalendar = BaseCalendar;

	// Gregorian calendar implementation
	$.calendars.calendars.gregorian = GregorianCalendar;

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS5jYWxlbmRhcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXG4gICBDYWxlbmRhcnMgZm9yIGpRdWVyeSB2Mi4wLjEuXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEF1Z3VzdCAyMDA5LlxuICAgQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvbGljZW5jZS5odG1sKSBsaWNlbnNlLiBcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xuXG4oZnVuY3Rpb24oJCkgeyAvLyBIaWRlIHNjb3BlLCBubyAkIGNvbmZsaWN0XG5cblx0ZnVuY3Rpb24gQ2FsZW5kYXJzKCkge1xuXHRcdHRoaXMucmVnaW9uYWxPcHRpb25zID0gW107XG5cdFx0dGhpcy5yZWdpb25hbE9wdGlvbnNbJyddID0ge1xuXHRcdFx0aW52YWxpZENhbGVuZGFyOiAnQ2FsZW5kYXIgezB9IG5vdCBmb3VuZCcsXG5cdFx0XHRpbnZhbGlkRGF0ZTogJ0ludmFsaWQgezB9IGRhdGUnLFxuXHRcdFx0aW52YWxpZE1vbnRoOiAnSW52YWxpZCB7MH0gbW9udGgnLFxuXHRcdFx0aW52YWxpZFllYXI6ICdJbnZhbGlkIHswfSB5ZWFyJyxcblx0XHRcdGRpZmZlcmVudENhbGVuZGFyczogJ0Nhbm5vdCBtaXggezB9IGFuZCB7MX0gZGF0ZXMnXG5cdFx0fTtcblx0XHR0aGlzLmxvY2FsID0gdGhpcy5yZWdpb25hbE9wdGlvbnNbJyddO1xuXHRcdHRoaXMuY2FsZW5kYXJzID0ge307XG5cdFx0dGhpcy5fbG9jYWxDYWxzID0ge307XG5cdH1cblxuXHQvKiogQ3JlYXRlIHRoZSBjYWxlbmRhcnMgcGx1Z2luLlxuXHRcdDxwPlByb3ZpZGVzIHN1cHBvcnQgZm9yIHZhcmlvdXMgd29ybGQgY2FsZW5kYXJzIGluIGEgY29uc2lzdGVudCBtYW5uZXIuPC9wPlxuXHQgXHRAY2xhc3MgQ2FsZW5kYXJzXG5cdFx0QGV4YW1wbGUgJC5jYWxlbmRhcnMuaW5zdGFuY2UoJ2p1bGlhbicpLm5ld0RhdGUoMjAxNCwgMTIsIDI1KSAqL1xuXHQkLmV4dGVuZChDYWxlbmRhcnMucHJvdG90eXBlLCB7XG5cblx0XHQvKiogT2J0YWluIGEgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24gYW5kIGxvY2FsaXNhdGlvbi5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNcblx0XHRcdEBwYXJhbSBbbmFtZT0nZ3JlZ29yaWFuJ10ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLCBlLmcuICdncmVnb3JpYW4nLCAncGVyc2lhbicsICdpc2xhbWljJy5cblx0XHRcdEBwYXJhbSBbbGFuZ3VhZ2U9JyddIHtzdHJpbmd9IFRoZSBsYW5ndWFnZSBjb2RlIHRvIHVzZSBmb3IgbG9jYWxpc2F0aW9uIChkZWZhdWx0IGlzIEVuZ2xpc2gpLlxuXHRcdFx0QHJldHVybiB7Q2FsZW5kYXJ9IFRoZSBjYWxlbmRhciBhbmQgbG9jYWxpc2F0aW9uLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBjYWxlbmRhciBub3QgZm91bmQuICovXG5cdFx0aW5zdGFuY2U6IGZ1bmN0aW9uKG5hbWUsIGxhbmd1YWdlKSB7XG5cdFx0XHRuYW1lID0gKG5hbWUgfHwgJ2dyZWdvcmlhbicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRsYW5ndWFnZSA9IGxhbmd1YWdlIHx8ICcnO1xuXHRcdFx0dmFyIGNhbCA9IHRoaXMuX2xvY2FsQ2Fsc1tuYW1lICsgJy0nICsgbGFuZ3VhZ2VdO1xuXHRcdFx0aWYgKCFjYWwgJiYgdGhpcy5jYWxlbmRhcnNbbmFtZV0pIHtcblx0XHRcdFx0Y2FsID0gbmV3IHRoaXMuY2FsZW5kYXJzW25hbWVdKGxhbmd1YWdlKTtcblx0XHRcdFx0dGhpcy5fbG9jYWxDYWxzW25hbWUgKyAnLScgKyBsYW5ndWFnZV0gPSBjYWw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNhbCkge1xuXHRcdFx0XHR0aHJvdyAodGhpcy5sb2NhbC5pbnZhbGlkQ2FsZW5kYXIgfHwgdGhpcy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRDYWxlbmRhcikuXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbDtcblx0XHR9LFxuXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIC0gZm9yIHRvZGF5IGlmIG5vIG90aGVyIHBhcmFtZXRlcnMgZ2l2ZW4uXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb3B5IG9yIHRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gW2NhbGVuZGFyPSdncmVnb3JpYW4nXSB7QmFzZUNhbGVuZGFyfHN0cmluZ30gVGhlIHVuZGVybHlpbmcgY2FsZW5kYXIgb3IgdGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLlxuXHRcdFx0QHBhcmFtIFtsYW5ndWFnZT0nJ10ge3N0cmluZ30gVGhlIGxhbmd1YWdlIHRvIHVzZSBmb3IgbG9jYWxpc2F0aW9uIChkZWZhdWx0IEVuZ2xpc2gpLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdG5ld0RhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyLCBsYW5ndWFnZSkge1xuXHRcdFx0Y2FsZW5kYXIgPSAoeWVhciAhPSBudWxsICYmIHllYXIueWVhciA/IHllYXIuY2FsZW5kYXIoKSA6ICh0eXBlb2YgY2FsZW5kYXIgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0dGhpcy5pbnN0YW5jZShjYWxlbmRhciwgbGFuZ3VhZ2UpIDogY2FsZW5kYXIpKSB8fCB0aGlzLmluc3RhbmNlKCk7XG5cdFx0XHRyZXR1cm4gY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKiBHZW5lcmljIGRhdGUsIGJhc2VkIG9uIGEgcGFydGljdWxhciBjYWxlbmRhci5cblx0XHRAY2xhc3MgQ0RhdGVcblx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIHVuZGVybHlpbmcgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24uXG5cdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgZm9yIHRoaXMgZGF0ZS5cblx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXG5cdFx0QHBhcmFtIGRheSB7bnVtYmVyfSBUaGUgZGF5IGZvciB0aGlzIGRhdGUuXG5cdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBkYXRlIG9iamVjdC5cblx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cblx0ZnVuY3Rpb24gQ0RhdGUoY2FsZW5kYXIsIHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHR0aGlzLl9jYWxlbmRhciA9IGNhbGVuZGFyO1xuXHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xuXHRcdHRoaXMuX21vbnRoID0gbW9udGg7XG5cdFx0dGhpcy5fZGF5ID0gZGF5O1xuXHRcdGlmICh0aGlzLl9jYWxlbmRhci5fdmFsaWRhdGVMZXZlbCA9PT0gMCAmJlxuXHRcdFx0XHQhdGhpcy5fY2FsZW5kYXIuaXNWYWxpZCh0aGlzLl95ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5fZGF5KSkge1xuXHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpLlxuXHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIFBhZCBhIG51bWVyaWMgdmFsdWUgd2l0aCBsZWFkaW5nIHplcm9lcy5cblx0XHRAcHJpdmF0ZVxuXHRcdEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBUaGUgbnVtYmVyIHRvIGZvcm1hdC5cblx0XHRAcGFyYW0gbGVuZ3RoIHtudW1iZXJ9IFRoZSBtaW5pbXVtIGxlbmd0aC5cblx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgbnVtYmVyLiAqL1xuXHRmdW5jdGlvbiBwYWQodmFsdWUsIGxlbmd0aCkge1xuXHRcdHZhbHVlID0gJycgKyB2YWx1ZTtcblx0XHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIHZhbHVlLmxlbmd0aCkgKyB2YWx1ZTtcblx0fVxuXG5cdCQuZXh0ZW5kKENEYXRlLnByb3RvdHlwZSwge1xuXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvcHkgb3IgdGhlIHllYXIgZm9yIHRoZSBkYXRlIChkZWZhdWx0IHRoaXMgZGF0ZSkuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdG5ld0RhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5uZXdEYXRlKCh5ZWFyID09IG51bGwgPyB0aGlzIDogeWVhciksIG1vbnRoLCBkYXkpO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IG9yIHJldHJpZXZlIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEBwYXJhbSBbeWVhcl0ge251bWJlcn0gVGhlIHllYXIgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfENEYXRlfSBUaGUgZGF0ZSdzIHllYXIgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdHllYXI6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHRoaXMuX3llYXIgOiB0aGlzLnNldCh5ZWFyLCAneScpKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgbW9udGggZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGUgZGF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0ZX0gVGhlIGRhdGUncyBtb250aCAoaWYgbm8gcGFyYW1ldGVyKSBvciB0aGUgdXBkYXRlZCBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXG5cdFx0bW9udGg6IGZ1bmN0aW9uKG1vbnRoKSB7XG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9tb250aCA6IHRoaXMuc2V0KG1vbnRoLCAnbScpKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgZGF5IGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IGZvciB0aGUgZGF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0YX0gVGhlIGRhdGUncyBkYXkgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdGRheTogZnVuY3Rpb24oZGF5KSB7XG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9kYXkgOiB0aGlzLnNldChkYXksICdkJykpO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IG5ldyB2YWx1ZXMgZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gZGF5IHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cblx0XHRkYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHRpZiAoIXRoaXMuX2NhbGVuZGFyLmlzVmFsaWQoeWVhciwgbW9udGgsIGRheSkpIHtcblx0XHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpLlxuXHRcdFx0XHRcdHJlcGxhY2UoL1xcezBcXH0vLCB0aGlzLl9jYWxlbmRhci5sb2NhbC5uYW1lKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xuXHRcdFx0dGhpcy5fbW9udGggPSBtb250aDtcblx0XHRcdHRoaXMuX2RheSA9IGRheTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGlzIGEgbGVhcCB5ZWFyLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xuXHRcdGxlYXBZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5sZWFwWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBlcG9jaCBkZXNpZ25hdG9yIGZvciB0aGlzIGRhdGUsIGUuZy4gQkNFIG9yIENFLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IGVwb2NoLiAqL1xuXHRcdGVwb2NoOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5lcG9jaCh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIEZvcm1hdCB0aGUgeWVhciwgaWYgbm90IGEgc2ltcGxlIHNlcXVlbnRpYWwgbnVtYmVyLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgeWVhci4gKi9cblx0XHRmb3JtYXRZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mb3JtYXRZZWFyKHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIG1vbnRoIG9mIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUsXG5cdFx0XHRpLmUuIHRoZSBtb250aCdzIHBvc2l0aW9uIHdpdGhpbiBhIG51bWJlcmVkIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG1vbnRoIG9mIHRoZSB5ZWFyOiA8Y29kZT5taW5Nb250aDwvY29kZT4gdG8gbW9udGhzIHBlciB5ZWFyLiAqL1xuXHRcdG1vbnRoT2ZZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5tb250aE9mWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHdlZWsgb2YgdGhlIHllYXI6IDEgdG8gd2Vla3MgcGVyIHllYXIuICovXG5cdFx0d2Vla09mWWVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIud2Vla09mWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIHllYXIuICovXG5cdFx0ZGF5c0luWWVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZGF5c0luWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHllYXIgZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyOiAxIHRvIGRheXMgcGVyIHllYXIuICovXG5cdFx0ZGF5T2ZZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlPZlllYXIodGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzLiAqL1xuXHRcdGRheXNJbk1vbnRoOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlzSW5Nb250aCh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB3ZWVrOiAwIHRvIG51bWJlciBvZiBkYXlzIC0gMS4gKi9cblx0XHRkYXlPZldlZWs6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmRheU9mV2Vlayh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBhIHdlZWsgZGF5LlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xuXHRcdHdlZWtEYXk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLndlZWtEYXkodGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7b2JqZWN0fSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIC0gY29udGVudHMgZGVwZW5kcyBvbiBjYWxlbmRhci4gKi9cblx0XHRleHRyYUluZm86IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmV4dHJhSW5mbyh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcGVyaW9kcyB0byBhZGp1c3QgYnkuXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS4gKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuYWRkKHRoaXMsIG9mZnNldCwgcGVyaW9kKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNldCBhIHBvcnRpb24gb2YgdGhlIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgcGVyaW9kLlxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAnZCcgZm9yIGRheS5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBub3QgYSB2YWxpZCBkYXRlLiAqL1xuXHRcdHNldDogZnVuY3Rpb24odmFsdWUsIHBlcmlvZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLnNldCh0aGlzLCB2YWx1ZSwgcGVyaW9kKTtcblx0XHR9LFxuXG5cdFx0LyoqIENvbXBhcmUgdGhpcyBkYXRlIHRvIGFub3RoZXIgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgb3RoZXIgZGF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gLTEgaWYgdGhpcyBkYXRlIGlzIGJlZm9yZSB0aGUgb3RoZXIgZGF0ZSxcblx0XHRcdFx0XHQwIGlmIHRoZXkgYXJlIGVxdWFsLCBvciArMSBpZiB0aGlzIGRhdGUgaXMgYWZ0ZXIgdGhlIG90aGVyIGRhdGUuICovXG5cdFx0Y29tcGFyZVRvOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0XHRpZiAodGhpcy5fY2FsZW5kYXIubmFtZSAhPT0gZGF0ZS5fY2FsZW5kYXIubmFtZSkge1xuXHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwuZGlmZmVyZW50Q2FsZW5kYXJzIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uZGlmZmVyZW50Q2FsZW5kYXJzKS5cblx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSkucmVwbGFjZSgvXFx7MVxcfS8sIGRhdGUuX2NhbGVuZGFyLmxvY2FsLm5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGMgPSAodGhpcy5feWVhciAhPT0gZGF0ZS5feWVhciA/IHRoaXMuX3llYXIgLSBkYXRlLl95ZWFyIDpcblx0XHRcdFx0dGhpcy5fbW9udGggIT09IGRhdGUuX21vbnRoID8gdGhpcy5tb250aE9mWWVhcigpIC0gZGF0ZS5tb250aE9mWWVhcigpIDpcblx0XHRcdFx0dGhpcy5fZGF5IC0gZGF0ZS5fZGF5KTtcblx0XHRcdHJldHVybiAoYyA9PT0gMCA/IDAgOiAoYyA8IDAgPyAtMSA6ICsxKSk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgY2FsZW5kYXIgYmFja2luZyB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge0Jhc2VDYWxlbmRhcn0gVGhlIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uLiAqL1xuXHRcdGNhbGVuZGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhcjtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBKdWxpYW4gZGF0ZSBlcXVpdmFsZW50IGZvciB0aGlzIGRhdGUsXG5cdFx0XHRpLmUuIGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbi5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBKdWxpYW4gZGF0ZS4gKi9cblx0XHR0b0pEOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci50b0pEKHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgZnJvbSBhIEp1bGlhbiBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcGFyYW0gamQge251bWJlcn0gVGhlIEp1bGlhbiBkYXRlIHRvIGNvbnZlcnQuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGVxdWl2YWxlbnQgZGF0ZS4gKi9cblx0XHRmcm9tSkQ6IGZ1bmN0aW9uKGpkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZnJvbUpEKGpkKTtcblx0XHR9LFxuXG5cdFx0LyoqIENvbnZlcnQgdGhpcyBkYXRlIHRvIGEgc3RhbmRhcmQgKEdyZWdvcmlhbikgSmF2YVNjcmlwdCBEYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuICovXG5cdFx0dG9KU0RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLnRvSlNEYXRlKHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgZnJvbSBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXG5cdFx0ZnJvbUpTRGF0ZTogZnVuY3Rpb24oanNkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZnJvbUpTRGF0ZShqc2QpO1xuXHRcdH0sXG5cblx0XHQvKiogQ29udmVydCB0byBhIHN0cmluZyBmb3IgZGlzcGxheS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGlzIGRhdGUgYXMgYSBzdHJpbmcuICovXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLnllYXIoKSA8IDAgPyAnLScgOiAnJykgKyBwYWQoTWF0aC5hYnModGhpcy55ZWFyKCkpLCA0KSArXG5cdFx0XHRcdCctJyArIHBhZCh0aGlzLm1vbnRoKCksIDIpICsgJy0nICsgcGFkKHRoaXMuZGF5KCksIDIpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGFsbCBjYWxlbmRhcnMuXG5cdFx0T3RoZXIgY2FsZW5kYXJzIHNob3VsZCBleHRlbmQgdGhpczpcblx0XHQ8cHJlPk90aGVyQ2FsZW5kYXIucHJvdG90eXBlID0gbmV3IEJhc2VDYWxlbmRhcjs8L3ByZT5cblx0XHRAY2xhc3MgQmFzZUNhbGVuZGFyICovXG5cdGZ1bmN0aW9uIEJhc2VDYWxlbmRhcigpIHtcblx0XHR0aGlzLnNob3J0WWVhckN1dG9mZiA9ICcrMTAnO1xuXHR9XG5cblx0JC5leHRlbmQoQmFzZUNhbGVuZGFyLnByb3RvdHlwZSwge1xuXHRcdF92YWxpZGF0ZUxldmVsOiAwLCAvLyBcIlN0YWNrXCIgdG8gdHVybiB2YWxpZGF0aW9uIG9uL29mZlxuXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIHdpdGhpbiB0aGlzIGNhbGVuZGFyIC0gdG9kYXkgaWYgbm8gcGFyYW1ldGVycyBnaXZlbi5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGR1cGxpY2F0ZSBvciB0aGUgeWVhciBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgbm90IGEgdmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdG5ld0RhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdGlmICh5ZWFyID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudG9kYXkoKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyLnllYXIpIHtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcblx0XHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdFx0ZGF5ID0geWVhci5kYXkoKTtcblx0XHRcdFx0bW9udGggPSB5ZWFyLm1vbnRoKCk7XG5cdFx0XHRcdHllYXIgPSB5ZWFyLnllYXIoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgQ0RhdGUodGhpcywgeWVhciwgbW9udGgsIGRheSk7XG5cdFx0fSxcblxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmb3IgdG9kYXkuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVG9kYXkncyBkYXRlLiAqL1xuXHRcdHRvZGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZyb21KU0RhdGUobmV3IERhdGUoKSk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgZXBvY2ggZGVzaWduYXRvciBmb3IgdGhpcyBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgY3VycmVudCBlcG9jaC5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZXBvY2g6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZFllYXIpO1xuXHRcdFx0cmV0dXJuIChkYXRlLnllYXIoKSA8IDAgPyB0aGlzLmxvY2FsLmVwb2Noc1swXSA6IHRoaXMubG9jYWwuZXBvY2hzWzFdKTtcblx0XHR9LFxuXG5cdFx0LyoqIEZvcm1hdCB0aGUgeWVhciwgaWYgbm90IGEgc2ltcGxlIHNlcXVlbnRpYWwgbnVtYmVyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBmb3JtYXQgb3IgdGhlIHllYXIgdG8gZm9ybWF0LlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHllYXIuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdGZvcm1hdFllYXI6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZFllYXIpO1xuXHRcdFx0cmV0dXJuIChkYXRlLnllYXIoKSA8IDAgPyAnLScgOiAnJykgKyBwYWQoTWF0aC5hYnMoZGF0ZS55ZWFyKCkpLCA0KVxuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBtb250aHMgaW4gYSB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1vbnRocy5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0bW9udGhzSW5ZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XG5cdFx0XHRyZXR1cm4gMTI7XG5cdFx0fSxcblxuXHRcdC8qKiBDYWxjdWxhdGUgdGhlIG1vbnRoJ3Mgb3JkaW5hbCBwb3NpdGlvbiB3aXRoaW4gdGhlIHllYXIgLVxuXHRcdFx0Zm9yIHRob3NlIGNhbGVuZGFycyB0aGF0IGRvbid0IHN0YXJ0IGF0IG1vbnRoIDEhXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBvcmRpbmFsIHBvc2l0aW9uLCBzdGFydGluZyBmcm9tIDxjb2RlPm1pbk1vbnRoPC9jb2RlPi5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyL21vbnRoIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0bW9udGhPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZE1vbnRoIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZE1vbnRoKTtcblx0XHRcdHJldHVybiAoZGF0ZS5tb250aCgpICsgdGhpcy5tb250aHNJblllYXIoZGF0ZSkgLSB0aGlzLmZpcnN0TW9udGgpICVcblx0XHRcdFx0dGhpcy5tb250aHNJblllYXIoZGF0ZSkgKyB0aGlzLm1pbk1vbnRoO1xuXHRcdH0sXG5cblx0XHQvKiogQ2FsY3VsYXRlIGFjdHVhbCBtb250aCBmcm9tIG9yZGluYWwgcG9zaXRpb24sIHN0YXJ0aW5nIGZyb20gbWluTW9udGguXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7bnVtYmVyfSBUaGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIG9yZCB7bnVtYmVyfSBUaGUgbW9udGgncyBvcmRpbmFsIHBvc2l0aW9uLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbW9udGgncyBudW1iZXIuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhci9tb250aC4gKi9cblx0XHRmcm9tTW9udGhPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG9yZCkge1xuXHRcdFx0dmFyIG0gPSAob3JkICsgdGhpcy5maXJzdE1vbnRoIC0gMiAqIHRoaXMubWluTW9udGgpICVcblx0XHRcdFx0dGhpcy5tb250aHNJblllYXIoeWVhcikgKyB0aGlzLm1pbk1vbnRoO1xuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbSwgdGhpcy5taW5EYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRNb250aCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRNb250aCk7XG5cdFx0XHRyZXR1cm4gbTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cy5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZGF5c0luWWVhcjogZnVuY3Rpb24oeWVhcikge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XG5cdFx0XHRyZXR1cm4gKHRoaXMubGVhcFllYXIoZGF0ZSkgPyAzNjYgOiAzNjUpO1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIGRheSBvZiB0aGUgeWVhciBmb3IgYSBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRkYXlPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XG5cdFx0XHRyZXR1cm4gZGF0ZS50b0pEKCkgLSB0aGlzLm5ld0RhdGUoZGF0ZS55ZWFyKCksXG5cdFx0XHRcdHRoaXMuZnJvbU1vbnRoT2ZZZWFyKGRhdGUueWVhcigpLCB0aGlzLm1pbk1vbnRoKSwgdGhpcy5taW5EYXkpLnRvSkQoKSArIDE7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB3ZWVrLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMuICovXG5cdFx0ZGF5c0luV2VlazogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gNztcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGEgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGRheSBvZiB0aGUgd2VlazogMCB0byBudW1iZXIgb2YgZGF5cyAtIDEuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdGRheU9mV2VlazogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHJldHVybiAoTWF0aC5mbG9vcih0aGlzLnRvSkQoZGF0ZSkpICsgMikgJSB0aGlzLmRheXNJbldlZWsoKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7b2JqZWN0fSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIC0gY29udGVudHMgZGVwZW5kcyBvbiBjYWxlbmRhci5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZXh0cmFJbmZvOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9LFxuXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxuXHRcdFx0Q2F0ZXIgZm9yIG5vIHllYXIgemVyby5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcGVyaW9kcyB0byBhZGp1c3QgYnkuXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKGRhdGUsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZShkYXRlLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29ycmVjdEFkZChkYXRlLCB0aGlzLl9hZGQoZGF0ZSwgb2Zmc2V0LCBwZXJpb2QpLCBvZmZzZXQsIHBlcmlvZCk7XG5cdFx0fSxcblxuXHRcdC8qKiBBZGQgcGVyaW9kKHMpIHRvIGEgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBzdGFydGluZyBkYXRlLlxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAndycgZm9yIHdlZWssICdkJyBmb3IgZGF5LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuICovXG5cdFx0X2FkZDogZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0LCBwZXJpb2QpIHtcblx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwrKztcblx0XHRcdGlmIChwZXJpb2QgPT09ICdkJyB8fCBwZXJpb2QgPT09ICd3Jykge1xuXHRcdFx0XHR2YXIgamQgPSBkYXRlLnRvSkQoKSArIG9mZnNldCAqIChwZXJpb2QgPT09ICd3JyA/IHRoaXMuZGF5c0luV2VlaygpIDogMSk7XG5cdFx0XHRcdHZhciBkID0gZGF0ZS5jYWxlbmRhcigpLmZyb21KRChqZCk7XG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcblx0XHRcdFx0cmV0dXJuIFtkLnllYXIoKSwgZC5tb250aCgpLCBkLmRheSgpXTtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB5ID0gZGF0ZS55ZWFyKCkgKyAocGVyaW9kID09PSAneScgPyBvZmZzZXQgOiAwKTtcblx0XHRcdFx0dmFyIG0gPSBkYXRlLm1vbnRoT2ZZZWFyKCkgKyAocGVyaW9kID09PSAnbScgPyBvZmZzZXQgOiAwKTtcblx0XHRcdFx0dmFyIGQgPSBkYXRlLmRheSgpOy8vICsgKHBlcmlvZCA9PT0gJ2QnID8gb2Zmc2V0IDogMCkgK1xuXHRcdFx0XHRcdC8vKHBlcmlvZCA9PT0gJ3cnID8gb2Zmc2V0ICogdGhpcy5kYXlzSW5XZWVrKCkgOiAwKTtcblx0XHRcdFx0dmFyIHJlc3luY1llYXJNb250aCA9IGZ1bmN0aW9uKGNhbGVuZGFyKSB7XG5cdFx0XHRcdFx0d2hpbGUgKG0gPCBjYWxlbmRhci5taW5Nb250aCkge1xuXHRcdFx0XHRcdFx0eS0tO1xuXHRcdFx0XHRcdFx0bSArPSBjYWxlbmRhci5tb250aHNJblllYXIoeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB5ZWFyTW9udGhzID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHkpO1xuXHRcdFx0XHRcdHdoaWxlIChtID4geWVhck1vbnRocyAtIDEgKyBjYWxlbmRhci5taW5Nb250aCkge1xuXHRcdFx0XHRcdFx0eSsrO1xuXHRcdFx0XHRcdFx0bSAtPSB5ZWFyTW9udGhzO1xuXHRcdFx0XHRcdFx0eWVhck1vbnRocyA9IGNhbGVuZGFyLm1vbnRoc0luWWVhcih5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChwZXJpb2QgPT09ICd5Jykge1xuXHRcdFx0XHRcdGlmIChkYXRlLm1vbnRoKCkgIT09IHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pKSB7IC8vIEhlYnJld1xuXHRcdFx0XHRcdFx0bSA9IHRoaXMubmV3RGF0ZSh5LCBkYXRlLm1vbnRoKCksIHRoaXMubWluRGF5KS5tb250aE9mWWVhcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtID0gTWF0aC5taW4obSwgdGhpcy5tb250aHNJblllYXIoeSkpO1xuXHRcdFx0XHRcdGQgPSBNYXRoLm1pbihkLCB0aGlzLmRheXNJbk1vbnRoKHksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocGVyaW9kID09PSAnbScpIHtcblx0XHRcdFx0XHRyZXN5bmNZZWFyTW9udGgodGhpcyk7XG5cdFx0XHRcdFx0ZCA9IE1hdGgubWluKGQsIHRoaXMuZGF5c0luTW9udGgoeSwgdGhpcy5mcm9tTW9udGhPZlllYXIoeSwgbSkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgeW1kID0gW3ksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pLCBkXTtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xuXHRcdFx0XHRyZXR1cm4geW1kO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xuXHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogQ29ycmVjdCBhIGNhbmRpZGF0ZSBkYXRlIGFmdGVyIGFkZGluZyBwZXJpb2QocykgdG8gYSBkYXRlLlxuXHRcdFx0SGFuZGxlIG5vIHllYXIgemVybyBpZiBuZWNlc3NhcnkuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgc3RhcnRpbmcgZGF0ZS5cblx0XHRcdEBwYXJhbSB5bWQge251bWJlcltdfSBUaGUgYWRkZWQgZGF0ZS5cblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIG51bWJlciBvZiBwZXJpb2RzIHRvIGFkanVzdCBieS5cblx0XHRcdEBwYXJhbSBwZXJpb2Qge3N0cmluZ30gT25lIG9mICd5JyBmb3IgeWVhciwgJ20nIGZvciBtb250aCwgJ3cnIGZvciB3ZWVrLCAnZCcgZm9yIGRheS5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xuXHRcdF9jb3JyZWN0QWRkOiBmdW5jdGlvbihkYXRlLCB5bWQsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0XHRpZiAoIXRoaXMuaGFzWWVhclplcm8gJiYgKHBlcmlvZCA9PT0gJ3knIHx8IHBlcmlvZCA9PT0gJ20nKSkge1xuXHRcdFx0XHRpZiAoeW1kWzBdID09PSAwIHx8IC8vIEluIHllYXIgemVyb1xuXHRcdFx0XHRcdFx0KGRhdGUueWVhcigpID4gMCkgIT09ICh5bWRbMF0gPiAwKSkgeyAvLyBDcm9zc2VkIHllYXIgemVyb1xuXHRcdFx0XHRcdHZhciBhZGogPSB7eTogWzEsIDEsICd5J10sIG06IFsxLCB0aGlzLm1vbnRoc0luWWVhcigtMSksICdtJ10sXG5cdFx0XHRcdFx0XHR3OiBbdGhpcy5kYXlzSW5XZWVrKCksIHRoaXMuZGF5c0luWWVhcigtMSksICdkJ10sXG5cdFx0XHRcdFx0XHRkOiBbMSwgdGhpcy5kYXlzSW5ZZWFyKC0xKSwgJ2QnXX1bcGVyaW9kXTtcblx0XHRcdFx0XHR2YXIgZGlyID0gKG9mZnNldCA8IDAgPyAtMSA6ICsxKTtcblx0XHRcdFx0XHR5bWQgPSB0aGlzLl9hZGQoZGF0ZSwgb2Zmc2V0ICogYWRqWzBdICsgZGlyICogYWRqWzFdLCBhZGpbMl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXRlKHltZFswXSwgeW1kWzFdLCB5bWRbMl0pO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IGEgcG9ydGlvbiBvZiB0aGUgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXG5cdFx0XHRAcGFyYW0gdmFsdWUge251bWJlcn0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHBlcmlvZC5cblx0XHRcdEBwYXJhbSBwZXJpb2Qge3N0cmluZ30gT25lIG9mICd5JyBmb3IgeWVhciwgJ20nIGZvciBtb250aCwgJ2QnIGZvciBkYXkuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0c2V0OiBmdW5jdGlvbihkYXRlLCB2YWx1ZSwgcGVyaW9kKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZShkYXRlLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XG5cdFx0XHR2YXIgeSA9IChwZXJpb2QgPT09ICd5JyA/IHZhbHVlIDogZGF0ZS55ZWFyKCkpO1xuXHRcdFx0dmFyIG0gPSAocGVyaW9kID09PSAnbScgPyB2YWx1ZSA6IGRhdGUubW9udGgoKSk7XG5cdFx0XHR2YXIgZCA9IChwZXJpb2QgPT09ICdkJyA/IHZhbHVlIDogZGF0ZS5kYXkoKSk7XG5cdFx0XHRpZiAocGVyaW9kID09PSAneScgfHwgcGVyaW9kID09PSAnbScpIHtcblx0XHRcdFx0ZCA9IE1hdGgubWluKGQsIHRoaXMuZGF5c0luTW9udGgoeSwgbSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGUuZGF0ZSh5LCBtLCBkKTtcblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIGEgZGF0ZSBpcyB2YWxpZCBmb3IgdGhpcyBjYWxlbmRhci5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gZGF5IHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGEgdmFsaWQgZGF0ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cblx0XHRpc1ZhbGlkOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsKys7XG5cdFx0XHR2YXIgdmFsaWQgPSAodGhpcy5oYXNZZWFyWmVybyB8fCB5ZWFyICE9PSAwKTtcblx0XHRcdGlmICh2YWxpZCkge1xuXHRcdFx0XHR2YXIgZGF0ZSA9IHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgdGhpcy5taW5EYXkpO1xuXHRcdFx0XHR2YWxpZCA9IChtb250aCA+PSB0aGlzLm1pbk1vbnRoICYmIG1vbnRoIC0gdGhpcy5taW5Nb250aCA8IHRoaXMubW9udGhzSW5ZZWFyKGRhdGUpKSAmJlxuXHRcdFx0XHRcdChkYXkgPj0gdGhpcy5taW5EYXkgJiYgZGF5IC0gdGhpcy5taW5EYXkgPCB0aGlzLmRheXNJbk1vbnRoKGRhdGUpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcblx0XHRcdHJldHVybiB2YWxpZDtcblx0XHR9LFxuXG5cdFx0LyoqIENvbnZlcnQgdGhlIGRhdGUgdG8gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb252ZXJ0IG9yIHRoZSB5ZWFyIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gY29udmVydC5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdHRvSlNEYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpO1xuXHRcdFx0cmV0dXJuICQuY2FsZW5kYXJzLmluc3RhbmNlKCkuZnJvbUpEKHRoaXMudG9KRChkYXRlKSkudG9KU0RhdGUoKTtcblx0XHR9LFxuXG5cdFx0LyoqIENvbnZlcnQgdGhlIGRhdGUgZnJvbSBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBqc2Qge0RhdGV9IFRoZSBKYXZhU2NyaXB0IGRhdGUuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGVxdWl2YWxlbnQgY2FsZW5kYXIgZGF0ZS4gKi9cblx0XHRmcm9tSlNEYXRlOiBmdW5jdGlvbihqc2QpIHtcblx0XHRcdHJldHVybiB0aGlzLmZyb21KRCgkLmNhbGVuZGFycy5pbnN0YW5jZSgpLmZyb21KU0RhdGUoanNkKS50b0pEKCkpO1xuXHRcdH0sXG5cblx0XHQvKiogQ2hlY2sgdGhhdCBhIGNhbmRpZGF0ZSBkYXRlIGlzIGZyb20gdGhlIHNhbWUgY2FsZW5kYXIgYW5kIGlzIHZhbGlkLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIHZhbGlkYXRlIG9yIHRoZSB5ZWFyIHRvIHZhbGlkYXRlLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIHZhbGlkYXRlLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gdmFsaWRhdGUuXG5cdFx0XHRAcGFyYW0gZXJyb3Ige3N0cmluZ30gUnJyb3IgbWVzc2FnZSBpZiBpbnZhbGlkLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBkaWZmZXJlbnQgY2FsZW5kYXJzIHVzZWQgb3IgaW52YWxpZCBkYXRlLiAqL1xuXHRcdF92YWxpZGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgZXJyb3IpIHtcblx0XHRcdGlmICh5ZWFyLnllYXIpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3ZhbGlkYXRlTGV2ZWwgPT09IDAgJiYgdGhpcy5uYW1lICE9PSB5ZWFyLmNhbGVuZGFyKCkubmFtZSkge1xuXHRcdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5kaWZmZXJlbnRDYWxlbmRhcnMgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5kaWZmZXJlbnRDYWxlbmRhcnMpLlxuXHRcdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIHRoaXMubG9jYWwubmFtZSkucmVwbGFjZSgvXFx7MVxcfS8sIHllYXIuY2FsZW5kYXIoKS5sb2NhbC5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geWVhcjtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwrKztcblx0XHRcdFx0aWYgKHRoaXMuX3ZhbGlkYXRlTGV2ZWwgPT09IDEgJiYgIXRoaXMuaXNWYWxpZCh5ZWFyLCBtb250aCwgZGF5KSkge1xuXHRcdFx0XHRcdHRocm93IGVycm9yLnJlcGxhY2UoL1xcezBcXH0vLCB0aGlzLmxvY2FsLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBkYXRlID0gdGhpcy5uZXdEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuXHRcdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsLS07XG5cdFx0XHRcdHJldHVybiBkYXRlO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xuXHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyLlxuXHRcdFNlZSA8YSBocmVmPVwiOmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JlZ29yaWFuX2NhbGVuZGFyXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmVnb3JpYW5fY2FsZW5kYXI8L2E+XG5cdFx0YW5kIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2xlcHRpY19HcmVnb3JpYW5fY2FsZW5kYXJcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2xlcHRpY19HcmVnb3JpYW5fY2FsZW5kYXI8L2E+LlxuXHRcdEBjbGFzcyBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdEBhdWdtZW50cyBCYXNlQ2FsZW5kYXJcblx0XHRAcGFyYW0gW2xhbmd1YWdlPScnXSB7c3RyaW5nfSBUaGUgbGFuZ3VhZ2UgY29kZSAoZGVmYXVsdCBFbmdsaXNoKSBmb3IgbG9jYWxpc2F0aW9uLiAqL1xuXHRmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhcihsYW5ndWFnZSkge1xuXHRcdHRoaXMubG9jYWwgPSB0aGlzLnJlZ2lvbmFsT3B0aW9uc1tsYW5ndWFnZV0gfHwgdGhpcy5yZWdpb25hbE9wdGlvbnNbJyddO1xuXHR9XG5cblx0R3JlZ29yaWFuQ2FsZW5kYXIucHJvdG90eXBlID0gbmV3IEJhc2VDYWxlbmRhcjtcblxuXHQkLmV4dGVuZChHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUsIHtcblx0XHQvKiogVGhlIGNhbGVuZGFyIG5hbWUuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRuYW1lOiAnR3JlZ29yaWFuJyxcblx0XHQgLyoqIEp1bGlhbiBkYXRlIG9mIHN0YXJ0IG9mIEdyZWdvcmlhbiBlcG9jaDogMSBKYW51YXJ5IDAwMDEgQ0UuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRqZEVwb2NoOiAxNzIxNDI1LjUsXG5cdFx0IC8qKiBEYXlzIHBlciBtb250aCBpbiBhIGNvbW1vbiB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXG5cdFx0ZGF5c1Blck1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG5cdFx0IC8qKiA8Y29kZT50cnVlPC9jb2RlPiBpZiBoYXMgYSB5ZWFyIHplcm8sIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRoYXNZZWFyWmVybzogZmFsc2UsXG5cdFx0LyoqIFRoZSBtaW5pbXVtIG1vbnRoIG51bWJlci5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhciAqL1xuXHRcdG1pbk1vbnRoOiAxLFxuXHRcdC8qKiBUaGUgZmlyc3QgbW9udGggaW4gdGhlIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRmaXJzdE1vbnRoOiAxLFxuXHRcdCAvKiogVGhlIG1pbmltdW0gZGF5IG51bWJlci5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhciAqL1xuXHRcdG1pbkRheTogMSxcblxuXHRcdC8qKiBMb2NhbGlzYXRpb25zIGZvciB0aGUgcGx1Z2luLlxuXHRcdFx0RW50cmllcyBhcmUgb2JqZWN0cyBpbmRleGVkIGJ5IHRoZSBsYW5ndWFnZSBjb2RlICgnJyBiZWluZyB0aGUgZGVmYXVsdCBVUy9FbmdsaXNoKS5cblx0XHRcdEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcblx0XHRcdEBwcm9wZXJ0eSBuYW1lIHtzdHJpbmd9IFRoZSBjYWxlbmRhciBuYW1lLlxuXHRcdFx0QHByb3BlcnR5IGVwb2NocyB7c3RyaW5nW119IFRoZSBlcG9jaCBuYW1lcy5cblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzIHtzdHJpbmdbXX0gVGhlIGxvbmcgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lcyB7c3RyaW5nW119IFRoZSBsb25nIG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXNNaW4ge3N0cmluZ1tdfSBUaGUgbWluaW1hbCBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cblx0XHRcdEBwcm9wZXJ0eSBkYXRlRm9ybWF0IHtzdHJpbmd9IFRoZSBkYXRlIGZvcm1hdCBmb3IgdGhpcyBjYWxlbmRhci5cblx0XHRcdFx0XHRTZWUgdGhlIG9wdGlvbnMgb24gPGEgaHJlZj1cIkJhc2VDYWxlbmRhci5odG1sI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4gZm9yIGRldGFpbHMuXG5cdFx0XHRAcHJvcGVydHkgZmlyc3REYXkge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBzdGFydGluZyBhdCAwLlxuXHRcdFx0QHByb3BlcnR5IGlzUlRMIHtudW1iZXJ9IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgbG9jYWxpc2F0aW9uIHJlYWRzIHJpZ2h0LXRvLWxlZnQuICovXG5cdFx0cmVnaW9uYWxPcHRpb25zOiB7IC8vIExvY2FsaXNhdGlvbnNcblx0XHRcdCcnOiB7XG5cdFx0XHRcdG5hbWU6ICdHcmVnb3JpYW4nLFxuXHRcdFx0XHRlcG9jaHM6IFsnQkNFJywgJ0NFJ10sXG5cdFx0XHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsXG5cdFx0XHRcdCdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuXHRcdFx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRcdFx0ZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcblx0XHRcdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcblx0XHRcdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcblx0XHRcdFx0ZGF0ZUZvcm1hdDogJ21tL2RkL3l5eXknLFxuXHRcdFx0XHRmaXJzdERheTogMCxcblx0XHRcdFx0aXNSVEw6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGlzIGEgbGVhcCB5ZWFyLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRsZWFwWWVhcjogZnVuY3Rpb24oeWVhcikge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XG5cdFx0XHR2YXIgeWVhciA9IGRhdGUueWVhcigpICsgKGRhdGUueWVhcigpIDwgMCA/IDEgOiAwKTsgLy8gTm8geWVhciB6ZXJvXG5cdFx0XHRyZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZSAtIElTTyA4NjAxLlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSB3ZWVrIG9mIHRoZSB5ZWFyLCBzdGFydGluZyBmcm9tIDEuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdHdlZWtPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdC8vIEZpbmQgVGh1cnNkYXkgb2YgdGhpcyB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxuXHRcdFx0dmFyIGNoZWNrRGF0ZSA9IHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHRcdGNoZWNrRGF0ZS5hZGQoNCAtIChjaGVja0RhdGUuZGF5T2ZXZWVrKCkgfHwgNyksICdkJyk7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigoY2hlY2tEYXRlLmRheU9mWWVhcigpIC0gMSkgLyA3KSArIDE7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aC5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciBvZiB0aGUgbW9udGguXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGguXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIG1vbnRoLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIG1vbnRoL3llYXIgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRkYXlzSW5Nb250aDogZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkTW9udGggfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkTW9udGgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF5c1Blck1vbnRoW2RhdGUubW9udGgoKSAtIDFdICtcblx0XHRcdFx0KGRhdGUubW9udGgoKSA9PT0gMiAmJiB0aGlzLmxlYXBZZWFyKGRhdGUueWVhcigpKSA/IDEgOiAwKTtcblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBhIHdlZWsgZGF5LlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR3ZWVrRGF5OiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHx8IDcpIDwgNjtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBKdWxpYW4gZGF0ZSBlcXVpdmFsZW50IGZvciB0aGlzIGRhdGUsXG5cdFx0XHRpLmUuIGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbi5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBKdWxpYW4gZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0dG9KRDogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHllYXIgPSBkYXRlLnllYXIoKTtcblx0XHRcdG1vbnRoID0gZGF0ZS5tb250aCgpO1xuXHRcdFx0ZGF5ID0gZGF0ZS5kYXkoKTtcblx0XHRcdGlmICh5ZWFyIDwgMCkgeyB5ZWFyKys7IH0gLy8gTm8geWVhciB6ZXJvXG5cdFx0XHQvLyBKZWFuIE1lZXVzIGFsZ29yaXRobSwgXCJBc3Ryb25vbWljYWwgQWxnb3JpdGhtc1wiLCAxOTkxXG5cdFx0XHRpZiAobW9udGggPCAzKSB7XG5cdFx0XHRcdG1vbnRoICs9IDEyO1xuXHRcdFx0XHR5ZWFyLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IE1hdGguZmxvb3IoeWVhciAvIDEwMCk7XG5cdFx0XHR2YXIgYiA9IDIgLSBhICsgTWF0aC5mbG9vcihhIC8gNCk7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigzNjUuMjUgKiAoeWVhciArIDQ3MTYpKSArXG5cdFx0XHRcdE1hdGguZmxvb3IoMzAuNjAwMSAqIChtb250aCArIDEpKSArIGRheSArIGIgLSAxNTI0LjU7XG5cdFx0fSxcblxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmcm9tIGEgSnVsaWFuIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBqZCB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUgdG8gY29udmVydC5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZXF1aXZhbGVudCBkYXRlLiAqL1xuXHRcdGZyb21KRDogZnVuY3Rpb24oamQpIHtcblx0XHRcdC8vIEplYW4gTWVldXMgYWxnb3JpdGhtLCBcIkFzdHJvbm9taWNhbCBBbGdvcml0aG1zXCIsIDE5OTFcblx0XHRcdHZhciB6ID0gTWF0aC5mbG9vcihqZCArIDAuNSk7XG5cdFx0XHR2YXIgYSA9IE1hdGguZmxvb3IoKHogLSAxODY3MjE2LjI1KSAvIDM2NTI0LjI1KTtcblx0XHRcdGEgPSB6ICsgMSArIGEgLSBNYXRoLmZsb29yKGEgLyA0KTtcblx0XHRcdHZhciBiID0gYSArIDE1MjQ7XG5cdFx0XHR2YXIgYyA9IE1hdGguZmxvb3IoKGIgLSAxMjIuMSkgLyAzNjUuMjUpO1xuXHRcdFx0dmFyIGQgPSBNYXRoLmZsb29yKDM2NS4yNSAqIGMpO1xuXHRcdFx0dmFyIGUgPSBNYXRoLmZsb29yKChiIC0gZCkgLyAzMC42MDAxKTtcblx0XHRcdHZhciBkYXkgPSBiIC0gZCAtIE1hdGguZmxvb3IoZSAqIDMwLjYwMDEpO1xuXHRcdFx0dmFyIG1vbnRoID0gZSAtIChlID4gMTMuNSA/IDEzIDogMSk7XG5cdFx0XHR2YXIgeWVhciA9IGMgLSAobW9udGggPiAyLjUgPyA0NzE2IDogNDcxNSk7XG5cdFx0XHRpZiAoeWVhciA8PSAwKSB7IHllYXItLTsgfSAvLyBObyB5ZWFyIHplcm9cblx0XHRcdHJldHVybiB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSk7XG5cdFx0fSxcblxuXHRcdC8qKiBDb252ZXJ0IHRoaXMgZGF0ZSB0byBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7RGF0ZX0gVGhlIGVxdWl2YWxlbnQgSmF2YVNjcmlwdCBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR0b0pTRGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHZhciBqc2QgPSBuZXcgRGF0ZShkYXRlLnllYXIoKSwgZGF0ZS5tb250aCgpIC0gMSwgZGF0ZS5kYXkoKSk7XG5cdFx0XHRqc2Quc2V0SG91cnMoMCk7XG5cdFx0XHRqc2Quc2V0TWludXRlcygwKTtcblx0XHRcdGpzZC5zZXRTZWNvbmRzKDApO1xuXHRcdFx0anNkLnNldE1pbGxpc2Vjb25kcygwKTtcblx0XHRcdC8vIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XG5cdFx0XHQvLyA+IDEyIHdoZW4gbWlkbmlnaHQgY2hhbmdlb3ZlciwgYnV0IHRoZW4gY2Fubm90IGdlbmVyYXRlXG5cdFx0XHQvLyBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cblx0XHRcdGpzZC5zZXRIb3Vycyhqc2QuZ2V0SG91cnMoKSA+IDEyID8ganNkLmdldEhvdXJzKCkgKyAyIDogMCk7XG5cdFx0XHRyZXR1cm4ganNkO1xuXHRcdH0sXG5cblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgZnJvbSBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXG5cdFx0ZnJvbUpTRGF0ZTogZnVuY3Rpb24oanNkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5uZXdEYXRlKGpzZC5nZXRGdWxsWWVhcigpLCBqc2QuZ2V0TW9udGgoKSArIDEsIGpzZC5nZXREYXRlKCkpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gU2luZ2xldG9uIG1hbmFnZXJcblx0JC5jYWxlbmRhcnMgPSBuZXcgQ2FsZW5kYXJzKCk7XG5cblx0Ly8gRGF0ZSB0ZW1wbGF0ZVxuXHQkLmNhbGVuZGFycy5jZGF0ZSA9IENEYXRlO1xuXG5cdC8vIEJhc2UgY2FsZW5kYXIgdGVtcGxhdGVcblx0JC5jYWxlbmRhcnMuYmFzZUNhbGVuZGFyID0gQmFzZUNhbGVuZGFyO1xuXG5cdC8vIEdyZWdvcmlhbiBjYWxlbmRhciBpbXBsZW1lbnRhdGlvblxuXHQkLmNhbGVuZGFycy5jYWxlbmRhcnMuZ3JlZ29yaWFuID0gR3JlZ29yaWFuQ2FsZW5kYXI7XG5cbn0pKGpRdWVyeSk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
