/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Julian calendar for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	/** Implementation of the Julian calendar.
		Based on code from <a href="http://www.fourmilab.ch/documents/calendar/">http://www.fourmilab.ch/documents/calendar/</a>.
		See also <a href="http://en.wikipedia.org/wiki/Julian_calendar">http://en.wikipedia.org/wiki/Julian_calendar</a>.
		@class JulianCalendar
		@augments BaseCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function JulianCalendar(language) {
		this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
	}

	JulianCalendar.prototype = new $.calendars.baseCalendar;

	$.extend(JulianCalendar.prototype, {
		/** The calendar name.
			@memberof JulianCalendar */
		name: 'Julian',
		/** Julian date of start of Persian epoch: 1 January 0001 AD = 30 December 0001 BCE.
			@memberof JulianCalendar */
		jdEpoch: 1721423.5,
		/** Days per month in a common year.
			@memberof JulianCalendar */
		daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		/** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof JulianCalendar */
		hasYearZero: false,
		/** The minimum month number.
			@memberof JulianCalendar */
		minMonth: 1,
		/** The first month in the year.
			@memberof JulianCalendar */
		firstMonth: 1,
		/** The minimum day number.
			@memberof JulianCalendar */
		minDay: 1,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof JulianCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
		regionalOptions: { // Localisations
			'': {
				name: 'Julian',
				epochs: ['BC', 'AD'],
				monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
				'July', 'August', 'September', 'October', 'November', 'December'],
				monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
				dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
				dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
				dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
				dateFormat: 'mm/dd/yyyy',
				firstDay: 0,
				isRTL: false
			}
		},

		/** Determine whether this date is in a leap year.
			@memberof JulianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			var year = (date.year() < 0 ? date.year() + 1 : date.year()); // No year zero
			return (year % 4) === 0;
		},

		/** Determine the week of the year for a date - ISO 8601.
			@memberof JulianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			// Find Thursday of this week starting on Monday
			var checkDate = this.newDate(year, month, day);
			checkDate.add(4 - (checkDate.dayOfWeek() || 7), 'd');
			return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
		},

		/** Retrieve the number of days in a month.
			@memberof JulianCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			var date = this._validate(year, month, this.minDay, $.calendars.local.invalidMonth);
			return this.daysPerMonth[date.month() - 1] +
				(date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
		},

		/** Determine whether this date is a week day.
			@memberof JulianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} True if a week day, false if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			return (this.dayOfWeek(year, month, day) || 7) < 6;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof JulianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			year = date.year();
			month = date.month();
			day = date.day();
			if (year < 0) { year++; } // No year zero
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			if (month <= 2) {
				year--;
				month += 12;
			}
			return Math.floor(365.25 * (year + 4716)) +
				Math.floor(30.6001 * (month + 1)) + day - 1524.5;
		},

		/** Create a new date from a Julian date.
			@memberof JulianCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			var a = Math.floor(jd + 0.5);
			var b = a + 1524;
			var c = Math.floor((b - 122.1) / 365.25);
			var d = Math.floor(365.25 * c);
			var e = Math.floor((b - d) / 30.6001);
			var month = e - Math.floor(e < 14 ? 1 : 13);
			var year = c - Math.floor(month > 2 ? 4716 : 4715);
			var day = b - d - Math.floor(30.6001 * e);
			if (year <= 0) { year--; } // No year zero
			return this.newDate(year, month, day);
		}
	});

	// Julian calendar implementation
	$.calendars.calendars.julian = JulianCalendar;

})(jQuery);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMuanVsaWFuLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxBQUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJqcXVlcnkuY2FsZW5kYXJzLmp1bGlhbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvY2FsZW5kYXJzLmh0bWxcbiAgIEp1bGlhbiBjYWxlbmRhciBmb3IgalF1ZXJ5IHYyLjAuMS5cbiAgIFdyaXR0ZW4gYnkgS2VpdGggV29vZCAoa2J3b29ke2F0fWlpbmV0LmNvbS5hdSkgQXVndXN0IDIwMDkuXG4gICBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCAoaHR0cDovL2tlaXRoLXdvb2QubmFtZS9saWNlbmNlLmh0bWwpIGxpY2Vuc2UuIFxuICAgUGxlYXNlIGF0dHJpYnV0ZSB0aGUgYXV0aG9yIGlmIHlvdSB1c2UgaXQuICovXG5cbihmdW5jdGlvbigkKSB7IC8vIEhpZGUgc2NvcGUsIG5vICQgY29uZmxpY3RcblxuXHQvKiogSW1wbGVtZW50YXRpb24gb2YgdGhlIEp1bGlhbiBjYWxlbmRhci5cblx0XHRCYXNlZCBvbiBjb2RlIGZyb20gPGEgaHJlZj1cImh0dHA6Ly93d3cuZm91cm1pbGFiLmNoL2RvY3VtZW50cy9jYWxlbmRhci9cIj5odHRwOi8vd3d3LmZvdXJtaWxhYi5jaC9kb2N1bWVudHMvY2FsZW5kYXIvPC9hPi5cblx0XHRTZWUgYWxzbyA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KdWxpYW5fY2FsZW5kYXJcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0p1bGlhbl9jYWxlbmRhcjwvYT4uXG5cdFx0QGNsYXNzIEp1bGlhbkNhbGVuZGFyXG5cdFx0QGF1Z21lbnRzIEJhc2VDYWxlbmRhclxuXHRcdEBwYXJhbSBbbGFuZ3VhZ2U9JyddIHtzdHJpbmd9IFRoZSBsYW5ndWFnZSBjb2RlIChkZWZhdWx0IEVuZ2xpc2gpIGZvciBsb2NhbGlzYXRpb24uICovXG5cdGZ1bmN0aW9uIEp1bGlhbkNhbGVuZGFyKGxhbmd1YWdlKSB7XG5cdFx0dGhpcy5sb2NhbCA9IHRoaXMucmVnaW9uYWxPcHRpb25zW2xhbmd1YWdlIHx8ICcnXSB8fCB0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ107XG5cdH1cblxuXHRKdWxpYW5DYWxlbmRhci5wcm90b3R5cGUgPSBuZXcgJC5jYWxlbmRhcnMuYmFzZUNhbGVuZGFyO1xuXG5cdCQuZXh0ZW5kKEp1bGlhbkNhbGVuZGFyLnByb3RvdHlwZSwge1xuXHRcdC8qKiBUaGUgY2FsZW5kYXIgbmFtZS5cblx0XHRcdEBtZW1iZXJvZiBKdWxpYW5DYWxlbmRhciAqL1xuXHRcdG5hbWU6ICdKdWxpYW4nLFxuXHRcdC8qKiBKdWxpYW4gZGF0ZSBvZiBzdGFydCBvZiBQZXJzaWFuIGVwb2NoOiAxIEphbnVhcnkgMDAwMSBBRCA9IDMwIERlY2VtYmVyIDAwMDEgQkNFLlxuXHRcdFx0QG1lbWJlcm9mIEp1bGlhbkNhbGVuZGFyICovXG5cdFx0amRFcG9jaDogMTcyMTQyMy41LFxuXHRcdC8qKiBEYXlzIHBlciBtb250aCBpbiBhIGNvbW1vbiB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIEp1bGlhbkNhbGVuZGFyICovXG5cdFx0ZGF5c1Blck1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG5cdFx0LyoqIDxjb2RlPnRydWU8L2NvZGU+IGlmIGhhcyBhIHllYXIgemVybywgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cblx0XHRcdEBtZW1iZXJvZiBKdWxpYW5DYWxlbmRhciAqL1xuXHRcdGhhc1llYXJaZXJvOiBmYWxzZSxcblx0XHQvKiogVGhlIG1pbmltdW0gbW9udGggbnVtYmVyLlxuXHRcdFx0QG1lbWJlcm9mIEp1bGlhbkNhbGVuZGFyICovXG5cdFx0bWluTW9udGg6IDEsXG5cdFx0LyoqIFRoZSBmaXJzdCBtb250aCBpbiB0aGUgeWVhci5cblx0XHRcdEBtZW1iZXJvZiBKdWxpYW5DYWxlbmRhciAqL1xuXHRcdGZpcnN0TW9udGg6IDEsXG5cdFx0LyoqIFRoZSBtaW5pbXVtIGRheSBudW1iZXIuXG5cdFx0XHRAbWVtYmVyb2YgSnVsaWFuQ2FsZW5kYXIgKi9cblx0XHRtaW5EYXk6IDEsXG5cblx0XHQvKiogTG9jYWxpc2F0aW9ucyBmb3IgdGhlIHBsdWdpbi5cblx0XHRcdEVudHJpZXMgYXJlIG9iamVjdHMgaW5kZXhlZCBieSB0aGUgbGFuZ3VhZ2UgY29kZSAoJycgYmVpbmcgdGhlIGRlZmF1bHQgVVMvRW5nbGlzaCkuXG5cdFx0XHRFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzLlxuXHRcdFx0QG1lbWJlcm9mIEp1bGlhbkNhbGVuZGFyXG5cdFx0XHRAcHJvcGVydHkgbmFtZSB7c3RyaW5nfSBUaGUgY2FsZW5kYXIgbmFtZS5cblx0XHRcdEBwcm9wZXJ0eSBlcG9jaHMge3N0cmluZ1tdfSBUaGUgZXBvY2ggbmFtZXMuXG5cdFx0XHRAcHJvcGVydHkgbW9udGhOYW1lcyB7c3RyaW5nW119IFRoZSBsb25nIG5hbWVzIG9mIHRoZSBtb250aHMgb2YgdGhlIHllYXIuXG5cdFx0XHRAcHJvcGVydHkgbW9udGhOYW1lc1Nob3J0IHtzdHJpbmdbXX0gVGhlIHNob3J0IG5hbWVzIG9mIHRoZSBtb250aHMgb2YgdGhlIHllYXIuXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXMge3N0cmluZ1tdfSBUaGUgbG9uZyBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lc1Nob3J0IHtzdHJpbmdbXX0gVGhlIHNob3J0IG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzTWluIHtzdHJpbmdbXX0gVGhlIG1pbmltYWwgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXG5cdFx0XHRAcHJvcGVydHkgZGF0ZUZvcm1hdCB7c3RyaW5nfSBUaGUgZGF0ZSBmb3JtYXQgZm9yIHRoaXMgY2FsZW5kYXIuXG5cdFx0XHRcdFx0U2VlIHRoZSBvcHRpb25zIG9uIDxhIGhyZWY9XCJCYXNlQ2FsZW5kYXIuaHRtbCNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+IGZvciBkZXRhaWxzLlxuXHRcdFx0QHByb3BlcnR5IGZpcnN0RGF5IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlaywgc3RhcnRpbmcgYXQgMC5cblx0XHRcdEBwcm9wZXJ0eSBpc1JUTCB7bnVtYmVyfSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGxvY2FsaXNhdGlvbiByZWFkcyByaWdodC10by1sZWZ0LiAqL1xuXHRcdHJlZ2lvbmFsT3B0aW9uczogeyAvLyBMb2NhbGlzYXRpb25zXG5cdFx0XHQnJzoge1xuXHRcdFx0XHRuYW1lOiAnSnVsaWFuJyxcblx0XHRcdFx0ZXBvY2hzOiBbJ0JDJywgJ0FEJ10sXG5cdFx0XHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsXG5cdFx0XHRcdCdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuXHRcdFx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRcdFx0ZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcblx0XHRcdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcblx0XHRcdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcblx0XHRcdFx0ZGF0ZUZvcm1hdDogJ21tL2RkL3l5eXknLFxuXHRcdFx0XHRmaXJzdERheTogMCxcblx0XHRcdFx0aXNSVEw6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGRhdGUgaXMgaW4gYSBsZWFwIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgSnVsaWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgaXMgYSBsZWFwIHllYXIsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdGxlYXBZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIHRoaXMubWluTW9udGgsIHRoaXMubWluRGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkWWVhcik7XG5cdFx0XHR2YXIgeWVhciA9IChkYXRlLnllYXIoKSA8IDAgPyBkYXRlLnllYXIoKSArIDEgOiBkYXRlLnllYXIoKSk7IC8vIE5vIHllYXIgemVyb1xuXHRcdFx0cmV0dXJuICh5ZWFyICUgNCkgPT09IDA7XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZSAtIElTTyA4NjAxLlxuXHRcdFx0QG1lbWJlcm9mIEp1bGlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSB3ZWVrIG9mIHRoZSB5ZWFyLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR3ZWVrT2ZZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcblx0XHRcdHZhciBjaGVja0RhdGUgPSB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSk7XG5cdFx0XHRjaGVja0RhdGUuYWRkKDQgLSAoY2hlY2tEYXRlLmRheU9mV2VlaygpIHx8IDcpLCAnZCcpO1xuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoKGNoZWNrRGF0ZS5kYXlPZlllYXIoKSAtIDEpIC8gNykgKyAxO1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGguXG5cdFx0XHRAbWVtYmVyb2YgSnVsaWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgb2YgdGhlIG1vbnRoLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBtb250aC5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBtb250aC95ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZGF5c0luTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCB0aGlzLm1pbkRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZE1vbnRoKTtcblx0XHRcdHJldHVybiB0aGlzLmRheXNQZXJNb250aFtkYXRlLm1vbnRoKCkgLSAxXSArXG5cdFx0XHRcdChkYXRlLm1vbnRoKCkgPT09IDIgJiYgdGhpcy5sZWFwWWVhcihkYXRlLnllYXIoKSkgPyAxIDogMCk7XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGRhdGUgaXMgYSB3ZWVrIGRheS5cblx0XHRcdEBtZW1iZXJvZiBKdWxpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIHdlZWsgZGF5LCBmYWxzZSBpZiBub3QuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdHdlZWtEYXk6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHJldHVybiAodGhpcy5kYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkgfHwgNykgPCA2O1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIEp1bGlhbiBkYXRlIGVxdWl2YWxlbnQgZm9yIHRoaXMgZGF0ZSxcblx0XHRcdGkuZS4gZGF5cyBzaW5jZSBKYW51YXJ5IDEsIDQ3MTMgQkNFIEdyZWVud2ljaCBub29uLlxuXHRcdFx0QG1lbWJlcm9mIEp1bGlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb252ZXJ0IG9yIHRoZSB5ZWFyIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gY29udmVydC5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBlcXVpdmFsZW50IEp1bGlhbiBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR0b0pEOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlKTtcblx0XHRcdHllYXIgPSBkYXRlLnllYXIoKTtcblx0XHRcdG1vbnRoID0gZGF0ZS5tb250aCgpO1xuXHRcdFx0ZGF5ID0gZGF0ZS5kYXkoKTtcblx0XHRcdGlmICh5ZWFyIDwgMCkgeyB5ZWFyKys7IH0gLy8gTm8geWVhciB6ZXJvXG5cdFx0XHQvLyBKZWFuIE1lZXVzIGFsZ29yaXRobSwgXCJBc3Ryb25vbWljYWwgQWxnb3JpdGhtc1wiLCAxOTkxXG5cdFx0XHRpZiAobW9udGggPD0gMikge1xuXHRcdFx0XHR5ZWFyLS07XG5cdFx0XHRcdG1vbnRoICs9IDEyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoMzY1LjI1ICogKHllYXIgKyA0NzE2KSkgK1xuXHRcdFx0XHRNYXRoLmZsb29yKDMwLjYwMDEgKiAobW9udGggKyAxKSkgKyBkYXkgLSAxNTI0LjU7XG5cdFx0fSxcblxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmcm9tIGEgSnVsaWFuIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgSnVsaWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBqZCB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUgdG8gY29udmVydC5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZXF1aXZhbGVudCBkYXRlLiAqL1xuXHRcdGZyb21KRDogZnVuY3Rpb24oamQpIHtcblx0XHRcdC8vIEplYW4gTWVldXMgYWxnb3JpdGhtLCBcIkFzdHJvbm9taWNhbCBBbGdvcml0aG1zXCIsIDE5OTFcblx0XHRcdHZhciBhID0gTWF0aC5mbG9vcihqZCArIDAuNSk7XG5cdFx0XHR2YXIgYiA9IGEgKyAxNTI0O1xuXHRcdFx0dmFyIGMgPSBNYXRoLmZsb29yKChiIC0gMTIyLjEpIC8gMzY1LjI1KTtcblx0XHRcdHZhciBkID0gTWF0aC5mbG9vcigzNjUuMjUgKiBjKTtcblx0XHRcdHZhciBlID0gTWF0aC5mbG9vcigoYiAtIGQpIC8gMzAuNjAwMSk7XG5cdFx0XHR2YXIgbW9udGggPSBlIC0gTWF0aC5mbG9vcihlIDwgMTQgPyAxIDogMTMpO1xuXHRcdFx0dmFyIHllYXIgPSBjIC0gTWF0aC5mbG9vcihtb250aCA+IDIgPyA0NzE2IDogNDcxNSk7XG5cdFx0XHR2YXIgZGF5ID0gYiAtIGQgLSBNYXRoLmZsb29yKDMwLjYwMDEgKiBlKTtcblx0XHRcdGlmICh5ZWFyIDw9IDApIHsgeWVhci0tOyB9IC8vIE5vIHllYXIgemVyb1xuXHRcdFx0cmV0dXJuIHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIEp1bGlhbiBjYWxlbmRhciBpbXBsZW1lbnRhdGlvblxuXHQkLmNhbGVuZGFycy5jYWxlbmRhcnMuanVsaWFuID0gSnVsaWFuQ2FsZW5kYXI7XG5cbn0pKGpRdWVyeSk7Il0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
