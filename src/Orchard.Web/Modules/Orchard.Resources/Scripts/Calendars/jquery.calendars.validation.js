/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars Validation extension for jQuery 2.0.1.
   Requires JÃ¶rn Zaefferer's Validation plugin (http://plugins.jquery.com/project/validate).
   Written by Keith Wood (kbwood{at}iinet.com.au).
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide the namespace

	/* Add validation methods if validation plugin available. */
	if ($.fn.validate) {

		$.calendarsPicker.selectDateOrig = $.calendarsPicker.selectDate;
		
		$.extend($.calendarsPicker.regionalOptions[''], {
			validateDate: 'Please enter a valid date',
			validateDateMin: 'Please enter a date on or after {0}',
			validateDateMax: 'Please enter a date on or before {0}',
			validateDateMinMax: 'Please enter a date between {0} and {1}',
			validateDateCompare: 'Please enter a date {0} {1}',
			validateDateToday: 'today',
			validateDateOther: 'the other date',
			validateDateEQ: 'equal to',
			validateDateNE: 'not equal to',
			validateDateLT: 'before',
			validateDateGT: 'after',
			validateDateLE: 'not after',
			validateDateGE: 'not before'
		});
		
		$.extend($.calendarsPicker.defaultOptions, $.calendarsPicker.regionalOptions['']);

		$.extend($.calendarsPicker, {

			/** Trigger a validation after updating the input field with the selected date.
				@param elem {Element} The control to examine.
				@param target {Element} The selected datepicker element. */
			selectDate: function(elem, target) {
				this.selectDateOrig(elem, target);
				var inst = $.calendarsPicker._getInst(elem);
				if (!inst.inline && $.fn.validate) {
					var validation = $(elem).parents('form').validate();
					if (validation) {
						validation.element('#' + elem.id);
					}
				}
			},

			/** Correct error placement for validation errors - after any trigger.
				@param error {jQuery} The error message.
				@param elem {jQuery} The field in error. */
			errorPlacement: function(error, elem) {
				var inst = $.calendarsPicker._getInst(elem);
				if (inst) {
					error[inst.options.isRTL ? 'insertBefore' : 'insertAfter'](
						inst.trigger.length > 0 ? inst.trigger : elem);
				}
				else {
					error.insertAfter(elem);
				}
			},

			/** Format a validation error message involving dates.
				@param source {string} The error message.
				@param params {Date[]} The dates.
				@return {string} The formatted message. */
			errorFormat: function(source, params) {
				var format = ($.calendarsPicker.curInst ?
					$.calendarsPicker.curInst.get('dateFormat') :
					$.calendarsPicker.defaultOptions.dateFormat);
				$.each(params, function(index, value) {
					source = source.replace(new RegExp('\\{' + index + '\\}', 'g'),
						value.formatDate(format) || 'nothing');
				});
				return source;
			}
		});

		var lastElem = null;

		/* Validate date field. */
		$.validator.addMethod('cpDate', function(value, elem) {
				lastElem = elem;
				return this.optional(elem) || validateEach(value, elem);
			},
			function(params) {
				var inst = $.calendarsPicker._getInst(lastElem);
				var minDate = inst.get('minDate');
				var maxDate = inst.get('maxDate');
				var messages = $.calendarsPicker.defaultOptions;
				return (minDate && maxDate ?
					$.calendarsPicker.errorFormat(messages.validateDateMinMax, [minDate, maxDate]) :
					(minDate ? $.calendarsPicker.errorFormat(messages.validateDateMin, [minDate]) :
					(maxDate ? $.calendarsPicker.errorFormat(messages.validateDateMax, [maxDate]) :
					messages.validateDate)));
			});

		/** Apply a validation test to each date provided.
			@private
			@param value {string} The current field value.
			@param elem {Element} The field control.
			@return {boolean} <code>true</code> if OK, <code>false</code> if failed validation. */
		function validateEach(value, elem) {
			var inst = $.calendarsPicker._getInst(elem);
			var dates = (inst.options.multiSelect ? value.split(inst.options.multiSeparator) :
				(inst.options.rangeSelect ? value.split(inst.options.rangeSeparator) : [value]));
			var ok = (inst.options.multiSelect && dates.length <= inst.options.multiSelect) ||
				(!inst.options.multiSelect && inst.options.rangeSelect && dates.length === 2) ||
				(!inst.options.multiSelect && !inst.options.rangeSelect && dates.length === 1);
			if (ok) {
				try {
					var dateFormat = inst.get('dateFormat');
					var minDate = inst.get('minDate');
					var maxDate = inst.get('maxDate');
					var cp = $(elem);
					$.each(dates, function(i, v) {
						dates[i] = inst.options.calendar.parseDate(dateFormat, v);
						ok = ok && (!dates[i] || (cp.calendarsPicker('isSelectable', dates[i]) &&
							(!minDate || dates[i].compareTo(minDate) !== -1) &&
							(!maxDate || dates[i].compareTo(maxDate) !== +1)));
					});
				}
				catch (e) {
					ok = false;
				}
			}
			if (ok && inst.options.rangeSelect) {
				ok = (dates[0].compareTo(dates[1]) !== +1);
			}
			return ok;
		}

		/* And allow as a class rule. */
		$.validator.addClassRules('cpDate', {cpDate: true});

		var comparisons = {equal: 'eq', same: 'eq', notEqual: 'ne', notSame: 'ne',
			lessThan: 'lt', before: 'lt', greaterThan: 'gt', after: 'gt',
			notLessThan: 'ge', notBefore: 'ge', notGreaterThan: 'le', notAfter: 'le'};

		/** Cross-validate date fields.
			params should be an array with [0] comparison type eq/ne/lt/gt/le/ge or synonyms,
			[1] 'today' or date string or CDate or other field selector/element/jQuery OR
			an object with one attribute with name eq/ne/lt/gt/le/ge or synonyms
			and value 'today' or date string or CDate or other field selector/element/jQuery OR
			a string with eq/ne/lt/gt/le/ge or synonyms followed by 'today' or date string or jQuery selector. */
		$.validator.addMethod('cpCompareDate', function(value, elem, params) {
				if (this.optional(elem)) {
					return true;
				}
				params = normaliseParams(params);
				var thisDate = $(elem).calendarsPicker('getDate');
				var thatDate = extractOtherDate(elem, params[1]);
				if (thisDate.length === 0 || thatDate.length === 0) {
					return true;
				}
				lastElem = elem;
				var finalResult = true;
				for (var i = 0; i < thisDate.length; i++) {
					var result = thisDate[i].compareTo(thatDate[0]);
					switch (comparisons[params[0]] || params[0]) {
						case 'eq': finalResult = (result === 0); break;
						case 'ne': finalResult = (result !== 0); break;
						case 'lt': finalResult = (result < 0); break;
						case 'gt': finalResult = (result > 0); break;
						case 'le': finalResult = (result <= 0); break;
						case 'ge': finalResult = (result >= 0); break;
						default:   finalResult = true;
					}
					if (!finalResult) {
						break;
					}
				}
				return finalResult;
			},
			function(params) {
				var messages = $.calendarsPicker.defaultOptions;
				params = normaliseParams(params);
				var thatDate = extractOtherDate(lastElem, params[1], true);
				thatDate = (params[1] === 'today' ? messages.validateDateToday : 
					(thatDate.length ? thatDate[0].formatDate() : messages.validateDateOther));
				return messages.validateDateCompare.replace(/\{0\}/,
					messages['validateDate' + (comparisons[params[0]] || params[0]).toUpperCase()]).
					replace(/\{1\}/, thatDate);
			});

		/** Normalise the comparison parameters to an array.
			@param params {Array|object|string} The original parameters.
			@return {Array} The normalised parameters. */
		function normaliseParams(params) {
			if (typeof params === 'string') {
				params = params.split(' ');
			}
			else if (!$.isArray(params)) {
				var opts = [];
				for (var name in params) {
					opts[0] = name;
					opts[1] = params[name];
				}
				params = opts;
			}
			return params;
		}

		/** Determine the comparison date.
			@param elem {Element} The current datepicker element.
			@param source {string|CDate|jQueryElement} The source of the other date.
			@param noOther {boolean} <code>true</code> to not get the date from another field.
			@return {CDate[]} The date for comparison. */
		function extractOtherDate(elem, source, noOther) {
			if (source.newDate && source.extraInfo) { // Already a CDate
				return [source];
			}
			var inst = $.calendarsPicker._getInst(elem);
			var thatDate = null;
			try {
				if (typeof source === 'string' && source !== 'today') {
					thatDate = inst.options.calendar.parseDate(inst.get('dateFormat'), source);
				}
			}
			catch (e) {
				// Ignore
			}
			thatDate = (thatDate ? [thatDate] : (source === 'today' ?
				[inst.options.calendar.today()] : (noOther ? [] : $(source).calendarsPicker('getDate'))));
			return thatDate;
		}
	}

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMudmFsaWRhdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS5jYWxlbmRhcnMudmFsaWRhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvY2FsZW5kYXJzLmh0bWxcclxuICAgQ2FsZW5kYXJzIFZhbGlkYXRpb24gZXh0ZW5zaW9uIGZvciBqUXVlcnkgMi4wLjEuXHJcbiAgIFJlcXVpcmVzIErDtnJuIFphZWZmZXJlcidzIFZhbGlkYXRpb24gcGx1Z2luIChodHRwOi8vcGx1Z2lucy5qcXVlcnkuY29tL3Byb2plY3QvdmFsaWRhdGUpLlxyXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpLlxyXG4gICBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCAoaHR0cDovL2tlaXRoLXdvb2QubmFtZS9saWNlbmNlLmh0bWwpIGxpY2Vuc2UuIFxyXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cclxuXHJcbihmdW5jdGlvbigkKSB7IC8vIEhpZGUgdGhlIG5hbWVzcGFjZVxyXG5cclxuXHQvKiBBZGQgdmFsaWRhdGlvbiBtZXRob2RzIGlmIHZhbGlkYXRpb24gcGx1Z2luIGF2YWlsYWJsZS4gKi9cclxuXHRpZiAoJC5mbi52YWxpZGF0ZSkge1xyXG5cclxuXHRcdCQuY2FsZW5kYXJzUGlja2VyLnNlbGVjdERhdGVPcmlnID0gJC5jYWxlbmRhcnNQaWNrZXIuc2VsZWN0RGF0ZTtcclxuXHRcdFxyXG5cdFx0JC5leHRlbmQoJC5jYWxlbmRhcnNQaWNrZXIucmVnaW9uYWxPcHRpb25zWycnXSwge1xyXG5cdFx0XHR2YWxpZGF0ZURhdGU6ICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlJyxcclxuXHRcdFx0dmFsaWRhdGVEYXRlTWluOiAnUGxlYXNlIGVudGVyIGEgZGF0ZSBvbiBvciBhZnRlciB7MH0nLFxyXG5cdFx0XHR2YWxpZGF0ZURhdGVNYXg6ICdQbGVhc2UgZW50ZXIgYSBkYXRlIG9uIG9yIGJlZm9yZSB7MH0nLFxyXG5cdFx0XHR2YWxpZGF0ZURhdGVNaW5NYXg6ICdQbGVhc2UgZW50ZXIgYSBkYXRlIGJldHdlZW4gezB9IGFuZCB7MX0nLFxyXG5cdFx0XHR2YWxpZGF0ZURhdGVDb21wYXJlOiAnUGxlYXNlIGVudGVyIGEgZGF0ZSB7MH0gezF9JyxcclxuXHRcdFx0dmFsaWRhdGVEYXRlVG9kYXk6ICd0b2RheScsXHJcblx0XHRcdHZhbGlkYXRlRGF0ZU90aGVyOiAndGhlIG90aGVyIGRhdGUnLFxyXG5cdFx0XHR2YWxpZGF0ZURhdGVFUTogJ2VxdWFsIHRvJyxcclxuXHRcdFx0dmFsaWRhdGVEYXRlTkU6ICdub3QgZXF1YWwgdG8nLFxyXG5cdFx0XHR2YWxpZGF0ZURhdGVMVDogJ2JlZm9yZScsXHJcblx0XHRcdHZhbGlkYXRlRGF0ZUdUOiAnYWZ0ZXInLFxyXG5cdFx0XHR2YWxpZGF0ZURhdGVMRTogJ25vdCBhZnRlcicsXHJcblx0XHRcdHZhbGlkYXRlRGF0ZUdFOiAnbm90IGJlZm9yZSdcclxuXHRcdH0pO1xyXG5cdFx0XHJcblx0XHQkLmV4dGVuZCgkLmNhbGVuZGFyc1BpY2tlci5kZWZhdWx0T3B0aW9ucywgJC5jYWxlbmRhcnNQaWNrZXIucmVnaW9uYWxPcHRpb25zWycnXSk7XHJcblxyXG5cdFx0JC5leHRlbmQoJC5jYWxlbmRhcnNQaWNrZXIsIHtcclxuXHJcblx0XHRcdC8qKiBUcmlnZ2VyIGEgdmFsaWRhdGlvbiBhZnRlciB1cGRhdGluZyB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS5cclxuXHRcdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cclxuXHRcdFx0XHRAcGFyYW0gdGFyZ2V0IHtFbGVtZW50fSBUaGUgc2VsZWN0ZWQgZGF0ZXBpY2tlciBlbGVtZW50LiAqL1xyXG5cdFx0XHRzZWxlY3REYXRlOiBmdW5jdGlvbihlbGVtLCB0YXJnZXQpIHtcclxuXHRcdFx0XHR0aGlzLnNlbGVjdERhdGVPcmlnKGVsZW0sIHRhcmdldCk7XHJcblx0XHRcdFx0dmFyIGluc3QgPSAkLmNhbGVuZGFyc1BpY2tlci5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0XHRpZiAoIWluc3QuaW5saW5lICYmICQuZm4udmFsaWRhdGUpIHtcclxuXHRcdFx0XHRcdHZhciB2YWxpZGF0aW9uID0gJChlbGVtKS5wYXJlbnRzKCdmb3JtJykudmFsaWRhdGUoKTtcclxuXHRcdFx0XHRcdGlmICh2YWxpZGF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdHZhbGlkYXRpb24uZWxlbWVudCgnIycgKyBlbGVtLmlkKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvKiogQ29ycmVjdCBlcnJvciBwbGFjZW1lbnQgZm9yIHZhbGlkYXRpb24gZXJyb3JzIC0gYWZ0ZXIgYW55IHRyaWdnZXIuXHJcblx0XHRcdFx0QHBhcmFtIGVycm9yIHtqUXVlcnl9IFRoZSBlcnJvciBtZXNzYWdlLlxyXG5cdFx0XHRcdEBwYXJhbSBlbGVtIHtqUXVlcnl9IFRoZSBmaWVsZCBpbiBlcnJvci4gKi9cclxuXHRcdFx0ZXJyb3JQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVycm9yLCBlbGVtKSB7XHJcblx0XHRcdFx0dmFyIGluc3QgPSAkLmNhbGVuZGFyc1BpY2tlci5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0XHRpZiAoaW5zdCkge1xyXG5cdFx0XHRcdFx0ZXJyb3JbaW5zdC5vcHRpb25zLmlzUlRMID8gJ2luc2VydEJlZm9yZScgOiAnaW5zZXJ0QWZ0ZXInXShcclxuXHRcdFx0XHRcdFx0aW5zdC50cmlnZ2VyLmxlbmd0aCA+IDAgPyBpbnN0LnRyaWdnZXIgOiBlbGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRlcnJvci5pbnNlcnRBZnRlcihlbGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvKiogRm9ybWF0IGEgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlIGludm9sdmluZyBkYXRlcy5cclxuXHRcdFx0XHRAcGFyYW0gc291cmNlIHtzdHJpbmd9IFRoZSBlcnJvciBtZXNzYWdlLlxyXG5cdFx0XHRcdEBwYXJhbSBwYXJhbXMge0RhdGVbXX0gVGhlIGRhdGVzLlxyXG5cdFx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBtZXNzYWdlLiAqL1xyXG5cdFx0XHRlcnJvckZvcm1hdDogZnVuY3Rpb24oc291cmNlLCBwYXJhbXMpIHtcclxuXHRcdFx0XHR2YXIgZm9ybWF0ID0gKCQuY2FsZW5kYXJzUGlja2VyLmN1ckluc3QgP1xyXG5cdFx0XHRcdFx0JC5jYWxlbmRhcnNQaWNrZXIuY3VySW5zdC5nZXQoJ2RhdGVGb3JtYXQnKSA6XHJcblx0XHRcdFx0XHQkLmNhbGVuZGFyc1BpY2tlci5kZWZhdWx0T3B0aW9ucy5kYXRlRm9ybWF0KTtcclxuXHRcdFx0XHQkLmVhY2gocGFyYW1zLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuXHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFx7JyArIGluZGV4ICsgJ1xcXFx9JywgJ2cnKSxcclxuXHRcdFx0XHRcdFx0dmFsdWUuZm9ybWF0RGF0ZShmb3JtYXQpIHx8ICdub3RoaW5nJyk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0cmV0dXJuIHNvdXJjZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIGxhc3RFbGVtID0gbnVsbDtcclxuXHJcblx0XHQvKiBWYWxpZGF0ZSBkYXRlIGZpZWxkLiAqL1xyXG5cdFx0JC52YWxpZGF0b3IuYWRkTWV0aG9kKCdjcERhdGUnLCBmdW5jdGlvbih2YWx1ZSwgZWxlbSkge1xyXG5cdFx0XHRcdGxhc3RFbGVtID0gZWxlbTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbChlbGVtKSB8fCB2YWxpZGF0ZUVhY2godmFsdWUsIGVsZW0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRmdW5jdGlvbihwYXJhbXMpIHtcclxuXHRcdFx0XHR2YXIgaW5zdCA9ICQuY2FsZW5kYXJzUGlja2VyLl9nZXRJbnN0KGxhc3RFbGVtKTtcclxuXHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuZ2V0KCdtaW5EYXRlJyk7XHJcblx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdHZhciBtZXNzYWdlcyA9ICQuY2FsZW5kYXJzUGlja2VyLmRlZmF1bHRPcHRpb25zO1xyXG5cdFx0XHRcdHJldHVybiAobWluRGF0ZSAmJiBtYXhEYXRlID9cclxuXHRcdFx0XHRcdCQuY2FsZW5kYXJzUGlja2VyLmVycm9yRm9ybWF0KG1lc3NhZ2VzLnZhbGlkYXRlRGF0ZU1pbk1heCwgW21pbkRhdGUsIG1heERhdGVdKSA6XHJcblx0XHRcdFx0XHQobWluRGF0ZSA/ICQuY2FsZW5kYXJzUGlja2VyLmVycm9yRm9ybWF0KG1lc3NhZ2VzLnZhbGlkYXRlRGF0ZU1pbiwgW21pbkRhdGVdKSA6XHJcblx0XHRcdFx0XHQobWF4RGF0ZSA/ICQuY2FsZW5kYXJzUGlja2VyLmVycm9yRm9ybWF0KG1lc3NhZ2VzLnZhbGlkYXRlRGF0ZU1heCwgW21heERhdGVdKSA6XHJcblx0XHRcdFx0XHRtZXNzYWdlcy52YWxpZGF0ZURhdGUpKSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8qKiBBcHBseSBhIHZhbGlkYXRpb24gdGVzdCB0byBlYWNoIGRhdGUgcHJvdmlkZWQuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSB2YWx1ZSB7c3RyaW5nfSBUaGUgY3VycmVudCBmaWVsZCB2YWx1ZS5cclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBmaWVsZCBjb250cm9sLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBPSywgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIGZhaWxlZCB2YWxpZGF0aW9uLiAqL1xyXG5cdFx0ZnVuY3Rpb24gdmFsaWRhdGVFYWNoKHZhbHVlLCBlbGVtKSB7XHJcblx0XHRcdHZhciBpbnN0ID0gJC5jYWxlbmRhcnNQaWNrZXIuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdHZhciBkYXRlcyA9IChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgPyB2YWx1ZS5zcGxpdChpbnN0Lm9wdGlvbnMubXVsdGlTZXBhcmF0b3IpIDpcclxuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gdmFsdWUuc3BsaXQoaW5zdC5vcHRpb25zLnJhbmdlU2VwYXJhdG9yKSA6IFt2YWx1ZV0pKTtcclxuXHRcdFx0dmFyIG9rID0gKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCAmJiBkYXRlcy5sZW5ndGggPD0gaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0KSB8fFxyXG5cdFx0XHRcdCghaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0ICYmIGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCAmJiBkYXRlcy5sZW5ndGggPT09IDIpIHx8XHJcblx0XHRcdFx0KCFpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgJiYgIWluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCAmJiBkYXRlcy5sZW5ndGggPT09IDEpO1xyXG5cdFx0XHRpZiAob2spIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xyXG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmdldCgnbWluRGF0ZScpO1xyXG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdFx0dmFyIGNwID0gJChlbGVtKTtcclxuXHRcdFx0XHRcdCQuZWFjaChkYXRlcywgZnVuY3Rpb24oaSwgdikge1xyXG5cdFx0XHRcdFx0XHRkYXRlc1tpXSA9IGluc3Qub3B0aW9ucy5jYWxlbmRhci5wYXJzZURhdGUoZGF0ZUZvcm1hdCwgdik7XHJcblx0XHRcdFx0XHRcdG9rID0gb2sgJiYgKCFkYXRlc1tpXSB8fCAoY3AuY2FsZW5kYXJzUGlja2VyKCdpc1NlbGVjdGFibGUnLCBkYXRlc1tpXSkgJiZcclxuXHRcdFx0XHRcdFx0XHQoIW1pbkRhdGUgfHwgZGF0ZXNbaV0uY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSkgJiZcclxuXHRcdFx0XHRcdFx0XHQoIW1heERhdGUgfHwgZGF0ZXNbaV0uY29tcGFyZVRvKG1heERhdGUpICE9PSArMSkpKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0b2sgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9rICYmIGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCkge1xyXG5cdFx0XHRcdG9rID0gKGRhdGVzWzBdLmNvbXBhcmVUbyhkYXRlc1sxXSkgIT09ICsxKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gb2s7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogQW5kIGFsbG93IGFzIGEgY2xhc3MgcnVsZS4gKi9cclxuXHRcdCQudmFsaWRhdG9yLmFkZENsYXNzUnVsZXMoJ2NwRGF0ZScsIHtjcERhdGU6IHRydWV9KTtcclxuXHJcblx0XHR2YXIgY29tcGFyaXNvbnMgPSB7ZXF1YWw6ICdlcScsIHNhbWU6ICdlcScsIG5vdEVxdWFsOiAnbmUnLCBub3RTYW1lOiAnbmUnLFxyXG5cdFx0XHRsZXNzVGhhbjogJ2x0JywgYmVmb3JlOiAnbHQnLCBncmVhdGVyVGhhbjogJ2d0JywgYWZ0ZXI6ICdndCcsXHJcblx0XHRcdG5vdExlc3NUaGFuOiAnZ2UnLCBub3RCZWZvcmU6ICdnZScsIG5vdEdyZWF0ZXJUaGFuOiAnbGUnLCBub3RBZnRlcjogJ2xlJ307XHJcblxyXG5cdFx0LyoqIENyb3NzLXZhbGlkYXRlIGRhdGUgZmllbGRzLlxyXG5cdFx0XHRwYXJhbXMgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggWzBdIGNvbXBhcmlzb24gdHlwZSBlcS9uZS9sdC9ndC9sZS9nZSBvciBzeW5vbnltcyxcclxuXHRcdFx0WzFdICd0b2RheScgb3IgZGF0ZSBzdHJpbmcgb3IgQ0RhdGUgb3Igb3RoZXIgZmllbGQgc2VsZWN0b3IvZWxlbWVudC9qUXVlcnkgT1JcclxuXHRcdFx0YW4gb2JqZWN0IHdpdGggb25lIGF0dHJpYnV0ZSB3aXRoIG5hbWUgZXEvbmUvbHQvZ3QvbGUvZ2Ugb3Igc3lub255bXNcclxuXHRcdFx0YW5kIHZhbHVlICd0b2RheScgb3IgZGF0ZSBzdHJpbmcgb3IgQ0RhdGUgb3Igb3RoZXIgZmllbGQgc2VsZWN0b3IvZWxlbWVudC9qUXVlcnkgT1JcclxuXHRcdFx0YSBzdHJpbmcgd2l0aCBlcS9uZS9sdC9ndC9sZS9nZSBvciBzeW5vbnltcyBmb2xsb3dlZCBieSAndG9kYXknIG9yIGRhdGUgc3RyaW5nIG9yIGpRdWVyeSBzZWxlY3Rvci4gKi9cclxuXHRcdCQudmFsaWRhdG9yLmFkZE1ldGhvZCgnY3BDb21wYXJlRGF0ZScsIGZ1bmN0aW9uKHZhbHVlLCBlbGVtLCBwYXJhbXMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25hbChlbGVtKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBhcmFtcyA9IG5vcm1hbGlzZVBhcmFtcyhwYXJhbXMpO1xyXG5cdFx0XHRcdHZhciB0aGlzRGF0ZSA9ICQoZWxlbSkuY2FsZW5kYXJzUGlja2VyKCdnZXREYXRlJyk7XHJcblx0XHRcdFx0dmFyIHRoYXREYXRlID0gZXh0cmFjdE90aGVyRGF0ZShlbGVtLCBwYXJhbXNbMV0pO1xyXG5cdFx0XHRcdGlmICh0aGlzRGF0ZS5sZW5ndGggPT09IDAgfHwgdGhhdERhdGUubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGFzdEVsZW0gPSBlbGVtO1xyXG5cdFx0XHRcdHZhciBmaW5hbFJlc3VsdCA9IHRydWU7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzRGF0ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXNEYXRlW2ldLmNvbXBhcmVUbyh0aGF0RGF0ZVswXSk7XHJcblx0XHRcdFx0XHRzd2l0Y2ggKGNvbXBhcmlzb25zW3BhcmFtc1swXV0gfHwgcGFyYW1zWzBdKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2VxJzogZmluYWxSZXN1bHQgPSAocmVzdWx0ID09PSAwKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ25lJzogZmluYWxSZXN1bHQgPSAocmVzdWx0ICE9PSAwKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2x0JzogZmluYWxSZXN1bHQgPSAocmVzdWx0IDwgMCk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdndCc6IGZpbmFsUmVzdWx0ID0gKHJlc3VsdCA+IDApOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbGUnOiBmaW5hbFJlc3VsdCA9IChyZXN1bHQgPD0gMCk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdnZSc6IGZpbmFsUmVzdWx0ID0gKHJlc3VsdCA+PSAwKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6ICAgZmluYWxSZXN1bHQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCFmaW5hbFJlc3VsdCkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZpbmFsUmVzdWx0O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRmdW5jdGlvbihwYXJhbXMpIHtcclxuXHRcdFx0XHR2YXIgbWVzc2FnZXMgPSAkLmNhbGVuZGFyc1BpY2tlci5kZWZhdWx0T3B0aW9ucztcclxuXHRcdFx0XHRwYXJhbXMgPSBub3JtYWxpc2VQYXJhbXMocGFyYW1zKTtcclxuXHRcdFx0XHR2YXIgdGhhdERhdGUgPSBleHRyYWN0T3RoZXJEYXRlKGxhc3RFbGVtLCBwYXJhbXNbMV0sIHRydWUpO1xyXG5cdFx0XHRcdHRoYXREYXRlID0gKHBhcmFtc1sxXSA9PT0gJ3RvZGF5JyA/IG1lc3NhZ2VzLnZhbGlkYXRlRGF0ZVRvZGF5IDogXHJcblx0XHRcdFx0XHQodGhhdERhdGUubGVuZ3RoID8gdGhhdERhdGVbMF0uZm9ybWF0RGF0ZSgpIDogbWVzc2FnZXMudmFsaWRhdGVEYXRlT3RoZXIpKTtcclxuXHRcdFx0XHRyZXR1cm4gbWVzc2FnZXMudmFsaWRhdGVEYXRlQ29tcGFyZS5yZXBsYWNlKC9cXHswXFx9LyxcclxuXHRcdFx0XHRcdG1lc3NhZ2VzWyd2YWxpZGF0ZURhdGUnICsgKGNvbXBhcmlzb25zW3BhcmFtc1swXV0gfHwgcGFyYW1zWzBdKS50b1VwcGVyQ2FzZSgpXSkuXHJcblx0XHRcdFx0XHRyZXBsYWNlKC9cXHsxXFx9LywgdGhhdERhdGUpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHQvKiogTm9ybWFsaXNlIHRoZSBjb21wYXJpc29uIHBhcmFtZXRlcnMgdG8gYW4gYXJyYXkuXHJcblx0XHRcdEBwYXJhbSBwYXJhbXMge0FycmF5fG9iamVjdHxzdHJpbmd9IFRoZSBvcmlnaW5hbCBwYXJhbWV0ZXJzLlxyXG5cdFx0XHRAcmV0dXJuIHtBcnJheX0gVGhlIG5vcm1hbGlzZWQgcGFyYW1ldGVycy4gKi9cclxuXHRcdGZ1bmN0aW9uIG5vcm1hbGlzZVBhcmFtcyhwYXJhbXMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0cGFyYW1zID0gcGFyYW1zLnNwbGl0KCcgJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoISQuaXNBcnJheShwYXJhbXMpKSB7XHJcblx0XHRcdFx0dmFyIG9wdHMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIHBhcmFtcykge1xyXG5cdFx0XHRcdFx0b3B0c1swXSA9IG5hbWU7XHJcblx0XHRcdFx0XHRvcHRzWzFdID0gcGFyYW1zW25hbWVdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwYXJhbXMgPSBvcHRzO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBwYXJhbXM7XHJcblx0XHR9XHJcblxyXG5cdFx0LyoqIERldGVybWluZSB0aGUgY29tcGFyaXNvbiBkYXRlLlxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGN1cnJlbnQgZGF0ZXBpY2tlciBlbGVtZW50LlxyXG5cdFx0XHRAcGFyYW0gc291cmNlIHtzdHJpbmd8Q0RhdGV8alF1ZXJ5RWxlbWVudH0gVGhlIHNvdXJjZSBvZiB0aGUgb3RoZXIgZGF0ZS5cclxuXHRcdFx0QHBhcmFtIG5vT3RoZXIge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIG5vdCBnZXQgdGhlIGRhdGUgZnJvbSBhbm90aGVyIGZpZWxkLlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZVtdfSBUaGUgZGF0ZSBmb3IgY29tcGFyaXNvbi4gKi9cclxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RPdGhlckRhdGUoZWxlbSwgc291cmNlLCBub090aGVyKSB7XHJcblx0XHRcdGlmIChzb3VyY2UubmV3RGF0ZSAmJiBzb3VyY2UuZXh0cmFJbmZvKSB7IC8vIEFscmVhZHkgYSBDRGF0ZVxyXG5cdFx0XHRcdHJldHVybiBbc291cmNlXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaW5zdCA9ICQuY2FsZW5kYXJzUGlja2VyLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHR2YXIgdGhhdERhdGUgPSBudWxsO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiBzb3VyY2UgIT09ICd0b2RheScpIHtcclxuXHRcdFx0XHRcdHRoYXREYXRlID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyLnBhcnNlRGF0ZShpbnN0LmdldCgnZGF0ZUZvcm1hdCcpLCBzb3VyY2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdC8vIElnbm9yZVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoYXREYXRlID0gKHRoYXREYXRlID8gW3RoYXREYXRlXSA6IChzb3VyY2UgPT09ICd0b2RheScgP1xyXG5cdFx0XHRcdFtpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKV0gOiAobm9PdGhlciA/IFtdIDogJChzb3VyY2UpLmNhbGVuZGFyc1BpY2tlcignZ2V0RGF0ZScpKSkpO1xyXG5cdFx0XHRyZXR1cm4gdGhhdERhdGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufSkoalF1ZXJ5KTtcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
