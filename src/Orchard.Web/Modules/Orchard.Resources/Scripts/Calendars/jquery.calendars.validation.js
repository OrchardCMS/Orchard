/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars Validation extension for jQuery 2.0.1.
   Requires JÃ¶rn Zaefferer's Validation plugin (http://plugins.jquery.com/project/validate).
   Written by Keith Wood (kbwood{at}iinet.com.au).
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide the namespace

	/* Add validation methods if validation plugin available. */
	if ($.fn.validate) {

		$.calendarsPicker.selectDateOrig = $.calendarsPicker.selectDate;
		
		$.extend($.calendarsPicker.regionalOptions[''], {
			validateDate: 'Please enter a valid date',
			validateDateMin: 'Please enter a date on or after {0}',
			validateDateMax: 'Please enter a date on or before {0}',
			validateDateMinMax: 'Please enter a date between {0} and {1}',
			validateDateCompare: 'Please enter a date {0} {1}',
			validateDateToday: 'today',
			validateDateOther: 'the other date',
			validateDateEQ: 'equal to',
			validateDateNE: 'not equal to',
			validateDateLT: 'before',
			validateDateGT: 'after',
			validateDateLE: 'not after',
			validateDateGE: 'not before'
		});
		
		$.extend($.calendarsPicker.defaultOptions, $.calendarsPicker.regionalOptions['']);

		$.extend($.calendarsPicker, {

			/** Trigger a validation after updating the input field with the selected date.
				@param elem {Element} The control to examine.
				@param target {Element} The selected datepicker element. */
			selectDate: function(elem, target) {
				this.selectDateOrig(elem, target);
				var inst = $.calendarsPicker._getInst(elem);
				if (!inst.inline && $.fn.validate) {
					var validation = $(elem).parents('form').validate();
					if (validation) {
						validation.element('#' + elem.id);
					}
				}
			},

			/** Correct error placement for validation errors - after any trigger.
				@param error {jQuery} The error message.
				@param elem {jQuery} The field in error. */
			errorPlacement: function(error, elem) {
				var inst = $.calendarsPicker._getInst(elem);
				if (inst) {
					error[inst.options.isRTL ? 'insertBefore' : 'insertAfter'](
						inst.trigger.length > 0 ? inst.trigger : elem);
				}
				else {
					error.insertAfter(elem);
				}
			},

			/** Format a validation error message involving dates.
				@param source {string} The error message.
				@param params {Date[]} The dates.
				@return {string} The formatted message. */
			errorFormat: function(source, params) {
				var format = ($.calendarsPicker.curInst ?
					$.calendarsPicker.curInst.get('dateFormat') :
					$.calendarsPicker.defaultOptions.dateFormat);
				$.each(params, function(index, value) {
					source = source.replace(new RegExp('\\{' + index + '\\}', 'g'),
						value.formatDate(format) || 'nothing');
				});
				return source;
			}
		});

		var lastElem = null;

		/* Validate date field. */
		$.validator.addMethod('cpDate', function(value, elem) {
				lastElem = elem;
				return this.optional(elem) || validateEach(value, elem);
			},
			function(params) {
				var inst = $.calendarsPicker._getInst(lastElem);
				var minDate = inst.get('minDate');
				var maxDate = inst.get('maxDate');
				var messages = $.calendarsPicker.defaultOptions;
				return (minDate && maxDate ?
					$.calendarsPicker.errorFormat(messages.validateDateMinMax, [minDate, maxDate]) :
					(minDate ? $.calendarsPicker.errorFormat(messages.validateDateMin, [minDate]) :
					(maxDate ? $.calendarsPicker.errorFormat(messages.validateDateMax, [maxDate]) :
					messages.validateDate)));
			});

		/** Apply a validation test to each date provided.
			@private
			@param value {string} The current field value.
			@param elem {Element} The field control.
			@return {boolean} <code>true</code> if OK, <code>false</code> if failed validation. */
		function validateEach(value, elem) {
			var inst = $.calendarsPicker._getInst(elem);
			var dates = (inst.options.multiSelect ? value.split(inst.options.multiSeparator) :
				(inst.options.rangeSelect ? value.split(inst.options.rangeSeparator) : [value]));
			var ok = (inst.options.multiSelect && dates.length <= inst.options.multiSelect) ||
				(!inst.options.multiSelect && inst.options.rangeSelect && dates.length === 2) ||
				(!inst.options.multiSelect && !inst.options.rangeSelect && dates.length === 1);
			if (ok) {
				try {
					var dateFormat = inst.get('dateFormat');
					var minDate = inst.get('minDate');
					var maxDate = inst.get('maxDate');
					var cp = $(elem);
					$.each(dates, function(i, v) {
						dates[i] = inst.options.calendar.parseDate(dateFormat, v);
						ok = ok && (!dates[i] || (cp.calendarsPicker('isSelectable', dates[i]) &&
							(!minDate || dates[i].compareTo(minDate) !== -1) &&
							(!maxDate || dates[i].compareTo(maxDate) !== +1)));
					});
				}
				catch (e) {
					ok = false;
				}
			}
			if (ok && inst.options.rangeSelect) {
				ok = (dates[0].compareTo(dates[1]) !== +1);
			}
			return ok;
		}

		/* And allow as a class rule. */
		$.validator.addClassRules('cpDate', {cpDate: true});

		var comparisons = {equal: 'eq', same: 'eq', notEqual: 'ne', notSame: 'ne',
			lessThan: 'lt', before: 'lt', greaterThan: 'gt', after: 'gt',
			notLessThan: 'ge', notBefore: 'ge', notGreaterThan: 'le', notAfter: 'le'};

		/** Cross-validate date fields.
			params should be an array with [0] comparison type eq/ne/lt/gt/le/ge or synonyms,
			[1] 'today' or date string or CDate or other field selector/element/jQuery OR
			an object with one attribute with name eq/ne/lt/gt/le/ge or synonyms
			and value 'today' or date string or CDate or other field selector/element/jQuery OR
			a string with eq/ne/lt/gt/le/ge or synonyms followed by 'today' or date string or jQuery selector. */
		$.validator.addMethod('cpCompareDate', function(value, elem, params) {
				if (this.optional(elem)) {
					return true;
				}
				params = normaliseParams(params);
				var thisDate = $(elem).calendarsPicker('getDate');
				var thatDate = extractOtherDate(elem, params[1]);
				if (thisDate.length === 0 || thatDate.length === 0) {
					return true;
				}
				lastElem = elem;
				var finalResult = true;
				for (var i = 0; i < thisDate.length; i++) {
					var result = thisDate[i].compareTo(thatDate[0]);
					switch (comparisons[params[0]] || params[0]) {
						case 'eq': finalResult = (result === 0); break;
						case 'ne': finalResult = (result !== 0); break;
						case 'lt': finalResult = (result < 0); break;
						case 'gt': finalResult = (result > 0); break;
						case 'le': finalResult = (result <= 0); break;
						case 'ge': finalResult = (result >= 0); break;
						default:   finalResult = true;
					}
					if (!finalResult) {
						break;
					}
				}
				return finalResult;
			},
			function(params) {
				var messages = $.calendarsPicker.defaultOptions;
				params = normaliseParams(params);
				var thatDate = extractOtherDate(lastElem, params[1], true);
				thatDate = (params[1] === 'today' ? messages.validateDateToday : 
					(thatDate.length ? thatDate[0].formatDate() : messages.validateDateOther));
				return messages.validateDateCompare.replace(/\{0\}/,
					messages['validateDate' + (comparisons[params[0]] || params[0]).toUpperCase()]).
					replace(/\{1\}/, thatDate);
			});

		/** Normalise the comparison parameters to an array.
			@param params {Array|object|string} The original parameters.
			@return {Array} The normalised parameters. */
		function normaliseParams(params) {
			if (typeof params === 'string') {
				params = params.split(' ');
			}
			else if (!$.isArray(params)) {
				var opts = [];
				for (var name in params) {
					opts[0] = name;
					opts[1] = params[name];
				}
				params = opts;
			}
			return params;
		}

		/** Determine the comparison date.
			@param elem {Element} The current datepicker element.
			@param source {string|CDate|jQueryElement} The source of the other date.
			@param noOther {boolean} <code>true</code> to not get the date from another field.
			@return {CDate[]} The date for comparison. */
		function extractOtherDate(elem, source, noOther) {
			if (source.newDate && source.extraInfo) { // Already a CDate
				return [source];
			}
			var inst = $.calendarsPicker._getInst(elem);
			var thatDate = null;
			try {
				if (typeof source === 'string' && source !== 'today') {
					thatDate = inst.options.calendar.parseDate(inst.get('dateFormat'), source);
				}
			}
			catch (e) {
				// Ignore
			}
			thatDate = (thatDate ? [thatDate] : (source === 'today' ?
				[inst.options.calendar.today()] : (noOther ? [] : $(source).calendarsPicker('getDate'))));
			return thatDate;
		}
	}

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMudmFsaWRhdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS5jYWxlbmRhcnMudmFsaWRhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvY2FsZW5kYXJzLmh0bWxcbiAgIENhbGVuZGFycyBWYWxpZGF0aW9uIGV4dGVuc2lvbiBmb3IgalF1ZXJ5IDIuMC4xLlxuICAgUmVxdWlyZXMgSsO2cm4gWmFlZmZlcmVyJ3MgVmFsaWRhdGlvbiBwbHVnaW4gKGh0dHA6Ly9wbHVnaW5zLmpxdWVyeS5jb20vcHJvamVjdC92YWxpZGF0ZSkuXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpLlxuICAgQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvbGljZW5jZS5odG1sKSBsaWNlbnNlLiBcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xuXG4oZnVuY3Rpb24oJCkgeyAvLyBIaWRlIHRoZSBuYW1lc3BhY2VcblxuXHQvKiBBZGQgdmFsaWRhdGlvbiBtZXRob2RzIGlmIHZhbGlkYXRpb24gcGx1Z2luIGF2YWlsYWJsZS4gKi9cblx0aWYgKCQuZm4udmFsaWRhdGUpIHtcblxuXHRcdCQuY2FsZW5kYXJzUGlja2VyLnNlbGVjdERhdGVPcmlnID0gJC5jYWxlbmRhcnNQaWNrZXIuc2VsZWN0RGF0ZTtcblx0XHRcblx0XHQkLmV4dGVuZCgkLmNhbGVuZGFyc1BpY2tlci5yZWdpb25hbE9wdGlvbnNbJyddLCB7XG5cdFx0XHR2YWxpZGF0ZURhdGU6ICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlJyxcblx0XHRcdHZhbGlkYXRlRGF0ZU1pbjogJ1BsZWFzZSBlbnRlciBhIGRhdGUgb24gb3IgYWZ0ZXIgezB9Jyxcblx0XHRcdHZhbGlkYXRlRGF0ZU1heDogJ1BsZWFzZSBlbnRlciBhIGRhdGUgb24gb3IgYmVmb3JlIHswfScsXG5cdFx0XHR2YWxpZGF0ZURhdGVNaW5NYXg6ICdQbGVhc2UgZW50ZXIgYSBkYXRlIGJldHdlZW4gezB9IGFuZCB7MX0nLFxuXHRcdFx0dmFsaWRhdGVEYXRlQ29tcGFyZTogJ1BsZWFzZSBlbnRlciBhIGRhdGUgezB9IHsxfScsXG5cdFx0XHR2YWxpZGF0ZURhdGVUb2RheTogJ3RvZGF5Jyxcblx0XHRcdHZhbGlkYXRlRGF0ZU90aGVyOiAndGhlIG90aGVyIGRhdGUnLFxuXHRcdFx0dmFsaWRhdGVEYXRlRVE6ICdlcXVhbCB0bycsXG5cdFx0XHR2YWxpZGF0ZURhdGVORTogJ25vdCBlcXVhbCB0bycsXG5cdFx0XHR2YWxpZGF0ZURhdGVMVDogJ2JlZm9yZScsXG5cdFx0XHR2YWxpZGF0ZURhdGVHVDogJ2FmdGVyJyxcblx0XHRcdHZhbGlkYXRlRGF0ZUxFOiAnbm90IGFmdGVyJyxcblx0XHRcdHZhbGlkYXRlRGF0ZUdFOiAnbm90IGJlZm9yZSdcblx0XHR9KTtcblx0XHRcblx0XHQkLmV4dGVuZCgkLmNhbGVuZGFyc1BpY2tlci5kZWZhdWx0T3B0aW9ucywgJC5jYWxlbmRhcnNQaWNrZXIucmVnaW9uYWxPcHRpb25zWycnXSk7XG5cblx0XHQkLmV4dGVuZCgkLmNhbGVuZGFyc1BpY2tlciwge1xuXG5cdFx0XHQvKiogVHJpZ2dlciBhIHZhbGlkYXRpb24gYWZ0ZXIgdXBkYXRpbmcgdGhlIGlucHV0IGZpZWxkIHdpdGggdGhlIHNlbGVjdGVkIGRhdGUuXG5cdFx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxuXHRcdFx0XHRAcGFyYW0gdGFyZ2V0IHtFbGVtZW50fSBUaGUgc2VsZWN0ZWQgZGF0ZXBpY2tlciBlbGVtZW50LiAqL1xuXHRcdFx0c2VsZWN0RGF0ZTogZnVuY3Rpb24oZWxlbSwgdGFyZ2V0KSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0RGF0ZU9yaWcoZWxlbSwgdGFyZ2V0KTtcblx0XHRcdFx0dmFyIGluc3QgPSAkLmNhbGVuZGFyc1BpY2tlci5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdFx0aWYgKCFpbnN0LmlubGluZSAmJiAkLmZuLnZhbGlkYXRlKSB7XG5cdFx0XHRcdFx0dmFyIHZhbGlkYXRpb24gPSAkKGVsZW0pLnBhcmVudHMoJ2Zvcm0nKS52YWxpZGF0ZSgpO1xuXHRcdFx0XHRcdGlmICh2YWxpZGF0aW9uKSB7XG5cdFx0XHRcdFx0XHR2YWxpZGF0aW9uLmVsZW1lbnQoJyMnICsgZWxlbS5pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiogQ29ycmVjdCBlcnJvciBwbGFjZW1lbnQgZm9yIHZhbGlkYXRpb24gZXJyb3JzIC0gYWZ0ZXIgYW55IHRyaWdnZXIuXG5cdFx0XHRcdEBwYXJhbSBlcnJvciB7alF1ZXJ5fSBUaGUgZXJyb3IgbWVzc2FnZS5cblx0XHRcdFx0QHBhcmFtIGVsZW0ge2pRdWVyeX0gVGhlIGZpZWxkIGluIGVycm9yLiAqL1xuXHRcdFx0ZXJyb3JQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVycm9yLCBlbGVtKSB7XG5cdFx0XHRcdHZhciBpbnN0ID0gJC5jYWxlbmRhcnNQaWNrZXIuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRcdGlmIChpbnN0KSB7XG5cdFx0XHRcdFx0ZXJyb3JbaW5zdC5vcHRpb25zLmlzUlRMID8gJ2luc2VydEJlZm9yZScgOiAnaW5zZXJ0QWZ0ZXInXShcblx0XHRcdFx0XHRcdGluc3QudHJpZ2dlci5sZW5ndGggPiAwID8gaW5zdC50cmlnZ2VyIDogZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZXJyb3IuaW5zZXJ0QWZ0ZXIoZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKiBGb3JtYXQgYSB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2UgaW52b2x2aW5nIGRhdGVzLlxuXHRcdFx0XHRAcGFyYW0gc291cmNlIHtzdHJpbmd9IFRoZSBlcnJvciBtZXNzYWdlLlxuXHRcdFx0XHRAcGFyYW0gcGFyYW1zIHtEYXRlW119IFRoZSBkYXRlcy5cblx0XHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIG1lc3NhZ2UuICovXG5cdFx0XHRlcnJvckZvcm1hdDogZnVuY3Rpb24oc291cmNlLCBwYXJhbXMpIHtcblx0XHRcdFx0dmFyIGZvcm1hdCA9ICgkLmNhbGVuZGFyc1BpY2tlci5jdXJJbnN0ID9cblx0XHRcdFx0XHQkLmNhbGVuZGFyc1BpY2tlci5jdXJJbnN0LmdldCgnZGF0ZUZvcm1hdCcpIDpcblx0XHRcdFx0XHQkLmNhbGVuZGFyc1BpY2tlci5kZWZhdWx0T3B0aW9ucy5kYXRlRm9ybWF0KTtcblx0XHRcdFx0JC5lYWNoKHBhcmFtcywgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG5cdFx0XHRcdFx0c291cmNlID0gc291cmNlLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXHsnICsgaW5kZXggKyAnXFxcXH0nLCAnZycpLFxuXHRcdFx0XHRcdFx0dmFsdWUuZm9ybWF0RGF0ZShmb3JtYXQpIHx8ICdub3RoaW5nJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gc291cmNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dmFyIGxhc3RFbGVtID0gbnVsbDtcblxuXHRcdC8qIFZhbGlkYXRlIGRhdGUgZmllbGQuICovXG5cdFx0JC52YWxpZGF0b3IuYWRkTWV0aG9kKCdjcERhdGUnLCBmdW5jdGlvbih2YWx1ZSwgZWxlbSkge1xuXHRcdFx0XHRsYXN0RWxlbSA9IGVsZW07XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKGVsZW0pIHx8IHZhbGlkYXRlRWFjaCh2YWx1ZSwgZWxlbSk7XG5cdFx0XHR9LFxuXHRcdFx0ZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0XHRcdHZhciBpbnN0ID0gJC5jYWxlbmRhcnNQaWNrZXIuX2dldEluc3QobGFzdEVsZW0pO1xuXHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuZ2V0KCdtaW5EYXRlJyk7XG5cdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcblx0XHRcdFx0dmFyIG1lc3NhZ2VzID0gJC5jYWxlbmRhcnNQaWNrZXIuZGVmYXVsdE9wdGlvbnM7XG5cdFx0XHRcdHJldHVybiAobWluRGF0ZSAmJiBtYXhEYXRlID9cblx0XHRcdFx0XHQkLmNhbGVuZGFyc1BpY2tlci5lcnJvckZvcm1hdChtZXNzYWdlcy52YWxpZGF0ZURhdGVNaW5NYXgsIFttaW5EYXRlLCBtYXhEYXRlXSkgOlxuXHRcdFx0XHRcdChtaW5EYXRlID8gJC5jYWxlbmRhcnNQaWNrZXIuZXJyb3JGb3JtYXQobWVzc2FnZXMudmFsaWRhdGVEYXRlTWluLCBbbWluRGF0ZV0pIDpcblx0XHRcdFx0XHQobWF4RGF0ZSA/ICQuY2FsZW5kYXJzUGlja2VyLmVycm9yRm9ybWF0KG1lc3NhZ2VzLnZhbGlkYXRlRGF0ZU1heCwgW21heERhdGVdKSA6XG5cdFx0XHRcdFx0bWVzc2FnZXMudmFsaWRhdGVEYXRlKSkpO1xuXHRcdFx0fSk7XG5cblx0XHQvKiogQXBwbHkgYSB2YWxpZGF0aW9uIHRlc3QgdG8gZWFjaCBkYXRlIHByb3ZpZGVkLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSB2YWx1ZSB7c3RyaW5nfSBUaGUgY3VycmVudCBmaWVsZCB2YWx1ZS5cblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgZmllbGQgY29udHJvbC5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIE9LLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgZmFpbGVkIHZhbGlkYXRpb24uICovXG5cdFx0ZnVuY3Rpb24gdmFsaWRhdGVFYWNoKHZhbHVlLCBlbGVtKSB7XG5cdFx0XHR2YXIgaW5zdCA9ICQuY2FsZW5kYXJzUGlja2VyLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0dmFyIGRhdGVzID0gKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCA/IHZhbHVlLnNwbGl0KGluc3Qub3B0aW9ucy5tdWx0aVNlcGFyYXRvcikgOlxuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gdmFsdWUuc3BsaXQoaW5zdC5vcHRpb25zLnJhbmdlU2VwYXJhdG9yKSA6IFt2YWx1ZV0pKTtcblx0XHRcdHZhciBvayA9IChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgJiYgZGF0ZXMubGVuZ3RoIDw9IGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCkgfHxcblx0XHRcdFx0KCFpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgJiYgaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ICYmIGRhdGVzLmxlbmd0aCA9PT0gMikgfHxcblx0XHRcdFx0KCFpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgJiYgIWluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCAmJiBkYXRlcy5sZW5ndGggPT09IDEpO1xuXHRcdFx0aWYgKG9rKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5nZXQoJ21pbkRhdGUnKTtcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XG5cdFx0XHRcdFx0dmFyIGNwID0gJChlbGVtKTtcblx0XHRcdFx0XHQkLmVhY2goZGF0ZXMsIGZ1bmN0aW9uKGksIHYpIHtcblx0XHRcdFx0XHRcdGRhdGVzW2ldID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyLnBhcnNlRGF0ZShkYXRlRm9ybWF0LCB2KTtcblx0XHRcdFx0XHRcdG9rID0gb2sgJiYgKCFkYXRlc1tpXSB8fCAoY3AuY2FsZW5kYXJzUGlja2VyKCdpc1NlbGVjdGFibGUnLCBkYXRlc1tpXSkgJiZcblx0XHRcdFx0XHRcdFx0KCFtaW5EYXRlIHx8IGRhdGVzW2ldLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXG5cdFx0XHRcdFx0XHRcdCghbWF4RGF0ZSB8fCBkYXRlc1tpXS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKSkpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9rICYmIGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCkge1xuXHRcdFx0XHRvayA9IChkYXRlc1swXS5jb21wYXJlVG8oZGF0ZXNbMV0pICE9PSArMSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2s7XG5cdFx0fVxuXG5cdFx0LyogQW5kIGFsbG93IGFzIGEgY2xhc3MgcnVsZS4gKi9cblx0XHQkLnZhbGlkYXRvci5hZGRDbGFzc1J1bGVzKCdjcERhdGUnLCB7Y3BEYXRlOiB0cnVlfSk7XG5cblx0XHR2YXIgY29tcGFyaXNvbnMgPSB7ZXF1YWw6ICdlcScsIHNhbWU6ICdlcScsIG5vdEVxdWFsOiAnbmUnLCBub3RTYW1lOiAnbmUnLFxuXHRcdFx0bGVzc1RoYW46ICdsdCcsIGJlZm9yZTogJ2x0JywgZ3JlYXRlclRoYW46ICdndCcsIGFmdGVyOiAnZ3QnLFxuXHRcdFx0bm90TGVzc1RoYW46ICdnZScsIG5vdEJlZm9yZTogJ2dlJywgbm90R3JlYXRlclRoYW46ICdsZScsIG5vdEFmdGVyOiAnbGUnfTtcblxuXHRcdC8qKiBDcm9zcy12YWxpZGF0ZSBkYXRlIGZpZWxkcy5cblx0XHRcdHBhcmFtcyBzaG91bGQgYmUgYW4gYXJyYXkgd2l0aCBbMF0gY29tcGFyaXNvbiB0eXBlIGVxL25lL2x0L2d0L2xlL2dlIG9yIHN5bm9ueW1zLFxuXHRcdFx0WzFdICd0b2RheScgb3IgZGF0ZSBzdHJpbmcgb3IgQ0RhdGUgb3Igb3RoZXIgZmllbGQgc2VsZWN0b3IvZWxlbWVudC9qUXVlcnkgT1Jcblx0XHRcdGFuIG9iamVjdCB3aXRoIG9uZSBhdHRyaWJ1dGUgd2l0aCBuYW1lIGVxL25lL2x0L2d0L2xlL2dlIG9yIHN5bm9ueW1zXG5cdFx0XHRhbmQgdmFsdWUgJ3RvZGF5JyBvciBkYXRlIHN0cmluZyBvciBDRGF0ZSBvciBvdGhlciBmaWVsZCBzZWxlY3Rvci9lbGVtZW50L2pRdWVyeSBPUlxuXHRcdFx0YSBzdHJpbmcgd2l0aCBlcS9uZS9sdC9ndC9sZS9nZSBvciBzeW5vbnltcyBmb2xsb3dlZCBieSAndG9kYXknIG9yIGRhdGUgc3RyaW5nIG9yIGpRdWVyeSBzZWxlY3Rvci4gKi9cblx0XHQkLnZhbGlkYXRvci5hZGRNZXRob2QoJ2NwQ29tcGFyZURhdGUnLCBmdW5jdGlvbih2YWx1ZSwgZWxlbSwgcGFyYW1zKSB7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbmFsKGVsZW0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyYW1zID0gbm9ybWFsaXNlUGFyYW1zKHBhcmFtcyk7XG5cdFx0XHRcdHZhciB0aGlzRGF0ZSA9ICQoZWxlbSkuY2FsZW5kYXJzUGlja2VyKCdnZXREYXRlJyk7XG5cdFx0XHRcdHZhciB0aGF0RGF0ZSA9IGV4dHJhY3RPdGhlckRhdGUoZWxlbSwgcGFyYW1zWzFdKTtcblx0XHRcdFx0aWYgKHRoaXNEYXRlLmxlbmd0aCA9PT0gMCB8fCB0aGF0RGF0ZS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0RWxlbSA9IGVsZW07XG5cdFx0XHRcdHZhciBmaW5hbFJlc3VsdCA9IHRydWU7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpc0RhdGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gdGhpc0RhdGVbaV0uY29tcGFyZVRvKHRoYXREYXRlWzBdKTtcblx0XHRcdFx0XHRzd2l0Y2ggKGNvbXBhcmlzb25zW3BhcmFtc1swXV0gfHwgcGFyYW1zWzBdKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdlcSc6IGZpbmFsUmVzdWx0ID0gKHJlc3VsdCA9PT0gMCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbmUnOiBmaW5hbFJlc3VsdCA9IChyZXN1bHQgIT09IDApOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2x0JzogZmluYWxSZXN1bHQgPSAocmVzdWx0IDwgMCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZ3QnOiBmaW5hbFJlc3VsdCA9IChyZXN1bHQgPiAwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdsZSc6IGZpbmFsUmVzdWx0ID0gKHJlc3VsdCA8PSAwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdnZSc6IGZpbmFsUmVzdWx0ID0gKHJlc3VsdCA+PSAwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OiAgIGZpbmFsUmVzdWx0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFmaW5hbFJlc3VsdCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmaW5hbFJlc3VsdDtcblx0XHRcdH0sXG5cdFx0XHRmdW5jdGlvbihwYXJhbXMpIHtcblx0XHRcdFx0dmFyIG1lc3NhZ2VzID0gJC5jYWxlbmRhcnNQaWNrZXIuZGVmYXVsdE9wdGlvbnM7XG5cdFx0XHRcdHBhcmFtcyA9IG5vcm1hbGlzZVBhcmFtcyhwYXJhbXMpO1xuXHRcdFx0XHR2YXIgdGhhdERhdGUgPSBleHRyYWN0T3RoZXJEYXRlKGxhc3RFbGVtLCBwYXJhbXNbMV0sIHRydWUpO1xuXHRcdFx0XHR0aGF0RGF0ZSA9IChwYXJhbXNbMV0gPT09ICd0b2RheScgPyBtZXNzYWdlcy52YWxpZGF0ZURhdGVUb2RheSA6IFxuXHRcdFx0XHRcdCh0aGF0RGF0ZS5sZW5ndGggPyB0aGF0RGF0ZVswXS5mb3JtYXREYXRlKCkgOiBtZXNzYWdlcy52YWxpZGF0ZURhdGVPdGhlcikpO1xuXHRcdFx0XHRyZXR1cm4gbWVzc2FnZXMudmFsaWRhdGVEYXRlQ29tcGFyZS5yZXBsYWNlKC9cXHswXFx9Lyxcblx0XHRcdFx0XHRtZXNzYWdlc1sndmFsaWRhdGVEYXRlJyArIChjb21wYXJpc29uc1twYXJhbXNbMF1dIHx8IHBhcmFtc1swXSkudG9VcHBlckNhc2UoKV0pLlxuXHRcdFx0XHRcdHJlcGxhY2UoL1xcezFcXH0vLCB0aGF0RGF0ZSk7XG5cdFx0XHR9KTtcblxuXHRcdC8qKiBOb3JtYWxpc2UgdGhlIGNvbXBhcmlzb24gcGFyYW1ldGVycyB0byBhbiBhcnJheS5cblx0XHRcdEBwYXJhbSBwYXJhbXMge0FycmF5fG9iamVjdHxzdHJpbmd9IFRoZSBvcmlnaW5hbCBwYXJhbWV0ZXJzLlxuXHRcdFx0QHJldHVybiB7QXJyYXl9IFRoZSBub3JtYWxpc2VkIHBhcmFtZXRlcnMuICovXG5cdFx0ZnVuY3Rpb24gbm9ybWFsaXNlUGFyYW1zKHBhcmFtcykge1xuXHRcdFx0aWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHBhcmFtcyA9IHBhcmFtcy5zcGxpdCgnICcpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoISQuaXNBcnJheShwYXJhbXMpKSB7XG5cdFx0XHRcdHZhciBvcHRzID0gW107XG5cdFx0XHRcdGZvciAodmFyIG5hbWUgaW4gcGFyYW1zKSB7XG5cdFx0XHRcdFx0b3B0c1swXSA9IG5hbWU7XG5cdFx0XHRcdFx0b3B0c1sxXSA9IHBhcmFtc1tuYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJhbXMgPSBvcHRzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcmFtcztcblx0XHR9XG5cblx0XHQvKiogRGV0ZXJtaW5lIHRoZSBjb21wYXJpc29uIGRhdGUuXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGN1cnJlbnQgZGF0ZXBpY2tlciBlbGVtZW50LlxuXHRcdFx0QHBhcmFtIHNvdXJjZSB7c3RyaW5nfENEYXRlfGpRdWVyeUVsZW1lbnR9IFRoZSBzb3VyY2Ugb2YgdGhlIG90aGVyIGRhdGUuXG5cdFx0XHRAcGFyYW0gbm9PdGhlciB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gbm90IGdldCB0aGUgZGF0ZSBmcm9tIGFub3RoZXIgZmllbGQuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZVtdfSBUaGUgZGF0ZSBmb3IgY29tcGFyaXNvbi4gKi9cblx0XHRmdW5jdGlvbiBleHRyYWN0T3RoZXJEYXRlKGVsZW0sIHNvdXJjZSwgbm9PdGhlcikge1xuXHRcdFx0aWYgKHNvdXJjZS5uZXdEYXRlICYmIHNvdXJjZS5leHRyYUluZm8pIHsgLy8gQWxyZWFkeSBhIENEYXRlXG5cdFx0XHRcdHJldHVybiBbc291cmNlXTtcblx0XHRcdH1cblx0XHRcdHZhciBpbnN0ID0gJC5jYWxlbmRhcnNQaWNrZXIuX2dldEluc3QoZWxlbSk7XG5cdFx0XHR2YXIgdGhhdERhdGUgPSBudWxsO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIHNvdXJjZSAhPT0gJ3RvZGF5Jykge1xuXHRcdFx0XHRcdHRoYXREYXRlID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyLnBhcnNlRGF0ZShpbnN0LmdldCgnZGF0ZUZvcm1hdCcpLCBzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBJZ25vcmVcblx0XHRcdH1cblx0XHRcdHRoYXREYXRlID0gKHRoYXREYXRlID8gW3RoYXREYXRlXSA6IChzb3VyY2UgPT09ICd0b2RheScgP1xuXHRcdFx0XHRbaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCldIDogKG5vT3RoZXIgPyBbXSA6ICQoc291cmNlKS5jYWxlbmRhcnNQaWNrZXIoJ2dldERhdGUnKSkpKTtcblx0XHRcdHJldHVybiB0aGF0RGF0ZTtcblx0XHR9XG5cdH1cblxufSkoalF1ZXJ5KTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
