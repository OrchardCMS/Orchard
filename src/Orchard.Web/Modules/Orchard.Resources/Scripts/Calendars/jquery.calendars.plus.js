/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars extras for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	$.extend($.calendars.regionalOptions[''], {
		invalidArguments: 'Invalid arguments',
		invalidFormat: 'Cannot format a date from another calendar',
		missingNumberAt: 'Missing number at position {0}',
		unknownNameAt: 'Unknown name at position {0}',
		unexpectedLiteralAt: 'Unexpected literal at position {0}',
		unexpectedText: 'Additional text found at end'
	});
	$.calendars.local = $.calendars.regionalOptions[''];

	$.extend($.calendars.cdate.prototype, {

		/** Format this date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof CDate
			@param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
			@return {string} The formatted date. */
		formatDate: function(format) {
			return this._calendar.formatDate(format || '', this);
		}
	});

	$.extend($.calendars.baseCalendar.prototype, {

		UNIX_EPOCH: $.calendars.instance().newDate(1970, 1, 1).toJD(),
		SECS_PER_DAY: 24 * 60 * 60,
		TICKS_EPOCH: $.calendars.instance().jdEpoch, // 1 January 0001 CE
		TICKS_PER_DAY: 24 * 60 * 60 * 10000000,

		/** Date form for ATOM (RFC 3339/ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ATOM: 'yyyy-mm-dd',
		/** Date form for cookies.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		COOKIE: 'D, dd M yyyy',
		/** Date form for full date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		FULL: 'DD, MM d, yyyy',
		/** Date form for ISO 8601.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ISO_8601: 'yyyy-mm-dd',
		/** Date form for Julian date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		JULIAN: 'J',
		/** Date form for RFC 822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_822: 'D, d M yy',
		/** Date form for RFC 850.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_850: 'DD, dd-M-yy',
		/** Date form for RFC 1036.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1036: 'D, d M yy',
		/** Date form for RFC 1123.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1123: 'D, d M yyyy',
		/** Date form for RFC 2822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_2822: 'D, d M yyyy',
		/** Date form for RSS (RFC 822).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RSS: 'D, d M yy',
		/** Date form for Windows ticks.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TICKS: '!',
		/** Date form for Unix timestamp.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TIMESTAMP: '@',
		/** Date form for W3c (ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		W3C: 'yyyy-mm-dd',

		/** Format a date object into a string value.
			The format can be combinations of the following:
			<ul>
			<li>d  - day of month (no leading zero)</li>
			<li>dd - day of month (two digit)</li>
			<li>o  - day of year (no leading zeros)</li>
			<li>oo - day of year (three digit)</li>
			<li>D  - day name short</li>
			<li>DD - day name long</li>
			<li>w  - week of year (no leading zero)</li>
			<li>ww - week of year (two digit)</li>
			<li>m  - month of year (no leading zero)</li>
			<li>mm - month of year (two digit)</li>
			<li>M  - month name short</li>
			<li>MM - month name long</li>
			<li>yy - year (two digit)</li>
			<li>yyyy - year (four digit)</li>
			<li>YYYY - formatted year</li>
			<li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
			<li>@  - Unix timestamp (s since 01/01/1970)</li>
			<li>!  - Windows ticks (100ns since 01/01/0001)</li>
			<li>'...' - literal text</li>
			<li>'' - single quote</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param [format] {string} The desired format of the date (defaults to calendar format).
			@param date {CDate} The date value to format.
			@param [settings] {object} Addition options, whose attributes include:
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
			@return {string} The date in the above format.
			@throws Errors if the date is from a different calendar. */
		formatDate: function(format, date, settings) {
			if (typeof format !== 'string') {
				settings = date;
				date = format;
				format = '';
			}
			if (!date) {
				return '';
			}
			if (date.calendar() !== this) {
				throw $.calendars.local.invalidFormat || $.calendars.regionalOptions[''].invalidFormat;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Format a number, with leading zeroes if necessary
			var formatNumber = function(match, value, len, step) {
				var num = '' + value;
				if (doubled(match, step)) {
					while (num.length < len) {
						num = '0' + num;
					}
				}
				return num;
			};
			// Format a name, short or long as requested
			var formatName = function(match, value, shortNames, longNames) {
				return (doubled(match) ? longNames[value] : shortNames[value]);
			};
			var output = '';
			var literal = false;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						output += format.charAt(iFormat);
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': output += formatNumber('d', date.day(), 2); break;
						case 'D': output += formatName('D', date.dayOfWeek(),
							dayNamesShort, dayNames); break;
						case 'o': output += formatNumber('o', date.dayOfYear(), 3); break;
						case 'w': output += formatNumber('w', date.weekOfYear(), 2); break;
						case 'm': output += formatNumber('m', date.month(), 2); break;
						case 'M': output += formatName('M', date.month() - this.minMonth,
							monthNamesShort, monthNames); break;
						case 'y':
							output += (doubled('y', 2) ? date.year() :
								(date.year() % 100 < 10 ? '0' : '') + date.year() % 100);
							break;
						case 'Y':
							doubled('Y', 2);
							output += date.formatYear();
							break;
						case 'J': output += date.toJD(); break;
						case '@': output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY; break;
						case '!': output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY; break;
						case "'":
							if (doubled("'")) {
								output += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
			return output;
		},

		/** Parse a string value into a date object.
			See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
			<ul>
			<li>* - ignore rest of string</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param format {string} The expected format of the date ('' for default calendar format).
			@param value {string} The date in the above format.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The extracted date value or <code>null</code> if value is blank.
			@throws Errors if the format and/or value are missing,
					if the value doesn't match the format, or if the date is invalid. */
		parseDate: function(format, value, settings) {
			if (value == null) {
				throw $.calendars.local.invalidArguments || $.calendars.regionalOptions[''].invalidArguments;
			}
			value = (typeof value === 'object' ? value.toString() : value + '');
			if (value === '') {
				return null;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
			shortYearCutoff = (typeof shortYearCutoff !== 'string' ? shortYearCutoff :
				this.today().year() % 100 + parseInt(shortYearCutoff, 10));
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var jd = -1;
			var year = -1;
			var month = -1;
			var day = -1;
			var doy = -1;
			var shortYear = false;
			var literal = false;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Extract a number from the string value
			var getNumber = function(match, step) {
				var isDoubled = doubled(match, step);
				var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]['oyYJ@!'.indexOf(match) + 1];
				var digits = new RegExp('^-?\\d{1,' + size + '}');
				var num = value.substring(iValue).match(digits);
				if (!num) {
					throw ($.calendars.local.missingNumberAt || $.calendars.regionalOptions[''].missingNumberAt).
						replace(/\{0\}/, iValue);
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			};
			// Extract a name from the string value and convert to an index
			var calendar = this;
			var getName = function(match, shortNames, longNames, step) {
				var names = (doubled(match, step) ? longNames : shortNames);
				for (var i = 0; i < names.length; i++) {
					if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
						iValue += names[i].length;
						return i + calendar.minMonth;
					}
				}
				throw ($.calendars.local.unknownNameAt || $.calendars.regionalOptions[''].unknownNameAt).
					replace(/\{0\}/, iValue);
			};
			// Confirm that a literal character matches the string value
			var checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw ($.calendars.local.unexpectedLiteralAt ||
						$.calendars.regionalOptions[''].unexpectedLiteralAt).replace(/\{0\}/, iValue);
				}
				iValue++;
			};
			var iValue = 0;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						checkLiteral();
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': day = getNumber('d'); break;
						case 'D': getName('D', dayNamesShort, dayNames); break;
						case 'o': doy = getNumber('o'); break;
						case 'w': getNumber('w'); break;
						case 'm': month = getNumber('m'); break;
						case 'M': month = getName('M', monthNamesShort, monthNames); break;
						case 'y':
							var iSave = iFormat;
							shortYear = !doubled('y', 2);
							iFormat = iSave;
							year = getNumber('y', 2);
							break;
						case 'Y': year = getNumber('Y', 2); break;
						case 'J':
							jd = getNumber('J') + 0.5;
							if (value.charAt(iValue) === '.') {
								iValue++;
								getNumber('J');
							}
							break;
						case '@': jd = getNumber('@') / this.SECS_PER_DAY + this.UNIX_EPOCH; break;
						case '!': jd = getNumber('!') / this.TICKS_PER_DAY + this.TICKS_EPOCH; break;
						case '*': iValue = value.length; break;
						case "'":
							if (doubled("'")) {
								checkLiteral();
							}
							else {
								literal = true;
							}
							break;
						default: checkLiteral();
					}
				}
			}
			if (iValue < value.length) {
				throw $.calendars.local.unexpectedText || $.calendars.regionalOptions[''].unexpectedText;
			}
			if (year === -1) {
				year = this.today().year();
			}
			else if (year < 100 && shortYear) {
				year += (shortYearCutoff === -1 ? 1900 : this.today().year() -
					this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100));
			}
			if (doy > -1) {
				month = 1;
				day = doy;
				for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
					month++;
					day -= dim;
				}
			}
			return (jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day));
		},

		/** A date may be specified as an exact value or a relative one.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param dateSpec {CDate|number|string} The date as an object or string in the given format or
					an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
			@param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
			@param currentDate {CDate} The current date as a possible basis for relative dates,
					if <code>null</code> today is used (optional)
			@param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The decoded date. */
		determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
			if (currentDate && typeof currentDate !== 'object') {
				settings = dateFormat;
				dateFormat = currentDate;
				currentDate = null;
			}
			if (typeof dateFormat !== 'string') {
				settings = dateFormat;
				dateFormat = '';
			}
			var calendar = this;
			var offsetString = function(offset) {
				try {
					return calendar.parseDate(dateFormat, offset, settings);
				}
				catch (e) {
					// Ignore
				}
				offset = offset.toLowerCase();
				var date = (offset.match(/^c/) && currentDate ?
					currentDate.newDate() : null) || calendar.today();
				var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
				var matches = pattern.exec(offset);
				while (matches) {
					date.add(parseInt(matches[1], 10), matches[2] || 'd');
					matches = pattern.exec(offset);
				}
				return date;
			};
			defaultDate = (defaultDate ? defaultDate.newDate() : null);
			dateSpec = (dateSpec == null ? defaultDate :
				(typeof dateSpec === 'string' ? offsetString(dateSpec) : (typeof dateSpec === 'number' ?
				(isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate :
				calendar.today().add(dateSpec, 'd')) : calendar.newDate(dateSpec))));
			return dateSpec;
		}
	});

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMucGx1cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogaHR0cDovL2tlaXRoLXdvb2QubmFtZS9jYWxlbmRhcnMuaHRtbFxyXG4gICBDYWxlbmRhcnMgZXh0cmFzIGZvciBqUXVlcnkgdjIuMC4xLlxyXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEF1Z3VzdCAyMDA5LlxyXG4gICBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCAoaHR0cDovL2tlaXRoLXdvb2QubmFtZS9saWNlbmNlLmh0bWwpIGxpY2Vuc2UuIFxyXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cclxuXHJcbihmdW5jdGlvbigkKSB7IC8vIEhpZGUgc2NvcGUsIG5vICQgY29uZmxpY3RcclxuXHJcblx0JC5leHRlbmQoJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXSwge1xyXG5cdFx0aW52YWxpZEFyZ3VtZW50czogJ0ludmFsaWQgYXJndW1lbnRzJyxcclxuXHRcdGludmFsaWRGb3JtYXQ6ICdDYW5ub3QgZm9ybWF0IGEgZGF0ZSBmcm9tIGFub3RoZXIgY2FsZW5kYXInLFxyXG5cdFx0bWlzc2luZ051bWJlckF0OiAnTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gezB9JyxcclxuXHRcdHVua25vd25OYW1lQXQ6ICdVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gezB9JyxcclxuXHRcdHVuZXhwZWN0ZWRMaXRlcmFsQXQ6ICdVbmV4cGVjdGVkIGxpdGVyYWwgYXQgcG9zaXRpb24gezB9JyxcclxuXHRcdHVuZXhwZWN0ZWRUZXh0OiAnQWRkaXRpb25hbCB0ZXh0IGZvdW5kIGF0IGVuZCdcclxuXHR9KTtcclxuXHQkLmNhbGVuZGFycy5sb2NhbCA9ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ107XHJcblxyXG5cdCQuZXh0ZW5kKCQuY2FsZW5kYXJzLmNkYXRlLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8qKiBGb3JtYXQgdGhpcyBkYXRlLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxyXG5cdFx0XHRAcGFyYW0gW2Zvcm1hdF0ge3N0cmluZ30gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSAoc2VlIDxhIGhyZWY9XCJCYXNlQ2FsZW5kYXIuaHRtbCNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+KS5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIGRhdGUuICovXHJcblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihmb3JtYXQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmZvcm1hdERhdGUoZm9ybWF0IHx8ICcnLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0JC5leHRlbmQoJC5jYWxlbmRhcnMuYmFzZUNhbGVuZGFyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdFVOSVhfRVBPQ0g6ICQuY2FsZW5kYXJzLmluc3RhbmNlKCkubmV3RGF0ZSgxOTcwLCAxLCAxKS50b0pEKCksXHJcblx0XHRTRUNTX1BFUl9EQVk6IDI0ICogNjAgKiA2MCxcclxuXHRcdFRJQ0tTX0VQT0NIOiAkLmNhbGVuZGFycy5pbnN0YW5jZSgpLmpkRXBvY2gsIC8vIDEgSmFudWFyeSAwMDAxIENFXHJcblx0XHRUSUNLU19QRVJfREFZOiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCxcclxuXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBBVE9NIChSRkMgMzMzOS9JU08gODYwMSkuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0QVRPTTogJ3l5eXktbW0tZGQnLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgY29va2llcy5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRDT09LSUU6ICdELCBkZCBNIHl5eXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgZnVsbCBkYXRlLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cclxuXHRcdEZVTEw6ICdERCwgTU0gZCwgeXl5eScsXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBJU08gODYwMS5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRJU09fODYwMTogJ3l5eXktbW0tZGQnLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgSnVsaWFuIGRhdGUuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0SlVMSUFOOiAnSicsXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgODIyLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cclxuXHRcdFJGQ184MjI6ICdELCBkIE0geXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDg1MC5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRSRkNfODUwOiAnREQsIGRkLU0teXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDEwMzYuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0UkZDXzEwMzY6ICdELCBkIE0geXknLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDExMjMuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0UkZDXzExMjM6ICdELCBkIE0geXl5eScsXHJcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgMjgyMi5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXHJcblx0XHRSRkNfMjgyMjogJ0QsIGQgTSB5eXl5JyxcclxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFJTUyAoUkZDIDgyMikuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0UlNTOiAnRCwgZCBNIHl5JyxcclxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFdpbmRvd3MgdGlja3MuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0VElDS1M6ICchJyxcclxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFVuaXggdGltZXN0YW1wLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cclxuXHRcdFRJTUVTVEFNUDogJ0AnLFxyXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgVzNjIChJU08gODYwMSkuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xyXG5cdFx0VzNDOiAneXl5eS1tbS1kZCcsXHJcblxyXG5cdFx0LyoqIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXHJcblx0XHRcdFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdDxsaT5kICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKTwvbGk+XHJcblx0XHRcdDxsaT5kZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KTwvbGk+XHJcblx0XHRcdDxsaT5vICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKTwvbGk+XHJcblx0XHRcdDxsaT5vbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdCk8L2xpPlxyXG5cdFx0XHQ8bGk+RCAgLSBkYXkgbmFtZSBzaG9ydDwvbGk+XHJcblx0XHRcdDxsaT5ERCAtIGRheSBuYW1lIGxvbmc8L2xpPlxyXG5cdFx0XHQ8bGk+dyAgLSB3ZWVrIG9mIHllYXIgKG5vIGxlYWRpbmcgemVybyk8L2xpPlxyXG5cdFx0XHQ8bGk+d3cgLSB3ZWVrIG9mIHllYXIgKHR3byBkaWdpdCk8L2xpPlxyXG5cdFx0XHQ8bGk+bSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pPC9saT5cclxuXHRcdFx0PGxpPm1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KTwvbGk+XHJcblx0XHRcdDxsaT5NICAtIG1vbnRoIG5hbWUgc2hvcnQ8L2xpPlxyXG5cdFx0XHQ8bGk+TU0gLSBtb250aCBuYW1lIGxvbmc8L2xpPlxyXG5cdFx0XHQ8bGk+eXkgLSB5ZWFyICh0d28gZGlnaXQpPC9saT5cclxuXHRcdFx0PGxpPnl5eXkgLSB5ZWFyIChmb3VyIGRpZ2l0KTwvbGk+XHJcblx0XHRcdDxsaT5ZWVlZIC0gZm9ybWF0dGVkIHllYXI8L2xpPlxyXG5cdFx0XHQ8bGk+SiAgLSBKdWxpYW4gZGF0ZSAoZGF5cyBzaW5jZSBKYW51YXJ5IDEsIDQ3MTMgQkNFIEdyZWVud2ljaCBub29uKTwvbGk+XHJcblx0XHRcdDxsaT5AICAtIFVuaXggdGltZXN0YW1wIChzIHNpbmNlIDAxLzAxLzE5NzApPC9saT5cclxuXHRcdFx0PGxpPiEgIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSk8L2xpPlxyXG5cdFx0XHQ8bGk+Jy4uLicgLSBsaXRlcmFsIHRleHQ8L2xpPlxyXG5cdFx0XHQ8bGk+JycgLSBzaW5nbGUgcXVvdGU8L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIFtmb3JtYXRdIHtzdHJpbmd9IFRoZSBkZXNpcmVkIGZvcm1hdCBvZiB0aGUgZGF0ZSAoZGVmYXVsdHMgdG8gY2FsZW5kYXIgZm9ybWF0KS5cclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXQuXHJcblx0XHRcdEBwYXJhbSBbc2V0dGluZ3NdIHtvYmplY3R9IEFkZGl0aW9uIG9wdGlvbnMsIHdob3NlIGF0dHJpYnV0ZXMgaW5jbHVkZTpcclxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNTaG9ydF0ge3N0cmluZ1tdfSBBYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIG1vbnRocy5cclxuXHRcdFx0QHByb3BlcnR5IFtjYWxjdWxhdGVXZWVrXSB7Q2FsZW5kYXJzUGlja2VyQ2FsY3VsYXRlV2Vla30gRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdlZWsgb2YgdGhlIHllYXIuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdC5cclxuXHRcdFx0QHRocm93cyBFcnJvcnMgaWYgdGhlIGRhdGUgaXMgZnJvbSBhIGRpZmZlcmVudCBjYWxlbmRhci4gKi9cclxuXHRcdGZvcm1hdERhdGU6IGZ1bmN0aW9uKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0c2V0dGluZ3MgPSBkYXRlO1xyXG5cdFx0XHRcdGRhdGUgPSBmb3JtYXQ7XHJcblx0XHRcdFx0Zm9ybWF0ID0gJyc7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFkYXRlKSB7XHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChkYXRlLmNhbGVuZGFyKCkgIT09IHRoaXMpIHtcclxuXHRcdFx0XHR0aHJvdyAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRm9ybWF0IHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZEZvcm1hdDtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5sb2NhbC5kYXRlRm9ybWF0O1xyXG5cdFx0XHRzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG5cdFx0XHR2YXIgZGF5TmFtZXNTaG9ydCA9IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgfHwgdGhpcy5sb2NhbC5kYXlOYW1lc1Nob3J0O1xyXG5cdFx0XHR2YXIgZGF5TmFtZXMgPSBzZXR0aW5ncy5kYXlOYW1lcyB8fCB0aGlzLmxvY2FsLmRheU5hbWVzO1xyXG5cdFx0XHR2YXIgbW9udGhOYW1lc1Nob3J0ID0gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IHx8IHRoaXMubG9jYWwubW9udGhOYW1lc1Nob3J0O1xyXG5cdFx0XHR2YXIgbW9udGhOYW1lcyA9IHNldHRpbmdzLm1vbnRoTmFtZXMgfHwgdGhpcy5sb2NhbC5tb250aE5hbWVzO1xyXG5cdFx0XHR2YXIgY2FsY3VsYXRlV2VlayA9IHNldHRpbmdzLmNhbGN1bGF0ZVdlZWsgfHwgdGhpcy5sb2NhbC5jYWxjdWxhdGVXZWVrO1xyXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXHJcblx0XHRcdHZhciBkb3VibGVkID0gZnVuY3Rpb24obWF0Y2gsIHN0ZXApIHtcclxuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IDE7XHJcblx0XHRcdFx0d2hpbGUgKGlGb3JtYXQgKyBtYXRjaGVzIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyBtYXRjaGVzKSA9PT0gbWF0Y2gpIHtcclxuXHRcdFx0XHRcdG1hdGNoZXMrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aUZvcm1hdCArPSBtYXRjaGVzIC0gMTtcclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihtYXRjaGVzIC8gKHN0ZXAgfHwgMSkpID4gMTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVyb2VzIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHR2YXIgZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBsZW4sIHN0ZXApIHtcclxuXHRcdFx0XHR2YXIgbnVtID0gJycgKyB2YWx1ZTtcclxuXHRcdFx0XHRpZiAoZG91YmxlZChtYXRjaCwgc3RlcCkpIHtcclxuXHRcdFx0XHRcdHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKSB7XHJcblx0XHRcdFx0XHRcdG51bSA9ICcwJyArIG51bTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG51bTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gRm9ybWF0IGEgbmFtZSwgc2hvcnQgb3IgbG9uZyBhcyByZXF1ZXN0ZWRcclxuXHRcdFx0dmFyIGZvcm1hdE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcykge1xyXG5cdFx0XHRcdHJldHVybiAoZG91YmxlZChtYXRjaCkgPyBsb25nTmFtZXNbdmFsdWVdIDogc2hvcnROYW1lc1t2YWx1ZV0pO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XHJcblx0XHRcdHZhciBsaXRlcmFsID0gZmFsc2U7XHJcblx0XHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XHJcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcclxuXHRcdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhZG91YmxlZChcIidcIikpIHtcclxuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlICdkJzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcignZCcsIGRhdGUuZGF5KCksIDIpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnRCc6IG91dHB1dCArPSBmb3JtYXROYW1lKCdEJywgZGF0ZS5kYXlPZldlZWsoKSxcclxuXHRcdFx0XHRcdFx0XHRkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdvJzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcignbycsIGRhdGUuZGF5T2ZZZWFyKCksIDMpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAndyc6IG91dHB1dCArPSBmb3JtYXROdW1iZXIoJ3cnLCBkYXRlLndlZWtPZlllYXIoKSwgMik7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdtJzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcignbScsIGRhdGUubW9udGgoKSwgMik7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdNJzogb3V0cHV0ICs9IGZvcm1hdE5hbWUoJ00nLCBkYXRlLm1vbnRoKCkgLSB0aGlzLm1pbk1vbnRoLFxyXG5cdFx0XHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICd5JzpcclxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gKGRvdWJsZWQoJ3knLCAyKSA/IGRhdGUueWVhcigpIDpcclxuXHRcdFx0XHRcdFx0XHRcdChkYXRlLnllYXIoKSAlIDEwMCA8IDEwID8gJzAnIDogJycpICsgZGF0ZS55ZWFyKCkgJSAxMDApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdZJzpcclxuXHRcdFx0XHRcdFx0XHRkb3VibGVkKCdZJywgMik7XHJcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZm9ybWF0WWVhcigpO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdKJzogb3V0cHV0ICs9IGRhdGUudG9KRCgpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnQCc6IG91dHB1dCArPSAoZGF0ZS50b0pEKCkgLSB0aGlzLlVOSVhfRVBPQ0gpICogdGhpcy5TRUNTX1BFUl9EQVk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICchJzogb3V0cHV0ICs9IChkYXRlLnRvSkQoKSAtIHRoaXMuVElDS1NfRVBPQ0gpICogdGhpcy5USUNLU19QRVJfREFZOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcclxuXHRcdFx0XHRcdFx0XHRpZiAoZG91YmxlZChcIidcIikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG91dHB1dCArPSBcIidcIjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvdXRwdXQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXHJcblx0XHRcdFNlZSA8YSBocmVmPVwiI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4gZm9yIHRoZSBwb3NzaWJsZSBmb3JtYXRzLCBwbHVzOlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdDxsaT4qIC0gaWdub3JlIHJlc3Qgb2Ygc3RyaW5nPC9saT5cclxuXHRcdFx0PC91bD5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSBmb3JtYXQge3N0cmluZ30gVGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZSAoJycgZm9yIGRlZmF1bHQgY2FsZW5kYXIgZm9ybWF0KS5cclxuXHRcdFx0QHBhcmFtIHZhbHVlIHtzdHJpbmd9IFRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXQuXHJcblx0XHRcdEBwYXJhbSBbc2V0dGluZ3NdIHtvYmplY3R9IEFkZGl0aW9uYWwgb3B0aW9ucyB3aG9zZSBhdHRyaWJ1dGVzIGluY2x1ZGU6XHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvcnRZZWFyQ3V0b2ZmXSB7bnVtYmVyfSBUaGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5LlxyXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXHJcblx0XHRcdEBwcm9wZXJ0eSBbZGF5TmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc10ge3N0cmluZ1tdfSBOYW1lcyBvZiB0aGUgbW9udGhzLlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGV4dHJhY3RlZCBkYXRlIHZhbHVlIG9yIDxjb2RlPm51bGw8L2NvZGU+IGlmIHZhbHVlIGlzIGJsYW5rLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9ycyBpZiB0aGUgZm9ybWF0IGFuZC9vciB2YWx1ZSBhcmUgbWlzc2luZyxcclxuXHRcdFx0XHRcdGlmIHRoZSB2YWx1ZSBkb2Vzbid0IG1hdGNoIHRoZSBmb3JtYXQsIG9yIGlmIHRoZSBkYXRlIGlzIGludmFsaWQuICovXHJcblx0XHRwYXJzZURhdGU6IGZ1bmN0aW9uKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XHJcblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcblx0XHRcdFx0dGhyb3cgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZEFyZ3VtZW50cyB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRBcmd1bWVudHM7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSArICcnKTtcclxuXHRcdFx0aWYgKHZhbHVlID09PSAnJykge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLmxvY2FsLmRhdGVGb3JtYXQ7XHJcblx0XHRcdHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcblx0XHRcdHZhciBzaG9ydFllYXJDdXRvZmYgPSBzZXR0aW5ncy5zaG9ydFllYXJDdXRvZmYgfHwgdGhpcy5zaG9ydFllYXJDdXRvZmY7XHJcblx0XHRcdHNob3J0WWVhckN1dG9mZiA9ICh0eXBlb2Ygc2hvcnRZZWFyQ3V0b2ZmICE9PSAnc3RyaW5nJyA/IHNob3J0WWVhckN1dG9mZiA6XHJcblx0XHRcdFx0dGhpcy50b2RheSgpLnllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZiwgMTApKTtcclxuXHRcdFx0dmFyIGRheU5hbWVzU2hvcnQgPSBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IHx8IHRoaXMubG9jYWwuZGF5TmFtZXNTaG9ydDtcclxuXHRcdFx0dmFyIGRheU5hbWVzID0gc2V0dGluZ3MuZGF5TmFtZXMgfHwgdGhpcy5sb2NhbC5kYXlOYW1lcztcclxuXHRcdFx0dmFyIG1vbnRoTmFtZXNTaG9ydCA9IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCB8fCB0aGlzLmxvY2FsLm1vbnRoTmFtZXNTaG9ydDtcclxuXHRcdFx0dmFyIG1vbnRoTmFtZXMgPSBzZXR0aW5ncy5tb250aE5hbWVzIHx8IHRoaXMubG9jYWwubW9udGhOYW1lcztcclxuXHRcdFx0dmFyIGpkID0gLTE7XHJcblx0XHRcdHZhciB5ZWFyID0gLTE7XHJcblx0XHRcdHZhciBtb250aCA9IC0xO1xyXG5cdFx0XHR2YXIgZGF5ID0gLTE7XHJcblx0XHRcdHZhciBkb3kgPSAtMTtcclxuXHRcdFx0dmFyIHNob3J0WWVhciA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXHJcblx0XHRcdHZhciBkb3VibGVkID0gZnVuY3Rpb24obWF0Y2gsIHN0ZXApIHtcclxuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IDE7XHJcblx0XHRcdFx0d2hpbGUgKGlGb3JtYXQgKyBtYXRjaGVzIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyBtYXRjaGVzKSA9PT0gbWF0Y2gpIHtcclxuXHRcdFx0XHRcdG1hdGNoZXMrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aUZvcm1hdCArPSBtYXRjaGVzIC0gMTtcclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihtYXRjaGVzIC8gKHN0ZXAgfHwgMSkpID4gMTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcclxuXHRcdFx0dmFyIGdldE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoLCBzdGVwKSB7XHJcblx0XHRcdFx0dmFyIGlzRG91YmxlZCA9IGRvdWJsZWQobWF0Y2gsIHN0ZXApO1xyXG5cdFx0XHRcdHZhciBzaXplID0gWzIsIDMsIGlzRG91YmxlZCA/IDQgOiAyLCBpc0RvdWJsZWQgPyA0IDogMiwgMTAsIDExLCAyMF1bJ295WUpAIScuaW5kZXhPZihtYXRjaCkgKyAxXTtcclxuXHRcdFx0XHR2YXIgZGlnaXRzID0gbmV3IFJlZ0V4cCgnXi0/XFxcXGR7MSwnICsgc2l6ZSArICd9Jyk7XHJcblx0XHRcdFx0dmFyIG51bSA9IHZhbHVlLnN1YnN0cmluZyhpVmFsdWUpLm1hdGNoKGRpZ2l0cyk7XHJcblx0XHRcdFx0aWYgKCFudW0pIHtcclxuXHRcdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5taXNzaW5nTnVtYmVyQXQgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5taXNzaW5nTnVtYmVyQXQpLlxyXG5cdFx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgaVZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aVZhbHVlICs9IG51bVswXS5sZW5ndGg7XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG51bVswXSwgMTApO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHQvLyBFeHRyYWN0IGEgbmFtZSBmcm9tIHRoZSBzdHJpbmcgdmFsdWUgYW5kIGNvbnZlcnQgdG8gYW4gaW5kZXhcclxuXHRcdFx0dmFyIGNhbGVuZGFyID0gdGhpcztcclxuXHRcdFx0dmFyIGdldE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzLCBzdGVwKSB7XHJcblx0XHRcdFx0dmFyIG5hbWVzID0gKGRvdWJsZWQobWF0Y2gsIHN0ZXApID8gbG9uZ05hbWVzIDogc2hvcnROYW1lcyk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWVzW2ldLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZXNbaV0udG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZXNbaV0ubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaSArIGNhbGVuZGFyLm1pbk1vbnRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwudW5rbm93bk5hbWVBdCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLnVua25vd25OYW1lQXQpLlxyXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIGlWYWx1ZSk7XHJcblx0XHRcdH07XHJcblx0XHRcdC8vIENvbmZpcm0gdGhhdCBhIGxpdGVyYWwgY2hhcmFjdGVyIG1hdGNoZXMgdGhlIHN0cmluZyB2YWx1ZVxyXG5cdFx0XHR2YXIgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlLmNoYXJBdChpVmFsdWUpICE9PSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwudW5leHBlY3RlZExpdGVyYWxBdCB8fFxyXG5cdFx0XHRcdFx0XHQkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLnVuZXhwZWN0ZWRMaXRlcmFsQXQpLnJlcGxhY2UoL1xcezBcXH0vLCBpVmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpVmFsdWUrKztcclxuXHRcdFx0fTtcclxuXHRcdFx0dmFyIGlWYWx1ZSA9IDA7XHJcblx0XHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XHJcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcclxuXHRcdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhZG91YmxlZChcIidcIikpIHtcclxuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlICdkJzogZGF5ID0gZ2V0TnVtYmVyKCdkJyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdEJzogZ2V0TmFtZSgnRCcsIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ28nOiBkb3kgPSBnZXROdW1iZXIoJ28nKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3cnOiBnZXROdW1iZXIoJ3cnKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ20nOiBtb250aCA9IGdldE51bWJlcignbScpOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnTSc6IG1vbnRoID0gZ2V0TmFtZSgnTScsIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICd5JzpcclxuXHRcdFx0XHRcdFx0XHR2YXIgaVNhdmUgPSBpRm9ybWF0O1xyXG5cdFx0XHRcdFx0XHRcdHNob3J0WWVhciA9ICFkb3VibGVkKCd5JywgMik7XHJcblx0XHRcdFx0XHRcdFx0aUZvcm1hdCA9IGlTYXZlO1xyXG5cdFx0XHRcdFx0XHRcdHllYXIgPSBnZXROdW1iZXIoJ3knLCAyKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnWSc6IHllYXIgPSBnZXROdW1iZXIoJ1knLCAyKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0onOlxyXG5cdFx0XHRcdFx0XHRcdGpkID0gZ2V0TnVtYmVyKCdKJykgKyAwLjU7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLmNoYXJBdChpVmFsdWUpID09PSAnLicpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlWYWx1ZSsrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2V0TnVtYmVyKCdKJyk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdAJzogamQgPSBnZXROdW1iZXIoJ0AnKSAvIHRoaXMuU0VDU19QRVJfREFZICsgdGhpcy5VTklYX0VQT0NIOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnISc6IGpkID0gZ2V0TnVtYmVyKCchJykgLyB0aGlzLlRJQ0tTX1BFUl9EQVkgKyB0aGlzLlRJQ0tTX0VQT0NIOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnKic6IGlWYWx1ZSA9IHZhbHVlLmxlbmd0aDsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6XHJcblx0XHRcdFx0XHRcdFx0aWYgKGRvdWJsZWQoXCInXCIpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IGNoZWNrTGl0ZXJhbCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhyb3cgJC5jYWxlbmRhcnMubG9jYWwudW5leHBlY3RlZFRleHQgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS51bmV4cGVjdGVkVGV4dDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeWVhciA9PT0gLTEpIHtcclxuXHRcdFx0XHR5ZWFyID0gdGhpcy50b2RheSgpLnllYXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh5ZWFyIDwgMTAwICYmIHNob3J0WWVhcikge1xyXG5cdFx0XHRcdHllYXIgKz0gKHNob3J0WWVhckN1dG9mZiA9PT0gLTEgPyAxOTAwIDogdGhpcy50b2RheSgpLnllYXIoKSAtXHJcblx0XHRcdFx0XHR0aGlzLnRvZGF5KCkueWVhcigpICUgMTAwIC0gKHllYXIgPD0gc2hvcnRZZWFyQ3V0b2ZmID8gMCA6IDEwMCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChkb3kgPiAtMSkge1xyXG5cdFx0XHRcdG1vbnRoID0gMTtcclxuXHRcdFx0XHRkYXkgPSBkb3k7XHJcblx0XHRcdFx0Zm9yICh2YXIgZGltID0gdGhpcy5kYXlzSW5Nb250aCh5ZWFyLCBtb250aCk7IGRheSA+IGRpbTsgZGltID0gdGhpcy5kYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpIHtcclxuXHRcdFx0XHRcdG1vbnRoKys7XHJcblx0XHRcdFx0XHRkYXkgLT0gZGltO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gKGpkID4gLTEgPyB0aGlzLmZyb21KRChqZCkgOiB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQSBkYXRlIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gZXhhY3QgdmFsdWUgb3IgYSByZWxhdGl2ZSBvbmUuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0gZGF0ZVNwZWMge0NEYXRlfG51bWJlcnxzdHJpbmd9IFRoZSBkYXRlIGFzIGFuIG9iamVjdCBvciBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdCBvclxyXG5cdFx0XHRcdFx0YW4gb2Zmc2V0IC0gbnVtZXJpYyBkYXlzIGZyb20gdG9kYXksIG9yIHN0cmluZyBhbW91bnRzIGFuZCBwZXJpb2RzLCBlLmcuICcrMW0gKzJ3Jy5cclxuXHRcdFx0QHBhcmFtIGRlZmF1bHREYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gdXNlIGlmIG5vIG90aGVyIHN1cHBsaWVkLCBtYXkgYmUgPGNvZGU+bnVsbDwvY29kZT4uXHJcblx0XHRcdEBwYXJhbSBjdXJyZW50RGF0ZSB7Q0RhdGV9IFRoZSBjdXJyZW50IGRhdGUgYXMgYSBwb3NzaWJsZSBiYXNpcyBmb3IgcmVsYXRpdmUgZGF0ZXMsXHJcblx0XHRcdFx0XHRpZiA8Y29kZT5udWxsPC9jb2RlPiB0b2RheSBpcyB1c2VkIChvcHRpb25hbClcclxuXHRcdFx0QHBhcmFtIFtkYXRlRm9ybWF0XSB7c3RyaW5nfSBUaGUgZXhwZWN0ZWQgZGF0ZSBmb3JtYXQgLSBzZWUgPGEgaHJlZj1cIiNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+LlxyXG5cdFx0XHRAcGFyYW0gW3NldHRpbmdzXSB7b2JqZWN0fSBBZGRpdGlvbmFsIG9wdGlvbnMgd2hvc2UgYXR0cmlidXRlcyBpbmNsdWRlOlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3J0WWVhckN1dG9mZl0ge251bWJlcn0gVGhlIGN1dG9mZiB5ZWFyIGZvciBkZXRlcm1pbmluZyB0aGUgY2VudHVyeS5cclxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNTaG9ydF0ge3N0cmluZ1tdfSBBYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIG1vbnRocy5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBkZWNvZGVkIGRhdGUuICovXHJcblx0XHRkZXRlcm1pbmVEYXRlOiBmdW5jdGlvbihkYXRlU3BlYywgZGVmYXVsdERhdGUsIGN1cnJlbnREYXRlLCBkYXRlRm9ybWF0LCBzZXR0aW5ncykge1xyXG5cdFx0XHRpZiAoY3VycmVudERhdGUgJiYgdHlwZW9mIGN1cnJlbnREYXRlICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdHNldHRpbmdzID0gZGF0ZUZvcm1hdDtcclxuXHRcdFx0XHRkYXRlRm9ybWF0ID0gY3VycmVudERhdGU7XHJcblx0XHRcdFx0Y3VycmVudERhdGUgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2YgZGF0ZUZvcm1hdCAhPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRzZXR0aW5ncyA9IGRhdGVGb3JtYXQ7XHJcblx0XHRcdFx0ZGF0ZUZvcm1hdCA9ICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBjYWxlbmRhciA9IHRoaXM7XHJcblx0XHRcdHZhciBvZmZzZXRTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGVuZGFyLnBhcnNlRGF0ZShkYXRlRm9ybWF0LCBvZmZzZXQsIHNldHRpbmdzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRvZmZzZXQgPSBvZmZzZXQudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHR2YXIgZGF0ZSA9IChvZmZzZXQubWF0Y2goL15jLykgJiYgY3VycmVudERhdGUgP1xyXG5cdFx0XHRcdFx0Y3VycmVudERhdGUubmV3RGF0ZSgpIDogbnVsbCkgfHwgY2FsZW5kYXIudG9kYXkoKTtcclxuXHRcdFx0XHR2YXIgcGF0dGVybiA9IC8oWystXT9bMC05XSspXFxzKihkfHd8bXx5KT8vZztcclxuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xyXG5cdFx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XHJcblx0XHRcdFx0XHRkYXRlLmFkZChwYXJzZUludChtYXRjaGVzWzFdLCAxMCksIG1hdGNoZXNbMl0gfHwgJ2QnKTtcclxuXHRcdFx0XHRcdG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGRhdGU7XHJcblx0XHRcdH07XHJcblx0XHRcdGRlZmF1bHREYXRlID0gKGRlZmF1bHREYXRlID8gZGVmYXVsdERhdGUubmV3RGF0ZSgpIDogbnVsbCk7XHJcblx0XHRcdGRhdGVTcGVjID0gKGRhdGVTcGVjID09IG51bGwgPyBkZWZhdWx0RGF0ZSA6XHJcblx0XHRcdFx0KHR5cGVvZiBkYXRlU3BlYyA9PT0gJ3N0cmluZycgPyBvZmZzZXRTdHJpbmcoZGF0ZVNwZWMpIDogKHR5cGVvZiBkYXRlU3BlYyA9PT0gJ251bWJlcicgP1xyXG5cdFx0XHRcdChpc05hTihkYXRlU3BlYykgfHwgZGF0ZVNwZWMgPT09IEluZmluaXR5IHx8IGRhdGVTcGVjID09PSAtSW5maW5pdHkgPyBkZWZhdWx0RGF0ZSA6XHJcblx0XHRcdFx0Y2FsZW5kYXIudG9kYXkoKS5hZGQoZGF0ZVNwZWMsICdkJykpIDogY2FsZW5kYXIubmV3RGF0ZShkYXRlU3BlYykpKSk7XHJcblx0XHRcdHJldHVybiBkYXRlU3BlYztcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcbn0pKGpRdWVyeSk7XHJcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
