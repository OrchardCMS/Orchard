/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars extras for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	$.extend($.calendars.regionalOptions[''], {
		invalidArguments: 'Invalid arguments',
		invalidFormat: 'Cannot format a date from another calendar',
		missingNumberAt: 'Missing number at position {0}',
		unknownNameAt: 'Unknown name at position {0}',
		unexpectedLiteralAt: 'Unexpected literal at position {0}',
		unexpectedText: 'Additional text found at end'
	});
	$.calendars.local = $.calendars.regionalOptions[''];

	$.extend($.calendars.cdate.prototype, {

		/** Format this date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof CDate
			@param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
			@return {string} The formatted date. */
		formatDate: function(format) {
			return this._calendar.formatDate(format || '', this);
		}
	});

	$.extend($.calendars.baseCalendar.prototype, {

		UNIX_EPOCH: $.calendars.instance().newDate(1970, 1, 1).toJD(),
		SECS_PER_DAY: 24 * 60 * 60,
		TICKS_EPOCH: $.calendars.instance().jdEpoch, // 1 January 0001 CE
		TICKS_PER_DAY: 24 * 60 * 60 * 10000000,

		/** Date form for ATOM (RFC 3339/ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ATOM: 'yyyy-mm-dd',
		/** Date form for cookies.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		COOKIE: 'D, dd M yyyy',
		/** Date form for full date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		FULL: 'DD, MM d, yyyy',
		/** Date form for ISO 8601.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ISO_8601: 'yyyy-mm-dd',
		/** Date form for Julian date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		JULIAN: 'J',
		/** Date form for RFC 822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_822: 'D, d M yy',
		/** Date form for RFC 850.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_850: 'DD, dd-M-yy',
		/** Date form for RFC 1036.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1036: 'D, d M yy',
		/** Date form for RFC 1123.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1123: 'D, d M yyyy',
		/** Date form for RFC 2822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_2822: 'D, d M yyyy',
		/** Date form for RSS (RFC 822).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RSS: 'D, d M yy',
		/** Date form for Windows ticks.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TICKS: '!',
		/** Date form for Unix timestamp.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TIMESTAMP: '@',
		/** Date form for W3c (ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		W3C: 'yyyy-mm-dd',

		/** Format a date object into a string value.
			The format can be combinations of the following:
			<ul>
			<li>d  - day of month (no leading zero)</li>
			<li>dd - day of month (two digit)</li>
			<li>o  - day of year (no leading zeros)</li>
			<li>oo - day of year (three digit)</li>
			<li>D  - day name short</li>
			<li>DD - day name long</li>
			<li>w  - week of year (no leading zero)</li>
			<li>ww - week of year (two digit)</li>
			<li>m  - month of year (no leading zero)</li>
			<li>mm - month of year (two digit)</li>
			<li>M  - month name short</li>
			<li>MM - month name long</li>
			<li>yy - year (two digit)</li>
			<li>yyyy - year (four digit)</li>
			<li>YYYY - formatted year</li>
			<li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
			<li>@  - Unix timestamp (s since 01/01/1970)</li>
			<li>!  - Windows ticks (100ns since 01/01/0001)</li>
			<li>'...' - literal text</li>
			<li>'' - single quote</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param [format] {string} The desired format of the date (defaults to calendar format).
			@param date {CDate} The date value to format.
			@param [settings] {object} Addition options, whose attributes include:
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
			@return {string} The date in the above format.
			@throws Errors if the date is from a different calendar. */
		formatDate: function(format, date, settings) {
			if (typeof format !== 'string') {
				settings = date;
				date = format;
				format = '';
			}
			if (!date) {
				return '';
			}
			if (date.calendar() !== this) {
				throw $.calendars.local.invalidFormat || $.calendars.regionalOptions[''].invalidFormat;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Format a number, with leading zeroes if necessary
			var formatNumber = function(match, value, len, step) {
				var num = '' + value;
				if (doubled(match, step)) {
					while (num.length < len) {
						num = '0' + num;
					}
				}
				return num;
			};
			// Format a name, short or long as requested
			var formatName = function(match, value, shortNames, longNames) {
				return (doubled(match) ? longNames[value] : shortNames[value]);
			};
			var output = '';
			var literal = false;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						output += format.charAt(iFormat);
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': output += formatNumber('d', date.day(), 2); break;
						case 'D': output += formatName('D', date.dayOfWeek(),
							dayNamesShort, dayNames); break;
						case 'o': output += formatNumber('o', date.dayOfYear(), 3); break;
						case 'w': output += formatNumber('w', date.weekOfYear(), 2); break;
						case 'm': output += formatNumber('m', date.month(), 2); break;
						case 'M': output += formatName('M', date.month() - this.minMonth,
							monthNamesShort, monthNames); break;
						case 'y':
							output += (doubled('y', 2) ? date.year() :
								(date.year() % 100 < 10 ? '0' : '') + date.year() % 100);
							break;
						case 'Y':
							doubled('Y', 2);
							output += date.formatYear();
							break;
						case 'J': output += date.toJD(); break;
						case '@': output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY; break;
						case '!': output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY; break;
						case "'":
							if (doubled("'")) {
								output += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
			return output;
		},

		/** Parse a string value into a date object.
			See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
			<ul>
			<li>* - ignore rest of string</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param format {string} The expected format of the date ('' for default calendar format).
			@param value {string} The date in the above format.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The extracted date value or <code>null</code> if value is blank.
			@throws Errors if the format and/or value are missing,
					if the value doesn't match the format, or if the date is invalid. */
		parseDate: function(format, value, settings) {
			if (value == null) {
				throw $.calendars.local.invalidArguments || $.calendars.regionalOptions[''].invalidArguments;
			}
			value = (typeof value === 'object' ? value.toString() : value + '');
			if (value === '') {
				return null;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
			shortYearCutoff = (typeof shortYearCutoff !== 'string' ? shortYearCutoff :
				this.today().year() % 100 + parseInt(shortYearCutoff, 10));
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var jd = -1;
			var year = -1;
			var month = -1;
			var day = -1;
			var doy = -1;
			var shortYear = false;
			var literal = false;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Extract a number from the string value
			var getNumber = function(match, step) {
				var isDoubled = doubled(match, step);
				var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]['oyYJ@!'.indexOf(match) + 1];
				var digits = new RegExp('^-?\\d{1,' + size + '}');
				var num = value.substring(iValue).match(digits);
				if (!num) {
					throw ($.calendars.local.missingNumberAt || $.calendars.regionalOptions[''].missingNumberAt).
						replace(/\{0\}/, iValue);
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			};
			// Extract a name from the string value and convert to an index
			var calendar = this;
			var getName = function(match, shortNames, longNames, step) {
				var names = (doubled(match, step) ? longNames : shortNames);
				for (var i = 0; i < names.length; i++) {
					if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
						iValue += names[i].length;
						return i + calendar.minMonth;
					}
				}
				throw ($.calendars.local.unknownNameAt || $.calendars.regionalOptions[''].unknownNameAt).
					replace(/\{0\}/, iValue);
			};
			// Confirm that a literal character matches the string value
			var checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw ($.calendars.local.unexpectedLiteralAt ||
						$.calendars.regionalOptions[''].unexpectedLiteralAt).replace(/\{0\}/, iValue);
				}
				iValue++;
			};
			var iValue = 0;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						checkLiteral();
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': day = getNumber('d'); break;
						case 'D': getName('D', dayNamesShort, dayNames); break;
						case 'o': doy = getNumber('o'); break;
						case 'w': getNumber('w'); break;
						case 'm': month = getNumber('m'); break;
						case 'M': month = getName('M', monthNamesShort, monthNames); break;
						case 'y':
							var iSave = iFormat;
							shortYear = !doubled('y', 2);
							iFormat = iSave;
							year = getNumber('y', 2);
							break;
						case 'Y': year = getNumber('Y', 2); break;
						case 'J':
							jd = getNumber('J') + 0.5;
							if (value.charAt(iValue) === '.') {
								iValue++;
								getNumber('J');
							}
							break;
						case '@': jd = getNumber('@') / this.SECS_PER_DAY + this.UNIX_EPOCH; break;
						case '!': jd = getNumber('!') / this.TICKS_PER_DAY + this.TICKS_EPOCH; break;
						case '*': iValue = value.length; break;
						case "'":
							if (doubled("'")) {
								checkLiteral();
							}
							else {
								literal = true;
							}
							break;
						default: checkLiteral();
					}
				}
			}
			if (iValue < value.length) {
				throw $.calendars.local.unexpectedText || $.calendars.regionalOptions[''].unexpectedText;
			}
			if (year === -1) {
				year = this.today().year();
			}
			else if (year < 100 && shortYear) {
				year += (shortYearCutoff === -1 ? 1900 : this.today().year() -
					this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100));
			}
			if (doy > -1) {
				month = 1;
				day = doy;
				for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
					month++;
					day -= dim;
				}
			}
			return (jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day));
		},

		/** A date may be specified as an exact value or a relative one.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param dateSpec {CDate|number|string} The date as an object or string in the given format or
					an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
			@param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
			@param currentDate {CDate} The current date as a possible basis for relative dates,
					if <code>null</code> today is used (optional)
			@param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The decoded date. */
		determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
			if (currentDate && typeof currentDate !== 'object') {
				settings = dateFormat;
				dateFormat = currentDate;
				currentDate = null;
			}
			if (typeof dateFormat !== 'string') {
				settings = dateFormat;
				dateFormat = '';
			}
			var calendar = this;
			var offsetString = function(offset) {
				try {
					return calendar.parseDate(dateFormat, offset, settings);
				}
				catch (e) {
					// Ignore
				}
				offset = offset.toLowerCase();
				var date = (offset.match(/^c/) && currentDate ?
					currentDate.newDate() : null) || calendar.today();
				var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
				var matches = pattern.exec(offset);
				while (matches) {
					date.add(parseInt(matches[1], 10), matches[2] || 'd');
					matches = pattern.exec(offset);
				}
				return date;
			};
			defaultDate = (defaultDate ? defaultDate.newDate() : null);
			dateSpec = (dateSpec == null ? defaultDate :
				(typeof dateSpec === 'string' ? offsetString(dateSpec) : (typeof dateSpec === 'number' ?
				(isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate :
				calendar.today().add(dateSpec, 'd')) : calendar.newDate(dateSpec))));
			return dateSpec;
		}
	});

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMucGx1cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogaHR0cDovL2tlaXRoLXdvb2QubmFtZS9jYWxlbmRhcnMuaHRtbFxuICAgQ2FsZW5kYXJzIGV4dHJhcyBmb3IgalF1ZXJ5IHYyLjAuMS5cbiAgIFdyaXR0ZW4gYnkgS2VpdGggV29vZCAoa2J3b29ke2F0fWlpbmV0LmNvbS5hdSkgQXVndXN0IDIwMDkuXG4gICBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCAoaHR0cDovL2tlaXRoLXdvb2QubmFtZS9saWNlbmNlLmh0bWwpIGxpY2Vuc2UuIFxuICAgUGxlYXNlIGF0dHJpYnV0ZSB0aGUgYXV0aG9yIGlmIHlvdSB1c2UgaXQuICovXG5cbihmdW5jdGlvbigkKSB7IC8vIEhpZGUgc2NvcGUsIG5vICQgY29uZmxpY3RcblxuXHQkLmV4dGVuZCgkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLCB7XG5cdFx0aW52YWxpZEFyZ3VtZW50czogJ0ludmFsaWQgYXJndW1lbnRzJyxcblx0XHRpbnZhbGlkRm9ybWF0OiAnQ2Fubm90IGZvcm1hdCBhIGRhdGUgZnJvbSBhbm90aGVyIGNhbGVuZGFyJyxcblx0XHRtaXNzaW5nTnVtYmVyQXQ6ICdNaXNzaW5nIG51bWJlciBhdCBwb3NpdGlvbiB7MH0nLFxuXHRcdHVua25vd25OYW1lQXQ6ICdVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gezB9Jyxcblx0XHR1bmV4cGVjdGVkTGl0ZXJhbEF0OiAnVW5leHBlY3RlZCBsaXRlcmFsIGF0IHBvc2l0aW9uIHswfScsXG5cdFx0dW5leHBlY3RlZFRleHQ6ICdBZGRpdGlvbmFsIHRleHQgZm91bmQgYXQgZW5kJ1xuXHR9KTtcblx0JC5jYWxlbmRhcnMubG9jYWwgPSAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddO1xuXG5cdCQuZXh0ZW5kKCQuY2FsZW5kYXJzLmNkYXRlLnByb3RvdHlwZSwge1xuXG5cdFx0LyoqIEZvcm1hdCB0aGlzIGRhdGUuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEBwYXJhbSBbZm9ybWF0XSB7c3RyaW5nfSBUaGUgZGF0ZSBmb3JtYXQgdG8gdXNlIChzZWUgPGEgaHJlZj1cIkJhc2VDYWxlbmRhci5odG1sI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4pLlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIGRhdGUuICovXG5cdFx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24oZm9ybWF0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZm9ybWF0RGF0ZShmb3JtYXQgfHwgJycsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG5cblx0JC5leHRlbmQoJC5jYWxlbmRhcnMuYmFzZUNhbGVuZGFyLnByb3RvdHlwZSwge1xuXG5cdFx0VU5JWF9FUE9DSDogJC5jYWxlbmRhcnMuaW5zdGFuY2UoKS5uZXdEYXRlKDE5NzAsIDEsIDEpLnRvSkQoKSxcblx0XHRTRUNTX1BFUl9EQVk6IDI0ICogNjAgKiA2MCxcblx0XHRUSUNLU19FUE9DSDogJC5jYWxlbmRhcnMuaW5zdGFuY2UoKS5qZEVwb2NoLCAvLyAxIEphbnVhcnkgMDAwMSBDRVxuXHRcdFRJQ0tTX1BFUl9EQVk6IDI0ICogNjAgKiA2MCAqIDEwMDAwMDAwLFxuXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgQVRPTSAoUkZDIDMzMzkvSVNPIDg2MDEpLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdEFUT006ICd5eXl5LW1tLWRkJyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBjb29raWVzLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdENPT0tJRTogJ0QsIGRkIE0geXl5eScsXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgZnVsbCBkYXRlLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdEZVTEw6ICdERCwgTU0gZCwgeXl5eScsXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgSVNPIDg2MDEuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0SVNPXzg2MDE6ICd5eXl5LW1tLWRkJyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBKdWxpYW4gZGF0ZS5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRKVUxJQU46ICdKJyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgODIyLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdFJGQ184MjI6ICdELCBkIE0geXknLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFJGQyA4NTAuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0UkZDXzg1MDogJ0RELCBkZC1NLXl5Jyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgMTAzNi5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRSRkNfMTAzNjogJ0QsIGQgTSB5eScsXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDExMjMuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0UkZDXzExMjM6ICdELCBkIE0geXl5eScsXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDI4MjIuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0UkZDXzI4MjI6ICdELCBkIE0geXl5eScsXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUlNTIChSRkMgODIyKS5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRSU1M6ICdELCBkIE0geXknLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFdpbmRvd3MgdGlja3MuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0VElDS1M6ICchJyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBVbml4IHRpbWVzdGFtcC5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRUSU1FU1RBTVA6ICdAJyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBXM2MgKElTTyA4NjAxKS5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRXM0M6ICd5eXl5LW1tLWRkJyxcblxuXHRcdC8qKiBGb3JtYXQgYSBkYXRlIG9iamVjdCBpbnRvIGEgc3RyaW5nIHZhbHVlLlxuXHRcdFx0VGhlIGZvcm1hdCBjYW4gYmUgY29tYmluYXRpb25zIG9mIHRoZSBmb2xsb3dpbmc6XG5cdFx0XHQ8dWw+XG5cdFx0XHQ8bGk+ZCAgLSBkYXkgb2YgbW9udGggKG5vIGxlYWRpbmcgemVybyk8L2xpPlxuXHRcdFx0PGxpPmRkIC0gZGF5IG9mIG1vbnRoICh0d28gZGlnaXQpPC9saT5cblx0XHRcdDxsaT5vICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKTwvbGk+XG5cdFx0XHQ8bGk+b28gLSBkYXkgb2YgeWVhciAodGhyZWUgZGlnaXQpPC9saT5cblx0XHRcdDxsaT5EICAtIGRheSBuYW1lIHNob3J0PC9saT5cblx0XHRcdDxsaT5ERCAtIGRheSBuYW1lIGxvbmc8L2xpPlxuXHRcdFx0PGxpPncgIC0gd2VlayBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pPC9saT5cblx0XHRcdDxsaT53dyAtIHdlZWsgb2YgeWVhciAodHdvIGRpZ2l0KTwvbGk+XG5cdFx0XHQ8bGk+bSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pPC9saT5cblx0XHRcdDxsaT5tbSAtIG1vbnRoIG9mIHllYXIgKHR3byBkaWdpdCk8L2xpPlxuXHRcdFx0PGxpPk0gIC0gbW9udGggbmFtZSBzaG9ydDwvbGk+XG5cdFx0XHQ8bGk+TU0gLSBtb250aCBuYW1lIGxvbmc8L2xpPlxuXHRcdFx0PGxpPnl5IC0geWVhciAodHdvIGRpZ2l0KTwvbGk+XG5cdFx0XHQ8bGk+eXl5eSAtIHllYXIgKGZvdXIgZGlnaXQpPC9saT5cblx0XHRcdDxsaT5ZWVlZIC0gZm9ybWF0dGVkIHllYXI8L2xpPlxuXHRcdFx0PGxpPkogIC0gSnVsaWFuIGRhdGUgKGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbik8L2xpPlxuXHRcdFx0PGxpPkAgIC0gVW5peCB0aW1lc3RhbXAgKHMgc2luY2UgMDEvMDEvMTk3MCk8L2xpPlxuXHRcdFx0PGxpPiEgIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSk8L2xpPlxuXHRcdFx0PGxpPicuLi4nIC0gbGl0ZXJhbCB0ZXh0PC9saT5cblx0XHRcdDxsaT4nJyAtIHNpbmdsZSBxdW90ZTwvbGk+XG5cdFx0XHQ8L3VsPlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIFtmb3JtYXRdIHtzdHJpbmd9IFRoZSBkZXNpcmVkIGZvcm1hdCBvZiB0aGUgZGF0ZSAoZGVmYXVsdHMgdG8gY2FsZW5kYXIgZm9ybWF0KS5cblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdmFsdWUgdG8gZm9ybWF0LlxuXHRcdFx0QHBhcmFtIFtzZXR0aW5nc10ge29iamVjdH0gQWRkaXRpb24gb3B0aW9ucywgd2hvc2UgYXR0cmlidXRlcyBpbmNsdWRlOlxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc10ge3N0cmluZ1tdfSBOYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheS5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMuXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIG1vbnRocy5cblx0XHRcdEBwcm9wZXJ0eSBbY2FsY3VsYXRlV2Vla10ge0NhbGVuZGFyc1BpY2tlckNhbGN1bGF0ZVdlZWt9IEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3ZWVrIG9mIHRoZSB5ZWFyLlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0LlxuXHRcdFx0QHRocm93cyBFcnJvcnMgaWYgdGhlIGRhdGUgaXMgZnJvbSBhIGRpZmZlcmVudCBjYWxlbmRhci4gKi9cblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihmb3JtYXQsIGRhdGUsIHNldHRpbmdzKSB7XG5cdFx0XHRpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0c2V0dGluZ3MgPSBkYXRlO1xuXHRcdFx0XHRkYXRlID0gZm9ybWF0O1xuXHRcdFx0XHRmb3JtYXQgPSAnJztcblx0XHRcdH1cblx0XHRcdGlmICghZGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0ZS5jYWxlbmRhcigpICE9PSB0aGlzKSB7XG5cdFx0XHRcdHRocm93ICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRGb3JtYXQgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRm9ybWF0O1xuXHRcdFx0fVxuXHRcdFx0Zm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMubG9jYWwuZGF0ZUZvcm1hdDtcblx0XHRcdHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG5cdFx0XHR2YXIgZGF5TmFtZXNTaG9ydCA9IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgfHwgdGhpcy5sb2NhbC5kYXlOYW1lc1Nob3J0O1xuXHRcdFx0dmFyIGRheU5hbWVzID0gc2V0dGluZ3MuZGF5TmFtZXMgfHwgdGhpcy5sb2NhbC5kYXlOYW1lcztcblx0XHRcdHZhciBtb250aE5hbWVzU2hvcnQgPSBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgfHwgdGhpcy5sb2NhbC5tb250aE5hbWVzU2hvcnQ7XG5cdFx0XHR2YXIgbW9udGhOYW1lcyA9IHNldHRpbmdzLm1vbnRoTmFtZXMgfHwgdGhpcy5sb2NhbC5tb250aE5hbWVzO1xuXHRcdFx0dmFyIGNhbGN1bGF0ZVdlZWsgPSBzZXR0aW5ncy5jYWxjdWxhdGVXZWVrIHx8IHRoaXMubG9jYWwuY2FsY3VsYXRlV2Vlaztcblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHRcdHZhciBkb3VibGVkID0gZnVuY3Rpb24obWF0Y2gsIHN0ZXApIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAxO1xuXHRcdFx0XHR3aGlsZSAoaUZvcm1hdCArIG1hdGNoZXMgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIG1hdGNoZXMpID09PSBtYXRjaCkge1xuXHRcdFx0XHRcdG1hdGNoZXMrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRpRm9ybWF0ICs9IG1hdGNoZXMgLSAxO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihtYXRjaGVzIC8gKHN0ZXAgfHwgMSkpID4gMTtcblx0XHRcdH07XG5cdFx0XHQvLyBGb3JtYXQgYSBudW1iZXIsIHdpdGggbGVhZGluZyB6ZXJvZXMgaWYgbmVjZXNzYXJ5XG5cdFx0XHR2YXIgZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBsZW4sIHN0ZXApIHtcblx0XHRcdFx0dmFyIG51bSA9ICcnICsgdmFsdWU7XG5cdFx0XHRcdGlmIChkb3VibGVkKG1hdGNoLCBzdGVwKSkge1xuXHRcdFx0XHRcdHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKSB7XG5cdFx0XHRcdFx0XHRudW0gPSAnMCcgKyBudW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudW07XG5cdFx0XHR9O1xuXHRcdFx0Ly8gRm9ybWF0IGEgbmFtZSwgc2hvcnQgb3IgbG9uZyBhcyByZXF1ZXN0ZWRcblx0XHRcdHZhciBmb3JtYXROYW1lID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcblx0XHRcdFx0cmV0dXJuIChkb3VibGVkKG1hdGNoKSA/IGxvbmdOYW1lc1t2YWx1ZV0gOiBzaG9ydE5hbWVzW3ZhbHVlXSk7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0dmFyIGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFwiJ1wiICYmICFkb3VibGVkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2QnOiBvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKCdkJywgZGF0ZS5kYXkoKSwgMik7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnRCc6IG91dHB1dCArPSBmb3JtYXROYW1lKCdEJywgZGF0ZS5kYXlPZldlZWsoKSxcblx0XHRcdFx0XHRcdFx0ZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ28nOiBvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKCdvJywgZGF0ZS5kYXlPZlllYXIoKSwgMyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAndyc6IG91dHB1dCArPSBmb3JtYXROdW1iZXIoJ3cnLCBkYXRlLndlZWtPZlllYXIoKSwgMik7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbSc6IG91dHB1dCArPSBmb3JtYXROdW1iZXIoJ20nLCBkYXRlLm1vbnRoKCksIDIpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ00nOiBvdXRwdXQgKz0gZm9ybWF0TmFtZSgnTScsIGRhdGUubW9udGgoKSAtIHRoaXMubWluTW9udGgsXG5cdFx0XHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAneSc6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSAoZG91YmxlZCgneScsIDIpID8gZGF0ZS55ZWFyKCkgOlxuXHRcdFx0XHRcdFx0XHRcdChkYXRlLnllYXIoKSAlIDEwMCA8IDEwID8gJzAnIDogJycpICsgZGF0ZS55ZWFyKCkgJSAxMDApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ1knOlxuXHRcdFx0XHRcdFx0XHRkb3VibGVkKCdZJywgMik7XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmZvcm1hdFllYXIoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdKJzogb3V0cHV0ICs9IGRhdGUudG9KRCgpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0AnOiBvdXRwdXQgKz0gKGRhdGUudG9KRCgpIC0gdGhpcy5VTklYX0VQT0NIKSAqIHRoaXMuU0VDU19QRVJfREFZOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJyEnOiBvdXRwdXQgKz0gKGRhdGUudG9KRCgpIC0gdGhpcy5USUNLU19FUE9DSCkgKiB0aGlzLlRJQ0tTX1BFUl9EQVk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdFx0aWYgKGRvdWJsZWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IFwiJ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0sXG5cblx0XHQvKiogUGFyc2UgYSBzdHJpbmcgdmFsdWUgaW50byBhIGRhdGUgb2JqZWN0LlxuXHRcdFx0U2VlIDxhIGhyZWY9XCIjZm9ybWF0RGF0ZVwiPjxjb2RlPmZvcm1hdERhdGU8L2NvZGU+PC9hPiBmb3IgdGhlIHBvc3NpYmxlIGZvcm1hdHMsIHBsdXM6XG5cdFx0XHQ8dWw+XG5cdFx0XHQ8bGk+KiAtIGlnbm9yZSByZXN0IG9mIHN0cmluZzwvbGk+XG5cdFx0XHQ8L3VsPlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIGZvcm1hdCB7c3RyaW5nfSBUaGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSBkYXRlICgnJyBmb3IgZGVmYXVsdCBjYWxlbmRhciBmb3JtYXQpLlxuXHRcdFx0QHBhcmFtIHZhbHVlIHtzdHJpbmd9IFRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXQuXG5cdFx0XHRAcGFyYW0gW3NldHRpbmdzXSB7b2JqZWN0fSBBZGRpdGlvbmFsIG9wdGlvbnMgd2hvc2UgYXR0cmlidXRlcyBpbmNsdWRlOlxuXHRcdFx0QHByb3BlcnR5IFtzaG9ydFllYXJDdXRvZmZdIHtudW1iZXJ9IFRoZSBjdXRvZmYgeWVhciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGNlbnR1cnkuXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxuXHRcdFx0QHByb3BlcnR5IFttb250aE5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocy5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc10ge3N0cmluZ1tdfSBOYW1lcyBvZiB0aGUgbW9udGhzLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBleHRyYWN0ZWQgZGF0ZSB2YWx1ZSBvciA8Y29kZT5udWxsPC9jb2RlPiBpZiB2YWx1ZSBpcyBibGFuay5cblx0XHRcdEB0aHJvd3MgRXJyb3JzIGlmIHRoZSBmb3JtYXQgYW5kL29yIHZhbHVlIGFyZSBtaXNzaW5nLFxuXHRcdFx0XHRcdGlmIHRoZSB2YWx1ZSBkb2Vzbid0IG1hdGNoIHRoZSBmb3JtYXQsIG9yIGlmIHRoZSBkYXRlIGlzIGludmFsaWQuICovXG5cdFx0cGFyc2VEYXRlOiBmdW5jdGlvbihmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xuXHRcdFx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZEFyZ3VtZW50cyB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRBcmd1bWVudHM7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlICsgJycpO1xuXHRcdFx0aWYgKHZhbHVlID09PSAnJykge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLmxvY2FsLmRhdGVGb3JtYXQ7XG5cdFx0XHRzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuXHRcdFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IHNldHRpbmdzLnNob3J0WWVhckN1dG9mZiB8fCB0aGlzLnNob3J0WWVhckN1dG9mZjtcblx0XHRcdHNob3J0WWVhckN1dG9mZiA9ICh0eXBlb2Ygc2hvcnRZZWFyQ3V0b2ZmICE9PSAnc3RyaW5nJyA/IHNob3J0WWVhckN1dG9mZiA6XG5cdFx0XHRcdHRoaXMudG9kYXkoKS55ZWFyKCkgJSAxMDAgKyBwYXJzZUludChzaG9ydFllYXJDdXRvZmYsIDEwKSk7XG5cdFx0XHR2YXIgZGF5TmFtZXNTaG9ydCA9IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgfHwgdGhpcy5sb2NhbC5kYXlOYW1lc1Nob3J0O1xuXHRcdFx0dmFyIGRheU5hbWVzID0gc2V0dGluZ3MuZGF5TmFtZXMgfHwgdGhpcy5sb2NhbC5kYXlOYW1lcztcblx0XHRcdHZhciBtb250aE5hbWVzU2hvcnQgPSBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgfHwgdGhpcy5sb2NhbC5tb250aE5hbWVzU2hvcnQ7XG5cdFx0XHR2YXIgbW9udGhOYW1lcyA9IHNldHRpbmdzLm1vbnRoTmFtZXMgfHwgdGhpcy5sb2NhbC5tb250aE5hbWVzO1xuXHRcdFx0dmFyIGpkID0gLTE7XG5cdFx0XHR2YXIgeWVhciA9IC0xO1xuXHRcdFx0dmFyIG1vbnRoID0gLTE7XG5cdFx0XHR2YXIgZGF5ID0gLTE7XG5cdFx0XHR2YXIgZG95ID0gLTE7XG5cdFx0XHR2YXIgc2hvcnRZZWFyID0gZmFsc2U7XG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0dmFyIGRvdWJsZWQgPSBmdW5jdGlvbihtYXRjaCwgc3RlcCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IDE7XG5cdFx0XHRcdHdoaWxlIChpRm9ybWF0ICsgbWF0Y2hlcyA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgbWF0Y2hlcykgPT09IG1hdGNoKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcysrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlGb3JtYXQgKz0gbWF0Y2hlcyAtIDE7XG5cdFx0XHRcdHJldHVybiBNYXRoLmZsb29yKG1hdGNoZXMgLyAoc3RlcCB8fCAxKSkgPiAxO1xuXHRcdFx0fTtcblx0XHRcdC8vIEV4dHJhY3QgYSBudW1iZXIgZnJvbSB0aGUgc3RyaW5nIHZhbHVlXG5cdFx0XHR2YXIgZ2V0TnVtYmVyID0gZnVuY3Rpb24obWF0Y2gsIHN0ZXApIHtcblx0XHRcdFx0dmFyIGlzRG91YmxlZCA9IGRvdWJsZWQobWF0Y2gsIHN0ZXApO1xuXHRcdFx0XHR2YXIgc2l6ZSA9IFsyLCAzLCBpc0RvdWJsZWQgPyA0IDogMiwgaXNEb3VibGVkID8gNCA6IDIsIDEwLCAxMSwgMjBdWydveVlKQCEnLmluZGV4T2YobWF0Y2gpICsgMV07XG5cdFx0XHRcdHZhciBkaWdpdHMgPSBuZXcgUmVnRXhwKCdeLT9cXFxcZHsxLCcgKyBzaXplICsgJ30nKTtcblx0XHRcdFx0dmFyIG51bSA9IHZhbHVlLnN1YnN0cmluZyhpVmFsdWUpLm1hdGNoKGRpZ2l0cyk7XG5cdFx0XHRcdGlmICghbnVtKSB7XG5cdFx0XHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLm1pc3NpbmdOdW1iZXJBdCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLm1pc3NpbmdOdW1iZXJBdCkuXG5cdFx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgaVZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUgKz0gbnVtWzBdLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG51bVswXSwgMTApO1xuXHRcdFx0fTtcblx0XHRcdC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxuXHRcdFx0dmFyIGNhbGVuZGFyID0gdGhpcztcblx0XHRcdHZhciBnZXROYW1lID0gZnVuY3Rpb24obWF0Y2gsIHNob3J0TmFtZXMsIGxvbmdOYW1lcywgc3RlcCkge1xuXHRcdFx0XHR2YXIgbmFtZXMgPSAoZG91YmxlZChtYXRjaCwgc3RlcCkgPyBsb25nTmFtZXMgOiBzaG9ydE5hbWVzKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5zdWJzdHIoaVZhbHVlLCBuYW1lc1tpXS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IG5hbWVzW2ldLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRcdGlWYWx1ZSArPSBuYW1lc1tpXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaSArIGNhbGVuZGFyLm1pbk1vbnRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwudW5rbm93bk5hbWVBdCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLnVua25vd25OYW1lQXQpLlxuXHRcdFx0XHRcdHJlcGxhY2UoL1xcezBcXH0vLCBpVmFsdWUpO1xuXHRcdFx0fTtcblx0XHRcdC8vIENvbmZpcm0gdGhhdCBhIGxpdGVyYWwgY2hhcmFjdGVyIG1hdGNoZXMgdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0dmFyIGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodmFsdWUuY2hhckF0KGlWYWx1ZSkgIT09IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwudW5leHBlY3RlZExpdGVyYWxBdCB8fFxuXHRcdFx0XHRcdFx0JC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS51bmV4cGVjdGVkTGl0ZXJhbEF0KS5yZXBsYWNlKC9cXHswXFx9LywgaVZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUrKztcblx0XHRcdH07XG5cdFx0XHR2YXIgaVZhbHVlID0gMDtcblx0XHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFwiJ1wiICYmICFkb3VibGVkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2QnOiBkYXkgPSBnZXROdW1iZXIoJ2QnKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdEJzogZ2V0TmFtZSgnRCcsIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdvJzogZG95ID0gZ2V0TnVtYmVyKCdvJyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAndyc6IGdldE51bWJlcigndycpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ20nOiBtb250aCA9IGdldE51bWJlcignbScpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ00nOiBtb250aCA9IGdldE5hbWUoJ00nLCBtb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXMpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3knOlxuXHRcdFx0XHRcdFx0XHR2YXIgaVNhdmUgPSBpRm9ybWF0O1xuXHRcdFx0XHRcdFx0XHRzaG9ydFllYXIgPSAhZG91YmxlZCgneScsIDIpO1xuXHRcdFx0XHRcdFx0XHRpRm9ybWF0ID0gaVNhdmU7XG5cdFx0XHRcdFx0XHRcdHllYXIgPSBnZXROdW1iZXIoJ3knLCAyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdZJzogeWVhciA9IGdldE51bWJlcignWScsIDIpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0onOlxuXHRcdFx0XHRcdFx0XHRqZCA9IGdldE51bWJlcignSicpICsgMC41O1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUuY2hhckF0KGlWYWx1ZSkgPT09ICcuJykge1xuXHRcdFx0XHRcdFx0XHRcdGlWYWx1ZSsrO1xuXHRcdFx0XHRcdFx0XHRcdGdldE51bWJlcignSicpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnQCc6IGpkID0gZ2V0TnVtYmVyKCdAJykgLyB0aGlzLlNFQ1NfUEVSX0RBWSArIHRoaXMuVU5JWF9FUE9DSDsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICchJzogamQgPSBnZXROdW1iZXIoJyEnKSAvIHRoaXMuVElDS1NfUEVSX0RBWSArIHRoaXMuVElDS1NfRVBPQ0g7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnKic6IGlWYWx1ZSA9IHZhbHVlLmxlbmd0aDsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRcdFx0XHRpZiAoZG91YmxlZChcIidcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlWYWx1ZSA8IHZhbHVlLmxlbmd0aCkge1xuXHRcdFx0XHR0aHJvdyAkLmNhbGVuZGFycy5sb2NhbC51bmV4cGVjdGVkVGV4dCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLnVuZXhwZWN0ZWRUZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHllYXIgPT09IC0xKSB7XG5cdFx0XHRcdHllYXIgPSB0aGlzLnRvZGF5KCkueWVhcigpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoeWVhciA8IDEwMCAmJiBzaG9ydFllYXIpIHtcblx0XHRcdFx0eWVhciArPSAoc2hvcnRZZWFyQ3V0b2ZmID09PSAtMSA/IDE5MDAgOiB0aGlzLnRvZGF5KCkueWVhcigpIC1cblx0XHRcdFx0XHR0aGlzLnRvZGF5KCkueWVhcigpICUgMTAwIC0gKHllYXIgPD0gc2hvcnRZZWFyQ3V0b2ZmID8gMCA6IDEwMCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRveSA+IC0xKSB7XG5cdFx0XHRcdG1vbnRoID0gMTtcblx0XHRcdFx0ZGF5ID0gZG95O1xuXHRcdFx0XHRmb3IgKHZhciBkaW0gPSB0aGlzLmRheXNJbk1vbnRoKHllYXIsIG1vbnRoKTsgZGF5ID4gZGltOyBkaW0gPSB0aGlzLmRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkge1xuXHRcdFx0XHRcdG1vbnRoKys7XG5cdFx0XHRcdFx0ZGF5IC09IGRpbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChqZCA+IC0xID8gdGhpcy5mcm9tSkQoamQpIDogdGhpcy5uZXdEYXRlKHllYXIsIG1vbnRoLCBkYXkpKTtcblx0XHR9LFxuXG5cdFx0LyoqIEEgZGF0ZSBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGV4YWN0IHZhbHVlIG9yIGEgcmVsYXRpdmUgb25lLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIGRhdGVTcGVjIHtDRGF0ZXxudW1iZXJ8c3RyaW5nfSBUaGUgZGF0ZSBhcyBhbiBvYmplY3Qgb3Igc3RyaW5nIGluIHRoZSBnaXZlbiBmb3JtYXQgb3Jcblx0XHRcdFx0XHRhbiBvZmZzZXQgLSBudW1lcmljIGRheXMgZnJvbSB0b2RheSwgb3Igc3RyaW5nIGFtb3VudHMgYW5kIHBlcmlvZHMsIGUuZy4gJysxbSArMncnLlxuXHRcdFx0QHBhcmFtIGRlZmF1bHREYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gdXNlIGlmIG5vIG90aGVyIHN1cHBsaWVkLCBtYXkgYmUgPGNvZGU+bnVsbDwvY29kZT4uXG5cdFx0XHRAcGFyYW0gY3VycmVudERhdGUge0NEYXRlfSBUaGUgY3VycmVudCBkYXRlIGFzIGEgcG9zc2libGUgYmFzaXMgZm9yIHJlbGF0aXZlIGRhdGVzLFxuXHRcdFx0XHRcdGlmIDxjb2RlPm51bGw8L2NvZGU+IHRvZGF5IGlzIHVzZWQgKG9wdGlvbmFsKVxuXHRcdFx0QHBhcmFtIFtkYXRlRm9ybWF0XSB7c3RyaW5nfSBUaGUgZXhwZWN0ZWQgZGF0ZSBmb3JtYXQgLSBzZWUgPGEgaHJlZj1cIiNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+LlxuXHRcdFx0QHBhcmFtIFtzZXR0aW5nc10ge29iamVjdH0gQWRkaXRpb25hbCBvcHRpb25zIHdob3NlIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0XHRcdEBwcm9wZXJ0eSBbc2hvcnRZZWFyQ3V0b2ZmXSB7bnVtYmVyfSBUaGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5LlxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxuXHRcdFx0QHByb3BlcnR5IFtkYXlOYW1lc10ge3N0cmluZ1tdfSBOYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheS5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc1Nob3J0XSB7c3RyaW5nW119IEFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMuXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIG1vbnRocy5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZGVjb2RlZCBkYXRlLiAqL1xuXHRcdGRldGVybWluZURhdGU6IGZ1bmN0aW9uKGRhdGVTcGVjLCBkZWZhdWx0RGF0ZSwgY3VycmVudERhdGUsIGRhdGVGb3JtYXQsIHNldHRpbmdzKSB7XG5cdFx0XHRpZiAoY3VycmVudERhdGUgJiYgdHlwZW9mIGN1cnJlbnREYXRlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRzZXR0aW5ncyA9IGRhdGVGb3JtYXQ7XG5cdFx0XHRcdGRhdGVGb3JtYXQgPSBjdXJyZW50RGF0ZTtcblx0XHRcdFx0Y3VycmVudERhdGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBkYXRlRm9ybWF0ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRzZXR0aW5ncyA9IGRhdGVGb3JtYXQ7XG5cdFx0XHRcdGRhdGVGb3JtYXQgPSAnJztcblx0XHRcdH1cblx0XHRcdHZhciBjYWxlbmRhciA9IHRoaXM7XG5cdFx0XHR2YXIgb2Zmc2V0U3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNhbGVuZGFyLnBhcnNlRGF0ZShkYXRlRm9ybWF0LCBvZmZzZXQsIHNldHRpbmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdC8vIElnbm9yZVxuXHRcdFx0XHR9XG5cdFx0XHRcdG9mZnNldCA9IG9mZnNldC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgZGF0ZSA9IChvZmZzZXQubWF0Y2goL15jLykgJiYgY3VycmVudERhdGUgP1xuXHRcdFx0XHRcdGN1cnJlbnREYXRlLm5ld0RhdGUoKSA6IG51bGwpIHx8IGNhbGVuZGFyLnRvZGF5KCk7XG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gLyhbKy1dP1swLTldKylcXHMqKGR8d3xtfHkpPy9nO1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXHRcdFx0XHR3aGlsZSAobWF0Y2hlcykge1xuXHRcdFx0XHRcdGRhdGUuYWRkKHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSwgbWF0Y2hlc1syXSB8fCAnZCcpO1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHRcdH07XG5cdFx0XHRkZWZhdWx0RGF0ZSA9IChkZWZhdWx0RGF0ZSA/IGRlZmF1bHREYXRlLm5ld0RhdGUoKSA6IG51bGwpO1xuXHRcdFx0ZGF0ZVNwZWMgPSAoZGF0ZVNwZWMgPT0gbnVsbCA/IGRlZmF1bHREYXRlIDpcblx0XHRcdFx0KHR5cGVvZiBkYXRlU3BlYyA9PT0gJ3N0cmluZycgPyBvZmZzZXRTdHJpbmcoZGF0ZVNwZWMpIDogKHR5cGVvZiBkYXRlU3BlYyA9PT0gJ251bWJlcicgP1xuXHRcdFx0XHQoaXNOYU4oZGF0ZVNwZWMpIHx8IGRhdGVTcGVjID09PSBJbmZpbml0eSB8fCBkYXRlU3BlYyA9PT0gLUluZmluaXR5ID8gZGVmYXVsdERhdGUgOlxuXHRcdFx0XHRjYWxlbmRhci50b2RheSgpLmFkZChkYXRlU3BlYywgJ2QnKSkgOiBjYWxlbmRhci5uZXdEYXRlKGRhdGVTcGVjKSkpKTtcblx0XHRcdHJldHVybiBkYXRlU3BlYztcblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnkpO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
