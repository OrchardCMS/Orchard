/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Islamic calendar for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	/** Implementation of the Islamic or '16 civil' calendar.
		Based on code from <a href="http://www.iranchamber.com/calendar/converter/iranian_calendar_converter.php">http://www.iranchamber.com/calendar/converter/iranian_calendar_converter.php</a>.
		See also <a href="http://en.wikipedia.org/wiki/Islamic_calendar">http://en.wikipedia.org/wiki/Islamic_calendar</a>.
		@class IslamicCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function IslamicCalendar(language) {
		this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
	}

	IslamicCalendar.prototype = new $.calendars.baseCalendar;

	$.extend(IslamicCalendar.prototype, {
		/** The calendar name.
			@memberof IslamicCalendar */
		name: 'Islamic',
		/** Julian date of start of Islamic epoch: 16 July 622 CE.
			@memberof IslamicCalendar */
		jdEpoch: 1948439.5,
		/** Days per month in a common year.
			@memberof IslamicCalendar */
		daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],
		/** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof IslamicCalendar */
		hasYearZero: false,
		/** The minimum month number.
			@memberof IslamicCalendar */
		minMonth: 1,
		/** The first month in the year.
			@memberof IslamicCalendar */
		firstMonth: 1,
		/** The minimum day number.
			@memberof IslamicCalendar */
		minDay: 1,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof IslamicCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
		regionalOptions: { // Localisations
			'': {
				name: 'Islamic',
				epochs: ['BH', 'AH'],
				monthNames: ['Muharram', 'Safar', 'Rabi\' al-awwal', 'Rabi\' al-thani', 'Jumada al-awwal', 'Jumada al-thani',
				'Rajab', 'Sha\'aban', 'Ramadan', 'Shawwal', 'Dhu al-Qi\'dah', 'Dhu al-Hijjah'],
				monthNamesShort: ['Muh', 'Saf', 'Rab1', 'Rab2', 'Jum1', 'Jum2', 'Raj', 'Sha\'', 'Ram', 'Shaw', 'DhuQ', 'DhuH'],
				dayNames: ['Yawm al-ahad', 'Yawm al-ithnayn', 'Yawm ath-thulaathaa\'',
				'Yawm al-arbi\'aa\'', 'Yawm al-khamÄ«s', 'Yawm al-jum\'a', 'Yawm as-sabt'],
				dayNamesShort: ['Aha', 'Ith', 'Thu', 'Arb', 'Kha', 'Jum', 'Sab'],
				dayNamesMin: ['Ah','It','Th','Ar','Kh','Ju','Sa'],
				dateFormat: 'yyyy/mm/dd',
				firstDay: 6,
				isRTL: false
			}
		},

		/** Determine whether this date is in a leap year.
			@memberof IslamicCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			return (date.year() * 11 + 14) % 30 < 11;
		},

		/** Determine the week of the year for a date.
			@memberof IslamicCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			// Find Sunday of this week starting on Sunday
			var checkDate = this.newDate(year, month, day);
			checkDate.add(-checkDate.dayOfWeek(), 'd');
			return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
		},

		/** Retrieve the number of days in a year.
			@memberof IslamicCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of days.
			@throws Error if an invalid year or a different calendar used. */
		daysInYear: function(year) {
			return (this.leapYear(year) ? 355 : 354);
		},

		/** Retrieve the number of days in a month.
			@memberof IslamicCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			var date = this._validate(year, month, this.minDay, $.calendars.local.invalidMonth);
			return this.daysPerMonth[date.month() - 1] +
				(date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
		},

		/** Determine whether this date is a week day.
			@memberof IslamicCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			return this.dayOfWeek(year, month, day) !== 5;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof IslamicCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			year = date.year();
			month = date.month();
			day = date.day();
			year = (year <= 0 ? year + 1 : year);
			return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 +
				Math.floor((3 + (11 * year)) / 30) + this.jdEpoch - 1;
		},

		/** Create a new date from a Julian date.
			@memberof IslamicCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			jd = Math.floor(jd) + 0.5;
			var year = Math.floor((30 * (jd - this.jdEpoch) + 10646) / 10631);
			year = (year <= 0 ? year - 1 : year);
			var month = Math.min(12, Math.ceil((jd - 29 - this.toJD(year, 1, 1)) / 29.5) + 1);
			var day = jd - this.toJD(year, month, 1) + 1;
			return this.newDate(year, month, day);
		}
	});

	// Islamic (16 civil) calendar implementation
	$.calendars.calendars.islamic = IslamicCalendar;

})(jQuery);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMuaXNsYW1pYy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJqcXVlcnkuY2FsZW5kYXJzLmlzbGFtaWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXHJcbiAgIElzbGFtaWMgY2FsZW5kYXIgZm9yIGpRdWVyeSB2Mi4wLjEuXHJcbiAgIFdyaXR0ZW4gYnkgS2VpdGggV29vZCAoa2J3b29ke2F0fWlpbmV0LmNvbS5hdSkgQXVndXN0IDIwMDkuXHJcbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwOi8va2VpdGgtd29vZC5uYW1lL2xpY2VuY2UuaHRtbCkgbGljZW5zZS4gXHJcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xyXG5cclxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxyXG5cclxuXHQvKiogSW1wbGVtZW50YXRpb24gb2YgdGhlIElzbGFtaWMgb3IgJzE2IGNpdmlsJyBjYWxlbmRhci5cclxuXHRcdEJhc2VkIG9uIGNvZGUgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5pcmFuY2hhbWJlci5jb20vY2FsZW5kYXIvY29udmVydGVyL2lyYW5pYW5fY2FsZW5kYXJfY29udmVydGVyLnBocFwiPmh0dHA6Ly93d3cuaXJhbmNoYW1iZXIuY29tL2NhbGVuZGFyL2NvbnZlcnRlci9pcmFuaWFuX2NhbGVuZGFyX2NvbnZlcnRlci5waHA8L2E+LlxyXG5cdFx0U2VlIGFsc28gPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSXNsYW1pY19jYWxlbmRhclwiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSXNsYW1pY19jYWxlbmRhcjwvYT4uXHJcblx0XHRAY2xhc3MgSXNsYW1pY0NhbGVuZGFyXHJcblx0XHRAcGFyYW0gW2xhbmd1YWdlPScnXSB7c3RyaW5nfSBUaGUgbGFuZ3VhZ2UgY29kZSAoZGVmYXVsdCBFbmdsaXNoKSBmb3IgbG9jYWxpc2F0aW9uLiAqL1xyXG5cdGZ1bmN0aW9uIElzbGFtaWNDYWxlbmRhcihsYW5ndWFnZSkge1xyXG5cdFx0dGhpcy5sb2NhbCA9IHRoaXMucmVnaW9uYWxPcHRpb25zW2xhbmd1YWdlIHx8ICcnXSB8fCB0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ107XHJcblx0fVxyXG5cclxuXHRJc2xhbWljQ2FsZW5kYXIucHJvdG90eXBlID0gbmV3ICQuY2FsZW5kYXJzLmJhc2VDYWxlbmRhcjtcclxuXHJcblx0JC5leHRlbmQoSXNsYW1pY0NhbGVuZGFyLnByb3RvdHlwZSwge1xyXG5cdFx0LyoqIFRoZSBjYWxlbmRhciBuYW1lLlxyXG5cdFx0XHRAbWVtYmVyb2YgSXNsYW1pY0NhbGVuZGFyICovXHJcblx0XHRuYW1lOiAnSXNsYW1pYycsXHJcblx0XHQvKiogSnVsaWFuIGRhdGUgb2Ygc3RhcnQgb2YgSXNsYW1pYyBlcG9jaDogMTYgSnVseSA2MjIgQ0UuXHJcblx0XHRcdEBtZW1iZXJvZiBJc2xhbWljQ2FsZW5kYXIgKi9cclxuXHRcdGpkRXBvY2g6IDE5NDg0MzkuNSxcclxuXHRcdC8qKiBEYXlzIHBlciBtb250aCBpbiBhIGNvbW1vbiB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgSXNsYW1pY0NhbGVuZGFyICovXHJcblx0XHRkYXlzUGVyTW9udGg6IFszMCwgMjksIDMwLCAyOSwgMzAsIDI5LCAzMCwgMjksIDMwLCAyOSwgMzAsIDI5XSxcclxuXHRcdC8qKiA8Y29kZT50cnVlPC9jb2RlPiBpZiBoYXMgYSB5ZWFyIHplcm8sIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXHJcblx0XHRcdEBtZW1iZXJvZiBJc2xhbWljQ2FsZW5kYXIgKi9cclxuXHRcdGhhc1llYXJaZXJvOiBmYWxzZSxcclxuXHRcdC8qKiBUaGUgbWluaW11bSBtb250aCBudW1iZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBJc2xhbWljQ2FsZW5kYXIgKi9cclxuXHRcdG1pbk1vbnRoOiAxLFxyXG5cdFx0LyoqIFRoZSBmaXJzdCBtb250aCBpbiB0aGUgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIElzbGFtaWNDYWxlbmRhciAqL1xyXG5cdFx0Zmlyc3RNb250aDogMSxcclxuXHRcdC8qKiBUaGUgbWluaW11bSBkYXkgbnVtYmVyLlxyXG5cdFx0XHRAbWVtYmVyb2YgSXNsYW1pY0NhbGVuZGFyICovXHJcblx0XHRtaW5EYXk6IDEsXHJcblxyXG5cdFx0LyoqIExvY2FsaXNhdGlvbnMgZm9yIHRoZSBwbHVnaW4uXHJcblx0XHRcdEVudHJpZXMgYXJlIG9iamVjdHMgaW5kZXhlZCBieSB0aGUgbGFuZ3VhZ2UgY29kZSAoJycgYmVpbmcgdGhlIGRlZmF1bHQgVVMvRW5nbGlzaCkuXHJcblx0XHRcdEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXHJcblx0XHRcdEBtZW1iZXJvZiBJc2xhbWljQ2FsZW5kYXJcclxuXHRcdFx0QHByb3BlcnR5IG5hbWUge3N0cmluZ30gVGhlIGNhbGVuZGFyIG5hbWUuXHJcblx0XHRcdEBwcm9wZXJ0eSBlcG9jaHMge3N0cmluZ1tdfSBUaGUgZXBvY2ggbmFtZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzIHtzdHJpbmdbXX0gVGhlIGxvbmcgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cclxuXHRcdFx0QHByb3BlcnR5IG1vbnRoTmFtZXNTaG9ydCB7c3RyaW5nW119IFRoZSBzaG9ydCBuYW1lcyBvZiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXMge3N0cmluZ1tdfSBUaGUgbG9uZyBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cclxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lc01pbiB7c3RyaW5nW119IFRoZSBtaW5pbWFsIG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF0ZUZvcm1hdCB7c3RyaW5nfSBUaGUgZGF0ZSBmb3JtYXQgZm9yIHRoaXMgY2FsZW5kYXIuXHJcblx0XHRcdFx0XHRTZWUgdGhlIG9wdGlvbnMgb24gPGEgaHJlZj1cIkJhc2VDYWxlbmRhci5odG1sI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4gZm9yIGRldGFpbHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBmaXJzdERheSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWssIHN0YXJ0aW5nIGF0IDAuXHJcblx0XHRcdEBwcm9wZXJ0eSBpc1JUTCB7bnVtYmVyfSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGxvY2FsaXNhdGlvbiByZWFkcyByaWdodC10by1sZWZ0LiAqL1xyXG5cdFx0cmVnaW9uYWxPcHRpb25zOiB7IC8vIExvY2FsaXNhdGlvbnNcclxuXHRcdFx0Jyc6IHtcclxuXHRcdFx0XHRuYW1lOiAnSXNsYW1pYycsXHJcblx0XHRcdFx0ZXBvY2hzOiBbJ0JIJywgJ0FIJ10sXHJcblx0XHRcdFx0bW9udGhOYW1lczogWydNdWhhcnJhbScsICdTYWZhcicsICdSYWJpXFwnIGFsLWF3d2FsJywgJ1JhYmlcXCcgYWwtdGhhbmknLCAnSnVtYWRhIGFsLWF3d2FsJywgJ0p1bWFkYSBhbC10aGFuaScsXHJcblx0XHRcdFx0J1JhamFiJywgJ1NoYVxcJ2FiYW4nLCAnUmFtYWRhbicsICdTaGF3d2FsJywgJ0RodSBhbC1RaVxcJ2RhaCcsICdEaHUgYWwtSGlqamFoJ10sXHJcblx0XHRcdFx0bW9udGhOYW1lc1Nob3J0OiBbJ011aCcsICdTYWYnLCAnUmFiMScsICdSYWIyJywgJ0p1bTEnLCAnSnVtMicsICdSYWonLCAnU2hhXFwnJywgJ1JhbScsICdTaGF3JywgJ0RodVEnLCAnRGh1SCddLFxyXG5cdFx0XHRcdGRheU5hbWVzOiBbJ1lhd20gYWwtYWhhZCcsICdZYXdtIGFsLWl0aG5heW4nLCAnWWF3bSBhdGgtdGh1bGFhdGhhYVxcJycsXHJcblx0XHRcdFx0J1lhd20gYWwtYXJiaVxcJ2FhXFwnJywgJ1lhd20gYWwta2hhbcSrcycsICdZYXdtIGFsLWp1bVxcJ2EnLCAnWWF3bSBhcy1zYWJ0J10sXHJcblx0XHRcdFx0ZGF5TmFtZXNTaG9ydDogWydBaGEnLCAnSXRoJywgJ1RodScsICdBcmInLCAnS2hhJywgJ0p1bScsICdTYWInXSxcclxuXHRcdFx0XHRkYXlOYW1lc01pbjogWydBaCcsJ0l0JywnVGgnLCdBcicsJ0toJywnSnUnLCdTYSddLFxyXG5cdFx0XHRcdGRhdGVGb3JtYXQ6ICd5eXl5L21tL2RkJyxcclxuXHRcdFx0XHRmaXJzdERheTogNixcclxuXHRcdFx0XHRpc1JUTDogZmFsc2VcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgSXNsYW1pY0NhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBpcyBhIGxlYXAgeWVhciwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdGxlYXBZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyKTtcclxuXHRcdFx0cmV0dXJuIChkYXRlLnllYXIoKSAqIDExICsgMTQpICUgMzAgPCAxMTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB0aGUgd2VlayBvZiB0aGUgeWVhciBmb3IgYSBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgSXNsYW1pY0NhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHdlZWsgb2YgdGhlIHllYXIuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHR3ZWVrT2ZZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdC8vIEZpbmQgU3VuZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBTdW5kYXlcclxuXHRcdFx0dmFyIGNoZWNrRGF0ZSA9IHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcclxuXHRcdFx0Y2hlY2tEYXRlLmFkZCgtY2hlY2tEYXRlLmRheU9mV2VlaygpLCAnZCcpO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigoY2hlY2tEYXRlLmRheU9mWWVhcigpIC0gMSkgLyA3KSArIDE7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgSXNsYW1pY0NhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRkYXlzSW5ZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XHJcblx0XHRcdHJldHVybiAodGhpcy5sZWFwWWVhcih5ZWFyKSA/IDM1NSA6IDM1NCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aC5cclxuXHRcdFx0QG1lbWJlcm9mIElzbGFtaWNDYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIG9mIHRoZSBtb250aC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIG1vbnRoLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgbW9udGgveWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZGF5c0luTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkTW9udGgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXlzUGVyTW9udGhbZGF0ZS5tb250aCgpIC0gMV0gK1xyXG5cdFx0XHRcdChkYXRlLm1vbnRoKCkgPT09IDEyICYmIHRoaXMubGVhcFllYXIoZGF0ZS55ZWFyKCkpID8gMSA6IDApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGEgd2VlayBkYXkuXHJcblx0XHRcdEBtZW1iZXJvZiBJc2xhbWljQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYSB3ZWVrIGRheSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdHdlZWtEYXk6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpICE9PSA1O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIEp1bGlhbiBkYXRlIGVxdWl2YWxlbnQgZm9yIHRoaXMgZGF0ZSxcclxuXHRcdFx0aS5lLiBkYXlzIHNpbmNlIEphbnVhcnkgMSwgNDcxMyBCQ0UgR3JlZW53aWNoIG5vb24uXHJcblx0XHRcdEBtZW1iZXJvZiBJc2xhbWljQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gY29udmVydC5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cclxuXHRcdHRvSkQ6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHllYXIgPSBkYXRlLnllYXIoKTtcclxuXHRcdFx0bW9udGggPSBkYXRlLm1vbnRoKCk7XHJcblx0XHRcdGRheSA9IGRhdGUuZGF5KCk7XHJcblx0XHRcdHllYXIgPSAoeWVhciA8PSAwID8geWVhciArIDEgOiB5ZWFyKTtcclxuXHRcdFx0cmV0dXJuIGRheSArIE1hdGguY2VpbCgyOS41ICogKG1vbnRoIC0gMSkpICsgKHllYXIgLSAxKSAqIDM1NCArXHJcblx0XHRcdFx0TWF0aC5mbG9vcigoMyArICgxMSAqIHllYXIpKSAvIDMwKSArIHRoaXMuamRFcG9jaCAtIDE7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmcm9tIGEgSnVsaWFuIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBJc2xhbWljQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIGpkIHtudW1iZXJ9IFRoZSBKdWxpYW4gZGF0ZSB0byBjb252ZXJ0LlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGVxdWl2YWxlbnQgZGF0ZS4gKi9cclxuXHRcdGZyb21KRDogZnVuY3Rpb24oamQpIHtcclxuXHRcdFx0amQgPSBNYXRoLmZsb29yKGpkKSArIDAuNTtcclxuXHRcdFx0dmFyIHllYXIgPSBNYXRoLmZsb29yKCgzMCAqIChqZCAtIHRoaXMuamRFcG9jaCkgKyAxMDY0NikgLyAxMDYzMSk7XHJcblx0XHRcdHllYXIgPSAoeWVhciA8PSAwID8geWVhciAtIDEgOiB5ZWFyKTtcclxuXHRcdFx0dmFyIG1vbnRoID0gTWF0aC5taW4oMTIsIE1hdGguY2VpbCgoamQgLSAyOSAtIHRoaXMudG9KRCh5ZWFyLCAxLCAxKSkgLyAyOS41KSArIDEpO1xyXG5cdFx0XHR2YXIgZGF5ID0gamQgLSB0aGlzLnRvSkQoeWVhciwgbW9udGgsIDEpICsgMTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gSXNsYW1pYyAoMTYgY2l2aWwpIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uXHJcblx0JC5jYWxlbmRhcnMuY2FsZW5kYXJzLmlzbGFtaWMgPSBJc2xhbWljQ2FsZW5kYXI7XHJcblxyXG59KShqUXVlcnkpOyJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
