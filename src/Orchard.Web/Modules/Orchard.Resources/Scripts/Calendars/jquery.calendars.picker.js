/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars date picker for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'calendarsPicker';


	/** Create the calendars datepicker plugin.
		<p>Sets an input field to popup a calendar for date entry,
			or a <code>div</code> or <code>span</code> to show an inline calendar.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;input type="text"> or &lt;div>&lt;/div></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;input type="text" data-calendarsPicker="name: 'value'"/></pre>
	 	@class CalendarsPicker
		@augments JQPlugin
		@example $(selector).calendarsPicker()
 $(selector).calendarsPicker({minDate: 0, maxDate: '+1m +1w'}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin.
			@memberof CalendarsPicker */
		name: pluginName,
		
		/** Default template for generating a datepicker.
			Insert anywhere:
			<ul>
			<li>'{l10n:name}' to insert localised value for name,</li>
			<li>'{link:name}' to insert a link trigger for command name,</li>
			<li>'{button:name}' to insert a button trigger for command name,</li>
			<li>'{popup:start}...{popup:end}' to mark a section for inclusion in a popup datepicker only,</li>
			<li>'{inline:start}...{inline:end}' to mark a section for inclusion in an inline datepicker only.</li>
			</ul>
			@memberof CalendarsPicker
			@property picker {string} Overall structure: '{months}' to insert calendar months.
			@property monthRow {string} One row of months: '{months}' to insert calendar months.
			@property month {string} A single month: '{monthHeader<em>:dateFormat</em>}' to insert the month header -
						<em>dateFormat</em> is optional and defaults to 'MM yyyy',
						'{weekHeader}' to insert a week header, '{weeks}' to insert the month's weeks.
			@property weekHeader {string} A week header: '{days}' to insert individual day names.
			@property dayHeader {string} Individual day header: '{day}' to insert day name.
			@property week {string} One week of the month: '{days}' to insert the week's days,
						'{weekOfYear}' to insert week of year.
			@property day {string} An individual day: '{day}' to insert day value.
			@property monthSelector {string} jQuery selector, relative to picker, for a single month.
			@property daySelector {string} jQuery selector, relative to picker, for individual days.
			@property rtlClass {string} Class for right-to-left (RTL) languages.
			@property multiClass {string} Class for multi-month datepickers.
			@property defaultClass {string} Class for selectable dates.
			@property selectedClass {string} Class for currently selected dates.
			@property highlightedClass {string} Class for highlighted dates.
			@property todayClass {string} Class for today.
			@property otherMonthClass {string} Class for days from other months.
			@property weekendClass {string} Class for days on weekends.
			@property commandClass {string} Class prefix for commands.
			@property commandButtonClass {string} Extra class(es) for commands that are buttons.
			@property commandLinkClass {string} Extra class(es) for commands that are links.
			@property disabledClass {string} Class for disabled commands. */
		defaultRenderer: {
			picker: '<div class="calendars">' +
			'<div class="calendars-nav">{link:prev}{link:today}{link:next}</div>{months}' +
			'{popup:start}<div class="calendars-ctrl">{link:clear}{link:close}</div>{popup:end}' +
			'<div class="calendars-clear-fix"></div></div>',
			monthRow: '<div class="calendars-month-row">{months}</div>',
			month: '<div class="calendars-month"><div class="calendars-month-header">{monthHeader}</div>' +
			'<table><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
			weekHeader: '<tr>{days}</tr>',
			dayHeader: '<th>{day}</th>',
			week: '<tr>{days}</tr>',
			day: '<td>{day}</td>',
			monthSelector: '.calendars-month',
			daySelector: 'td',
			rtlClass: 'calendars-rtl',
			multiClass: 'calendars-multi',
			defaultClass: '',
			selectedClass: 'calendars-selected',
			highlightedClass: 'calendars-highlight',
			todayClass: 'calendars-today',
			otherMonthClass: 'calendars-other-month',
			weekendClass: 'calendars-weekend',
			commandClass: 'calendars-cmd',
			commandButtonClass: '',
			commandLinkClass: '',
			disabledClass: 'calendars-disabled'
		},
	
		/** Command actions that may be added to a layout by name.
			<ul>
			<li>prev - Show the previous month (based on <code>monthsToStep</code> option) - <em>PageUp</em></li>
			<li>prevJump - Show the previous year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageUp</em></li>
			<li>next - Show the next month (based on <code>monthsToStep</code> option) - <em>PageDown</em></li>
			<li>nextJump - Show the next year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageDown</em></li>
			<li>current - Show the currently selected month or today's if none selected - <em>Ctrl+Home</em></li>
			<li>today - Show today's month - <em>Ctrl+Home</em></li>
			<li>clear - Erase the date and close the datepicker popup - <em>Ctrl+End</em></li>
			<li>close - Close the datepicker popup - <em>Esc</em></li>
			<li>prevWeek - Move the cursor to the previous week - <em>Ctrl+Up</em></li>
			<li>prevDay - Move the cursor to the previous day - <em>Ctrl+Left</em></li>
			<li>nextDay - Move the cursor to the next day - <em>Ctrl+Right</em></li>
			<li>nextWeek - Move the cursor to the next week - <em>Ctrl+Down</em></li>
			</ul>
			The command name is the key name and is used to add the command to a layout
			with '{button:name}' or '{link:name}'. Each has the following attributes.
			@memberof CalendarsPicker
			@property text {string} The field in the regional settings for the displayed text.
			@property status {string} The field in the regional settings for the status text.
			@property keystroke {object} The keystroke to trigger the action, with attributes:
				<code>keyCode</code> {number} the code for the keystroke,
				<code>ctrlKey</code> {boolean} <code>true</code> if <em>Ctrl</em> is required,
				<code>altKey</code> {boolean} <code>true</code> if <em>Alt</em> is required,
				<code>shiftKey</code> {boolean} <code>true</code> if <em>Shift</em> is required.
			@property enabled {CalendarsPickerCommandEnabled} The function that indicates the command is enabled.
			@property date {CalendarsPickerCommandDate} The function to get the date associated with this action.
			@property action {CalendarsPickerCommandAction} The function that implements the action. */
		commands: {
			prev: {text: 'prevText', status: 'prevStatus', // Previous month
				keystroke: {keyCode: 33}, // Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToStep); }
			},
			prevJump: {text: 'prevJumpText', status: 'prevJumpStatus', // Previous year
				keystroke: {keyCode: 33, ctrlKey: true}, // Ctrl + Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToJump); }
			},
			next: {text: 'nextText', status: 'nextStatus', // Next month
				keystroke: {keyCode: 34}, // Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToStep); }
			},
			nextJump: {text: 'nextJumpText', status: 'nextJumpStatus', // Next year
				keystroke: {keyCode: 34, ctrlKey: true}, // Ctrl + Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1);	},
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToJump); }
			},
			current: {text: 'currentText', status: 'currentStatus', // Current month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					return (!minDate || curDate.compareTo(minDate) !== -1) &&
						(!maxDate || curDate.compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.selectedDates[0] || inst.options.calendar.today(); },
				action: function(inst) {
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					plugin.showMonth(this, curDate.year(), curDate.month()); }
			},
			today: {text: 'todayText', status: 'todayStatus', // Today's month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					return (!minDate || inst.options.calendar.today().compareTo(minDate) !== -1) &&
						(!maxDate || inst.options.calendar.today().compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.options.calendar.today(); },
				action: function(inst) { plugin.showMonth(this); }
			},
			clear: {text: 'clearText', status: 'clearStatus', // Clear the datepicker
				keystroke: {keyCode: 35, ctrlKey: true}, // Ctrl + End
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.clear(this); }
			},
			close: {text: 'closeText', status: 'closeStatus', // Close the datepicker
				keystroke: {keyCode: 27}, // Escape
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.hide(this); }
			},
			prevWeek: {text: 'prevWeekText', status: 'prevWeekStatus', // Previous week
				keystroke: {keyCode: 38, ctrlKey: true}, // Ctrl + Up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(-inst.options.calendar.daysInWeek(), 'd').compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(-inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, -inst.options.calendar.daysInWeek()); }
			},
			prevDay: {text: 'prevDayText', status: 'prevDayStatus', // Previous day
				keystroke: {keyCode: 37, ctrlKey: true}, // Ctrl + Left
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().add(-1, 'd').
						compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().add(-1, 'd'); },
				action: function(inst) { plugin.changeDay(this, -1); }
			},
			nextDay: {text: 'nextDayText', status: 'nextDayStatus', // Next day
				keystroke: {keyCode: 39, ctrlKey: true}, // Ctrl + Right
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().add(1, 'd').
						compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().add(1, 'd'); },
				action: function(inst) { plugin.changeDay(this, 1); }
			},
			nextWeek: {text: 'nextWeekText', status: 'nextWeekStatus', // Next week
				keystroke: {keyCode: 40, ctrlKey: true}, // Ctrl + Down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.calendar.daysInWeek(), 'd').compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, inst.options.calendar.daysInWeek()); }
			}
		},

		/** Determine whether a command is enabled.
			@callback CalendarsPickerCommandEnabled
			@param inst {object} The current instance settings.
			@return {boolean} <code>true</code> if this command is enabled, <code>false</code> if not.
			@example enabled: function(inst) {
	return !!inst.curMinDate();
 } */

		/** Calculate the representative date for a command.
			@callback CalendarsPickerCommandDate
			@param inst {object} The current instance settings.
			@return {CDate} A date appropriate for this command.
			@example date: function(inst) {
	return inst.curMinDate();
 } */

		/** Perform the action for a command.
			@callback CalendarsPickerCommandAction
			@param inst {object} The current instance settings.
			@example date: function(inst) {
	$.datepick.setDate(inst.elem, inst.curMinDate());
 } */

		/** Calculate the week of the year for a date.
			@callback CalendarsPickerCalculateWeek
			@param date {CDate} The date to evaluate.
			@return {number} The week of the year.
			@example calculateWeek: function(date) {
	var startYear = $.calendars.newDate(date.year(), 1, 1);
	return Math.floor((date.dayOfYear() - startYear.dayOfYear()) / 7) + 1;
 } */

		/** Provide information about an individual date shown in the calendar.
			@callback CalendarsPickerOnDate
			@param date {CDate} The date to evaluate.
			@return {object} Information about that date, with the properties above.
			@property selectable {boolean} <code>true</code> if this date can be selected.
			@property dateClass {string} Class(es) to be applied to the date.
			@property content {string} The date cell content.
			@property tooltip {string} A popup tooltip for the date.
			@example onDate: function(date) {
	return {selectable: date.day() > 0 && date.day() &lt; 5,
		dateClass: date.day() === 4 ? 'last-day' : ''};
 } */

		/** Update the datepicker display.
			@callback CalendarsPickerOnShow
			@param picker {jQuery} The datepicker <code>div</code> to be shown.
			@param inst {object} The current instance settings.
			@example onShow: function(picker, inst) {
	picker.append('&lt;button type="button">Hi&lt;/button>').
		find('button:last').click(function() {
			alert('Hi!');
		});
 } */

		/** React to navigating through the months/years.
			@callback CalendarsPickerOnChangeMonthYear
			@param year {number} The new year.
			@param month {number} The new month (1 to 12).
			@example onChangeMonthYear: function(year, month) {
	alert('Now in ' + month + '/' + year);
 } */
			
		/** Datepicker on select callback.
			Triggered when a date is selected.
			@callback CalendarsPickerOnSelect
			@param dates {CDate[]} The selected date(s).
			@example onSelect: function(dates) {
 	alert('Selected ' + dates);
 } */
			
		/** Datepicker on close callback.
			Triggered when a popup calendar is closed.
			@callback CalendarsPickerOnClose
			@param dates {CDate[]} The selected date(s).
			@example onClose: function(dates) {
 	alert('Selected ' + dates);
 } */
		
		/** Default settings for the plugin.
			@memberof CalendarsPicker
			@property [calendar=$.calendars.instance()] {Calendar} The calendar for this datepicker.
			@property [pickerClass=''] {string} CSS class to add to this instance of the datepicker.
			@property [showOnFocus=true] {boolean} <code>true</code> for popup on focus, <code>false</code> for not.
			@property [showTrigger=null] {string|Element|jQuery} Element to be cloned for a trigger, <code>null</code> for none.
			@property [showAnim='show'] {string} Name of jQuery animation for popup, '' for no animation.
			@property [showOptions=null] {object} Options for enhanced animations.
			@property [showSpeed='normal'] {string} Duration of display/closure.
			@property [popupContainer=null] {string|Element|jQuery} The element to which a popup calendar is added, <code>null</code> for body.
			@property [alignment='bottom'] {string} Alignment of popup - with nominated corner of input:
						'top' or 'bottom' aligns depending on language direction,
						'topLeft', 'topRight', 'bottomLeft', 'bottomRight'.
			@property [fixedWeeks=false] {boolean} <code>true</code> to always show 6 weeks, <code>false</code> to only show as many as are needed.
			@property [firstDay=null] {number} First day of the week, 0 = Sunday, 1 = Monday, etc., <code>null</code> for <code>calendar</code> default.
			@property [calculateWeek=null] {CalendarsPickerCalculateWeek} Calculate week of the year from a date, <code>null</code> for <code>calendar</code> default.
			@property [monthsToShow=1] {number|number[]} How many months to show, cols or [rows, cols].
			@property [monthsOffset=0] {number} How many months to offset the primary month by;
						may be a function that takes the date and returns the offset.
			@property [monthsToStep=1] {number} How many months to move when prev/next clicked.
			@property [monthsToJump=12] {number} How many months to move when large prev/next clicked.
			@property [useMouseWheel=true] {boolean} <code>true</code> to use mousewheel if available, <code>false</code> to never use it.
			@property [changeMonth=true] {boolean} <code>true</code> to change month/year via drop-down, <code>false</code> for navigation only.
			@property [yearRange='c-10:c+10'] {string} Range of years to show in drop-down: 'any' for direct text entry
						or 'start:end', where start/end are '+-nn' for relative to today
						or 'c+-nn' for relative to the currently selected date
						or 'nnnn' for an absolute year.
			@property [showOtherMonths=false] {boolean} <code>true</code> to show dates from other months, <code>false</code> to not show them.
			@property [selectOtherMonths=false] {boolean} <code>true</code> to allow selection of dates from other months too.
			@property [defaultDate=null] {string|number|CDate} Date to show if no other selected.
			@property [selectDefaultDate=false] {boolean} <code>true</code> to pre-select the default date if no other is chosen.
			@property [minDate=null] {string|number|CDate} The minimum selectable date.
			@property [maxDate=null] {string|number|CDate} The maximum selectable date.
			@property [dateFormat='mm/dd/yyyy'] {string} Format for dates.
			@property [autoSize=false] {boolean} <code>true</code> to size the input field according to the date format.
			@property [rangeSelect=false] {boolean} Allows for selecting a date range on one date picker.
			@property [rangeSeparator=' - '] {string} Text between two dates in a range.
			@property [multiSelect=0] {number} Maximum number of selectable dates, zero for single select.
			@property [multiSeparator=','] {string} Text between multiple dates.
			@property [onDate=null] {CalendarsPickerOnDate} Callback as a date is added to the datepicker.
			@property [onShow=null] {CalendarsPickerOnShow} Callback just before a datepicker is shown.
			@property [onChangeMonthYear=null] {CalendarsPickerOnChangeMonthYear} Callback when a new month/year is selected.
			@property [onSelect=null] {CalendarsPickerOnSelect} Callback when a date is selected.
			@property [onClose=null] {CalendarsPickerOnClose} Callback when a datepicker is closed.
			@property [altField=null] {string|Element|jQuery} Alternate field to update in synch with the datepicker.
			@property [altFormat=null] {string} Date format for alternate field, defaults to <code>dateFormat</code>.
			@property [constrainInput=true] {boolean} <code>true</code> to constrain typed input to <code>dateFormat</code> allowed characters.
			@property [commandsAsDateFormat=false] {boolean} <code>true</code> to apply
						<code><a href="#formatDate">formatDate</a></code> to the command texts.
			@property [commands=this.commands] {object} Command actions that may be added to a layout by name. */
		defaultOptions: {
			calendar: $.calendars.instance(),
			pickerClass: '',
			showOnFocus: true,
			showTrigger: null,
			showAnim: 'show',
			showOptions: {},
			showSpeed: 'normal',
			popupContainer: null,
			alignment: 'bottom',
			fixedWeeks: false,
			firstDay: null,
			calculateWeek: null,
			monthsToShow: 1,
			monthsOffset: 0,
			monthsToStep: 1,
			monthsToJump: 12,
			useMouseWheel: true,
			changeMonth: true,
			yearRange: 'c-10:c+10',
			showOtherMonths: false,
			selectOtherMonths: false,
			defaultDate: null,
			selectDefaultDate: false,
			minDate: null,
			maxDate: null,
			dateFormat: null,
			autoSize: false,
			rangeSelect: false,
			rangeSeparator: ' - ',
			multiSelect: 0,
			multiSeparator: ',',
			onDate: null,
			onShow: null,
			onChangeMonthYear: null,
			onSelect: null,
			onClose: null,
			altField: null,
			altFormat: null,
			constrainInput: true,
			commandsAsDateFormat: false,
			commands: {} // this.commands
		},

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof CalendarsPicker
			@property [renderer=this.defaultRenderer] {string} The rendering templates.
			@property [prevText='&lt;Prev'] {string} Text for the previous month command.
			@property [prevStatus='Show the previous month'] {string} Status text for the previous month command.
			@property [prevJumpText='&lt;&lt;'] {string} Text for the previous year command.
			@property [prevJumpStatus='Show the previous year'] {string} Status text for the previous year command.
			@property [nextText='Next&gt;'] {string} Text for the next month command.
			@property [nextStatus='Show the next month'] {string} Status text for the next month command.
			@property [nextJumpText='&gt;&gt;'] {string} Text for the next year command.
			@property [nextJumpStatus='Show the next year'] {string} Status text for the next year command.
			@property [currentText='Current'] {string} Text for the current month command.
			@property [currentStatus='Show the current month'] {string} Status text for the current month command.
			@property [todayText='Today'] {string} Text for the today's month command.
			@property [todayStatus='Show today\'s month'] {string} Status text for the today's month command.
			@property [clearText='Clear'] {string} Text for the clear command.
			@property [clearStatus='Clear all the dates'] {string} Status text for the clear command.
			@property [closeText='Close'] {string} Text for the close command.
			@property [closeStatus='Close the datepicker'] {string} Status text for the close command.
			@property [yearStatus='Change the year'] {string} Status text for year selection.
			@property [earlierText='&#160;&#160;▲'] {string} Text for earlier years.
			@property [laterText='&#160;&#160;▼'] {string} Text for later years.
			@property [monthStatus='Change the month'] {string} Status text for month selection.
			@property [weekText='Wk'] {string} Text for week of the year column header.
			@property [weekStatus='Week of the year'] {string} Status text for week of the year column header.
			@property [dayStatus='Select DD,&#160;M&#160;d,&#160;yyyy'] {string} Status text for selectable days.
			@property [defaultStatus='Select a date'] {string} Status text shown by default.
			@property [isRTL=false] {boolean} <code>true</code> if language is right-to-left. */
		regionalOptions: { // Available regional settings, indexed by language/country code
			'': { // Default regional settings - English/US
				renderer: {}, // this.defaultRenderer
				prevText: '&lt;Prev',
				prevStatus: 'Show the previous month',
				prevJumpText: '&lt;&lt;',
				prevJumpStatus: 'Show the previous year',
				nextText: 'Next&gt;',
				nextStatus: 'Show the next month',
				nextJumpText: '&gt;&gt;',
				nextJumpStatus: 'Show the next year',
				currentText: 'Current',
				currentStatus: 'Show the current month',
				todayText: 'Today',
				todayStatus: 'Show today\'s month',
				clearText: 'Clear',
				clearStatus: 'Clear all the dates',
				closeText: 'Close',
				closeStatus: 'Close the datepicker',
				yearStatus: 'Change the year',
				earlierText: '&#160;&#160;▲',
				laterText: '&#160;&#160;▼',
				monthStatus: 'Change the month',
				weekText: 'Wk',
				weekStatus: 'Week of the year',
				dayStatus: 'Select DD, M d, yyyy',
				defaultStatus: 'Select a date',
				isRTL: false
			}
		},
		
		/** Names of getter methods - those that can't be chained.
			@memberof CalendarsPicker */
		_getters: ['getDate', 'isDisabled', 'isSelectable', 'retrieveDate'],

		_disabled: [],
		
		_popupClass: 'calendars-popup', // Marker for popup division
		_triggerClass: 'calendars-trigger', // Marker for trigger element
		_disableClass: 'calendars-disable', // Marker for disabled element
		_monthYearClass: 'calendars-month-year', // Marker for month/year inputs
		_curMonthClass: 'calendars-month-', // Marker for current month/year
		_anyYearClass: 'calendars-any-year', // Marker for year direct input
		_curDoWClass: 'calendars-dow-', // Marker for day of week

		_init: function() {
			this.defaultOptions.commands = this.commands;
			this.regionalOptions[''].renderer = this.defaultRenderer;
			this._super();
		},

		_instSettings: function(elem, options) {
			return {selectedDates: [], drawDate: null, pickingRange: false,
				inline: ($.inArray(elem[0].nodeName.toLowerCase(), ['div', 'span']) > -1),
				get: function(name) { // Get a setting value, computing if necessary
					if ($.inArray(name, ['defaultDate', 'minDate', 'maxDate']) > -1) { // Decode date settings
						return this.options.calendar.determineDate(this.options[name], null,
							this.selectedDates[0], this.get('dateFormat'), this.getConfig());
					}
					if (name === 'dateFormat') {
						return this.options.dateFormat || this.options.calendar.local.dateFormat;
					}
					return this.options[name];
				},
				curMinDate: function() {
					return (this.pickingRange ? this.selectedDates[0] : this.get('minDate'));
				},
				getConfig: function() {
					return {dayNamesShort: this.options.dayNamesShort, dayNames: this.options.dayNames,
						monthNamesShort: this.options.monthNamesShort, monthNames: this.options.monthNames,
						calculateWeek: this.options.calculateWeek, shortYearCutoff: this.options.shortYearCutoff};
				}
			};
		},

		_postAttach: function(elem, inst) {
			if (inst.inline) {
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				this._update(elem[0]);
				if ($.fn.mousewheel) {
					elem.mousewheel(this._doMouseWheel);
				}
			}
			else {
				this._attachments(elem, inst);
				elem.on('keydown.' + inst.name, this._keyDown).on('keypress.' + inst.name, this._keyPress).
					on('keyup.' + inst.name, this._keyUp);
				if (elem.attr('disabled')) {
					this.disable(elem[0]);
				}
			}
		},

		_optionsChanged: function(elem, inst, options) {
			if (options.calendar && options.calendar !== inst.options.calendar) {
				var discardDate = function(name) {
					return (typeof inst.options[name] === 'object' ? null : inst.options[name]);
				};
				options = $.extend({defaultDate: discardDate('defaultDate'),
					minDate: discardDate('minDate'), maxDate: discardDate('maxDate')}, options);
				inst.selectedDates = [];
				inst.drawDate = null;
			}
			var dates = inst.selectedDates;
			$.extend(inst.options, options);
			this.setDate(elem[0], dates, null, false, true);
			inst.pickingRange = false;
			var calendar = inst.options.calendar;
			var defaultDate = inst.get('defaultDate');
			inst.drawDate = this._checkMinMax((defaultDate ? defaultDate : inst.drawDate) ||
				defaultDate || calendar.today(), inst).newDate();
			if (!inst.inline) {
				this._attachments(elem, inst);
			}
			if (inst.inline || inst.div) {
				this._update(elem[0]);
			}
		},

		/** Attach events and trigger, if necessary.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_attachments: function(elem, inst) {
			elem.off('focus.' + inst.name);
			if (inst.options.showOnFocus) {
				elem.on('focus.' + inst.name, this.show);
			}
			if (inst.trigger) {
				inst.trigger.remove();
			}
			var trigger = inst.options.showTrigger;
			inst.trigger = (!trigger ? $([]) :
				$(trigger).clone().removeAttr('id').addClass(this._triggerClass)
					[inst.options.isRTL ? 'insertBefore' : 'insertAfter'](elem).
					click(function() {
						if (!plugin.isDisabled(elem[0])) {
							plugin[plugin.curInst === inst ? 'hide' : 'show'](elem[0]);
						}
					}));
			this._autoSize(elem, inst);
			var dates = this._extractDates(inst, elem.val());
			if (dates) {
				this.setDate(elem[0], dates, null, true);
			}
			var defaultDate = inst.get('defaultDate');
			if (inst.options.selectDefaultDate && defaultDate && inst.selectedDates.length === 0) {
				this.setDate(elem[0], (defaultDate || inst.options.calendar.today()).newDate());
			}
		},

		/** Apply the maximum length for the date format.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_autoSize: function(elem, inst) {
			if (inst.options.autoSize && !inst.inline) {
				var calendar = inst.options.calendar;
				var date = calendar.newDate(2009, 10, 20); // Ensure double digits
				var dateFormat = inst.get('dateFormat');
				if (dateFormat.match(/[DM]/)) {
					var findMax = function(names) {
						var max = 0;
						var maxI = 0;
						for (var i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.month(findMax(calendar.local[dateFormat.match(/MM/) ? // Longest month
						'monthNames' : 'monthNamesShort']) + 1);
					date.day(findMax(calendar.local[dateFormat.match(/DD/) ? // Longest day
						'dayNames' : 'dayNamesShort']) + 20 - date.dayOfWeek());
				}
				inst.elem.attr('size', date.formatDate(dateFormat).length);
			}
		},

		_preDestroy: function(elem, inst) {
			if (inst.trigger) {
				inst.trigger.remove();
			}
			elem.empty().off('.' + inst.name);
			if (inst.inline && $.fn.mousewheel) {
				elem.unmousewheel();
			}
			if (!inst.inline && inst.options.autoSize) {
				elem.removeAttr('size');
			}
		},

		/** Apply multiple event functions.
			@memberof CalendarsPicker
			@param fns {function} The functions to apply.
			@example onShow: multipleEvents(fn1, fn2, ...) */
		multipleEvents: function(fns) {
			var funcs = arguments;
			return function(args) {
				for (var i = 0; i < funcs.length; i++) {
					funcs[i].apply(this, arguments);
				}
			};
		},

		/** Enable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('enable') */
		enable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				elem.children('.' + this._disableClass).remove().end().
					find('button,select').prop('disabled', false).end().
					find('a').attr('href', 'javascript:void(0)');
			}
			else {
				elem.prop('disabled', false);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', false).end().
					filter('img.' + this._triggerClass).css({opacity: '1.0', cursor: ''});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
		},

		/** Disable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('disable') */
		disable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				var inline = elem.children(':last');
				var offset = inline.offset();
				var relOffset = {left: 0, top: 0};
				inline.parents().each(function() {
					if ($(this).css('position') === 'relative') {
						relOffset = $(this).offset();
						return false;
					}
				});
				var zIndex = elem.css('zIndex');
				zIndex = (zIndex === 'auto' ? 0 : parseInt(zIndex, 10)) + 1;
				elem.prepend('<div class="' + this._disableClass + '" style="' +
					'width: ' + inline.outerWidth() + 'px; height: ' + inline.outerHeight() +
					'px; left: ' + (offset.left - relOffset.left) + 'px; top: ' +
					(offset.top - relOffset.top) + 'px; z-index: ' + zIndex + '"></div>').
					find('button,select').prop('disabled', true).end().
					find('a').removeAttr('href');
			}
			else {
				elem.prop('disabled', true);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', true).end().
					filter('img.' + this._triggerClass).css({opacity: '0.5', cursor: 'default'});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
			this._disabled.push(elem[0]);
		},

		/** Is the first field in a jQuery collection disabled as a datepicker?
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {boolean} <code>true</code> if disabled, <code>false</code> if enabled.
			@example if ($(selector).datepick('isDisabled')) {...} */
		isDisabled: function(elem) {
			return (elem && $.inArray(elem, this._disabled) > -1);
		},

		/** Show a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Event|Element} a focus event or the control to use.
			@example $(selector).datepick('show') */
		show: function(elem) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (plugin.curInst === inst) {
				return;
			}
			if (plugin.curInst) {
				plugin.hide(plugin.curInst, true);
			}
			if (!$.isEmptyObject(inst)) {
				// Retrieve existing date(s)
				inst.lastVal = null;
				inst.selectedDates = plugin._extractDates(inst, elem.val());
				inst.pickingRange = false;
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				plugin.curInst = inst;
				// Generate content
				plugin._update(elem[0], true);
				// Adjust position before showing
				var offset = plugin._checkOffset(inst);
				inst.div.css({left: offset.left, top: offset.top});
				// And display
				var showAnim = inst.options.showAnim;
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					var data = inst.div.data(); // Update old effects data
					for (var key in data) {
						if (key.match(/^ec\.storage\./)) {
							data[key] = inst._mainDiv.css(key.replace(/ec\.storage\./, ''));
						}
					}
					inst.div.data(data).show(showAnim, inst.options.showOptions, showSpeed);
				}
				else {
					inst.div[showAnim || 'show'](showAnim ? showSpeed : 0);
				}
			}
		},

		/** Extract possible dates from a string.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param text {string} The text to extract from.
			@return {CDate[]} The extracted dates. */
		_extractDates: function(inst, datesText) {
			if (datesText === inst.lastVal) {
				return;
			}
			inst.lastVal = datesText;
			datesText = datesText.split(inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : '\x00'));
			var dates = [];
			for (var i = 0; i < datesText.length; i++) {
				try {
					var date = inst.options.calendar.parseDate(inst.get('dateFormat'), datesText[i]);
					if (date) {
						var found = false;
						for (var j = 0; j < dates.length; j++) {
							if (dates[j].compareTo(date) === 0) {
								found = true;
								break;
							}
						}
						if (!found) {
							dates.push(date);
						}
					}
				}
				catch (e) {
					// Ignore
				}
			}
			dates.splice(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1), dates.length);
			if (inst.options.rangeSelect && dates.length === 1) {
				dates[1] = dates[0];
			}
			return dates;
		},

		/** Update the datepicker display.
			@memberof CalendarsPicker
			@private
			@param elem {Event|Element} a focus event or the control to use.
			@param hidden {boolean} <code>true</code> to initially hide the datepicker. */
		_update: function(elem, hidden) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (inst.inline || plugin.curInst === inst) {
					if ($.isFunction(inst.options.onChangeMonthYear) && (!inst.prevDate ||
							inst.prevDate.year() !== inst.drawDate.year() ||
							inst.prevDate.month() !== inst.drawDate.month())) {
						inst.options.onChangeMonthYear.apply(elem[0],
							[inst.drawDate.year(), inst.drawDate.month()]);
					}
				}
				if (inst.inline) {
					var index = $('a, :input', elem).index($(':focus', elem));
					elem.html(this._generateContent(elem[0], inst));
					var focus = elem.find('a, :input');
					focus.eq(Math.max(Math.min(index, focus.length - 1), 0)).focus();
				}
				else if (plugin.curInst === inst) {
					if (!inst.div) {
						inst.div = $('<div></div>').addClass(this._popupClass).
							css({display: (hidden ? 'none' : 'static'), position: 'absolute',
								left: elem.offset().left, top: elem.offset().top + elem.outerHeight()}).
							appendTo($(inst.options.popupContainer || 'body'));
						if ($.fn.mousewheel) {
							inst.div.mousewheel(this._doMouseWheel);
						}
					}
					inst.div.html(this._generateContent(elem[0], inst));
					elem.focus();
				}
			}
		},

		/** Update the input field and any alternate field with the current dates.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to use.
			@param keyUp {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal). */
		_updateInput: function(elem, keyUp) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var value = '';
				var altValue = '';
				var sep = (inst.options.multiSelect ? inst.options.multiSeparator :
					inst.options.rangeSeparator);
				var calendar = inst.options.calendar;
				var dateFormat = inst.get('dateFormat');
				var altFormat = inst.options.altFormat || dateFormat;
				for (var i = 0; i < inst.selectedDates.length; i++) {
					value += (keyUp ? '' : (i > 0 ? sep : '') +
						calendar.formatDate(dateFormat, inst.selectedDates[i]));
					altValue += (i > 0 ? sep : '') +
						calendar.formatDate(altFormat, inst.selectedDates[i]);
				}
				if (!inst.inline && !keyUp) {
					$(elem).val(value);
				}
				$(inst.options.altField).val(altValue);
				if ($.isFunction(inst.options.onSelect) && !keyUp && !inst.inSelect) {
					inst.inSelect = true; // Prevent endless loops
					inst.options.onSelect.apply(elem, [inst.selectedDates]);
					inst.inSelect = false;
				}
			}
		},

		/** Retrieve the size of left and top borders for an element.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The element of interest.
			@return {number[]} The left and top borders. */
		_getBorders: function(elem) {
			var convert = function(value) {
				return {thin: 1, medium: 3, thick: 5}[value] || value;
			};
			return [parseFloat(convert(elem.css('border-left-width'))),
				parseFloat(convert(elem.css('border-top-width')))];
		},

		/** Check positioning to remain on the screen.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {object} The updated offset for the datepicker. */
		_checkOffset: function(inst) {
			var base = (inst.elem.is(':hidden') && inst.trigger ? inst.trigger : inst.elem);
			var offset = base.offset();
			var browserWidth = $(window).width();
			var browserHeight = $(window).height();
			if (browserWidth === 0) {
				return offset;
			}
			var isFixed = false;
			$(inst.elem).parents().each(function() {
				isFixed |= $(this).css('position') === 'fixed';
				return !isFixed;
			});
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			var above = offset.top - (isFixed ? scrollY : 0) - inst.div.outerHeight();
			var below = offset.top - (isFixed ? scrollY : 0) + base.outerHeight();
			var alignL = offset.left - (isFixed ? scrollX : 0);
			var alignR = offset.left - (isFixed ? scrollX : 0) + base.outerWidth() - inst.div.outerWidth();
			var tooWide = (offset.left - scrollX + inst.div.outerWidth()) > browserWidth;
			var tooHigh = (offset.top - scrollY + inst.elem.outerHeight() +
				inst.div.outerHeight()) > browserHeight;
			inst.div.css('position', isFixed ? 'fixed' : 'absolute');
			var alignment = inst.options.alignment;
			if (alignment === 'topLeft') {
				offset = {left: alignL, top: above};
			}
			else if (alignment === 'topRight') {
				offset = {left: alignR, top: above};
			}
			else if (alignment === 'bottomLeft') {
				offset = {left: alignL, top: below};
			}
			else if (alignment === 'bottomRight') {
				offset = {left: alignR, top: below};
			}
			else if (alignment === 'top') {
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL), top: above};
			}
			else { // bottom
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL),
					top: (tooHigh ? above : below)};
			}
			offset.left = Math.max((isFixed ? 0 : scrollX), offset.left);
			offset.top = Math.max((isFixed ? 0 : scrollY), offset.top);
			return offset;
		},

		/** Close date picker if clicked elsewhere.
			@memberof CalendarsPicker
			@private
			@param event {MouseEvent} The mouse click to check. */
		_checkExternalClick: function(event) {
			if (!plugin.curInst) {
				return;
			}
			var elem = $(event.target);
			if (elem.closest('.' + plugin._popupClass + ',.' + plugin._triggerClass).length === 0 &&
					!elem.hasClass(plugin._getMarker())) {
				plugin.hide(plugin.curInst);
			}
		},

		/** Hide a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element|object} The control to use or the current instance settings.
			@param immediate {boolean} <code>true</code> to close immediately without animation (internal).
			@example $(selector).datepick('hide') */
		hide: function(elem, immediate) {
			if (!elem) {
				return;
			}
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				inst = elem;
			}
			if (inst && inst === plugin.curInst) {
				var showAnim = (immediate ? '' : inst.options.showAnim);
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				var postProcess = function() {
					if (!inst.div) {
						return;
					}
					inst.div.remove();
					inst.div = null;
					plugin.curInst = null;
					if ($.isFunction(inst.options.onClose)) {
						inst.options.onClose.apply(elem, [inst.selectedDates]);
					}
				};
				inst.div.stop();
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					inst.div.hide(showAnim, inst.options.showOptions, showSpeed, postProcess);
				}
				else {
					var hideAnim = (showAnim === 'slideDown' ? 'slideUp' :
						(showAnim === 'fadeIn' ? 'fadeOut' : 'hide'));
					inst.div[hideAnim]((showAnim ? showSpeed : ''), postProcess);
				}
				if (!showAnim) {
					postProcess();
				}
			}
		},

		/** Handle keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if not handled, <code>false</code> if handled. */
		_keyDown: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			var handled = false;
			if (inst.inline || inst.div) {
				if (event.keyCode === 9) { // Tab - close
					plugin.hide(elem);
				}
				else if (event.keyCode === 13) { // Enter - select
					plugin.selectDate(elem,
						$('a.' + inst.options.renderer.highlightedClass, inst.div)[0]);
					handled = true;
				}
				else { // Command keystrokes
					var commands = inst.options.commands;
					for (var name in commands) {
						var command = commands[name];
						if (command.keystroke.keyCode === event.keyCode &&
								!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
								!!command.keystroke.altKey === event.altKey &&
								!!command.keystroke.shiftKey === event.shiftKey) {
							plugin.performAction(elem, name);
							handled = true;
							break;
						}
					}
				}
			}
			else { // Show on 'current' keystroke
				var command = inst.options.commands.current;
				if (command.keystroke.keyCode === event.keyCode &&
						!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
						!!command.keystroke.altKey === event.altKey &&
						!!command.keystroke.shiftKey === event.shiftKey) {
					plugin.show(elem);
					handled = true;
				}
			}
			inst.ctrlKey = ((event.keyCode < 48 && event.keyCode !== 32) || event.ctrlKey || event.metaKey);
			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
			return !handled;
		},

		/** Filter keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyPress: function(event) {
			var inst = plugin._getInst((event.data && event.data.elem) || event.target);
			if (!$.isEmptyObject(inst) && inst.options.constrainInput) {
				var ch = String.fromCharCode(event.keyCode || event.charCode);
				var allowedChars = plugin._allowedChars(inst);
				return (event.metaKey || inst.ctrlKey || ch < ' ' ||
					!allowedChars || allowedChars.indexOf(ch) > -1);
			}
			return true;
		},

		/** Determine the set of characters allowed by the date format.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {string} The set of allowed characters, or <code>null</code> if anything allowed. */
		_allowedChars: function(inst) {
			var allowedChars = (inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : ''));
			var literal = false;
			var hasNum = false;
			var dateFormat = inst.get('dateFormat');
			for (var i = 0; i < dateFormat.length; i++) {
				var ch = dateFormat.charAt(i);
				if (literal) {
					if (ch === "'" && dateFormat.charAt(i + 1) !== "'") {
						literal = false;
					}
					else {
						allowedChars += ch;
					}
				}
				else {
					switch (ch) {
						case 'd': case 'm': case 'o': case 'w':
							allowedChars += (hasNum ? '' : '0123456789'); hasNum = true; break;
						case 'y': case '@': case '!':
							allowedChars += (hasNum ? '' : '0123456789') + '-'; hasNum = true; break;
						case 'J':
							allowedChars += (hasNum ? '' : '0123456789') + '-.'; hasNum = true; break;
						case 'D': case 'M': case 'Y':
							return null; // Accept anything
						case "'":
							if (dateFormat.charAt(i + 1) === "'") {
								allowedChars += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							allowedChars += ch;
					}
				}
			}
			return allowedChars;
		},

		/** Synchronise datepicker with the field.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyUp: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst) && !inst.ctrlKey && inst.lastVal !== inst.elem.val()) {
				try {
					var dates = plugin._extractDates(inst, inst.elem.val());
					if (dates.length > 0) {
						plugin.setDate(elem, dates, null, true);
					}
				}
				catch (event) {
					// Ignore
				}
			}
			return true;
		},

		/** Increment/decrement month/year on mouse wheel activity.
			@memberof CalendarsPicker
			@private
			@param event {event} The mouse wheel event.
			@param delta {number} The amount of change. */
		_doMouseWheel: function(event, delta) {
			var elem = (plugin.curInst && plugin.curInst.elem[0]) ||
				$(event.target).closest('.' + plugin._getMarker())[0];
			if (plugin.isDisabled(elem)) {
				return;
			}
			var inst = plugin._getInst(elem);
			if (inst.options.useMouseWheel) {
				delta = (delta < 0 ? -1 : +1);
				plugin.changeMonth(elem, -inst.options[event.ctrlKey ? 'monthsToJump' : 'monthsToStep'] * delta);
			}
			event.preventDefault();
		},

		/** Clear an input and close a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to use.
			@example $(selector).datepick('clear') */
		clear: function(elem) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				inst.selectedDates = [];
				this.hide(elem);
				var defaultDate = inst.get('defaultDate');
				if (inst.options.selectDefaultDate && defaultDate) {
					this.setDate(elem, (defaultDate || inst.options.calendar.today()).newDate());
				}
				else {
					this._updateInput(elem);
				}
			}
		},

		/** Retrieve the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {CDate[]} The selected date(s).
			@example var dates = $(selector).datepick('getDate') */
		getDate: function(elem) {
			var inst = this._getInst(elem);
			return (!$.isEmptyObject(inst) ? inst.selectedDates : []);
		},

		/** Set the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} the control to examine.
			@param dates {CDate|number|string|array} the selected date(s).
			@param [endDate] {CDate|number|string} the ending date for a range.
			@param [keyUp] {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal).
			@param [setOpt] {boolean} <code>true</code> if coming from option processing (internal).
			@example $(selector).datepick('setDate', new Date(2014, 12-1, 25))
 $(selector).datepick('setDate', '12/25/2014', '01/01/2015')
 $(selector).datepick('setDate', [date1, date2, date3]) */
		setDate: function(elem, dates, endDate, keyUp, setOpt) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (!$.isArray(dates)) {
					dates = [dates];
					if (endDate) {
						dates.push(endDate);
					}
				}
				var minDate = inst.get('minDate');
				var maxDate = inst.get('maxDate');
				var curDate = inst.selectedDates[0];
				inst.selectedDates = [];
				for (var i = 0; i < dates.length; i++) {
					var date = inst.options.calendar.determineDate(
						dates[i], null, curDate, inst.get('dateFormat'), inst.getConfig());
					if (date) {
						if ((!minDate || date.compareTo(minDate) !== -1) &&
								(!maxDate || date.compareTo(maxDate) !== +1)) {
							var found = false;
							for (var j = 0; j < inst.selectedDates.length; j++) {
								if (inst.selectedDates[j].compareTo(date) === 0) {
									found = true;
									break;
								}
							}
							if (!found) {
								inst.selectedDates.push(date);
							}
						}
					}
				}
				inst.selectedDates.splice(inst.options.multiSelect ||
					(inst.options.rangeSelect ? 2 : 1), inst.selectedDates.length);
				if (inst.options.rangeSelect) {
					switch (inst.selectedDates.length) {
						case 1: inst.selectedDates[1] = inst.selectedDates[0]; break;
						case 2: inst.selectedDates[1] =
							(inst.selectedDates[0].compareTo(inst.selectedDates[1]) === +1 ?
							inst.selectedDates[0] : inst.selectedDates[1]); break;
					}
					inst.pickingRange = false;
				}
				inst.prevDate = (inst.drawDate ? inst.drawDate.newDate() : null);
				inst.drawDate = this._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				if (!setOpt) {
					this._update(elem);
					this._updateInput(elem, keyUp);
				}
			}
		},

		/** Determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to check.
			@param date {CDate|string|number} The date to check.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not.
			@example var selectable = $(selector).datepick('isSelectable', date) */
		isSelectable: function(elem, date) {
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				return false;
			}
			date = inst.options.calendar.determineDate(date,
				inst.selectedDates[0] || inst.options.calendar.today(), null,
				inst.options.dateFormat, inst.getConfig());
			return this._isSelectable(elem, date, inst.options.onDate,
				inst.get('minDate'), inst.get('maxDate'));
		},

		/** Internally determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} the control to check.
			@param date {CDate} The date to check.
			@param onDate {function|boolean} Any <code>onDate</code> callback or <code>callback.selectable</code>.
			@param minDate {CDate} The minimum allowed date.
			@param maxDate {CDate} The maximum allowed date.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not. */
		_isSelectable: function(elem, date, onDate, minDate, maxDate) {
			var dateInfo = (typeof onDate === 'boolean' ? {selectable: onDate} :
				(!$.isFunction(onDate) ? {} : onDate.apply(elem, [date, true])));
			return (dateInfo.selectable !== false) &&
				(!minDate || date.toJD() >= minDate.toJD()) && (!maxDate || date.toJD() <= maxDate.toJD());
		},

		/** Perform a named action for a datepicker.
			@memberof CalendarsPicker
			@param elem {element} The control to affect.
			@param action {string} The name of the action. */
		performAction: function(elem, action) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var commands = inst.options.commands;
				if (commands[action] && commands[action].enabled.apply(elem, [inst])) {
					commands[action].action.apply(elem, [inst]);
				}
			}
		},

		/** Set the currently shown month, defaulting to today's.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param [year] {number} The year to show.
			@param [month] {number} The month to show (1-12).
			@param [day] {number} The day to show.
			@example $(selector).datepick('showMonth', 2014, 12, 25) */
		showMonth: function(elem, year, month, day) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && (day != null ||
					(inst.drawDate.year() !== year || inst.drawDate.month() !== month))) {
				inst.prevDate = inst.drawDate.newDate();
				var calendar = inst.options.calendar;
				var show = this._checkMinMax((year != null ?
					calendar.newDate(year, month, 1) : calendar.today()), inst);
				inst.drawDate.date(show.year(), show.month(), 
					(day != null ? day : Math.min(inst.drawDate.day(),
					calendar.daysInMonth(show.year(), show.month()))));
				this._update(elem);
			}
		},

		/** Adjust the currently shown month.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of months to change by.
			@example $(selector).datepick('changeMonth', 2)*/
		changeMonth: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'm');
				this.showMonth(elem, date.year(), date.month());
			}
		},

		/** Adjust the currently shown day.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of days to change by.
			@example $(selector).datepick('changeDay', 7)*/
		changeDay: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'd');
				this.showMonth(elem, date.year(), date.month(), date.day());
			}
		},

		/** Restrict a date to the minimum/maximum specified.
			@memberof CalendarsPicker
			@private
			@param date {CDate} The date to check.
			@param inst {object} The current instance settings. */
		_checkMinMax: function(date, inst) {
			var minDate = inst.get('minDate');
			var maxDate = inst.get('maxDate');
			date = (minDate && date.compareTo(minDate) === -1 ? minDate.newDate() : date);
			date = (maxDate && date.compareTo(maxDate) === +1 ? maxDate.newDate() : date);
			return date;
		},

		/** Retrieve the date associated with an entry in the datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@return {CDate} The corresponding date, or <code>null</code>.			
			@example var date = $(selector).datepick('retrieveDate', $('div.datepick-popup a:contains(10)')[0]) */
		retrieveDate: function(elem, target) {
			var inst = this._getInst(elem);
			return ($.isEmptyObject(inst) ? null : inst.options.calendar.fromJD(
				parseFloat(target.className.replace(/^.*jd(\d+\.5).*$/, '$1'))));
		},

		/** Select a date for this datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@example $(selector).datepick('selectDate', $('div.datepick-popup a:contains(10)')[0]) */
		selectDate: function(elem, target) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var date = this.retrieveDate(elem, target);
				if (inst.options.multiSelect) {
					var found = false;
					for (var i = 0; i < inst.selectedDates.length; i++) {
						if (date.compareTo(inst.selectedDates[i]) === 0) {
							inst.selectedDates.splice(i, 1);
							found = true;
							break;
						}
					}
					if (!found && inst.selectedDates.length < inst.options.multiSelect) {
						inst.selectedDates.push(date);
					}
				}
				else if (inst.options.rangeSelect) {
					if (inst.pickingRange) {
						inst.selectedDates[1] = date;
					}
					else {
						inst.selectedDates = [date, date];
					}
					inst.pickingRange = !inst.pickingRange;
				}
				else {
					inst.selectedDates = [date];
				}
				inst.prevDate = inst.drawDate = date.newDate();
				this._updateInput(elem);
				if (inst.inline || inst.pickingRange || inst.selectedDates.length <
						(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1))) {
					this._update(elem);
				}
				else {
					this.hide(elem);
				}
			}
		},

		/** Generate the datepicker content for this control.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@return {jQuery} The datepicker content */
		_generateContent: function(elem, inst) {
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			inst.drawDate = this._checkMinMax(
				inst.drawDate || inst.get('defaultDate') || inst.options.calendar.today(), inst);
			var drawDate = inst.drawDate.newDate().add(-inst.options.monthsOffset, 'm');
			// Generate months
			var monthRows = '';
			for (var row = 0; row < monthsToShow[0]; row++) {
				var months = '';
				for (var col = 0; col < monthsToShow[1]; col++) {
					months += this._generateMonth(elem, inst, drawDate.year(),
						drawDate.month(), inst.options.calendar, inst.options.renderer, (row === 0 && col === 0));
					drawDate.add(1, 'm');
				}
				monthRows += this._prepare(inst.options.renderer.monthRow, inst).replace(/\{months\}/, months);
			}
			var picker = this._prepare(inst.options.renderer.picker, inst).replace(/\{months\}/, monthRows).
				replace(/\{weekHeader\}/g, this._generateDayHeaders(inst, inst.options.calendar, inst.options.renderer));
			// Add commands
			var addCommand = function(type, open, close, name, classes) {
				if (picker.indexOf('{' + type + ':' + name + '}') === -1) {
					return;
				}
				var command = inst.options.commands[name];
				var date = (inst.options.commandsAsDateFormat ? command.date.apply(elem, [inst]) : null);
				picker = picker.replace(new RegExp('\\{' + type + ':' + name + '\\}', 'g'),
					'<' + open + (command.status ? ' title="' + inst.options[command.status] + '"' : '') +
					' class="' + inst.options.renderer.commandClass + ' ' +
					inst.options.renderer.commandClass + '-' + name + ' ' + classes +
					(command.enabled(inst) ? '' : ' ' + inst.options.renderer.disabledClass) + '">' +
					(date ? date.formatDate(inst.options[command.text]) :
					inst.options[command.text]) + '</' + close + '>');
			};
			for (var name in inst.options.commands) {
				addCommand('button', 'button type="button"', 'button', name,
					inst.options.renderer.commandButtonClass);
				addCommand('link', 'a href="javascript:void(0)"', 'a', name,
					inst.options.renderer.commandLinkClass);
			}
			picker = $(picker);
			if (monthsToShow[1] > 1) {
				var count = 0;
				$(inst.options.renderer.monthSelector, picker).each(function() {
					var nth = ++count % monthsToShow[1];
					$(this).addClass(nth === 1 ? 'first' : (nth === 0 ? 'last' : ''));
				});
			}
			// Add datepicker behaviour
			var self = this;
			function removeHighlight() {
				(inst.inline ? $(this).closest('.' + self._getMarker()) : inst.div).
					find(inst.options.renderer.daySelector + ' a').
					removeClass(inst.options.renderer.highlightedClass);
			}
			picker.find(inst.options.renderer.daySelector + ' a').hover(
					function() {
						removeHighlight.apply(this);
						$(this).addClass(inst.options.renderer.highlightedClass);
					},
					removeHighlight).
				click(function() {
					self.selectDate(elem, this);
				}).end().
				find('select.' + this._monthYearClass + ':not(.' + this._anyYearClass + ')').
				change(function() {
					var monthYear = $(this).val().split('/');
					self.showMonth(elem, parseInt(monthYear[1], 10), parseInt(monthYear[0], 10));
				}).end().
				find('select.' + this._anyYearClass).click(function() {
					$(this).css('visibility', 'hidden').
						next('input').css({left: this.offsetLeft, top: this.offsetTop,
						width: this.offsetWidth, height: this.offsetHeight}).show().focus();
				}).end().
				find('input.' + self._monthYearClass).change(function() {
					try {
						var year = parseInt($(this).val(), 10);
						year = (isNaN(year) ? inst.drawDate.year() : year);
						self.showMonth(elem, year, inst.drawDate.month(), inst.drawDate.day());
					}
					catch (e) {
						alert(e);
					}
				}).keydown(function(event) {
					if (event.keyCode === 13) { // Enter
						$(event.elem).change();
					}
					else if (event.keyCode === 27) { // Escape
						$(event.elem).hide().prev('select').css('visibility', 'visible');
						inst.elem.focus();
					}
				});
			// Add keyboard handling
			var data = {elem: inst.elem[0]};
			picker.keydown(data, this._keyDown).keypress(data, this._keyPress).keyup(data, this._keyUp);
			// Add command behaviour
			picker.find('.' + inst.options.renderer.commandClass).click(function() {
					if (!$(this).hasClass(inst.options.renderer.disabledClass)) {
						var action = this.className.replace(
							new RegExp('^.*' + inst.options.renderer.commandClass + '-([^ ]+).*$'), '$1');
						plugin.performAction(elem, action);
					}
				});
			// Add classes
			if (inst.options.isRTL) {
				picker.addClass(inst.options.renderer.rtlClass);
			}
			if (monthsToShow[0] * monthsToShow[1] > 1) {
				picker.addClass(inst.options.renderer.multiClass);
			}
			if (inst.options.pickerClass) {
				picker.addClass(inst.options.pickerClass);
			}
			// Resize
			$('body').append(picker);
			var width = 0;
			picker.find(inst.options.renderer.monthSelector).each(function() {
				width += $(this).outerWidth();
			});
			picker.width(width / monthsToShow[0]);
			// Pre-show customisation
			if ($.isFunction(inst.options.onShow)) {
				inst.options.onShow.apply(elem, [picker, inst.options.calendar, inst]);
			}
			return picker;
		},

		/** Generate the content for a single month.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@param first {boolean} <code>true</code> if first of multiple months.
			@return {string} The month content. */
		_generateMonth: function(elem, inst, year, month, calendar, renderer, first) {
			var daysInMonth = calendar.daysInMonth(year, month);
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			var fixedWeeks = inst.options.fixedWeeks || (monthsToShow[0] * monthsToShow[1] > 1);
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var leadDays = (calendar.dayOfWeek(year, month, calendar.minDay) -
				firstDay + calendar.daysInWeek()) % calendar.daysInWeek();
			var numWeeks = (fixedWeeks ? 6 : Math.ceil((leadDays + daysInMonth) / calendar.daysInWeek()));
			var selectOtherMonths = inst.options.selectOtherMonths && inst.options.showOtherMonths;
			var minDate = (inst.pickingRange ? inst.selectedDates[0] : inst.get('minDate'));
			var maxDate = inst.get('maxDate');
			var showWeeks = renderer.week.indexOf('{weekOfYear}') > -1;
			var today = calendar.today();
			var drawDate = calendar.newDate(year, month, calendar.minDay);
			drawDate.add(-leadDays - (fixedWeeks &&
				(drawDate.dayOfWeek() === firstDay || drawDate.daysInMonth() < calendar.daysInWeek())?
				calendar.daysInWeek() : 0), 'd');
			var jd = drawDate.toJD();
			// Generate weeks
			var weeks = '';
			for (var week = 0; week < numWeeks; week++) {
				var weekOfYear = (!showWeeks ? '' : '<span class="jd' + jd + '">' +
					($.isFunction(inst.options.calculateWeek) ?
					inst.options.calculateWeek(drawDate) : drawDate.weekOfYear()) + '</span>');
				var days = '';
				for (var day = 0; day < calendar.daysInWeek(); day++) {
					var selected = false;
					if (inst.options.rangeSelect && inst.selectedDates.length > 0) {
						selected = (drawDate.compareTo(inst.selectedDates[0]) !== -1 &&
							drawDate.compareTo(inst.selectedDates[1]) !== +1)
					}
					else {
						for (var i = 0; i < inst.selectedDates.length; i++) {
							if (inst.selectedDates[i].compareTo(drawDate) === 0) {
								selected = true;
								break;
							}
						}
					}
					var dateInfo = (!$.isFunction(inst.options.onDate) ? {} :
						inst.options.onDate.apply(elem, [drawDate, drawDate.month() === month]));
					var selectable = (selectOtherMonths || drawDate.month() === month) &&
						this._isSelectable(elem, drawDate, dateInfo.selectable, minDate, maxDate);
					days += this._prepare(renderer.day, inst).replace(/\{day\}/g,
						(selectable ? '<a href="javascript:void(0)"' : '<span') +
						' class="jd' + jd + ' ' + (dateInfo.dateClass || '') +
						(selected && (selectOtherMonths || drawDate.month() === month) ?
						' ' + renderer.selectedClass : '') +
						(selectable ? ' ' + renderer.defaultClass : '') +
						(drawDate.weekDay() ? '' : ' ' + renderer.weekendClass) +
						(drawDate.month() === month ? '' : ' ' + renderer.otherMonthClass) +
						(drawDate.compareTo(today) === 0 && drawDate.month() === month ?
						' ' + renderer.todayClass : '') +
						(drawDate.compareTo(inst.drawDate) === 0 && drawDate.month() === month ?
						' ' + renderer.highlightedClass : '') + '"' +
						(dateInfo.title || (inst.options.dayStatus && selectable) ? ' title="' +
						(dateInfo.title || drawDate.formatDate(inst.options.dayStatus)) + '"' : '') + '>' +
						(inst.options.showOtherMonths || drawDate.month() === month ?
						dateInfo.content || drawDate.day() : '&#160;') +
						(selectable ? '</a>' : '</span>'));
					drawDate.add(1, 'd');
					jd++;
				}
				weeks += this._prepare(renderer.week, inst).replace(/\{days\}/g, days).
					replace(/\{weekOfYear\}/g, weekOfYear);
			}
			var monthHeader = this._prepare(renderer.month, inst).match(/\{monthHeader(:[^\}]+)?\}/);
			monthHeader = (monthHeader[0].length <= 13 ? 'MM yyyy' :
				monthHeader[0].substring(13, monthHeader[0].length - 1));
			monthHeader = (first ? this._generateMonthSelection(
				inst, year, month, minDate, maxDate, monthHeader, calendar, renderer) :
				calendar.formatDate(monthHeader, calendar.newDate(year, month, calendar.minDay)));
			var weekHeader = this._prepare(renderer.weekHeader, inst).
				replace(/\{days\}/g, this._generateDayHeaders(inst, calendar, renderer));
			return this._prepare(renderer.month, inst).replace(/\{monthHeader(:[^\}]+)?\}/g, monthHeader).
				replace(/\{weekHeader\}/g, weekHeader).replace(/\{weeks\}/g, weeks);
		},

		/** Generate the HTML for the day headers.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@return {string} A week's worth of day headers. */
		_generateDayHeaders: function(inst, calendar, renderer) {
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var header = '';
			for (var day = 0; day < calendar.daysInWeek(); day++) {
				var dow = (day + firstDay) % calendar.daysInWeek();
				header += this._prepare(renderer.dayHeader, inst).replace(/\{day\}/g,
					'<span class="' + this._curDoWClass + dow + '" title="' +
					calendar.local.dayNames[dow] + '">' + calendar.local.dayNamesMin[dow] + '</span>');
			}
			return header;
		},

		/** Generate selection controls for month.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param minDate {CDate} The minimum date allowed.
			@param maxDate {CDate} The maximum date allowed.
			@param monthHeader {string} The month/year format.
			@param calendar {BaseCalendar} The current calendar.
			@return {string} The month selection content. */
		_generateMonthSelection: function(inst, year, month, minDate, maxDate, monthHeader, calendar) {
			if (!inst.options.changeMonth) {
				return calendar.formatDate(monthHeader, calendar.newDate(year, month, 1));
			}
			// Months
			var monthNames = calendar.local[
				'monthNames' + (monthHeader.match(/mm/i) ? '' : 'Short')];
			var html = monthHeader.replace(/m+/i, '\\x2E').replace(/y+/i, '\\x2F');
			var selector = '<select class="' + this._monthYearClass +
				'" title="' + inst.options.monthStatus + '">';
			var maxMonth = calendar.monthsInYear(year) + calendar.minMonth;
			for (var m = calendar.minMonth; m < maxMonth; m++) {
				if ((!minDate || calendar.newDate(year, m,
						calendar.daysInMonth(year, m) - 1 + calendar.minDay).
						compareTo(minDate) !== -1) &&
						(!maxDate || calendar.newDate(year, m, calendar.minDay).
						compareTo(maxDate) !== +1)) {
					selector += '<option value="' + m + '/' + year + '"' +
						(month === m ? ' selected="selected"' : '') + '>' +
						monthNames[m - calendar.minMonth] + '</option>';
				}
			}
			selector += '</select>';
			html = html.replace(/\\x2E/, selector);
			// Years
			var yearRange = inst.options.yearRange;
			if (yearRange === 'any') {
				selector = '<select class="' + this._monthYearClass + ' ' + this._anyYearClass +
					'" title="' + inst.options.yearStatus + '">' +
					'<option>' + year + '</option></select>' +
					'<input class="' + this._monthYearClass + ' ' + this._curMonthClass +
					month + '" value="' + year + '">';
			}
			else {
				yearRange = yearRange.split(':');
				var todayYear = calendar.today().year();
				var start = (yearRange[0].match('c[+-].*') ? year + parseInt(yearRange[0].substring(1), 10) :
					((yearRange[0].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[0], 10)));
				var end = (yearRange[1].match('c[+-].*') ? year + parseInt(yearRange[1].substring(1), 10) :
					((yearRange[1].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[1], 10)));
				selector = '<select class="' + this._monthYearClass +
					'" title="' + inst.options.yearStatus + '">';
				start = calendar.newDate(start + 1, calendar.firstMonth, calendar.minDay).add(-1, 'd');
				end = calendar.newDate(end, calendar.firstMonth, calendar.minDay);
				var addYear = function(y, yDisplay) {
					if (y !== 0 || calendar.hasYearZero) {
						selector += '<option value="' +
							Math.min(month, calendar.monthsInYear(y) - 1 + calendar.minMonth) +
							'/' + y + '"' + (year === y ? ' selected="selected"' : '') + '>' +
							(yDisplay || y) + '</option>';
					}
				};
				if (start.toJD() < end.toJD()) {
					start = (minDate && minDate.compareTo(start) === +1 ? minDate : start).year();
					end = (maxDate && maxDate.compareTo(end) === -1 ? maxDate : end).year();
					var earlierLater = Math.floor((end - start) / 2);
					if (!minDate || minDate.year() < start) {
						addYear(start - earlierLater, inst.options.earlierText);
					}
					for (var y = start; y <= end; y++) {
						addYear(y);
					}
					if (!maxDate || maxDate.year() > end) {
						addYear(end + earlierLater, inst.options.laterText);
					}
				}
				else {
					start = (maxDate && maxDate.compareTo(start) === -1 ? maxDate : start).year();
					end = (minDate && minDate.compareTo(end) === +1 ? minDate : end).year();
					var earlierLater = Math.floor((start - end) / 2);
					if (!maxDate || maxDate.year() > start) {
						addYear(start + earlierLater, inst.options.earlierText);
					}
					for (var y = start; y >= end; y--) {
						addYear(y);
					}
					if (!minDate || minDate.year() < end) {
						addYear(end - earlierLater, inst.options.laterText);
					}
				}
				selector += '</select>';
			}
			html = html.replace(/\\x2F/, selector);
			return html;
		},

		/** Prepare a render template for use.
			Exclude popup/inline sections that are not applicable.
			Localise text of the form: {l10n:name}.
			@memberof CalendarsPicker
			@private
			@param text {string} The text to localise.
			@param inst {object} The current instance settings.
			@return {string} The localised text. */
		_prepare: function(text, inst) {
			var replaceSection = function(type, retain) {
				while (true) {
					var start = text.indexOf('{' + type + ':start}');
					if (start === -1) {
						return;
					}
					var end = text.substring(start).indexOf('{' + type + ':end}');
					if (end > -1) {
						text = text.substring(0, start) +
							(retain ? text.substr(start + type.length + 8, end - type.length - 8) : '') +
							text.substring(start + end + type.length + 6);
					}
				}
			};
			replaceSection('inline', inst.inline);
			replaceSection('popup', !inst.inline);
			var pattern = /\{l10n:([^\}]+)\}/;
			var matches = null;
			while (matches = pattern.exec(text)) {
				text = text.replace(matches[0], inst.options[matches[1]]);
			}
			return text;
		}
	});

	var plugin = $.calendarsPicker; // Singleton instance

	$(function() {
		$(document).on('mousedown.' + pluginName, plugin._checkExternalClick).
			on('resize.' + pluginName, function() { plugin.hide(plugin.curInst); });
	});

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxBQUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogaHR0cDovL2tlaXRoLXdvb2QubmFtZS9jYWxlbmRhcnMuaHRtbFxuICAgQ2FsZW5kYXJzIGRhdGUgcGlja2VyIGZvciBqUXVlcnkgdjIuMC4xLlxuICAgV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSBBdWd1c3QgMjAwOS5cbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwOi8va2VpdGgtd29vZC5uYW1lL2xpY2VuY2UuaHRtbCkgbGljZW5zZS4gXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cblxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxuXG5cdHZhciBwbHVnaW5OYW1lID0gJ2NhbGVuZGFyc1BpY2tlcic7XG5cblxuXHQvKiogQ3JlYXRlIHRoZSBjYWxlbmRhcnMgZGF0ZXBpY2tlciBwbHVnaW4uXG5cdFx0PHA+U2V0cyBhbiBpbnB1dCBmaWVsZCB0byBwb3B1cCBhIGNhbGVuZGFyIGZvciBkYXRlIGVudHJ5LFxuXHRcdFx0b3IgYSA8Y29kZT5kaXY8L2NvZGU+IG9yIDxjb2RlPnNwYW48L2NvZGU+IHRvIHNob3cgYW4gaW5saW5lIGNhbGVuZGFyLjwvcD5cblx0XHQ8cD5FeHBlY3RzIEhUTUwgbGlrZTo8L3A+XG5cdFx0PHByZT4mbHQ7aW5wdXQgdHlwZT1cInRleHRcIj4gb3IgJmx0O2Rpdj4mbHQ7L2Rpdj48L3ByZT5cblx0XHQ8cD5Qcm92aWRlIGlubGluZSBjb25maWd1cmF0aW9uIGxpa2U6PC9wPlxuXHRcdDxwcmU+Jmx0O2lucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1jYWxlbmRhcnNQaWNrZXI9XCJuYW1lOiAndmFsdWUnXCIvPjwvcHJlPlxuXHQgXHRAY2xhc3MgQ2FsZW5kYXJzUGlja2VyXG5cdFx0QGF1Z21lbnRzIEpRUGx1Z2luXG5cdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuY2FsZW5kYXJzUGlja2VyKClcbiAkKHNlbGVjdG9yKS5jYWxlbmRhcnNQaWNrZXIoe21pbkRhdGU6IDAsIG1heERhdGU6ICcrMW0gKzF3J30pICovXG5cdCQuSlFQbHVnaW4uY3JlYXRlUGx1Z2luKHtcblx0XG5cdFx0LyoqIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyICovXG5cdFx0bmFtZTogcGx1Z2luTmFtZSxcblx0XHRcblx0XHQvKiogRGVmYXVsdCB0ZW1wbGF0ZSBmb3IgZ2VuZXJhdGluZyBhIGRhdGVwaWNrZXIuXG5cdFx0XHRJbnNlcnQgYW55d2hlcmU6XG5cdFx0XHQ8dWw+XG5cdFx0XHQ8bGk+J3tsMTBuOm5hbWV9JyB0byBpbnNlcnQgbG9jYWxpc2VkIHZhbHVlIGZvciBuYW1lLDwvbGk+XG5cdFx0XHQ8bGk+J3tsaW5rOm5hbWV9JyB0byBpbnNlcnQgYSBsaW5rIHRyaWdnZXIgZm9yIGNvbW1hbmQgbmFtZSw8L2xpPlxuXHRcdFx0PGxpPid7YnV0dG9uOm5hbWV9JyB0byBpbnNlcnQgYSBidXR0b24gdHJpZ2dlciBmb3IgY29tbWFuZCBuYW1lLDwvbGk+XG5cdFx0XHQ8bGk+J3twb3B1cDpzdGFydH0uLi57cG9wdXA6ZW5kfScgdG8gbWFyayBhIHNlY3Rpb24gZm9yIGluY2x1c2lvbiBpbiBhIHBvcHVwIGRhdGVwaWNrZXIgb25seSw8L2xpPlxuXHRcdFx0PGxpPid7aW5saW5lOnN0YXJ0fS4uLntpbmxpbmU6ZW5kfScgdG8gbWFyayBhIHNlY3Rpb24gZm9yIGluY2x1c2lvbiBpbiBhbiBpbmxpbmUgZGF0ZXBpY2tlciBvbmx5LjwvbGk+XG5cdFx0XHQ8L3VsPlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByb3BlcnR5IHBpY2tlciB7c3RyaW5nfSBPdmVyYWxsIHN0cnVjdHVyZTogJ3ttb250aHN9JyB0byBpbnNlcnQgY2FsZW5kYXIgbW9udGhzLlxuXHRcdFx0QHByb3BlcnR5IG1vbnRoUm93IHtzdHJpbmd9IE9uZSByb3cgb2YgbW9udGhzOiAne21vbnRoc30nIHRvIGluc2VydCBjYWxlbmRhciBtb250aHMuXG5cdFx0XHRAcHJvcGVydHkgbW9udGgge3N0cmluZ30gQSBzaW5nbGUgbW9udGg6ICd7bW9udGhIZWFkZXI8ZW0+OmRhdGVGb3JtYXQ8L2VtPn0nIHRvIGluc2VydCB0aGUgbW9udGggaGVhZGVyIC1cblx0XHRcdFx0XHRcdDxlbT5kYXRlRm9ybWF0PC9lbT4gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICdNTSB5eXl5Jyxcblx0XHRcdFx0XHRcdCd7d2Vla0hlYWRlcn0nIHRvIGluc2VydCBhIHdlZWsgaGVhZGVyLCAne3dlZWtzfScgdG8gaW5zZXJ0IHRoZSBtb250aCdzIHdlZWtzLlxuXHRcdFx0QHByb3BlcnR5IHdlZWtIZWFkZXIge3N0cmluZ30gQSB3ZWVrIGhlYWRlcjogJ3tkYXlzfScgdG8gaW5zZXJ0IGluZGl2aWR1YWwgZGF5IG5hbWVzLlxuXHRcdFx0QHByb3BlcnR5IGRheUhlYWRlciB7c3RyaW5nfSBJbmRpdmlkdWFsIGRheSBoZWFkZXI6ICd7ZGF5fScgdG8gaW5zZXJ0IGRheSBuYW1lLlxuXHRcdFx0QHByb3BlcnR5IHdlZWsge3N0cmluZ30gT25lIHdlZWsgb2YgdGhlIG1vbnRoOiAne2RheXN9JyB0byBpbnNlcnQgdGhlIHdlZWsncyBkYXlzLFxuXHRcdFx0XHRcdFx0J3t3ZWVrT2ZZZWFyfScgdG8gaW5zZXJ0IHdlZWsgb2YgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBkYXkge3N0cmluZ30gQW4gaW5kaXZpZHVhbCBkYXk6ICd7ZGF5fScgdG8gaW5zZXJ0IGRheSB2YWx1ZS5cblx0XHRcdEBwcm9wZXJ0eSBtb250aFNlbGVjdG9yIHtzdHJpbmd9IGpRdWVyeSBzZWxlY3RvciwgcmVsYXRpdmUgdG8gcGlja2VyLCBmb3IgYSBzaW5nbGUgbW9udGguXG5cdFx0XHRAcHJvcGVydHkgZGF5U2VsZWN0b3Ige3N0cmluZ30galF1ZXJ5IHNlbGVjdG9yLCByZWxhdGl2ZSB0byBwaWNrZXIsIGZvciBpbmRpdmlkdWFsIGRheXMuXG5cdFx0XHRAcHJvcGVydHkgcnRsQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIHJpZ2h0LXRvLWxlZnQgKFJUTCkgbGFuZ3VhZ2VzLlxuXHRcdFx0QHByb3BlcnR5IG11bHRpQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIG11bHRpLW1vbnRoIGRhdGVwaWNrZXJzLlxuXHRcdFx0QHByb3BlcnR5IGRlZmF1bHRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3Igc2VsZWN0YWJsZSBkYXRlcy5cblx0XHRcdEBwcm9wZXJ0eSBzZWxlY3RlZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZXMuXG5cdFx0XHRAcHJvcGVydHkgaGlnaGxpZ2h0ZWRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgaGlnaGxpZ2h0ZWQgZGF0ZXMuXG5cdFx0XHRAcHJvcGVydHkgdG9kYXlDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgdG9kYXkuXG5cdFx0XHRAcHJvcGVydHkgb3RoZXJNb250aENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBkYXlzIGZyb20gb3RoZXIgbW9udGhzLlxuXHRcdFx0QHByb3BlcnR5IHdlZWtlbmRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgZGF5cyBvbiB3ZWVrZW5kcy5cblx0XHRcdEBwcm9wZXJ0eSBjb21tYW5kQ2xhc3Mge3N0cmluZ30gQ2xhc3MgcHJlZml4IGZvciBjb21tYW5kcy5cblx0XHRcdEBwcm9wZXJ0eSBjb21tYW5kQnV0dG9uQ2xhc3Mge3N0cmluZ30gRXh0cmEgY2xhc3MoZXMpIGZvciBjb21tYW5kcyB0aGF0IGFyZSBidXR0b25zLlxuXHRcdFx0QHByb3BlcnR5IGNvbW1hbmRMaW5rQ2xhc3Mge3N0cmluZ30gRXh0cmEgY2xhc3MoZXMpIGZvciBjb21tYW5kcyB0aGF0IGFyZSBsaW5rcy5cblx0XHRcdEBwcm9wZXJ0eSBkaXNhYmxlZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBkaXNhYmxlZCBjb21tYW5kcy4gKi9cblx0XHRkZWZhdWx0UmVuZGVyZXI6IHtcblx0XHRcdHBpY2tlcjogJzxkaXYgY2xhc3M9XCJjYWxlbmRhcnNcIj4nICtcblx0XHRcdCc8ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLW5hdlwiPntsaW5rOnByZXZ9e2xpbms6dG9kYXl9e2xpbms6bmV4dH08L2Rpdj57bW9udGhzfScgK1xuXHRcdFx0J3twb3B1cDpzdGFydH08ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLWN0cmxcIj57bGluazpjbGVhcn17bGluazpjbG9zZX08L2Rpdj57cG9wdXA6ZW5kfScgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtY2xlYXItZml4XCI+PC9kaXY+PC9kaXY+Jyxcblx0XHRcdG1vbnRoUm93OiAnPGRpdiBjbGFzcz1cImNhbGVuZGFycy1tb250aC1yb3dcIj57bW9udGhzfTwvZGl2PicsXG5cdFx0XHRtb250aDogJzxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtbW9udGhcIj48ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLW1vbnRoLWhlYWRlclwiPnttb250aEhlYWRlcn08L2Rpdj4nICtcblx0XHRcdCc8dGFibGU+PHRoZWFkPnt3ZWVrSGVhZGVyfTwvdGhlYWQ+PHRib2R5Pnt3ZWVrc308L3Rib2R5PjwvdGFibGU+PC9kaXY+Jyxcblx0XHRcdHdlZWtIZWFkZXI6ICc8dHI+e2RheXN9PC90cj4nLFxuXHRcdFx0ZGF5SGVhZGVyOiAnPHRoPntkYXl9PC90aD4nLFxuXHRcdFx0d2VlazogJzx0cj57ZGF5c308L3RyPicsXG5cdFx0XHRkYXk6ICc8dGQ+e2RheX08L3RkPicsXG5cdFx0XHRtb250aFNlbGVjdG9yOiAnLmNhbGVuZGFycy1tb250aCcsXG5cdFx0XHRkYXlTZWxlY3RvcjogJ3RkJyxcblx0XHRcdHJ0bENsYXNzOiAnY2FsZW5kYXJzLXJ0bCcsXG5cdFx0XHRtdWx0aUNsYXNzOiAnY2FsZW5kYXJzLW11bHRpJyxcblx0XHRcdGRlZmF1bHRDbGFzczogJycsXG5cdFx0XHRzZWxlY3RlZENsYXNzOiAnY2FsZW5kYXJzLXNlbGVjdGVkJyxcblx0XHRcdGhpZ2hsaWdodGVkQ2xhc3M6ICdjYWxlbmRhcnMtaGlnaGxpZ2h0Jyxcblx0XHRcdHRvZGF5Q2xhc3M6ICdjYWxlbmRhcnMtdG9kYXknLFxuXHRcdFx0b3RoZXJNb250aENsYXNzOiAnY2FsZW5kYXJzLW90aGVyLW1vbnRoJyxcblx0XHRcdHdlZWtlbmRDbGFzczogJ2NhbGVuZGFycy13ZWVrZW5kJyxcblx0XHRcdGNvbW1hbmRDbGFzczogJ2NhbGVuZGFycy1jbWQnLFxuXHRcdFx0Y29tbWFuZEJ1dHRvbkNsYXNzOiAnJyxcblx0XHRcdGNvbW1hbmRMaW5rQ2xhc3M6ICcnLFxuXHRcdFx0ZGlzYWJsZWRDbGFzczogJ2NhbGVuZGFycy1kaXNhYmxlZCdcblx0XHR9LFxuXHRcblx0XHQvKiogQ29tbWFuZCBhY3Rpb25zIHRoYXQgbWF5IGJlIGFkZGVkIHRvIGEgbGF5b3V0IGJ5IG5hbWUuXG5cdFx0XHQ8dWw+XG5cdFx0XHQ8bGk+cHJldiAtIFNob3cgdGhlIHByZXZpb3VzIG1vbnRoIChiYXNlZCBvbiA8Y29kZT5tb250aHNUb1N0ZXA8L2NvZGU+IG9wdGlvbikgLSA8ZW0+UGFnZVVwPC9lbT48L2xpPlxuXHRcdFx0PGxpPnByZXZKdW1wIC0gU2hvdyB0aGUgcHJldmlvdXMgeWVhciAoYmFzZWQgb24gPGNvZGU+bW9udGhzVG9KdW1wPC9jb2RlPiBvcHRpb24pIC0gPGVtPkN0cmwrUGFnZVVwPC9lbT48L2xpPlxuXHRcdFx0PGxpPm5leHQgLSBTaG93IHRoZSBuZXh0IG1vbnRoIChiYXNlZCBvbiA8Y29kZT5tb250aHNUb1N0ZXA8L2NvZGU+IG9wdGlvbikgLSA8ZW0+UGFnZURvd248L2VtPjwvbGk+XG5cdFx0XHQ8bGk+bmV4dEp1bXAgLSBTaG93IHRoZSBuZXh0IHllYXIgKGJhc2VkIG9uIDxjb2RlPm1vbnRoc1RvSnVtcDwvY29kZT4gb3B0aW9uKSAtIDxlbT5DdHJsK1BhZ2VEb3duPC9lbT48L2xpPlxuXHRcdFx0PGxpPmN1cnJlbnQgLSBTaG93IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbW9udGggb3IgdG9kYXkncyBpZiBub25lIHNlbGVjdGVkIC0gPGVtPkN0cmwrSG9tZTwvZW0+PC9saT5cblx0XHRcdDxsaT50b2RheSAtIFNob3cgdG9kYXkncyBtb250aCAtIDxlbT5DdHJsK0hvbWU8L2VtPjwvbGk+XG5cdFx0XHQ8bGk+Y2xlYXIgLSBFcmFzZSB0aGUgZGF0ZSBhbmQgY2xvc2UgdGhlIGRhdGVwaWNrZXIgcG9wdXAgLSA8ZW0+Q3RybCtFbmQ8L2VtPjwvbGk+XG5cdFx0XHQ8bGk+Y2xvc2UgLSBDbG9zZSB0aGUgZGF0ZXBpY2tlciBwb3B1cCAtIDxlbT5Fc2M8L2VtPjwvbGk+XG5cdFx0XHQ8bGk+cHJldldlZWsgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIHByZXZpb3VzIHdlZWsgLSA8ZW0+Q3RybCtVcDwvZW0+PC9saT5cblx0XHRcdDxsaT5wcmV2RGF5IC0gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBwcmV2aW91cyBkYXkgLSA8ZW0+Q3RybCtMZWZ0PC9lbT48L2xpPlxuXHRcdFx0PGxpPm5leHREYXkgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIG5leHQgZGF5IC0gPGVtPkN0cmwrUmlnaHQ8L2VtPjwvbGk+XG5cdFx0XHQ8bGk+bmV4dFdlZWsgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIG5leHQgd2VlayAtIDxlbT5DdHJsK0Rvd248L2VtPjwvbGk+XG5cdFx0XHQ8L3VsPlxuXHRcdFx0VGhlIGNvbW1hbmQgbmFtZSBpcyB0aGUga2V5IG5hbWUgYW5kIGlzIHVzZWQgdG8gYWRkIHRoZSBjb21tYW5kIHRvIGEgbGF5b3V0XG5cdFx0XHR3aXRoICd7YnV0dG9uOm5hbWV9JyBvciAne2xpbms6bmFtZX0nLiBFYWNoIGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJvcGVydHkgdGV4dCB7c3RyaW5nfSBUaGUgZmllbGQgaW4gdGhlIHJlZ2lvbmFsIHNldHRpbmdzIGZvciB0aGUgZGlzcGxheWVkIHRleHQuXG5cdFx0XHRAcHJvcGVydHkgc3RhdHVzIHtzdHJpbmd9IFRoZSBmaWVsZCBpbiB0aGUgcmVnaW9uYWwgc2V0dGluZ3MgZm9yIHRoZSBzdGF0dXMgdGV4dC5cblx0XHRcdEBwcm9wZXJ0eSBrZXlzdHJva2Uge29iamVjdH0gVGhlIGtleXN0cm9rZSB0byB0cmlnZ2VyIHRoZSBhY3Rpb24sIHdpdGggYXR0cmlidXRlczpcblx0XHRcdFx0PGNvZGU+a2V5Q29kZTwvY29kZT4ge251bWJlcn0gdGhlIGNvZGUgZm9yIHRoZSBrZXlzdHJva2UsXG5cdFx0XHRcdDxjb2RlPmN0cmxLZXk8L2NvZGU+IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8ZW0+Q3RybDwvZW0+IGlzIHJlcXVpcmVkLFxuXHRcdFx0XHQ8Y29kZT5hbHRLZXk8L2NvZGU+IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8ZW0+QWx0PC9lbT4gaXMgcmVxdWlyZWQsXG5cdFx0XHRcdDxjb2RlPnNoaWZ0S2V5PC9jb2RlPiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGVtPlNoaWZ0PC9lbT4gaXMgcmVxdWlyZWQuXG5cdFx0XHRAcHJvcGVydHkgZW5hYmxlZCB7Q2FsZW5kYXJzUGlja2VyQ29tbWFuZEVuYWJsZWR9IFRoZSBmdW5jdGlvbiB0aGF0IGluZGljYXRlcyB0aGUgY29tbWFuZCBpcyBlbmFibGVkLlxuXHRcdFx0QHByb3BlcnR5IGRhdGUge0NhbGVuZGFyc1BpY2tlckNvbW1hbmREYXRlfSBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBkYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFjdGlvbi5cblx0XHRcdEBwcm9wZXJ0eSBhY3Rpb24ge0NhbGVuZGFyc1BpY2tlckNvbW1hbmRBY3Rpb259IFRoZSBmdW5jdGlvbiB0aGF0IGltcGxlbWVudHMgdGhlIGFjdGlvbi4gKi9cblx0XHRjb21tYW5kczoge1xuXHRcdFx0cHJldjoge3RleHQ6ICdwcmV2VGV4dCcsIHN0YXR1czogJ3ByZXZTdGF0dXMnLCAvLyBQcmV2aW91cyBtb250aFxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzM30sIC8vIFBhZ2UgdXBcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cblx0XHRcdFx0XHRcdGFkZCgxIC0gaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuYWRkKC0xLCAnZCcpLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpOyB9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKC1pbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KTsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKHRoaXMsIC1pbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwKTsgfVxuXHRcdFx0fSxcblx0XHRcdHByZXZKdW1wOiB7dGV4dDogJ3ByZXZKdW1wVGV4dCcsIHN0YXR1czogJ3ByZXZKdW1wU3RhdHVzJywgLy8gUHJldmlvdXMgeWVhclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzMywgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBQYWdlIHVwXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0XHRhZGQoMSAtIGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpLmFkZCgtMSwgJ2QnKS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cblx0XHRcdFx0XHRcdGFkZCgtaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSk7IH0sXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aCh0aGlzLCAtaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCk7IH1cblx0XHRcdH0sXG5cdFx0XHRuZXh0OiB7dGV4dDogJ25leHRUZXh0Jywgc3RhdHVzOiAnbmV4dFN0YXR1cycsIC8vIE5leHQgbW9udGhcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzR9LCAvLyBQYWdlIGRvd25cblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpOyB9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgodGhpcywgaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCk7IH1cblx0XHRcdH0sXG5cdFx0XHRuZXh0SnVtcDoge3RleHQ6ICduZXh0SnVtcFRleHQnLCBzdGF0dXM6ICduZXh0SnVtcFN0YXR1cycsIC8vIE5leHQgeWVhclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNCwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBQYWdlIGRvd25cblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpO1x0fSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cblx0XHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KTsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKHRoaXMsIGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXApOyB9XG5cdFx0XHR9LFxuXHRcdFx0Y3VycmVudDoge3RleHQ6ICdjdXJyZW50VGV4dCcsIHN0YXR1czogJ2N1cnJlbnRTdGF0dXMnLCAvLyBDdXJyZW50IG1vbnRoXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM2LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIEhvbWVcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0XHRcdHZhciBjdXJEYXRlID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgY3VyRGF0ZS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxuXHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGN1ckRhdGUuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHR2YXIgY3VyRGF0ZSA9IGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKTtcblx0XHRcdFx0XHRwbHVnaW4uc2hvd01vbnRoKHRoaXMsIGN1ckRhdGUueWVhcigpLCBjdXJEYXRlLm1vbnRoKCkpOyB9XG5cdFx0XHR9LFxuXHRcdFx0dG9kYXk6IHt0ZXh0OiAndG9kYXlUZXh0Jywgc3RhdHVzOiAndG9kYXlTdGF0dXMnLCAvLyBUb2RheSdzIG1vbnRoXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM2LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIEhvbWVcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSkgJiZcblx0XHRcdFx0XHRcdCghbWF4RGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCk7IH0sXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uc2hvd01vbnRoKHRoaXMpOyB9XG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXI6IHt0ZXh0OiAnY2xlYXJUZXh0Jywgc3RhdHVzOiAnY2xlYXJTdGF0dXMnLCAvLyBDbGVhciB0aGUgZGF0ZXBpY2tlclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNSwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBFbmRcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gdHJ1ZTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gbnVsbDsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jbGVhcih0aGlzKTsgfVxuXHRcdFx0fSxcblx0XHRcdGNsb3NlOiB7dGV4dDogJ2Nsb3NlVGV4dCcsIHN0YXR1czogJ2Nsb3NlU3RhdHVzJywgLy8gQ2xvc2UgdGhlIGRhdGVwaWNrZXJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMjd9LCAvLyBFc2NhcGVcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gdHJ1ZTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gbnVsbDsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5oaWRlKHRoaXMpOyB9XG5cdFx0XHR9LFxuXHRcdFx0cHJldldlZWs6IHt0ZXh0OiAncHJldldlZWtUZXh0Jywgc3RhdHVzOiAncHJldldlZWtTdGF0dXMnLCAvLyBQcmV2aW91cyB3ZWVrXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM4LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIFVwXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0XHRhZGQoLWluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCksICdkJykuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSk7IH0sXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdGFkZCgtaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSwgJ2QnKTsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jaGFuZ2VEYXkodGhpcywgLWluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCkpOyB9XG5cdFx0XHR9LFxuXHRcdFx0cHJldkRheToge3RleHQ6ICdwcmV2RGF5VGV4dCcsIHN0YXR1czogJ3ByZXZEYXlTdGF0dXMnLCAvLyBQcmV2aW91cyBkYXlcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzcsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgTGVmdFxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgtMSwgJ2QnKS5cblx0XHRcdFx0XHRcdGNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpOyB9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQoLTEsICdkJyk7IH0sXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2hhbmdlRGF5KHRoaXMsIC0xKTsgfVxuXHRcdFx0fSxcblx0XHRcdG5leHREYXk6IHt0ZXh0OiAnbmV4dERheVRleHQnLCBzdGF0dXM6ICduZXh0RGF5U3RhdHVzJywgLy8gTmV4dCBkYXlcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzksIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgUmlnaHRcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgxLCAnZCcpLlxuXHRcdFx0XHRcdFx0Y29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgxLCAnZCcpOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNoYW5nZURheSh0aGlzLCAxKTsgfVxuXHRcdFx0fSxcblx0XHRcdG5leHRXZWVrOiB7dGV4dDogJ25leHRXZWVrVGV4dCcsIHN0YXR1czogJ25leHRXZWVrU3RhdHVzJywgLy8gTmV4dCB3ZWVrXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDQwLCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIERvd25cblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtYXhEYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCksICdkJykuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpLCAnZCcpOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNoYW5nZURheSh0aGlzLCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpKTsgfVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tYW5kIGlzIGVuYWJsZWQuXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyQ29tbWFuZEVuYWJsZWRcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBjb21tYW5kIGlzIGVuYWJsZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXG5cdFx0XHRAZXhhbXBsZSBlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdHJldHVybiAhIWluc3QuY3VyTWluRGF0ZSgpO1xuIH0gKi9cblxuXHRcdC8qKiBDYWxjdWxhdGUgdGhlIHJlcHJlc2VudGF0aXZlIGRhdGUgZm9yIGEgY29tbWFuZC5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDb21tYW5kRGF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gQSBkYXRlIGFwcHJvcHJpYXRlIGZvciB0aGlzIGNvbW1hbmQuXG5cdFx0XHRAZXhhbXBsZSBkYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdHJldHVybiBpbnN0LmN1ck1pbkRhdGUoKTtcbiB9ICovXG5cblx0XHQvKiogUGVyZm9ybSB0aGUgYWN0aW9uIGZvciBhIGNvbW1hbmQuXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyQ29tbWFuZEFjdGlvblxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAZXhhbXBsZSBkYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdCQuZGF0ZXBpY2suc2V0RGF0ZShpbnN0LmVsZW0sIGluc3QuY3VyTWluRGF0ZSgpKTtcbiB9ICovXG5cblx0XHQvKiogQ2FsY3VsYXRlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGZvciBhIGRhdGUuXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyQ2FsY3VsYXRlV2Vla1xuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byBldmFsdWF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHdlZWsgb2YgdGhlIHllYXIuXG5cdFx0XHRAZXhhbXBsZSBjYWxjdWxhdGVXZWVrOiBmdW5jdGlvbihkYXRlKSB7XG5cdHZhciBzdGFydFllYXIgPSAkLmNhbGVuZGFycy5uZXdEYXRlKGRhdGUueWVhcigpLCAxLCAxKTtcblx0cmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZGF5T2ZZZWFyKCkgLSBzdGFydFllYXIuZGF5T2ZZZWFyKCkpIC8gNykgKyAxO1xuIH0gKi9cblxuXHRcdC8qKiBQcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IGFuIGluZGl2aWR1YWwgZGF0ZSBzaG93biBpbiB0aGUgY2FsZW5kYXIuXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25EYXRlXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBkYXRlIHRvIGV2YWx1YXRlLlxuXHRcdFx0QHJldHVybiB7b2JqZWN0fSBJbmZvcm1hdGlvbiBhYm91dCB0aGF0IGRhdGUsIHdpdGggdGhlIHByb3BlcnRpZXMgYWJvdmUuXG5cdFx0XHRAcHJvcGVydHkgc2VsZWN0YWJsZSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBkYXRlIGNhbiBiZSBzZWxlY3RlZC5cblx0XHRcdEBwcm9wZXJ0eSBkYXRlQ2xhc3Mge3N0cmluZ30gQ2xhc3MoZXMpIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGRhdGUuXG5cdFx0XHRAcHJvcGVydHkgY29udGVudCB7c3RyaW5nfSBUaGUgZGF0ZSBjZWxsIGNvbnRlbnQuXG5cdFx0XHRAcHJvcGVydHkgdG9vbHRpcCB7c3RyaW5nfSBBIHBvcHVwIHRvb2x0aXAgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QGV4YW1wbGUgb25EYXRlOiBmdW5jdGlvbihkYXRlKSB7XG5cdHJldHVybiB7c2VsZWN0YWJsZTogZGF0ZS5kYXkoKSA+IDAgJiYgZGF0ZS5kYXkoKSAmbHQ7IDUsXG5cdFx0ZGF0ZUNsYXNzOiBkYXRlLmRheSgpID09PSA0ID8gJ2xhc3QtZGF5JyA6ICcnfTtcbiB9ICovXG5cblx0XHQvKiogVXBkYXRlIHRoZSBkYXRlcGlja2VyIGRpc3BsYXkuXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25TaG93XG5cdFx0XHRAcGFyYW0gcGlja2VyIHtqUXVlcnl9IFRoZSBkYXRlcGlja2VyIDxjb2RlPmRpdjwvY29kZT4gdG8gYmUgc2hvd24uXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBleGFtcGxlIG9uU2hvdzogZnVuY3Rpb24ocGlja2VyLCBpbnN0KSB7XG5cdHBpY2tlci5hcHBlbmQoJyZsdDtidXR0b24gdHlwZT1cImJ1dHRvblwiPkhpJmx0Oy9idXR0b24+JykuXG5cdFx0ZmluZCgnYnV0dG9uOmxhc3QnKS5jbGljayhmdW5jdGlvbigpIHtcblx0XHRcdGFsZXJ0KCdIaSEnKTtcblx0XHR9KTtcbiB9ICovXG5cblx0XHQvKiogUmVhY3QgdG8gbmF2aWdhdGluZyB0aHJvdWdoIHRoZSBtb250aHMveWVhcnMuXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25DaGFuZ2VNb250aFllYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSBuZXcgeWVhci5cblx0XHRcdEBwYXJhbSBtb250aCB7bnVtYmVyfSBUaGUgbmV3IG1vbnRoICgxIHRvIDEyKS5cblx0XHRcdEBleGFtcGxlIG9uQ2hhbmdlTW9udGhZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuXHRhbGVydCgnTm93IGluICcgKyBtb250aCArICcvJyArIHllYXIpO1xuIH0gKi9cblx0XHRcdFxuXHRcdC8qKiBEYXRlcGlja2VyIG9uIHNlbGVjdCBjYWxsYmFjay5cblx0XHRcdFRyaWdnZXJlZCB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZC5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPblNlbGVjdFxuXHRcdFx0QHBhcmFtIGRhdGVzIHtDRGF0ZVtdfSBUaGUgc2VsZWN0ZWQgZGF0ZShzKS5cblx0XHRcdEBleGFtcGxlIG9uU2VsZWN0OiBmdW5jdGlvbihkYXRlcykge1xuIFx0YWxlcnQoJ1NlbGVjdGVkICcgKyBkYXRlcyk7XG4gfSAqL1xuXHRcdFx0XG5cdFx0LyoqIERhdGVwaWNrZXIgb24gY2xvc2UgY2FsbGJhY2suXG5cdFx0XHRUcmlnZ2VyZWQgd2hlbiBhIHBvcHVwIGNhbGVuZGFyIGlzIGNsb3NlZC5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPbkNsb3NlXG5cdFx0XHRAcGFyYW0gZGF0ZXMge0NEYXRlW119IFRoZSBzZWxlY3RlZCBkYXRlKHMpLlxuXHRcdFx0QGV4YW1wbGUgb25DbG9zZTogZnVuY3Rpb24oZGF0ZXMpIHtcbiBcdGFsZXJ0KCdTZWxlY3RlZCAnICsgZGF0ZXMpO1xuIH0gKi9cblx0XHRcblx0XHQvKiogRGVmYXVsdCBzZXR0aW5ncyBmb3IgdGhlIHBsdWdpbi5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcm9wZXJ0eSBbY2FsZW5kYXI9JC5jYWxlbmRhcnMuaW5zdGFuY2UoKV0ge0NhbGVuZGFyfSBUaGUgY2FsZW5kYXIgZm9yIHRoaXMgZGF0ZXBpY2tlci5cblx0XHRcdEBwcm9wZXJ0eSBbcGlja2VyQ2xhc3M9JyddIHtzdHJpbmd9IENTUyBjbGFzcyB0byBhZGQgdG8gdGhpcyBpbnN0YW5jZSBvZiB0aGUgZGF0ZXBpY2tlci5cblx0XHRcdEBwcm9wZXJ0eSBbc2hvd09uRm9jdXM9dHJ1ZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGZvciBwb3B1cCBvbiBmb2N1cywgPGNvZGU+ZmFsc2U8L2NvZGU+IGZvciBub3QuXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dUcmlnZ2VyPW51bGxdIHtzdHJpbmd8RWxlbWVudHxqUXVlcnl9IEVsZW1lbnQgdG8gYmUgY2xvbmVkIGZvciBhIHRyaWdnZXIsIDxjb2RlPm51bGw8L2NvZGU+IGZvciBub25lLlxuXHRcdFx0QHByb3BlcnR5IFtzaG93QW5pbT0nc2hvdyddIHtzdHJpbmd9IE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXAsICcnIGZvciBubyBhbmltYXRpb24uXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dPcHRpb25zPW51bGxdIHtvYmplY3R9IE9wdGlvbnMgZm9yIGVuaGFuY2VkIGFuaW1hdGlvbnMuXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dTcGVlZD0nbm9ybWFsJ10ge3N0cmluZ30gRHVyYXRpb24gb2YgZGlzcGxheS9jbG9zdXJlLlxuXHRcdFx0QHByb3BlcnR5IFtwb3B1cENvbnRhaW5lcj1udWxsXSB7c3RyaW5nfEVsZW1lbnR8alF1ZXJ5fSBUaGUgZWxlbWVudCB0byB3aGljaCBhIHBvcHVwIGNhbGVuZGFyIGlzIGFkZGVkLCA8Y29kZT5udWxsPC9jb2RlPiBmb3IgYm9keS5cblx0XHRcdEBwcm9wZXJ0eSBbYWxpZ25tZW50PSdib3R0b20nXSB7c3RyaW5nfSBBbGlnbm1lbnQgb2YgcG9wdXAgLSB3aXRoIG5vbWluYXRlZCBjb3JuZXIgb2YgaW5wdXQ6XG5cdFx0XHRcdFx0XHQndG9wJyBvciAnYm90dG9tJyBhbGlnbnMgZGVwZW5kaW5nIG9uIGxhbmd1YWdlIGRpcmVjdGlvbixcblx0XHRcdFx0XHRcdCd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnLlxuXHRcdFx0QHByb3BlcnR5IFtmaXhlZFdlZWtzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gYWx3YXlzIHNob3cgNiB3ZWVrcywgPGNvZGU+ZmFsc2U8L2NvZGU+IHRvIG9ubHkgc2hvdyBhcyBtYW55IGFzIGFyZSBuZWVkZWQuXG5cdFx0XHRAcHJvcGVydHkgW2ZpcnN0RGF5PW51bGxdIHtudW1iZXJ9IEZpcnN0IGRheSBvZiB0aGUgd2VlaywgMCA9IFN1bmRheSwgMSA9IE1vbmRheSwgZXRjLiwgPGNvZGU+bnVsbDwvY29kZT4gZm9yIDxjb2RlPmNhbGVuZGFyPC9jb2RlPiBkZWZhdWx0LlxuXHRcdFx0QHByb3BlcnR5IFtjYWxjdWxhdGVXZWVrPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJDYWxjdWxhdGVXZWVrfSBDYWxjdWxhdGUgd2VlayBvZiB0aGUgeWVhciBmcm9tIGEgZGF0ZSwgPGNvZGU+bnVsbDwvY29kZT4gZm9yIDxjb2RlPmNhbGVuZGFyPC9jb2RlPiBkZWZhdWx0LlxuXHRcdFx0QHByb3BlcnR5IFttb250aHNUb1Nob3c9MV0ge251bWJlcnxudW1iZXJbXX0gSG93IG1hbnkgbW9udGhzIHRvIHNob3csIGNvbHMgb3IgW3Jvd3MsIGNvbHNdLlxuXHRcdFx0QHByb3BlcnR5IFttb250aHNPZmZzZXQ9MF0ge251bWJlcn0gSG93IG1hbnkgbW9udGhzIHRvIG9mZnNldCB0aGUgcHJpbWFyeSBtb250aCBieTtcblx0XHRcdFx0XHRcdG1heSBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGRhdGUgYW5kIHJldHVybnMgdGhlIG9mZnNldC5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhzVG9TdGVwPTFdIHtudW1iZXJ9IEhvdyBtYW55IG1vbnRocyB0byBtb3ZlIHdoZW4gcHJldi9uZXh0IGNsaWNrZWQuXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoc1RvSnVtcD0xMl0ge251bWJlcn0gSG93IG1hbnkgbW9udGhzIHRvIG1vdmUgd2hlbiBsYXJnZSBwcmV2L25leHQgY2xpY2tlZC5cblx0XHRcdEBwcm9wZXJ0eSBbdXNlTW91c2VXaGVlbD10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gdXNlIG1vdXNld2hlZWwgaWYgYXZhaWxhYmxlLCA8Y29kZT5mYWxzZTwvY29kZT4gdG8gbmV2ZXIgdXNlIGl0LlxuXHRcdFx0QHByb3BlcnR5IFtjaGFuZ2VNb250aD10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY2hhbmdlIG1vbnRoL3llYXIgdmlhIGRyb3AtZG93biwgPGNvZGU+ZmFsc2U8L2NvZGU+IGZvciBuYXZpZ2F0aW9uIG9ubHkuXG5cdFx0XHRAcHJvcGVydHkgW3llYXJSYW5nZT0nYy0xMDpjKzEwJ10ge3N0cmluZ30gUmFuZ2Ugb2YgeWVhcnMgdG8gc2hvdyBpbiBkcm9wLWRvd246ICdhbnknIGZvciBkaXJlY3QgdGV4dCBlbnRyeVxuXHRcdFx0XHRcdFx0b3IgJ3N0YXJ0OmVuZCcsIHdoZXJlIHN0YXJ0L2VuZCBhcmUgJystbm4nIGZvciByZWxhdGl2ZSB0byB0b2RheVxuXHRcdFx0XHRcdFx0b3IgJ2MrLW5uJyBmb3IgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlXG5cdFx0XHRcdFx0XHRvciAnbm5ubicgZm9yIGFuIGFic29sdXRlIHllYXIuXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dPdGhlck1vbnRocz1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHNob3cgZGF0ZXMgZnJvbSBvdGhlciBtb250aHMsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBub3Qgc2hvdyB0aGVtLlxuXHRcdFx0QHByb3BlcnR5IFtzZWxlY3RPdGhlck1vbnRocz1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGFsbG93IHNlbGVjdGlvbiBvZiBkYXRlcyBmcm9tIG90aGVyIG1vbnRocyB0b28uXG5cdFx0XHRAcHJvcGVydHkgW2RlZmF1bHREYXRlPW51bGxdIHtzdHJpbmd8bnVtYmVyfENEYXRlfSBEYXRlIHRvIHNob3cgaWYgbm8gb3RoZXIgc2VsZWN0ZWQuXG5cdFx0XHRAcHJvcGVydHkgW3NlbGVjdERlZmF1bHREYXRlPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gcHJlLXNlbGVjdCB0aGUgZGVmYXVsdCBkYXRlIGlmIG5vIG90aGVyIGlzIGNob3Nlbi5cblx0XHRcdEBwcm9wZXJ0eSBbbWluRGF0ZT1udWxsXSB7c3RyaW5nfG51bWJlcnxDRGF0ZX0gVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLlxuXHRcdFx0QHByb3BlcnR5IFttYXhEYXRlPW51bGxdIHtzdHJpbmd8bnVtYmVyfENEYXRlfSBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuXG5cdFx0XHRAcHJvcGVydHkgW2RhdGVGb3JtYXQ9J21tL2RkL3l5eXknXSB7c3RyaW5nfSBGb3JtYXQgZm9yIGRhdGVzLlxuXHRcdFx0QHByb3BlcnR5IFthdXRvU2l6ZT1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHNpemUgdGhlIGlucHV0IGZpZWxkIGFjY29yZGluZyB0byB0aGUgZGF0ZSBmb3JtYXQuXG5cdFx0XHRAcHJvcGVydHkgW3JhbmdlU2VsZWN0PWZhbHNlXSB7Ym9vbGVhbn0gQWxsb3dzIGZvciBzZWxlY3RpbmcgYSBkYXRlIHJhbmdlIG9uIG9uZSBkYXRlIHBpY2tlci5cblx0XHRcdEBwcm9wZXJ0eSBbcmFuZ2VTZXBhcmF0b3I9JyAtICddIHtzdHJpbmd9IFRleHQgYmV0d2VlbiB0d28gZGF0ZXMgaW4gYSByYW5nZS5cblx0XHRcdEBwcm9wZXJ0eSBbbXVsdGlTZWxlY3Q9MF0ge251bWJlcn0gTWF4aW11bSBudW1iZXIgb2Ygc2VsZWN0YWJsZSBkYXRlcywgemVybyBmb3Igc2luZ2xlIHNlbGVjdC5cblx0XHRcdEBwcm9wZXJ0eSBbbXVsdGlTZXBhcmF0b3I9JywnXSB7c3RyaW5nfSBUZXh0IGJldHdlZW4gbXVsdGlwbGUgZGF0ZXMuXG5cdFx0XHRAcHJvcGVydHkgW29uRGF0ZT1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25EYXRlfSBDYWxsYmFjayBhcyBhIGRhdGUgaXMgYWRkZWQgdG8gdGhlIGRhdGVwaWNrZXIuXG5cdFx0XHRAcHJvcGVydHkgW29uU2hvdz1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25TaG93fSBDYWxsYmFjayBqdXN0IGJlZm9yZSBhIGRhdGVwaWNrZXIgaXMgc2hvd24uXG5cdFx0XHRAcHJvcGVydHkgW29uQ2hhbmdlTW9udGhZZWFyPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPbkNoYW5nZU1vbnRoWWVhcn0gQ2FsbGJhY2sgd2hlbiBhIG5ldyBtb250aC95ZWFyIGlzIHNlbGVjdGVkLlxuXHRcdFx0QHByb3BlcnR5IFtvblNlbGVjdD1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25TZWxlY3R9IENhbGxiYWNrIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkLlxuXHRcdFx0QHByb3BlcnR5IFtvbkNsb3NlPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPbkNsb3NlfSBDYWxsYmFjayB3aGVuIGEgZGF0ZXBpY2tlciBpcyBjbG9zZWQuXG5cdFx0XHRAcHJvcGVydHkgW2FsdEZpZWxkPW51bGxdIHtzdHJpbmd8RWxlbWVudHxqUXVlcnl9IEFsdGVybmF0ZSBmaWVsZCB0byB1cGRhdGUgaW4gc3luY2ggd2l0aCB0aGUgZGF0ZXBpY2tlci5cblx0XHRcdEBwcm9wZXJ0eSBbYWx0Rm9ybWF0PW51bGxdIHtzdHJpbmd9IERhdGUgZm9ybWF0IGZvciBhbHRlcm5hdGUgZmllbGQsIGRlZmF1bHRzIHRvIDxjb2RlPmRhdGVGb3JtYXQ8L2NvZGU+LlxuXHRcdFx0QHByb3BlcnR5IFtjb25zdHJhaW5JbnB1dD10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY29uc3RyYWluIHR5cGVkIGlucHV0IHRvIDxjb2RlPmRhdGVGb3JtYXQ8L2NvZGU+IGFsbG93ZWQgY2hhcmFjdGVycy5cblx0XHRcdEBwcm9wZXJ0eSBbY29tbWFuZHNBc0RhdGVGb3JtYXQ9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBhcHBseVxuXHRcdFx0XHRcdFx0PGNvZGU+PGEgaHJlZj1cIiNmb3JtYXREYXRlXCI+Zm9ybWF0RGF0ZTwvYT48L2NvZGU+IHRvIHRoZSBjb21tYW5kIHRleHRzLlxuXHRcdFx0QHByb3BlcnR5IFtjb21tYW5kcz10aGlzLmNvbW1hbmRzXSB7b2JqZWN0fSBDb21tYW5kIGFjdGlvbnMgdGhhdCBtYXkgYmUgYWRkZWQgdG8gYSBsYXlvdXQgYnkgbmFtZS4gKi9cblx0XHRkZWZhdWx0T3B0aW9uczoge1xuXHRcdFx0Y2FsZW5kYXI6ICQuY2FsZW5kYXJzLmluc3RhbmNlKCksXG5cdFx0XHRwaWNrZXJDbGFzczogJycsXG5cdFx0XHRzaG93T25Gb2N1czogdHJ1ZSxcblx0XHRcdHNob3dUcmlnZ2VyOiBudWxsLFxuXHRcdFx0c2hvd0FuaW06ICdzaG93Jyxcblx0XHRcdHNob3dPcHRpb25zOiB7fSxcblx0XHRcdHNob3dTcGVlZDogJ25vcm1hbCcsXG5cdFx0XHRwb3B1cENvbnRhaW5lcjogbnVsbCxcblx0XHRcdGFsaWdubWVudDogJ2JvdHRvbScsXG5cdFx0XHRmaXhlZFdlZWtzOiBmYWxzZSxcblx0XHRcdGZpcnN0RGF5OiBudWxsLFxuXHRcdFx0Y2FsY3VsYXRlV2VlazogbnVsbCxcblx0XHRcdG1vbnRoc1RvU2hvdzogMSxcblx0XHRcdG1vbnRoc09mZnNldDogMCxcblx0XHRcdG1vbnRoc1RvU3RlcDogMSxcblx0XHRcdG1vbnRoc1RvSnVtcDogMTIsXG5cdFx0XHR1c2VNb3VzZVdoZWVsOiB0cnVlLFxuXHRcdFx0Y2hhbmdlTW9udGg6IHRydWUsXG5cdFx0XHR5ZWFyUmFuZ2U6ICdjLTEwOmMrMTAnLFxuXHRcdFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSxcblx0XHRcdHNlbGVjdE90aGVyTW9udGhzOiBmYWxzZSxcblx0XHRcdGRlZmF1bHREYXRlOiBudWxsLFxuXHRcdFx0c2VsZWN0RGVmYXVsdERhdGU6IGZhbHNlLFxuXHRcdFx0bWluRGF0ZTogbnVsbCxcblx0XHRcdG1heERhdGU6IG51bGwsXG5cdFx0XHRkYXRlRm9ybWF0OiBudWxsLFxuXHRcdFx0YXV0b1NpemU6IGZhbHNlLFxuXHRcdFx0cmFuZ2VTZWxlY3Q6IGZhbHNlLFxuXHRcdFx0cmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuXHRcdFx0bXVsdGlTZWxlY3Q6IDAsXG5cdFx0XHRtdWx0aVNlcGFyYXRvcjogJywnLFxuXHRcdFx0b25EYXRlOiBudWxsLFxuXHRcdFx0b25TaG93OiBudWxsLFxuXHRcdFx0b25DaGFuZ2VNb250aFllYXI6IG51bGwsXG5cdFx0XHRvblNlbGVjdDogbnVsbCxcblx0XHRcdG9uQ2xvc2U6IG51bGwsXG5cdFx0XHRhbHRGaWVsZDogbnVsbCxcblx0XHRcdGFsdEZvcm1hdDogbnVsbCxcblx0XHRcdGNvbnN0cmFpbklucHV0OiB0cnVlLFxuXHRcdFx0Y29tbWFuZHNBc0RhdGVGb3JtYXQ6IGZhbHNlLFxuXHRcdFx0Y29tbWFuZHM6IHt9IC8vIHRoaXMuY29tbWFuZHNcblx0XHR9LFxuXG5cdFx0LyoqIExvY2FsaXNhdGlvbnMgZm9yIHRoZSBwbHVnaW4uXG5cdFx0XHRFbnRyaWVzIGFyZSBvYmplY3RzIGluZGV4ZWQgYnkgdGhlIGxhbmd1YWdlIGNvZGUgKCcnIGJlaW5nIHRoZSBkZWZhdWx0IFVTL0VuZ2xpc2gpLlxuXHRcdFx0RWFjaCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcy5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcm9wZXJ0eSBbcmVuZGVyZXI9dGhpcy5kZWZhdWx0UmVuZGVyZXJdIHtzdHJpbmd9IFRoZSByZW5kZXJpbmcgdGVtcGxhdGVzLlxuXHRcdFx0QHByb3BlcnR5IFtwcmV2VGV4dD0nJmx0O1ByZXYnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgcHJldmlvdXMgbW9udGggY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbcHJldlN0YXR1cz0nU2hvdyB0aGUgcHJldmlvdXMgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIHByZXZpb3VzIG1vbnRoIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW3ByZXZKdW1wVGV4dD0nJmx0OyZsdDsnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgcHJldmlvdXMgeWVhciBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFtwcmV2SnVtcFN0YXR1cz0nU2hvdyB0aGUgcHJldmlvdXMgeWVhciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgcHJldmlvdXMgeWVhciBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFtuZXh0VGV4dD0nTmV4dCZndDsnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgbmV4dCBtb250aCBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFtuZXh0U3RhdHVzPSdTaG93IHRoZSBuZXh0IG1vbnRoJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBuZXh0IG1vbnRoIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW25leHRKdW1wVGV4dD0nJmd0OyZndDsnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgbmV4dCB5ZWFyIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW25leHRKdW1wU3RhdHVzPSdTaG93IHRoZSBuZXh0IHllYXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIG5leHQgeWVhciBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFtjdXJyZW50VGV4dD0nQ3VycmVudCddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBjdXJyZW50IG1vbnRoIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW2N1cnJlbnRTdGF0dXM9J1Nob3cgdGhlIGN1cnJlbnQgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIGN1cnJlbnQgbW9udGggY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbdG9kYXlUZXh0PSdUb2RheSddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSB0b2RheSdzIG1vbnRoIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW3RvZGF5U3RhdHVzPSdTaG93IHRvZGF5XFwncyBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgdG9kYXkncyBtb250aCBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFtjbGVhclRleHQ9J0NsZWFyJ10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIGNsZWFyIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW2NsZWFyU3RhdHVzPSdDbGVhciBhbGwgdGhlIGRhdGVzJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBjbGVhciBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFtjbG9zZVRleHQ9J0Nsb3NlJ10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIGNsb3NlIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW2Nsb3NlU3RhdHVzPSdDbG9zZSB0aGUgZGF0ZXBpY2tlciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgY2xvc2UgY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbeWVhclN0YXR1cz0nQ2hhbmdlIHRoZSB5ZWFyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHllYXIgc2VsZWN0aW9uLlxuXHRcdFx0QHByb3BlcnR5IFtlYXJsaWVyVGV4dD0nJiMxNjA7JiMxNjA74payJ10ge3N0cmluZ30gVGV4dCBmb3IgZWFybGllciB5ZWFycy5cblx0XHRcdEBwcm9wZXJ0eSBbbGF0ZXJUZXh0PScmIzE2MDsmIzE2MDvilrwnXSB7c3RyaW5nfSBUZXh0IGZvciBsYXRlciB5ZWFycy5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhTdGF0dXM9J0NoYW5nZSB0aGUgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgbW9udGggc2VsZWN0aW9uLlxuXHRcdFx0QHByb3BlcnR5IFt3ZWVrVGV4dD0nV2snXSB7c3RyaW5nfSBUZXh0IGZvciB3ZWVrIG9mIHRoZSB5ZWFyIGNvbHVtbiBoZWFkZXIuXG5cdFx0XHRAcHJvcGVydHkgW3dlZWtTdGF0dXM9J1dlZWsgb2YgdGhlIHllYXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3Igd2VlayBvZiB0aGUgeWVhciBjb2x1bW4gaGVhZGVyLlxuXHRcdFx0QHByb3BlcnR5IFtkYXlTdGF0dXM9J1NlbGVjdCBERCwmIzE2MDtNJiMxNjA7ZCwmIzE2MDt5eXl5J10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHNlbGVjdGFibGUgZGF5cy5cblx0XHRcdEBwcm9wZXJ0eSBbZGVmYXVsdFN0YXR1cz0nU2VsZWN0IGEgZGF0ZSddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IHNob3duIGJ5IGRlZmF1bHQuXG5cdFx0XHRAcHJvcGVydHkgW2lzUlRMPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGFuZ3VhZ2UgaXMgcmlnaHQtdG8tbGVmdC4gKi9cblx0XHRyZWdpb25hbE9wdGlvbnM6IHsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlL2NvdW50cnkgY29kZVxuXHRcdFx0Jyc6IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5ncyAtIEVuZ2xpc2gvVVNcblx0XHRcdFx0cmVuZGVyZXI6IHt9LCAvLyB0aGlzLmRlZmF1bHRSZW5kZXJlclxuXHRcdFx0XHRwcmV2VGV4dDogJyZsdDtQcmV2Jyxcblx0XHRcdFx0cHJldlN0YXR1czogJ1Nob3cgdGhlIHByZXZpb3VzIG1vbnRoJyxcblx0XHRcdFx0cHJldkp1bXBUZXh0OiAnJmx0OyZsdDsnLFxuXHRcdFx0XHRwcmV2SnVtcFN0YXR1czogJ1Nob3cgdGhlIHByZXZpb3VzIHllYXInLFxuXHRcdFx0XHRuZXh0VGV4dDogJ05leHQmZ3Q7Jyxcblx0XHRcdFx0bmV4dFN0YXR1czogJ1Nob3cgdGhlIG5leHQgbW9udGgnLFxuXHRcdFx0XHRuZXh0SnVtcFRleHQ6ICcmZ3Q7Jmd0OycsXG5cdFx0XHRcdG5leHRKdW1wU3RhdHVzOiAnU2hvdyB0aGUgbmV4dCB5ZWFyJyxcblx0XHRcdFx0Y3VycmVudFRleHQ6ICdDdXJyZW50Jyxcblx0XHRcdFx0Y3VycmVudFN0YXR1czogJ1Nob3cgdGhlIGN1cnJlbnQgbW9udGgnLFxuXHRcdFx0XHR0b2RheVRleHQ6ICdUb2RheScsXG5cdFx0XHRcdHRvZGF5U3RhdHVzOiAnU2hvdyB0b2RheVxcJ3MgbW9udGgnLFxuXHRcdFx0XHRjbGVhclRleHQ6ICdDbGVhcicsXG5cdFx0XHRcdGNsZWFyU3RhdHVzOiAnQ2xlYXIgYWxsIHRoZSBkYXRlcycsXG5cdFx0XHRcdGNsb3NlVGV4dDogJ0Nsb3NlJyxcblx0XHRcdFx0Y2xvc2VTdGF0dXM6ICdDbG9zZSB0aGUgZGF0ZXBpY2tlcicsXG5cdFx0XHRcdHllYXJTdGF0dXM6ICdDaGFuZ2UgdGhlIHllYXInLFxuXHRcdFx0XHRlYXJsaWVyVGV4dDogJyYjMTYwOyYjMTYwO+KWsicsXG5cdFx0XHRcdGxhdGVyVGV4dDogJyYjMTYwOyYjMTYwO+KWvCcsXG5cdFx0XHRcdG1vbnRoU3RhdHVzOiAnQ2hhbmdlIHRoZSBtb250aCcsXG5cdFx0XHRcdHdlZWtUZXh0OiAnV2snLFxuXHRcdFx0XHR3ZWVrU3RhdHVzOiAnV2VlayBvZiB0aGUgeWVhcicsXG5cdFx0XHRcdGRheVN0YXR1czogJ1NlbGVjdCBERCwgTSBkLCB5eXl5Jyxcblx0XHRcdFx0ZGVmYXVsdFN0YXR1czogJ1NlbGVjdCBhIGRhdGUnLFxuXHRcdFx0XHRpc1JUTDogZmFsc2Vcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKiBOYW1lcyBvZiBnZXR0ZXIgbWV0aG9kcyAtIHRob3NlIHRoYXQgY2FuJ3QgYmUgY2hhaW5lZC5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXIgKi9cblx0XHRfZ2V0dGVyczogWydnZXREYXRlJywgJ2lzRGlzYWJsZWQnLCAnaXNTZWxlY3RhYmxlJywgJ3JldHJpZXZlRGF0ZSddLFxuXG5cdFx0X2Rpc2FibGVkOiBbXSxcblx0XHRcblx0XHRfcG9wdXBDbGFzczogJ2NhbGVuZGFycy1wb3B1cCcsIC8vIE1hcmtlciBmb3IgcG9wdXAgZGl2aXNpb25cblx0XHRfdHJpZ2dlckNsYXNzOiAnY2FsZW5kYXJzLXRyaWdnZXInLCAvLyBNYXJrZXIgZm9yIHRyaWdnZXIgZWxlbWVudFxuXHRcdF9kaXNhYmxlQ2xhc3M6ICdjYWxlbmRhcnMtZGlzYWJsZScsIC8vIE1hcmtlciBmb3IgZGlzYWJsZWQgZWxlbWVudFxuXHRcdF9tb250aFllYXJDbGFzczogJ2NhbGVuZGFycy1tb250aC15ZWFyJywgLy8gTWFya2VyIGZvciBtb250aC95ZWFyIGlucHV0c1xuXHRcdF9jdXJNb250aENsYXNzOiAnY2FsZW5kYXJzLW1vbnRoLScsIC8vIE1hcmtlciBmb3IgY3VycmVudCBtb250aC95ZWFyXG5cdFx0X2FueVllYXJDbGFzczogJ2NhbGVuZGFycy1hbnkteWVhcicsIC8vIE1hcmtlciBmb3IgeWVhciBkaXJlY3QgaW5wdXRcblx0XHRfY3VyRG9XQ2xhc3M6ICdjYWxlbmRhcnMtZG93LScsIC8vIE1hcmtlciBmb3IgZGF5IG9mIHdlZWtcblxuXHRcdF9pbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZGVmYXVsdE9wdGlvbnMuY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuXHRcdFx0dGhpcy5yZWdpb25hbE9wdGlvbnNbJyddLnJlbmRlcmVyID0gdGhpcy5kZWZhdWx0UmVuZGVyZXI7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cblx0XHRfaW5zdFNldHRpbmdzOiBmdW5jdGlvbihlbGVtLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4ge3NlbGVjdGVkRGF0ZXM6IFtdLCBkcmF3RGF0ZTogbnVsbCwgcGlja2luZ1JhbmdlOiBmYWxzZSxcblx0XHRcdFx0aW5saW5lOiAoJC5pbkFycmF5KGVsZW1bMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgWydkaXYnLCAnc3BhbiddKSA+IC0xKSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbihuYW1lKSB7IC8vIEdldCBhIHNldHRpbmcgdmFsdWUsIGNvbXB1dGluZyBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoJC5pbkFycmF5KG5hbWUsIFsnZGVmYXVsdERhdGUnLCAnbWluRGF0ZScsICdtYXhEYXRlJ10pID4gLTEpIHsgLy8gRGVjb2RlIGRhdGUgc2V0dGluZ3Ncblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY2FsZW5kYXIuZGV0ZXJtaW5lRGF0ZSh0aGlzLm9wdGlvbnNbbmFtZV0sIG51bGwsXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWREYXRlc1swXSwgdGhpcy5nZXQoJ2RhdGVGb3JtYXQnKSwgdGhpcy5nZXRDb25maWcoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChuYW1lID09PSAnZGF0ZUZvcm1hdCcpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdCB8fCB0aGlzLm9wdGlvbnMuY2FsZW5kYXIubG9jYWwuZGF0ZUZvcm1hdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y3VyTWluRGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuICh0aGlzLnBpY2tpbmdSYW5nZSA/IHRoaXMuc2VsZWN0ZWREYXRlc1swXSA6IHRoaXMuZ2V0KCdtaW5EYXRlJykpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRDb25maWc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB7ZGF5TmFtZXNTaG9ydDogdGhpcy5vcHRpb25zLmRheU5hbWVzU2hvcnQsIGRheU5hbWVzOiB0aGlzLm9wdGlvbnMuZGF5TmFtZXMsXG5cdFx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQ6IHRoaXMub3B0aW9ucy5tb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXM6IHRoaXMub3B0aW9ucy5tb250aE5hbWVzLFxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlV2VlazogdGhpcy5vcHRpb25zLmNhbGN1bGF0ZVdlZWssIHNob3J0WWVhckN1dG9mZjogdGhpcy5vcHRpb25zLnNob3J0WWVhckN1dG9mZn07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdF9wb3N0QXR0YWNoOiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHBsdWdpbi5fY2hlY2tNaW5NYXgoKGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fFxuXHRcdFx0XHRcdGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCksIGluc3QpO1xuXHRcdFx0XHRpbnN0LnByZXZEYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtWzBdKTtcblx0XHRcdFx0aWYgKCQuZm4ubW91c2V3aGVlbCkge1xuXHRcdFx0XHRcdGVsZW0ubW91c2V3aGVlbCh0aGlzLl9kb01vdXNlV2hlZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5fYXR0YWNobWVudHMoZWxlbSwgaW5zdCk7XG5cdFx0XHRcdGVsZW0ub24oJ2tleWRvd24uJyArIGluc3QubmFtZSwgdGhpcy5fa2V5RG93bikub24oJ2tleXByZXNzLicgKyBpbnN0Lm5hbWUsIHRoaXMuX2tleVByZXNzKS5cblx0XHRcdFx0XHRvbigna2V5dXAuJyArIGluc3QubmFtZSwgdGhpcy5fa2V5VXApO1xuXHRcdFx0XHRpZiAoZWxlbS5hdHRyKCdkaXNhYmxlZCcpKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNhYmxlKGVsZW1bMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9vcHRpb25zQ2hhbmdlZDogZnVuY3Rpb24oZWxlbSwgaW5zdCwgb3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMuY2FsZW5kYXIgJiYgb3B0aW9ucy5jYWxlbmRhciAhPT0gaW5zdC5vcHRpb25zLmNhbGVuZGFyKSB7XG5cdFx0XHRcdHZhciBkaXNjYXJkRGF0ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gKHR5cGVvZiBpbnN0Lm9wdGlvbnNbbmFtZV0gPT09ICdvYmplY3QnID8gbnVsbCA6IGluc3Qub3B0aW9uc1tuYW1lXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7ZGVmYXVsdERhdGU6IGRpc2NhcmREYXRlKCdkZWZhdWx0RGF0ZScpLFxuXHRcdFx0XHRcdG1pbkRhdGU6IGRpc2NhcmREYXRlKCdtaW5EYXRlJyksIG1heERhdGU6IGRpc2NhcmREYXRlKCdtYXhEYXRlJyl9LCBvcHRpb25zKTtcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW107XG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGRhdGVzID0gaW5zdC5zZWxlY3RlZERhdGVzO1xuXHRcdFx0JC5leHRlbmQoaW5zdC5vcHRpb25zLCBvcHRpb25zKTtcblx0XHRcdHRoaXMuc2V0RGF0ZShlbGVtWzBdLCBkYXRlcywgbnVsbCwgZmFsc2UsIHRydWUpO1xuXHRcdFx0aW5zdC5waWNraW5nUmFuZ2UgPSBmYWxzZTtcblx0XHRcdHZhciBjYWxlbmRhciA9IGluc3Qub3B0aW9ucy5jYWxlbmRhcjtcblx0XHRcdHZhciBkZWZhdWx0RGF0ZSA9IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpO1xuXHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHRoaXMuX2NoZWNrTWluTWF4KChkZWZhdWx0RGF0ZSA/IGRlZmF1bHREYXRlIDogaW5zdC5kcmF3RGF0ZSkgfHxcblx0XHRcdFx0ZGVmYXVsdERhdGUgfHwgY2FsZW5kYXIudG9kYXkoKSwgaW5zdCkubmV3RGF0ZSgpO1xuXHRcdFx0aWYgKCFpbnN0LmlubGluZSkge1xuXHRcdFx0XHR0aGlzLl9hdHRhY2htZW50cyhlbGVtLCBpbnN0KTtcblx0XHRcdH1cblx0XHRcdGlmIChpbnN0LmlubGluZSB8fCBpbnN0LmRpdikge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbVswXSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBBdHRhY2ggZXZlbnRzIGFuZCB0cmlnZ2VyLCBpZiBuZWNlc3NhcnkuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge2pRdWVyeX0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuICovXG5cdFx0X2F0dGFjaG1lbnRzOiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XG5cdFx0XHRlbGVtLm9mZignZm9jdXMuJyArIGluc3QubmFtZSk7XG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNob3dPbkZvY3VzKSB7XG5cdFx0XHRcdGVsZW0ub24oJ2ZvY3VzLicgKyBpbnN0Lm5hbWUsIHRoaXMuc2hvdyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5zdC50cmlnZ2VyKSB7XG5cdFx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHZhciB0cmlnZ2VyID0gaW5zdC5vcHRpb25zLnNob3dUcmlnZ2VyO1xuXHRcdFx0aW5zdC50cmlnZ2VyID0gKCF0cmlnZ2VyID8gJChbXSkgOlxuXHRcdFx0XHQkKHRyaWdnZXIpLmNsb25lKCkucmVtb3ZlQXR0cignaWQnKS5hZGRDbGFzcyh0aGlzLl90cmlnZ2VyQ2xhc3MpXG5cdFx0XHRcdFx0W2luc3Qub3B0aW9ucy5pc1JUTCA/ICdpbnNlcnRCZWZvcmUnIDogJ2luc2VydEFmdGVyJ10oZWxlbSkuXG5cdFx0XHRcdFx0Y2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXBsdWdpbi5pc0Rpc2FibGVkKGVsZW1bMF0pKSB7XG5cdFx0XHRcdFx0XHRcdHBsdWdpbltwbHVnaW4uY3VySW5zdCA9PT0gaW5zdCA/ICdoaWRlJyA6ICdzaG93J10oZWxlbVswXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkpO1xuXHRcdFx0dGhpcy5fYXV0b1NpemUoZWxlbSwgaW5zdCk7XG5cdFx0XHR2YXIgZGF0ZXMgPSB0aGlzLl9leHRyYWN0RGF0ZXMoaW5zdCwgZWxlbS52YWwoKSk7XG5cdFx0XHRpZiAoZGF0ZXMpIHtcblx0XHRcdFx0dGhpcy5zZXREYXRlKGVsZW1bMF0sIGRhdGVzLCBudWxsLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHZhciBkZWZhdWx0RGF0ZSA9IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpO1xuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5zZWxlY3REZWZhdWx0RGF0ZSAmJiBkZWZhdWx0RGF0ZSAmJiBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0RGF0ZShlbGVtWzBdLCAoZGVmYXVsdERhdGUgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBBcHBseSB0aGUgbWF4aW11bSBsZW5ndGggZm9yIHRoZSBkYXRlIGZvcm1hdC5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZWxlbSB7alF1ZXJ5fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy4gKi9cblx0XHRfYXV0b1NpemU6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuYXV0b1NpemUgJiYgIWluc3QuaW5saW5lKSB7XG5cdFx0XHRcdHZhciBjYWxlbmRhciA9IGluc3Qub3B0aW9ucy5jYWxlbmRhcjtcblx0XHRcdFx0dmFyIGRhdGUgPSBjYWxlbmRhci5uZXdEYXRlKDIwMDksIDEwLCAyMCk7IC8vIEVuc3VyZSBkb3VibGUgZGlnaXRzXG5cdFx0XHRcdHZhciBkYXRlRm9ybWF0ID0gaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKTtcblx0XHRcdFx0aWYgKGRhdGVGb3JtYXQubWF0Y2goL1tETV0vKSkge1xuXHRcdFx0XHRcdHZhciBmaW5kTWF4ID0gZnVuY3Rpb24obmFtZXMpIHtcblx0XHRcdFx0XHRcdHZhciBtYXggPSAwO1xuXHRcdFx0XHRcdFx0dmFyIG1heEkgPSAwO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAobmFtZXNbaV0ubGVuZ3RoID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0bWF4ID0gbmFtZXNbaV0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdG1heEkgPSBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF4STtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGRhdGUubW9udGgoZmluZE1heChjYWxlbmRhci5sb2NhbFtkYXRlRm9ybWF0Lm1hdGNoKC9NTS8pID8gLy8gTG9uZ2VzdCBtb250aFxuXHRcdFx0XHRcdFx0J21vbnRoTmFtZXMnIDogJ21vbnRoTmFtZXNTaG9ydCddKSArIDEpO1xuXHRcdFx0XHRcdGRhdGUuZGF5KGZpbmRNYXgoY2FsZW5kYXIubG9jYWxbZGF0ZUZvcm1hdC5tYXRjaCgvREQvKSA/IC8vIExvbmdlc3QgZGF5XG5cdFx0XHRcdFx0XHQnZGF5TmFtZXMnIDogJ2RheU5hbWVzU2hvcnQnXSkgKyAyMCAtIGRhdGUuZGF5T2ZXZWVrKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QuZWxlbS5hdHRyKCdzaXplJywgZGF0ZS5mb3JtYXREYXRlKGRhdGVGb3JtYXQpLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9wcmVEZXN0cm95OiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XG5cdFx0XHRpZiAoaW5zdC50cmlnZ2VyKSB7XG5cdFx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdGVsZW0uZW1wdHkoKS5vZmYoJy4nICsgaW5zdC5uYW1lKTtcblx0XHRcdGlmIChpbnN0LmlubGluZSAmJiAkLmZuLm1vdXNld2hlZWwpIHtcblx0XHRcdFx0ZWxlbS51bm1vdXNld2hlZWwoKTtcblx0XHRcdH1cblx0XHRcdGlmICghaW5zdC5pbmxpbmUgJiYgaW5zdC5vcHRpb25zLmF1dG9TaXplKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cignc2l6ZScpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogQXBwbHkgbXVsdGlwbGUgZXZlbnQgZnVuY3Rpb25zLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGZucyB7ZnVuY3Rpb259IFRoZSBmdW5jdGlvbnMgdG8gYXBwbHkuXG5cdFx0XHRAZXhhbXBsZSBvblNob3c6IG11bHRpcGxlRXZlbnRzKGZuMSwgZm4yLCAuLi4pICovXG5cdFx0bXVsdGlwbGVFdmVudHM6IGZ1bmN0aW9uKGZucykge1xuXHRcdFx0dmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGZ1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKiBFbmFibGUgdGhlIGNvbnRyb2wuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2VuYWJsZScpICovXG5cdFx0ZW5hYmxlOiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRlbGVtID0gJChlbGVtKTtcblx0XHRcdGlmICghZWxlbS5oYXNDbGFzcyh0aGlzLl9nZXRNYXJrZXIoKSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKGluc3QuaW5saW5lKSB7XG5cdFx0XHRcdGVsZW0uY2hpbGRyZW4oJy4nICsgdGhpcy5fZGlzYWJsZUNsYXNzKS5yZW1vdmUoKS5lbmQoKS5cblx0XHRcdFx0XHRmaW5kKCdidXR0b24sc2VsZWN0JykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSkuZW5kKCkuXG5cdFx0XHRcdFx0ZmluZCgnYScpLmF0dHIoJ2hyZWYnLCAnamF2YXNjcmlwdDp2b2lkKDApJyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZWxlbS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblx0XHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcignYnV0dG9uLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpLmVuZCgpLlxuXHRcdFx0XHRcdGZpbHRlcignaW1nLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLmNzcyh7b3BhY2l0eTogJzEuMCcsIGN1cnNvcjogJyd9KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2Rpc2FibGVkID0gJC5tYXAodGhpcy5fZGlzYWJsZWQsXG5cdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IGVsZW1bMF0gPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gRGVsZXRlIGVudHJ5XG5cdFx0fSxcblxuXHRcdC8qKiBEaXNhYmxlIHRoZSBjb250cm9sLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdkaXNhYmxlJykgKi9cblx0XHRkaXNhYmxlOiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRlbGVtID0gJChlbGVtKTtcblx0XHRcdGlmICghZWxlbS5oYXNDbGFzcyh0aGlzLl9nZXRNYXJrZXIoKSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKGluc3QuaW5saW5lKSB7XG5cdFx0XHRcdHZhciBpbmxpbmUgPSBlbGVtLmNoaWxkcmVuKCc6bGFzdCcpO1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gaW5saW5lLm9mZnNldCgpO1xuXHRcdFx0XHR2YXIgcmVsT2Zmc2V0ID0ge2xlZnQ6IDAsIHRvcDogMH07XG5cdFx0XHRcdGlubGluZS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoJCh0aGlzKS5jc3MoJ3Bvc2l0aW9uJykgPT09ICdyZWxhdGl2ZScpIHtcblx0XHRcdFx0XHRcdHJlbE9mZnNldCA9ICQodGhpcykub2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dmFyIHpJbmRleCA9IGVsZW0uY3NzKCd6SW5kZXgnKTtcblx0XHRcdFx0ekluZGV4ID0gKHpJbmRleCA9PT0gJ2F1dG8nID8gMCA6IHBhcnNlSW50KHpJbmRleCwgMTApKSArIDE7XG5cdFx0XHRcdGVsZW0ucHJlcGVuZCgnPGRpdiBjbGFzcz1cIicgKyB0aGlzLl9kaXNhYmxlQ2xhc3MgKyAnXCIgc3R5bGU9XCInICtcblx0XHRcdFx0XHQnd2lkdGg6ICcgKyBpbmxpbmUub3V0ZXJXaWR0aCgpICsgJ3B4OyBoZWlnaHQ6ICcgKyBpbmxpbmUub3V0ZXJIZWlnaHQoKSArXG5cdFx0XHRcdFx0J3B4OyBsZWZ0OiAnICsgKG9mZnNldC5sZWZ0IC0gcmVsT2Zmc2V0LmxlZnQpICsgJ3B4OyB0b3A6ICcgK1xuXHRcdFx0XHRcdChvZmZzZXQudG9wIC0gcmVsT2Zmc2V0LnRvcCkgKyAncHg7IHotaW5kZXg6ICcgKyB6SW5kZXggKyAnXCI+PC9kaXY+JykuXG5cdFx0XHRcdFx0ZmluZCgnYnV0dG9uLHNlbGVjdCcpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSkuZW5kKCkuXG5cdFx0XHRcdFx0ZmluZCgnYScpLnJlbW92ZUF0dHIoJ2hyZWYnKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlbGVtLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cdFx0XHRcdGluc3QudHJpZ2dlci5maWx0ZXIoJ2J1dHRvbi4nICsgdGhpcy5fdHJpZ2dlckNsYXNzKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLmVuZCgpLlxuXHRcdFx0XHRcdGZpbHRlcignaW1nLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLmNzcyh7b3BhY2l0eTogJzAuNScsIGN1cnNvcjogJ2RlZmF1bHQnfSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kaXNhYmxlZCA9ICQubWFwKHRoaXMuX2Rpc2FibGVkLFxuXHRcdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSBlbGVtWzBdID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIERlbGV0ZSBlbnRyeVxuXHRcdFx0dGhpcy5fZGlzYWJsZWQucHVzaChlbGVtWzBdKTtcblx0XHR9LFxuXG5cdFx0LyoqIElzIHRoZSBmaXJzdCBmaWVsZCBpbiBhIGpRdWVyeSBjb2xsZWN0aW9uIGRpc2FibGVkIGFzIGEgZGF0ZXBpY2tlcj9cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgZGlzYWJsZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBlbmFibGVkLlxuXHRcdFx0QGV4YW1wbGUgaWYgKCQoc2VsZWN0b3IpLmRhdGVwaWNrKCdpc0Rpc2FibGVkJykpIHsuLi59ICovXG5cdFx0aXNEaXNhYmxlZDogZnVuY3Rpb24oZWxlbSkge1xuXHRcdFx0cmV0dXJuIChlbGVtICYmICQuaW5BcnJheShlbGVtLCB0aGlzLl9kaXNhYmxlZCkgPiAtMSk7XG5cdFx0fSxcblxuXHRcdC8qKiBTaG93IGEgcG9wdXAgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFdmVudHxFbGVtZW50fSBhIGZvY3VzIGV2ZW50IG9yIHRoZSBjb250cm9sIHRvIHVzZS5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzaG93JykgKi9cblx0XHRzaG93OiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRlbGVtID0gJChlbGVtLnRhcmdldCB8fCBlbGVtKTtcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKHBsdWdpbi5jdXJJbnN0ID09PSBpbnN0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChwbHVnaW4uY3VySW5zdCkge1xuXHRcdFx0XHRwbHVnaW4uaGlkZShwbHVnaW4uY3VySW5zdCwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xuXHRcdFx0XHQvLyBSZXRyaWV2ZSBleGlzdGluZyBkYXRlKHMpXG5cdFx0XHRcdGluc3QubGFzdFZhbCA9IG51bGw7XG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IHBsdWdpbi5fZXh0cmFjdERhdGVzKGluc3QsIGVsZW0udmFsKCkpO1xuXHRcdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRpbnN0LmRyYXdEYXRlID0gcGx1Z2luLl9jaGVja01pbk1heCgoaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8XG5cdFx0XHRcdFx0aW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSwgaW5zdCk7XG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKTtcblx0XHRcdFx0cGx1Z2luLmN1ckluc3QgPSBpbnN0O1xuXHRcdFx0XHQvLyBHZW5lcmF0ZSBjb250ZW50XG5cdFx0XHRcdHBsdWdpbi5fdXBkYXRlKGVsZW1bMF0sIHRydWUpO1xuXHRcdFx0XHQvLyBBZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcblx0XHRcdFx0dmFyIG9mZnNldCA9IHBsdWdpbi5fY2hlY2tPZmZzZXQoaW5zdCk7XG5cdFx0XHRcdGluc3QuZGl2LmNzcyh7bGVmdDogb2Zmc2V0LmxlZnQsIHRvcDogb2Zmc2V0LnRvcH0pO1xuXHRcdFx0XHQvLyBBbmQgZGlzcGxheVxuXHRcdFx0XHR2YXIgc2hvd0FuaW0gPSBpbnN0Lm9wdGlvbnMuc2hvd0FuaW07XG5cdFx0XHRcdHZhciBzaG93U3BlZWQgPSBpbnN0Lm9wdGlvbnMuc2hvd1NwZWVkO1xuXHRcdFx0XHRzaG93U3BlZWQgPSAoc2hvd1NwZWVkID09PSAnbm9ybWFsJyAmJiAkLnVpICYmXG5cdFx0XHRcdFx0cGFyc2VJbnQoJC51aS52ZXJzaW9uLnN1YnN0cmluZygyKSkgPj0gOCA/ICdfZGVmYXVsdCcgOiBzaG93U3BlZWQpO1xuXHRcdFx0XHRpZiAoJC5lZmZlY3RzICYmICgkLmVmZmVjdHNbc2hvd0FuaW1dIHx8ICgkLmVmZmVjdHMuZWZmZWN0ICYmICQuZWZmZWN0cy5lZmZlY3Rbc2hvd0FuaW1dKSkpIHtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGluc3QuZGl2LmRhdGEoKTsgLy8gVXBkYXRlIG9sZCBlZmZlY3RzIGRhdGFcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHRcdFx0XHRcdFx0aWYgKGtleS5tYXRjaCgvXmVjXFwuc3RvcmFnZVxcLi8pKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IGluc3QuX21haW5EaXYuY3NzKGtleS5yZXBsYWNlKC9lY1xcLnN0b3JhZ2VcXC4vLCAnJykpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnN0LmRpdi5kYXRhKGRhdGEpLnNob3coc2hvd0FuaW0sIGluc3Qub3B0aW9ucy5zaG93T3B0aW9ucywgc2hvd1NwZWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpbnN0LmRpdltzaG93QW5pbSB8fCAnc2hvdyddKHNob3dBbmltID8gc2hvd1NwZWVkIDogMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEV4dHJhY3QgcG9zc2libGUgZGF0ZXMgZnJvbSBhIHN0cmluZy5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSB0ZXh0IHtzdHJpbmd9IFRoZSB0ZXh0IHRvIGV4dHJhY3QgZnJvbS5cblx0XHRcdEByZXR1cm4ge0NEYXRlW119IFRoZSBleHRyYWN0ZWQgZGF0ZXMuICovXG5cdFx0X2V4dHJhY3REYXRlczogZnVuY3Rpb24oaW5zdCwgZGF0ZXNUZXh0KSB7XG5cdFx0XHRpZiAoZGF0ZXNUZXh0ID09PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aW5zdC5sYXN0VmFsID0gZGF0ZXNUZXh0O1xuXHRcdFx0ZGF0ZXNUZXh0ID0gZGF0ZXNUZXh0LnNwbGl0KGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCA/IGluc3Qub3B0aW9ucy5tdWx0aVNlcGFyYXRvciA6XG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyBpbnN0Lm9wdGlvbnMucmFuZ2VTZXBhcmF0b3IgOiAnXFx4MDAnKSk7XG5cdFx0XHR2YXIgZGF0ZXMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0ZXNUZXh0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIGRhdGUgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIucGFyc2VEYXRlKGluc3QuZ2V0KCdkYXRlRm9ybWF0JyksIGRhdGVzVGV4dFtpXSk7XG5cdFx0XHRcdFx0aWYgKGRhdGUpIHtcblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoZGF0ZXNbal0uY29tcGFyZVRvKGRhdGUpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGVzLnB1c2goZGF0ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly8gSWdub3JlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRhdGVzLnNwbGljZShpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgfHwgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IDIgOiAxKSwgZGF0ZXMubGVuZ3RoKTtcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgJiYgZGF0ZXMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGRhdGVzWzFdID0gZGF0ZXNbMF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0ZXM7XG5cdFx0fSxcblxuXHRcdC8qKiBVcGRhdGUgdGhlIGRhdGVwaWNrZXIgZGlzcGxheS5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZWxlbSB7RXZlbnR8RWxlbWVudH0gYSBmb2N1cyBldmVudCBvciB0aGUgY29udHJvbCB0byB1c2UuXG5cdFx0XHRAcGFyYW0gaGlkZGVuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBpbml0aWFsbHkgaGlkZSB0aGUgZGF0ZXBpY2tlci4gKi9cblx0XHRfdXBkYXRlOiBmdW5jdGlvbihlbGVtLCBoaWRkZW4pIHtcblx0XHRcdGVsZW0gPSAkKGVsZW0udGFyZ2V0IHx8IGVsZW0pO1xuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xuXHRcdFx0XHRpZiAoaW5zdC5pbmxpbmUgfHwgcGx1Z2luLmN1ckluc3QgPT09IGluc3QpIHtcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vbkNoYW5nZU1vbnRoWWVhcikgJiYgKCFpbnN0LnByZXZEYXRlIHx8XG5cdFx0XHRcdFx0XHRcdGluc3QucHJldkRhdGUueWVhcigpICE9PSBpbnN0LmRyYXdEYXRlLnllYXIoKSB8fFxuXHRcdFx0XHRcdFx0XHRpbnN0LnByZXZEYXRlLm1vbnRoKCkgIT09IGluc3QuZHJhd0RhdGUubW9udGgoKSkpIHtcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5vbkNoYW5nZU1vbnRoWWVhci5hcHBseShlbGVtWzBdLFxuXHRcdFx0XHRcdFx0XHRbaW5zdC5kcmF3RGF0ZS55ZWFyKCksIGluc3QuZHJhd0RhdGUubW9udGgoKV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcblx0XHRcdFx0XHR2YXIgaW5kZXggPSAkKCdhLCA6aW5wdXQnLCBlbGVtKS5pbmRleCgkKCc6Zm9jdXMnLCBlbGVtKSk7XG5cdFx0XHRcdFx0ZWxlbS5odG1sKHRoaXMuX2dlbmVyYXRlQ29udGVudChlbGVtWzBdLCBpbnN0KSk7XG5cdFx0XHRcdFx0dmFyIGZvY3VzID0gZWxlbS5maW5kKCdhLCA6aW5wdXQnKTtcblx0XHRcdFx0XHRmb2N1cy5lcShNYXRoLm1heChNYXRoLm1pbihpbmRleCwgZm9jdXMubGVuZ3RoIC0gMSksIDApKS5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHBsdWdpbi5jdXJJbnN0ID09PSBpbnN0KSB7XG5cdFx0XHRcdFx0aWYgKCFpbnN0LmRpdikge1xuXHRcdFx0XHRcdFx0aW5zdC5kaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKHRoaXMuX3BvcHVwQ2xhc3MpLlxuXHRcdFx0XHRcdFx0XHRjc3Moe2Rpc3BsYXk6IChoaWRkZW4gPyAnbm9uZScgOiAnc3RhdGljJyksIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0XHRcdGxlZnQ6IGVsZW0ub2Zmc2V0KCkubGVmdCwgdG9wOiBlbGVtLm9mZnNldCgpLnRvcCArIGVsZW0ub3V0ZXJIZWlnaHQoKX0pLlxuXHRcdFx0XHRcdFx0XHRhcHBlbmRUbygkKGluc3Qub3B0aW9ucy5wb3B1cENvbnRhaW5lciB8fCAnYm9keScpKTtcblx0XHRcdFx0XHRcdGlmICgkLmZuLm1vdXNld2hlZWwpIHtcblx0XHRcdFx0XHRcdFx0aW5zdC5kaXYubW91c2V3aGVlbCh0aGlzLl9kb01vdXNlV2hlZWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnN0LmRpdi5odG1sKHRoaXMuX2dlbmVyYXRlQ29udGVudChlbGVtWzBdLCBpbnN0KSk7XG5cdFx0XHRcdFx0ZWxlbS5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBVcGRhdGUgdGhlIGlucHV0IGZpZWxkIGFuZCBhbnkgYWx0ZXJuYXRlIGZpZWxkIHdpdGggdGhlIGN1cnJlbnQgZGF0ZXMuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIHVzZS5cblx0XHRcdEBwYXJhbSBrZXlVcCB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY29taW5nIGZyb20gPGNvZGU+a2V5VXA8L2NvZGU+IHByb2Nlc3NpbmcgKGludGVybmFsKS4gKi9cblx0XHRfdXBkYXRlSW5wdXQ6IGZ1bmN0aW9uKGVsZW0sIGtleVVwKSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSAnJztcblx0XHRcdFx0dmFyIGFsdFZhbHVlID0gJyc7XG5cdFx0XHRcdHZhciBzZXAgPSAoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0ID8gaW5zdC5vcHRpb25zLm11bHRpU2VwYXJhdG9yIDpcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmFuZ2VTZXBhcmF0b3IpO1xuXHRcdFx0XHR2YXIgY2FsZW5kYXIgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXI7XG5cdFx0XHRcdHZhciBkYXRlRm9ybWF0ID0gaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKTtcblx0XHRcdFx0dmFyIGFsdEZvcm1hdCA9IGluc3Qub3B0aW9ucy5hbHRGb3JtYXQgfHwgZGF0ZUZvcm1hdDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YWx1ZSArPSAoa2V5VXAgPyAnJyA6IChpID4gMCA/IHNlcCA6ICcnKSArXG5cdFx0XHRcdFx0XHRjYWxlbmRhci5mb3JtYXREYXRlKGRhdGVGb3JtYXQsIGluc3Quc2VsZWN0ZWREYXRlc1tpXSkpO1xuXHRcdFx0XHRcdGFsdFZhbHVlICs9IChpID4gMCA/IHNlcCA6ICcnKSArXG5cdFx0XHRcdFx0XHRjYWxlbmRhci5mb3JtYXREYXRlKGFsdEZvcm1hdCwgaW5zdC5zZWxlY3RlZERhdGVzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWluc3QuaW5saW5lICYmICFrZXlVcCkge1xuXHRcdFx0XHRcdCQoZWxlbSkudmFsKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKGluc3Qub3B0aW9ucy5hbHRGaWVsZCkudmFsKGFsdFZhbHVlKTtcblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMub25TZWxlY3QpICYmICFrZXlVcCAmJiAhaW5zdC5pblNlbGVjdCkge1xuXHRcdFx0XHRcdGluc3QuaW5TZWxlY3QgPSB0cnVlOyAvLyBQcmV2ZW50IGVuZGxlc3MgbG9vcHNcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMub25TZWxlY3QuYXBwbHkoZWxlbSwgW2luc3Quc2VsZWN0ZWREYXRlc10pO1xuXHRcdFx0XHRcdGluc3QuaW5TZWxlY3QgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIHNpemUgb2YgbGVmdCBhbmQgdG9wIGJvcmRlcnMgZm9yIGFuIGVsZW1lbnQuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge2pRdWVyeX0gVGhlIGVsZW1lbnQgb2YgaW50ZXJlc3QuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJbXX0gVGhlIGxlZnQgYW5kIHRvcCBib3JkZXJzLiAqL1xuXHRcdF9nZXRCb3JkZXJzOiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHR2YXIgY29udmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB7dGhpbjogMSwgbWVkaXVtOiAzLCB0aGljazogNX1bdmFsdWVdIHx8IHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBbcGFyc2VGbG9hdChjb252ZXJ0KGVsZW0uY3NzKCdib3JkZXItbGVmdC13aWR0aCcpKSksXG5cdFx0XHRcdHBhcnNlRmxvYXQoY29udmVydChlbGVtLmNzcygnYm9yZGVyLXRvcC13aWR0aCcpKSldO1xuXHRcdH0sXG5cblx0XHQvKiogQ2hlY2sgcG9zaXRpb25pbmcgdG8gcmVtYWluIG9uIHRoZSBzY3JlZW4uXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IFRoZSB1cGRhdGVkIG9mZnNldCBmb3IgdGhlIGRhdGVwaWNrZXIuICovXG5cdFx0X2NoZWNrT2Zmc2V0OiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHR2YXIgYmFzZSA9IChpbnN0LmVsZW0uaXMoJzpoaWRkZW4nKSAmJiBpbnN0LnRyaWdnZXIgPyBpbnN0LnRyaWdnZXIgOiBpbnN0LmVsZW0pO1xuXHRcdFx0dmFyIG9mZnNldCA9IGJhc2Uub2Zmc2V0KCk7XG5cdFx0XHR2YXIgYnJvd3NlcldpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG5cdFx0XHR2YXIgYnJvd3NlckhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKTtcblx0XHRcdGlmIChicm93c2VyV2lkdGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHRcdH1cblx0XHRcdHZhciBpc0ZpeGVkID0gZmFsc2U7XG5cdFx0XHQkKGluc3QuZWxlbSkucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlzRml4ZWQgfD0gJCh0aGlzKS5jc3MoJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCc7XG5cdFx0XHRcdHJldHVybiAhaXNGaXhlZDtcblx0XHRcdH0pO1xuXHRcdFx0dmFyIHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHR2YXIgc2Nyb2xsWSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG5cdFx0XHR2YXIgYWJvdmUgPSBvZmZzZXQudG9wIC0gKGlzRml4ZWQgPyBzY3JvbGxZIDogMCkgLSBpbnN0LmRpdi5vdXRlckhlaWdodCgpO1xuXHRcdFx0dmFyIGJlbG93ID0gb2Zmc2V0LnRvcCAtIChpc0ZpeGVkID8gc2Nyb2xsWSA6IDApICsgYmFzZS5vdXRlckhlaWdodCgpO1xuXHRcdFx0dmFyIGFsaWduTCA9IG9mZnNldC5sZWZ0IC0gKGlzRml4ZWQgPyBzY3JvbGxYIDogMCk7XG5cdFx0XHR2YXIgYWxpZ25SID0gb2Zmc2V0LmxlZnQgLSAoaXNGaXhlZCA/IHNjcm9sbFggOiAwKSArIGJhc2Uub3V0ZXJXaWR0aCgpIC0gaW5zdC5kaXYub3V0ZXJXaWR0aCgpO1xuXHRcdFx0dmFyIHRvb1dpZGUgPSAob2Zmc2V0LmxlZnQgLSBzY3JvbGxYICsgaW5zdC5kaXYub3V0ZXJXaWR0aCgpKSA+IGJyb3dzZXJXaWR0aDtcblx0XHRcdHZhciB0b29IaWdoID0gKG9mZnNldC50b3AgLSBzY3JvbGxZICsgaW5zdC5lbGVtLm91dGVySGVpZ2h0KCkgK1xuXHRcdFx0XHRpbnN0LmRpdi5vdXRlckhlaWdodCgpKSA+IGJyb3dzZXJIZWlnaHQ7XG5cdFx0XHRpbnN0LmRpdi5jc3MoJ3Bvc2l0aW9uJywgaXNGaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnKTtcblx0XHRcdHZhciBhbGlnbm1lbnQgPSBpbnN0Lm9wdGlvbnMuYWxpZ25tZW50O1xuXHRcdFx0aWYgKGFsaWdubWVudCA9PT0gJ3RvcExlZnQnKSB7XG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiBhbGlnbkwsIHRvcDogYWJvdmV9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoYWxpZ25tZW50ID09PSAndG9wUmlnaHQnKSB7XG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiBhbGlnblIsIHRvcDogYWJvdmV9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoYWxpZ25tZW50ID09PSAnYm90dG9tTGVmdCcpIHtcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduTCwgdG9wOiBiZWxvd307XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICdib3R0b21SaWdodCcpIHtcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduUiwgdG9wOiBiZWxvd307XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICd0b3AnKSB7XG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiAoaW5zdC5vcHRpb25zLmlzUlRMIHx8IHRvb1dpZGUgPyBhbGlnblIgOiBhbGlnbkwpLCB0b3A6IGFib3ZlfTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBib3R0b21cblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IChpbnN0Lm9wdGlvbnMuaXNSVEwgfHwgdG9vV2lkZSA/IGFsaWduUiA6IGFsaWduTCksXG5cdFx0XHRcdFx0dG9wOiAodG9vSGlnaCA/IGFib3ZlIDogYmVsb3cpfTtcblx0XHRcdH1cblx0XHRcdG9mZnNldC5sZWZ0ID0gTWF0aC5tYXgoKGlzRml4ZWQgPyAwIDogc2Nyb2xsWCksIG9mZnNldC5sZWZ0KTtcblx0XHRcdG9mZnNldC50b3AgPSBNYXRoLm1heCgoaXNGaXhlZCA/IDAgOiBzY3JvbGxZKSwgb2Zmc2V0LnRvcCk7XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH0sXG5cblx0XHQvKiogQ2xvc2UgZGF0ZSBwaWNrZXIgaWYgY2xpY2tlZCBlbHNld2hlcmUuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtNb3VzZUV2ZW50fSBUaGUgbW91c2UgY2xpY2sgdG8gY2hlY2suICovXG5cdFx0X2NoZWNrRXh0ZXJuYWxDbGljazogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmICghcGx1Z2luLmN1ckluc3QpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGVsZW0gPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRpZiAoZWxlbS5jbG9zZXN0KCcuJyArIHBsdWdpbi5fcG9wdXBDbGFzcyArICcsLicgKyBwbHVnaW4uX3RyaWdnZXJDbGFzcykubGVuZ3RoID09PSAwICYmXG5cdFx0XHRcdFx0IWVsZW0uaGFzQ2xhc3MocGx1Z2luLl9nZXRNYXJrZXIoKSkpIHtcblx0XHRcdFx0cGx1Z2luLmhpZGUocGx1Z2luLmN1ckluc3QpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogSGlkZSBhIHBvcHVwIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudHxvYmplY3R9IFRoZSBjb250cm9sIHRvIHVzZSBvciB0aGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSBpbW1lZGlhdGUge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGNsb3NlIGltbWVkaWF0ZWx5IHdpdGhvdXQgYW5pbWF0aW9uIChpbnRlcm5hbCkuXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnaGlkZScpICovXG5cdFx0aGlkZTogZnVuY3Rpb24oZWxlbSwgaW1tZWRpYXRlKSB7XG5cdFx0XHRpZiAoIWVsZW0pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKCQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xuXHRcdFx0XHRpbnN0ID0gZWxlbTtcblx0XHRcdH1cblx0XHRcdGlmIChpbnN0ICYmIGluc3QgPT09IHBsdWdpbi5jdXJJbnN0KSB7XG5cdFx0XHRcdHZhciBzaG93QW5pbSA9IChpbW1lZGlhdGUgPyAnJyA6IGluc3Qub3B0aW9ucy5zaG93QW5pbSk7XG5cdFx0XHRcdHZhciBzaG93U3BlZWQgPSBpbnN0Lm9wdGlvbnMuc2hvd1NwZWVkO1xuXHRcdFx0XHRzaG93U3BlZWQgPSAoc2hvd1NwZWVkID09PSAnbm9ybWFsJyAmJiAkLnVpICYmXG5cdFx0XHRcdFx0cGFyc2VJbnQoJC51aS52ZXJzaW9uLnN1YnN0cmluZygyKSkgPj0gOCA/ICdfZGVmYXVsdCcgOiBzaG93U3BlZWQpO1xuXHRcdFx0XHR2YXIgcG9zdFByb2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIWluc3QuZGl2KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc3QuZGl2LnJlbW92ZSgpO1xuXHRcdFx0XHRcdGluc3QuZGl2ID0gbnVsbDtcblx0XHRcdFx0XHRwbHVnaW4uY3VySW5zdCA9IG51bGw7XG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMub25DbG9zZSkpIHtcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5vbkNsb3NlLmFwcGx5KGVsZW0sIFtpbnN0LnNlbGVjdGVkRGF0ZXNdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGluc3QuZGl2LnN0b3AoKTtcblx0XHRcdFx0aWYgKCQuZWZmZWN0cyAmJiAoJC5lZmZlY3RzW3Nob3dBbmltXSB8fCAoJC5lZmZlY3RzLmVmZmVjdCAmJiAkLmVmZmVjdHMuZWZmZWN0W3Nob3dBbmltXSkpKSB7XG5cdFx0XHRcdFx0aW5zdC5kaXYuaGlkZShzaG93QW5pbSwgaW5zdC5vcHRpb25zLnNob3dPcHRpb25zLCBzaG93U3BlZWQsIHBvc3RQcm9jZXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgaGlkZUFuaW0gPSAoc2hvd0FuaW0gPT09ICdzbGlkZURvd24nID8gJ3NsaWRlVXAnIDpcblx0XHRcdFx0XHRcdChzaG93QW5pbSA9PT0gJ2ZhZGVJbicgPyAnZmFkZU91dCcgOiAnaGlkZScpKTtcblx0XHRcdFx0XHRpbnN0LmRpdltoaWRlQW5pbV0oKHNob3dBbmltID8gc2hvd1NwZWVkIDogJycpLCBwb3N0UHJvY2Vzcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzaG93QW5pbSkge1xuXHRcdFx0XHRcdHBvc3RQcm9jZXNzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEhhbmRsZSBrZXlzdHJva2VzIGluIHRoZSBkYXRlcGlja2VyLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBldmVudCB7S2V5RXZlbnR9IFRoZSBrZXlzdHJva2UuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBub3QgaGFuZGxlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIGhhbmRsZWQuICovXG5cdFx0X2tleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgZWxlbSA9IChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuZWxlbSkgfHwgZXZlbnQudGFyZ2V0O1xuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XG5cdFx0XHR2YXIgaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKGluc3QuaW5saW5lIHx8IGluc3QuZGl2KSB7XG5cdFx0XHRcdGlmIChldmVudC5rZXlDb2RlID09PSA5KSB7IC8vIFRhYiAtIGNsb3NlXG5cdFx0XHRcdFx0cGx1Z2luLmhpZGUoZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHsgLy8gRW50ZXIgLSBzZWxlY3Rcblx0XHRcdFx0XHRwbHVnaW4uc2VsZWN0RGF0ZShlbGVtLFxuXHRcdFx0XHRcdFx0JCgnYS4nICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MsIGluc3QuZGl2KVswXSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IC8vIENvbW1hbmQga2V5c3Ryb2tlc1xuXHRcdFx0XHRcdHZhciBjb21tYW5kcyA9IGluc3Qub3B0aW9ucy5jb21tYW5kcztcblx0XHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIGNvbW1hbmRzKSB7XG5cdFx0XHRcdFx0XHR2YXIgY29tbWFuZCA9IGNvbW1hbmRzW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKGNvbW1hbmQua2V5c3Ryb2tlLmtleUNvZGUgPT09IGV2ZW50LmtleUNvZGUgJiZcblx0XHRcdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLmN0cmxLZXkgPT09ICEhKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiZcblx0XHRcdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLmFsdEtleSA9PT0gZXZlbnQuYWx0S2V5ICYmXG5cdFx0XHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5zaGlmdEtleSA9PT0gZXZlbnQuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRcdFx0cGx1Z2luLnBlcmZvcm1BY3Rpb24oZWxlbSwgbmFtZSk7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBTaG93IG9uICdjdXJyZW50JyBrZXlzdHJva2Vcblx0XHRcdFx0dmFyIGNvbW1hbmQgPSBpbnN0Lm9wdGlvbnMuY29tbWFuZHMuY3VycmVudDtcblx0XHRcdFx0aWYgKGNvbW1hbmQua2V5c3Ryb2tlLmtleUNvZGUgPT09IGV2ZW50LmtleUNvZGUgJiZcblx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2UuY3RybEtleSA9PT0gISEoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJlxuXHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5hbHRLZXkgPT09IGV2ZW50LmFsdEtleSAmJlxuXHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5zaGlmdEtleSA9PT0gZXZlbnQuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRwbHVnaW4uc2hvdyhlbGVtKTtcblx0XHRcdFx0XHRoYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aW5zdC5jdHJsS2V5ID0gKChldmVudC5rZXlDb2RlIDwgNDggJiYgZXZlbnQua2V5Q29kZSAhPT0gMzIpIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSk7XG5cdFx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhaGFuZGxlZDtcblx0XHR9LFxuXG5cdFx0LyoqIEZpbHRlciBrZXlzdHJva2VzIGluIHRoZSBkYXRlcGlja2VyLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBldmVudCB7S2V5RXZlbnR9IFRoZSBrZXlzdHJva2UuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhbGxvd2VkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90IGFsbG93ZWQuICovXG5cdFx0X2tleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lbGVtKSB8fCBldmVudC50YXJnZXQpO1xuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgaW5zdC5vcHRpb25zLmNvbnN0cmFpbklucHV0KSB7XG5cdFx0XHRcdHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSB8fCBldmVudC5jaGFyQ29kZSk7XG5cdFx0XHRcdHZhciBhbGxvd2VkQ2hhcnMgPSBwbHVnaW4uX2FsbG93ZWRDaGFycyhpbnN0KTtcblx0XHRcdFx0cmV0dXJuIChldmVudC5tZXRhS2V5IHx8IGluc3QuY3RybEtleSB8fCBjaCA8ICcgJyB8fFxuXHRcdFx0XHRcdCFhbGxvd2VkQ2hhcnMgfHwgYWxsb3dlZENoYXJzLmluZGV4T2YoY2gpID4gLTEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgdGhlIHNldCBvZiBjaGFyYWN0ZXJzIGFsbG93ZWQgYnkgdGhlIGRhdGUgZm9ybWF0LlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgc2V0IG9mIGFsbG93ZWQgY2hhcmFjdGVycywgb3IgPGNvZGU+bnVsbDwvY29kZT4gaWYgYW55dGhpbmcgYWxsb3dlZC4gKi9cblx0XHRfYWxsb3dlZENoYXJzOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHR2YXIgYWxsb3dlZENoYXJzID0gKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCA/IGluc3Qub3B0aW9ucy5tdWx0aVNlcGFyYXRvciA6XG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyBpbnN0Lm9wdGlvbnMucmFuZ2VTZXBhcmF0b3IgOiAnJykpO1xuXHRcdFx0dmFyIGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdHZhciBoYXNOdW0gPSBmYWxzZTtcblx0XHRcdHZhciBkYXRlRm9ybWF0ID0gaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0ZUZvcm1hdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2ggPSBkYXRlRm9ybWF0LmNoYXJBdChpKTtcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcblx0XHRcdFx0XHRpZiAoY2ggPT09IFwiJ1wiICYmIGRhdGVGb3JtYXQuY2hhckF0KGkgKyAxKSAhPT0gXCInXCIpIHtcblx0XHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gY2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHN3aXRjaCAoY2gpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2QnOiBjYXNlICdtJzogY2FzZSAnbyc6IGNhc2UgJ3cnOlxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gKGhhc051bSA/ICcnIDogJzAxMjM0NTY3ODknKTsgaGFzTnVtID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd5JzogY2FzZSAnQCc6IGNhc2UgJyEnOlxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gKGhhc051bSA/ICcnIDogJzAxMjM0NTY3ODknKSArICctJzsgaGFzTnVtID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdKJzpcblx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IChoYXNOdW0gPyAnJyA6ICcwMTIzNDU2Nzg5JykgKyAnLS4nOyBoYXNOdW0gPSB0cnVlOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0QnOiBjYXNlICdNJzogY2FzZSAnWSc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsOyAvLyBBY2NlcHQgYW55dGhpbmdcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRcdGlmIChkYXRlRm9ybWF0LmNoYXJBdChpICsgMSkgPT09IFwiJ1wiKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IFwiJ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IGNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFsbG93ZWRDaGFycztcblx0XHR9LFxuXG5cdFx0LyoqIFN5bmNocm9uaXNlIGRhdGVwaWNrZXIgd2l0aCB0aGUgZmllbGQuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtLZXlFdmVudH0gVGhlIGtleXN0cm9rZS5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGFsbG93ZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QgYWxsb3dlZC4gKi9cblx0XHRfa2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgZWxlbSA9IChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuZWxlbSkgfHwgZXZlbnQudGFyZ2V0O1xuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiAhaW5zdC5jdHJsS2V5ICYmIGluc3QubGFzdFZhbCAhPT0gaW5zdC5lbGVtLnZhbCgpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIGRhdGVzID0gcGx1Z2luLl9leHRyYWN0RGF0ZXMoaW5zdCwgaW5zdC5lbGVtLnZhbCgpKTtcblx0XHRcdFx0XHRpZiAoZGF0ZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0cGx1Z2luLnNldERhdGUoZWxlbSwgZGF0ZXMsIG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZXZlbnQpIHtcblx0XHRcdFx0XHQvLyBJZ25vcmVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKiBJbmNyZW1lbnQvZGVjcmVtZW50IG1vbnRoL3llYXIgb24gbW91c2Ugd2hlZWwgYWN0aXZpdHkuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtldmVudH0gVGhlIG1vdXNlIHdoZWVsIGV2ZW50LlxuXHRcdFx0QHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgY2hhbmdlLiAqL1xuXHRcdF9kb01vdXNlV2hlZWw6IGZ1bmN0aW9uKGV2ZW50LCBkZWx0YSkge1xuXHRcdFx0dmFyIGVsZW0gPSAocGx1Z2luLmN1ckluc3QgJiYgcGx1Z2luLmN1ckluc3QuZWxlbVswXSkgfHxcblx0XHRcdFx0JChldmVudC50YXJnZXQpLmNsb3Nlc3QoJy4nICsgcGx1Z2luLl9nZXRNYXJrZXIoKSlbMF07XG5cdFx0XHRpZiAocGx1Z2luLmlzRGlzYWJsZWQoZWxlbSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnVzZU1vdXNlV2hlZWwpIHtcblx0XHRcdFx0ZGVsdGEgPSAoZGVsdGEgPCAwID8gLTEgOiArMSk7XG5cdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aChlbGVtLCAtaW5zdC5vcHRpb25zW2V2ZW50LmN0cmxLZXkgPyAnbW9udGhzVG9KdW1wJyA6ICdtb250aHNUb1N0ZXAnXSAqIGRlbHRhKTtcblx0XHRcdH1cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fSxcblxuXHRcdC8qKiBDbGVhciBhbiBpbnB1dCBhbmQgY2xvc2UgYSBwb3B1cCBkYXRlcGlja2VyLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIHVzZS5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdjbGVhcicpICovXG5cdFx0Y2xlYXI6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLmhpZGUoZWxlbSk7XG5cdFx0XHRcdHZhciBkZWZhdWx0RGF0ZSA9IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpO1xuXHRcdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNlbGVjdERlZmF1bHREYXRlICYmIGRlZmF1bHREYXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXREYXRlKGVsZW0sIChkZWZhdWx0RGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVJbnB1dChlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIHNlbGVjdGVkIGRhdGUocykgZm9yIGEgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7Q0RhdGVbXX0gVGhlIHNlbGVjdGVkIGRhdGUocykuXG5cdFx0XHRAZXhhbXBsZSB2YXIgZGF0ZXMgPSAkKHNlbGVjdG9yKS5kYXRlcGljaygnZ2V0RGF0ZScpICovXG5cdFx0Z2V0RGF0ZTogZnVuY3Rpb24oZWxlbSkge1xuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0cmV0dXJuICghJC5pc0VtcHR5T2JqZWN0KGluc3QpID8gaW5zdC5zZWxlY3RlZERhdGVzIDogW10pO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IHRoZSBzZWxlY3RlZCBkYXRlKHMpIGZvciBhIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gdGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBkYXRlcyB7Q0RhdGV8bnVtYmVyfHN0cmluZ3xhcnJheX0gdGhlIHNlbGVjdGVkIGRhdGUocykuXG5cdFx0XHRAcGFyYW0gW2VuZERhdGVdIHtDRGF0ZXxudW1iZXJ8c3RyaW5nfSB0aGUgZW5kaW5nIGRhdGUgZm9yIGEgcmFuZ2UuXG5cdFx0XHRAcGFyYW0gW2tleVVwXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY29taW5nIGZyb20gPGNvZGU+a2V5VXA8L2NvZGU+IHByb2Nlc3NpbmcgKGludGVybmFsKS5cblx0XHRcdEBwYXJhbSBbc2V0T3B0XSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY29taW5nIGZyb20gb3B0aW9uIHByb2Nlc3NpbmcgKGludGVybmFsKS5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzZXREYXRlJywgbmV3IERhdGUoMjAxNCwgMTItMSwgMjUpKVxuICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzZXREYXRlJywgJzEyLzI1LzIwMTQnLCAnMDEvMDEvMjAxNScpXG4gJChzZWxlY3RvcikuZGF0ZXBpY2soJ3NldERhdGUnLCBbZGF0ZTEsIGRhdGUyLCBkYXRlM10pICovXG5cdFx0c2V0RGF0ZTogZnVuY3Rpb24oZWxlbSwgZGF0ZXMsIGVuZERhdGUsIGtleVVwLCBzZXRPcHQpIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdGlmICghJC5pc0FycmF5KGRhdGVzKSkge1xuXHRcdFx0XHRcdGRhdGVzID0gW2RhdGVzXTtcblx0XHRcdFx0XHRpZiAoZW5kRGF0ZSkge1xuXHRcdFx0XHRcdFx0ZGF0ZXMucHVzaChlbmREYXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmdldCgnbWluRGF0ZScpO1xuXHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XG5cdFx0XHRcdHZhciBjdXJEYXRlID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdO1xuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBkYXRlID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRldGVybWluZURhdGUoXG5cdFx0XHRcdFx0XHRkYXRlc1tpXSwgbnVsbCwgY3VyRGF0ZSwgaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKSwgaW5zdC5nZXRDb25maWcoKSk7XG5cdFx0XHRcdFx0aWYgKGRhdGUpIHtcblx0XHRcdFx0XHRcdGlmICgoIW1pbkRhdGUgfHwgZGF0ZS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxuXHRcdFx0XHRcdFx0XHRcdCghbWF4RGF0ZSB8fCBkYXRlLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnN0LnNlbGVjdGVkRGF0ZXNbal0uY29tcGFyZVRvKGRhdGUpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcy5wdXNoKGRhdGUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcy5zcGxpY2UoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0IHx8XG5cdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IDIgOiAxKSwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCk7XG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNhc2UgMTogaW5zdC5zZWxlY3RlZERhdGVzWzFdID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgMjogaW5zdC5zZWxlY3RlZERhdGVzWzFdID1cblx0XHRcdFx0XHRcdFx0KGluc3Quc2VsZWN0ZWREYXRlc1swXS5jb21wYXJlVG8oaW5zdC5zZWxlY3RlZERhdGVzWzFdKSA9PT0gKzEgP1xuXHRcdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gOiBpbnN0LnNlbGVjdGVkRGF0ZXNbMV0pOyBicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zdC5waWNraW5nUmFuZ2UgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnN0LnByZXZEYXRlID0gKGluc3QuZHJhd0RhdGUgPyBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKSA6IG51bGwpO1xuXHRcdFx0XHRpbnN0LmRyYXdEYXRlID0gdGhpcy5fY2hlY2tNaW5NYXgoKGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fFxuXHRcdFx0XHRcdGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCksIGluc3QpO1xuXHRcdFx0XHRpZiAoIXNldE9wdCkge1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtKTtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVJbnB1dChlbGVtLCBrZXlVcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIGEgZGF0ZSBpcyBzZWxlY3RhYmxlIGZvciB0aGlzIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGNoZWNrLlxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfHN0cmluZ3xudW1iZXJ9IFRoZSBkYXRlIHRvIGNoZWNrLlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgc2VsZWN0YWJsZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cblx0XHRcdEBleGFtcGxlIHZhciBzZWxlY3RhYmxlID0gJChzZWxlY3RvcikuZGF0ZXBpY2soJ2lzU2VsZWN0YWJsZScsIGRhdGUpICovXG5cdFx0aXNTZWxlY3RhYmxlOiBmdW5jdGlvbihlbGVtLCBkYXRlKSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGRhdGUgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGV0ZXJtaW5lRGF0ZShkYXRlLFxuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCksIG51bGwsXG5cdFx0XHRcdGluc3Qub3B0aW9ucy5kYXRlRm9ybWF0LCBpbnN0LmdldENvbmZpZygpKTtcblx0XHRcdHJldHVybiB0aGlzLl9pc1NlbGVjdGFibGUoZWxlbSwgZGF0ZSwgaW5zdC5vcHRpb25zLm9uRGF0ZSxcblx0XHRcdFx0aW5zdC5nZXQoJ21pbkRhdGUnKSwgaW5zdC5nZXQoJ21heERhdGUnKSk7XG5cdFx0fSxcblxuXHRcdC8qKiBJbnRlcm5hbGx5IGRldGVybWluZSB3aGV0aGVyIGEgZGF0ZSBpcyBzZWxlY3RhYmxlIGZvciB0aGlzIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IHRoZSBjb250cm9sIHRvIGNoZWNrLlxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byBjaGVjay5cblx0XHRcdEBwYXJhbSBvbkRhdGUge2Z1bmN0aW9ufGJvb2xlYW59IEFueSA8Y29kZT5vbkRhdGU8L2NvZGU+IGNhbGxiYWNrIG9yIDxjb2RlPmNhbGxiYWNrLnNlbGVjdGFibGU8L2NvZGU+LlxuXHRcdFx0QHBhcmFtIG1pbkRhdGUge0NEYXRlfSBUaGUgbWluaW11bSBhbGxvd2VkIGRhdGUuXG5cdFx0XHRAcGFyYW0gbWF4RGF0ZSB7Q0RhdGV9IFRoZSBtYXhpbXVtIGFsbG93ZWQgZGF0ZS5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHNlbGVjdGFibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuICovXG5cdFx0X2lzU2VsZWN0YWJsZTogZnVuY3Rpb24oZWxlbSwgZGF0ZSwgb25EYXRlLCBtaW5EYXRlLCBtYXhEYXRlKSB7XG5cdFx0XHR2YXIgZGF0ZUluZm8gPSAodHlwZW9mIG9uRGF0ZSA9PT0gJ2Jvb2xlYW4nID8ge3NlbGVjdGFibGU6IG9uRGF0ZX0gOlxuXHRcdFx0XHQoISQuaXNGdW5jdGlvbihvbkRhdGUpID8ge30gOiBvbkRhdGUuYXBwbHkoZWxlbSwgW2RhdGUsIHRydWVdKSkpO1xuXHRcdFx0cmV0dXJuIChkYXRlSW5mby5zZWxlY3RhYmxlICE9PSBmYWxzZSkgJiZcblx0XHRcdFx0KCFtaW5EYXRlIHx8IGRhdGUudG9KRCgpID49IG1pbkRhdGUudG9KRCgpKSAmJiAoIW1heERhdGUgfHwgZGF0ZS50b0pEKCkgPD0gbWF4RGF0ZS50b0pEKCkpO1xuXHRcdH0sXG5cblx0XHQvKiogUGVyZm9ybSBhIG5hbWVkIGFjdGlvbiBmb3IgYSBkYXRlcGlja2VyLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge2VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cblx0XHRcdEBwYXJhbSBhY3Rpb24ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGFjdGlvbi4gKi9cblx0XHRwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbihlbGVtLCBhY3Rpb24pIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmICF0aGlzLmlzRGlzYWJsZWQoZWxlbSkpIHtcblx0XHRcdFx0dmFyIGNvbW1hbmRzID0gaW5zdC5vcHRpb25zLmNvbW1hbmRzO1xuXHRcdFx0XHRpZiAoY29tbWFuZHNbYWN0aW9uXSAmJiBjb21tYW5kc1thY3Rpb25dLmVuYWJsZWQuYXBwbHkoZWxlbSwgW2luc3RdKSkge1xuXHRcdFx0XHRcdGNvbW1hbmRzW2FjdGlvbl0uYWN0aW9uLmFwcGx5KGVsZW0sIFtpbnN0XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIFNldCB0aGUgY3VycmVudGx5IHNob3duIG1vbnRoLCBkZWZhdWx0aW5nIHRvIHRvZGF5J3MuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxuXHRcdFx0QHBhcmFtIFt5ZWFyXSB7bnVtYmVyfSBUaGUgeWVhciB0byBzaG93LlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIHNob3cgKDEtMTIpLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gc2hvdy5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzaG93TW9udGgnLCAyMDE0LCAxMiwgMjUpICovXG5cdFx0c2hvd01vbnRoOiBmdW5jdGlvbihlbGVtLCB5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiAoZGF5ICE9IG51bGwgfHxcblx0XHRcdFx0XHQoaW5zdC5kcmF3RGF0ZS55ZWFyKCkgIT09IHllYXIgfHwgaW5zdC5kcmF3RGF0ZS5tb250aCgpICE9PSBtb250aCkpKSB7XG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKTtcblx0XHRcdFx0dmFyIGNhbGVuZGFyID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyO1xuXHRcdFx0XHR2YXIgc2hvdyA9IHRoaXMuX2NoZWNrTWluTWF4KCh5ZWFyICE9IG51bGwgP1xuXHRcdFx0XHRcdGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIDEpIDogY2FsZW5kYXIudG9kYXkoKSksIGluc3QpO1xuXHRcdFx0XHRpbnN0LmRyYXdEYXRlLmRhdGUoc2hvdy55ZWFyKCksIHNob3cubW9udGgoKSwgXG5cdFx0XHRcdFx0KGRheSAhPSBudWxsID8gZGF5IDogTWF0aC5taW4oaW5zdC5kcmF3RGF0ZS5kYXkoKSxcblx0XHRcdFx0XHRjYWxlbmRhci5kYXlzSW5Nb250aChzaG93LnllYXIoKSwgc2hvdy5tb250aCgpKSkpKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogQWRqdXN0IHRoZSBjdXJyZW50bHkgc2hvd24gbW9udGguXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1vbnRocyB0byBjaGFuZ2UgYnkuXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnY2hhbmdlTW9udGgnLCAyKSovXG5cdFx0Y2hhbmdlTW9udGg6IGZ1bmN0aW9uKGVsZW0sIG9mZnNldCkge1xuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcblx0XHRcdFx0dmFyIGRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQob2Zmc2V0LCAnbScpO1xuXHRcdFx0XHR0aGlzLnNob3dNb250aChlbGVtLCBkYXRlLnllYXIoKSwgZGF0ZS5tb250aCgpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEFkanVzdCB0aGUgY3VycmVudGx5IHNob3duIGRheS5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyB0byBjaGFuZ2UgYnkuXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnY2hhbmdlRGF5JywgNykqL1xuXHRcdGNoYW5nZURheTogZnVuY3Rpb24oZWxlbSwgb2Zmc2V0KSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xuXHRcdFx0XHR2YXIgZGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZChvZmZzZXQsICdkJyk7XG5cdFx0XHRcdHRoaXMuc2hvd01vbnRoKGVsZW0sIGRhdGUueWVhcigpLCBkYXRlLm1vbnRoKCksIGRhdGUuZGF5KCkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogUmVzdHJpY3QgYSBkYXRlIHRvIHRoZSBtaW5pbXVtL21heGltdW0gc3BlY2lmaWVkLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gY2hlY2suXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy4gKi9cblx0XHRfY2hlY2tNaW5NYXg6IGZ1bmN0aW9uKGRhdGUsIGluc3QpIHtcblx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5nZXQoJ21pbkRhdGUnKTtcblx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcblx0XHRcdGRhdGUgPSAobWluRGF0ZSAmJiBkYXRlLmNvbXBhcmVUbyhtaW5EYXRlKSA9PT0gLTEgPyBtaW5EYXRlLm5ld0RhdGUoKSA6IGRhdGUpO1xuXHRcdFx0ZGF0ZSA9IChtYXhEYXRlICYmIGRhdGUuY29tcGFyZVRvKG1heERhdGUpID09PSArMSA/IG1heERhdGUubmV3RGF0ZSgpIDogZGF0ZSk7XG5cdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXRlIGFzc29jaWF0ZWQgd2l0aCBhbiBlbnRyeSBpbiB0aGUgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIHRhcmdldCB7RWxlbWVudH0gVGhlIHNlbGVjdGVkIGRhdGVwaWNrZXIgZWxlbWVudC5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgY29ycmVzcG9uZGluZyBkYXRlLCBvciA8Y29kZT5udWxsPC9jb2RlPi5cdFx0XHRcblx0XHRcdEBleGFtcGxlIHZhciBkYXRlID0gJChzZWxlY3RvcikuZGF0ZXBpY2soJ3JldHJpZXZlRGF0ZScsICQoJ2Rpdi5kYXRlcGljay1wb3B1cCBhOmNvbnRhaW5zKDEwKScpWzBdKSAqL1xuXHRcdHJldHJpZXZlRGF0ZTogZnVuY3Rpb24oZWxlbSwgdGFyZ2V0KSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRyZXR1cm4gKCQuaXNFbXB0eU9iamVjdChpbnN0KSA/IG51bGwgOiBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZnJvbUpEKFxuXHRcdFx0XHRwYXJzZUZsb2F0KHRhcmdldC5jbGFzc05hbWUucmVwbGFjZSgvXi4qamQoXFxkK1xcLjUpLiokLywgJyQxJykpKSk7XG5cdFx0fSxcblxuXHRcdC8qKiBTZWxlY3QgYSBkYXRlIGZvciB0aGlzIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSB0YXJnZXQge0VsZW1lbnR9IFRoZSBzZWxlY3RlZCBkYXRlcGlja2VyIGVsZW1lbnQuXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2VsZWN0RGF0ZScsICQoJ2Rpdi5kYXRlcGljay1wb3B1cCBhOmNvbnRhaW5zKDEwKScpWzBdKSAqL1xuXHRcdHNlbGVjdERhdGU6IGZ1bmN0aW9uKGVsZW0sIHRhcmdldCkge1xuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgIXRoaXMuaXNEaXNhYmxlZChlbGVtKSkge1xuXHRcdFx0XHR2YXIgZGF0ZSA9IHRoaXMucmV0cmlldmVEYXRlKGVsZW0sIHRhcmdldCk7XG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QpIHtcblx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGRhdGUuY29tcGFyZVRvKGluc3Quc2VsZWN0ZWREYXRlc1tpXSkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFmb3VuZCAmJiBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDwgaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0KSB7XG5cdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMucHVzaChkYXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0KSB7XG5cdFx0XHRcdFx0aWYgKGluc3QucGlja2luZ1JhbmdlKSB7XG5cdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXNbMV0gPSBkYXRlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtkYXRlLCBkYXRlXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zdC5waWNraW5nUmFuZ2UgPSAhaW5zdC5waWNraW5nUmFuZ2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW2RhdGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlID0gZGF0ZS5uZXdEYXRlKCk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUlucHV0KGVsZW0pO1xuXHRcdFx0XHRpZiAoaW5zdC5pbmxpbmUgfHwgaW5zdC5waWNraW5nUmFuZ2UgfHwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCA8XG5cdFx0XHRcdFx0XHQoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0IHx8IChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyAyIDogMSkpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaGlkZShlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogR2VuZXJhdGUgdGhlIGRhdGVwaWNrZXIgY29udGVudCBmb3IgdGhpcyBjb250cm9sLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEByZXR1cm4ge2pRdWVyeX0gVGhlIGRhdGVwaWNrZXIgY29udGVudCAqL1xuXHRcdF9nZW5lcmF0ZUNvbnRlbnQ6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcblx0XHRcdHZhciBtb250aHNUb1Nob3cgPSBpbnN0Lm9wdGlvbnMubW9udGhzVG9TaG93O1xuXHRcdFx0bW9udGhzVG9TaG93ID0gKCQuaXNBcnJheShtb250aHNUb1Nob3cpID8gbW9udGhzVG9TaG93IDogWzEsIG1vbnRoc1RvU2hvd10pO1xuXHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHRoaXMuX2NoZWNrTWluTWF4KFxuXHRcdFx0XHRpbnN0LmRyYXdEYXRlIHx8IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpLCBpbnN0KTtcblx0XHRcdHZhciBkcmF3RGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgtaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKTtcblx0XHRcdC8vIEdlbmVyYXRlIG1vbnRoc1xuXHRcdFx0dmFyIG1vbnRoUm93cyA9ICcnO1xuXHRcdFx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9udGhzVG9TaG93WzBdOyByb3crKykge1xuXHRcdFx0XHR2YXIgbW9udGhzID0gJyc7XG5cdFx0XHRcdGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vbnRoc1RvU2hvd1sxXTsgY29sKyspIHtcblx0XHRcdFx0XHRtb250aHMgKz0gdGhpcy5fZ2VuZXJhdGVNb250aChlbGVtLCBpbnN0LCBkcmF3RGF0ZS55ZWFyKCksXG5cdFx0XHRcdFx0XHRkcmF3RGF0ZS5tb250aCgpLCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIsIGluc3Qub3B0aW9ucy5yZW5kZXJlciwgKHJvdyA9PT0gMCAmJiBjb2wgPT09IDApKTtcblx0XHRcdFx0XHRkcmF3RGF0ZS5hZGQoMSwgJ20nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtb250aFJvd3MgKz0gdGhpcy5fcHJlcGFyZShpbnN0Lm9wdGlvbnMucmVuZGVyZXIubW9udGhSb3csIGluc3QpLnJlcGxhY2UoL1xce21vbnRoc1xcfS8sIG1vbnRocyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGlja2VyID0gdGhpcy5fcHJlcGFyZShpbnN0Lm9wdGlvbnMucmVuZGVyZXIucGlja2VyLCBpbnN0KS5yZXBsYWNlKC9cXHttb250aHNcXH0vLCBtb250aFJvd3MpLlxuXHRcdFx0XHRyZXBsYWNlKC9cXHt3ZWVrSGVhZGVyXFx9L2csIHRoaXMuX2dlbmVyYXRlRGF5SGVhZGVycyhpbnN0LCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIsIGluc3Qub3B0aW9ucy5yZW5kZXJlcikpO1xuXHRcdFx0Ly8gQWRkIGNvbW1hbmRzXG5cdFx0XHR2YXIgYWRkQ29tbWFuZCA9IGZ1bmN0aW9uKHR5cGUsIG9wZW4sIGNsb3NlLCBuYW1lLCBjbGFzc2VzKSB7XG5cdFx0XHRcdGlmIChwaWNrZXIuaW5kZXhPZigneycgKyB0eXBlICsgJzonICsgbmFtZSArICd9JykgPT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjb21tYW5kID0gaW5zdC5vcHRpb25zLmNvbW1hbmRzW25hbWVdO1xuXHRcdFx0XHR2YXIgZGF0ZSA9IChpbnN0Lm9wdGlvbnMuY29tbWFuZHNBc0RhdGVGb3JtYXQgPyBjb21tYW5kLmRhdGUuYXBwbHkoZWxlbSwgW2luc3RdKSA6IG51bGwpO1xuXHRcdFx0XHRwaWNrZXIgPSBwaWNrZXIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxceycgKyB0eXBlICsgJzonICsgbmFtZSArICdcXFxcfScsICdnJyksXG5cdFx0XHRcdFx0JzwnICsgb3BlbiArIChjb21tYW5kLnN0YXR1cyA/ICcgdGl0bGU9XCInICsgaW5zdC5vcHRpb25zW2NvbW1hbmQuc3RhdHVzXSArICdcIicgOiAnJykgK1xuXHRcdFx0XHRcdCcgY2xhc3M9XCInICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcyArICcgJyArXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcyArICctJyArIG5hbWUgKyAnICcgKyBjbGFzc2VzICtcblx0XHRcdFx0XHQoY29tbWFuZC5lbmFibGVkKGluc3QpID8gJycgOiAnICcgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGlzYWJsZWRDbGFzcykgKyAnXCI+JyArXG5cdFx0XHRcdFx0KGRhdGUgPyBkYXRlLmZvcm1hdERhdGUoaW5zdC5vcHRpb25zW2NvbW1hbmQudGV4dF0pIDpcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnNbY29tbWFuZC50ZXh0XSkgKyAnPC8nICsgY2xvc2UgKyAnPicpO1xuXHRcdFx0fTtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gaW5zdC5vcHRpb25zLmNvbW1hbmRzKSB7XG5cdFx0XHRcdGFkZENvbW1hbmQoJ2J1dHRvbicsICdidXR0b24gdHlwZT1cImJ1dHRvblwiJywgJ2J1dHRvbicsIG5hbWUsXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRCdXR0b25DbGFzcyk7XG5cdFx0XHRcdGFkZENvbW1hbmQoJ2xpbmsnLCAnYSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCInLCAnYScsIG5hbWUsXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRMaW5rQ2xhc3MpO1xuXHRcdFx0fVxuXHRcdFx0cGlja2VyID0gJChwaWNrZXIpO1xuXHRcdFx0aWYgKG1vbnRoc1RvU2hvd1sxXSA+IDEpIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gMDtcblx0XHRcdFx0JChpbnN0Lm9wdGlvbnMucmVuZGVyZXIubW9udGhTZWxlY3RvciwgcGlja2VyKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBudGggPSArK2NvdW50ICUgbW9udGhzVG9TaG93WzFdO1xuXHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MobnRoID09PSAxID8gJ2ZpcnN0JyA6IChudGggPT09IDAgPyAnbGFzdCcgOiAnJykpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBkYXRlcGlja2VyIGJlaGF2aW91clxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0ZnVuY3Rpb24gcmVtb3ZlSGlnaGxpZ2h0KCkge1xuXHRcdFx0XHQoaW5zdC5pbmxpbmUgPyAkKHRoaXMpLmNsb3Nlc3QoJy4nICsgc2VsZi5fZ2V0TWFya2VyKCkpIDogaW5zdC5kaXYpLlxuXHRcdFx0XHRcdGZpbmQoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmRheVNlbGVjdG9yICsgJyBhJykuXG5cdFx0XHRcdFx0cmVtb3ZlQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MpO1xuXHRcdFx0fVxuXHRcdFx0cGlja2VyLmZpbmQoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmRheVNlbGVjdG9yICsgJyBhJykuaG92ZXIoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVIaWdobGlnaHQuYXBwbHkodGhpcyk7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5oaWdobGlnaHRlZENsYXNzKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlbW92ZUhpZ2hsaWdodCkuXG5cdFx0XHRcdGNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYuc2VsZWN0RGF0ZShlbGVtLCB0aGlzKTtcblx0XHRcdFx0fSkuZW5kKCkuXG5cdFx0XHRcdGZpbmQoJ3NlbGVjdC4nICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgKyAnOm5vdCguJyArIHRoaXMuX2FueVllYXJDbGFzcyArICcpJykuXG5cdFx0XHRcdGNoYW5nZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgbW9udGhZZWFyID0gJCh0aGlzKS52YWwoKS5zcGxpdCgnLycpO1xuXHRcdFx0XHRcdHNlbGYuc2hvd01vbnRoKGVsZW0sIHBhcnNlSW50KG1vbnRoWWVhclsxXSwgMTApLCBwYXJzZUludChtb250aFllYXJbMF0sIDEwKSk7XG5cdFx0XHRcdH0pLmVuZCgpLlxuXHRcdFx0XHRmaW5kKCdzZWxlY3QuJyArIHRoaXMuX2FueVllYXJDbGFzcykuY2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuXG5cdFx0XHRcdFx0XHRuZXh0KCdpbnB1dCcpLmNzcyh7bGVmdDogdGhpcy5vZmZzZXRMZWZ0LCB0b3A6IHRoaXMub2Zmc2V0VG9wLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgsIGhlaWdodDogdGhpcy5vZmZzZXRIZWlnaHR9KS5zaG93KCkuZm9jdXMoKTtcblx0XHRcdFx0fSkuZW5kKCkuXG5cdFx0XHRcdGZpbmQoJ2lucHV0LicgKyBzZWxmLl9tb250aFllYXJDbGFzcykuY2hhbmdlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgeWVhciA9IHBhcnNlSW50KCQodGhpcykudmFsKCksIDEwKTtcblx0XHRcdFx0XHRcdHllYXIgPSAoaXNOYU4oeWVhcikgPyBpbnN0LmRyYXdEYXRlLnllYXIoKSA6IHllYXIpO1xuXHRcdFx0XHRcdFx0c2VsZi5zaG93TW9udGgoZWxlbSwgeWVhciwgaW5zdC5kcmF3RGF0ZS5tb250aCgpLCBpbnN0LmRyYXdEYXRlLmRheSgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGFsZXJ0KGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkua2V5ZG93bihmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdGlmIChldmVudC5rZXlDb2RlID09PSAxMykgeyAvLyBFbnRlclxuXHRcdFx0XHRcdFx0JChldmVudC5lbGVtKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHsgLy8gRXNjYXBlXG5cdFx0XHRcdFx0XHQkKGV2ZW50LmVsZW0pLmhpZGUoKS5wcmV2KCdzZWxlY3QnKS5jc3MoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuXHRcdFx0XHRcdFx0aW5zdC5lbGVtLmZvY3VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdC8vIEFkZCBrZXlib2FyZCBoYW5kbGluZ1xuXHRcdFx0dmFyIGRhdGEgPSB7ZWxlbTogaW5zdC5lbGVtWzBdfTtcblx0XHRcdHBpY2tlci5rZXlkb3duKGRhdGEsIHRoaXMuX2tleURvd24pLmtleXByZXNzKGRhdGEsIHRoaXMuX2tleVByZXNzKS5rZXl1cChkYXRhLCB0aGlzLl9rZXlVcCk7XG5cdFx0XHQvLyBBZGQgY29tbWFuZCBiZWhhdmlvdXJcblx0XHRcdHBpY2tlci5maW5kKCcuJyArIGluc3Qub3B0aW9ucy5yZW5kZXJlci5jb21tYW5kQ2xhc3MpLmNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICghJCh0aGlzKS5oYXNDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGlzYWJsZWRDbGFzcykpIHtcblx0XHRcdFx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0XHRuZXcgUmVnRXhwKCdeLionICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcyArICctKFteIF0rKS4qJCcpLCAnJDEnKTtcblx0XHRcdFx0XHRcdHBsdWdpbi5wZXJmb3JtQWN0aW9uKGVsZW0sIGFjdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdC8vIEFkZCBjbGFzc2VzXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLmlzUlRMKSB7XG5cdFx0XHRcdHBpY2tlci5hZGRDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIucnRsQ2xhc3MpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vbnRoc1RvU2hvd1swXSAqIG1vbnRoc1RvU2hvd1sxXSA+IDEpIHtcblx0XHRcdFx0cGlja2VyLmFkZENsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tdWx0aUNsYXNzKTtcblx0XHRcdH1cblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucGlja2VyQ2xhc3MpIHtcblx0XHRcdFx0cGlja2VyLmFkZENsYXNzKGluc3Qub3B0aW9ucy5waWNrZXJDbGFzcyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZXNpemVcblx0XHRcdCQoJ2JvZHknKS5hcHBlbmQocGlja2VyKTtcblx0XHRcdHZhciB3aWR0aCA9IDA7XG5cdFx0XHRwaWNrZXIuZmluZChpbnN0Lm9wdGlvbnMucmVuZGVyZXIubW9udGhTZWxlY3RvcikuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0d2lkdGggKz0gJCh0aGlzKS5vdXRlcldpZHRoKCk7XG5cdFx0XHR9KTtcblx0XHRcdHBpY2tlci53aWR0aCh3aWR0aCAvIG1vbnRoc1RvU2hvd1swXSk7XG5cdFx0XHQvLyBQcmUtc2hvdyBjdXN0b21pc2F0aW9uXG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vblNob3cpKSB7XG5cdFx0XHRcdGluc3Qub3B0aW9ucy5vblNob3cuYXBwbHkoZWxlbSwgW3BpY2tlciwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLCBpbnN0XSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGlja2VyO1xuXHRcdH0sXG5cblx0XHQvKiogR2VuZXJhdGUgdGhlIGNvbnRlbnQgZm9yIGEgc2luZ2xlIG1vbnRoLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIGdlbmVyYXRlLlxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCB0byBnZW5lcmF0ZS5cblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY3VycmVudCBjYWxlbmRhci5cblx0XHRcdEBwYXJhbSByZW5kZXJlciB7b2JqZWN0fSBUaGUgcmVuZGVyaW5nIHRlbXBsYXRlcy5cblx0XHRcdEBwYXJhbSBmaXJzdCB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgZmlyc3Qgb2YgbXVsdGlwbGUgbW9udGhzLlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgbW9udGggY29udGVudC4gKi9cblx0XHRfZ2VuZXJhdGVNb250aDogZnVuY3Rpb24oZWxlbSwgaW5zdCwgeWVhciwgbW9udGgsIGNhbGVuZGFyLCByZW5kZXJlciwgZmlyc3QpIHtcblx0XHRcdHZhciBkYXlzSW5Nb250aCA9IGNhbGVuZGFyLmRheXNJbk1vbnRoKHllYXIsIG1vbnRoKTtcblx0XHRcdHZhciBtb250aHNUb1Nob3cgPSBpbnN0Lm9wdGlvbnMubW9udGhzVG9TaG93O1xuXHRcdFx0bW9udGhzVG9TaG93ID0gKCQuaXNBcnJheShtb250aHNUb1Nob3cpID8gbW9udGhzVG9TaG93IDogWzEsIG1vbnRoc1RvU2hvd10pO1xuXHRcdFx0dmFyIGZpeGVkV2Vla3MgPSBpbnN0Lm9wdGlvbnMuZml4ZWRXZWVrcyB8fCAobW9udGhzVG9TaG93WzBdICogbW9udGhzVG9TaG93WzFdID4gMSk7XG5cdFx0XHR2YXIgZmlyc3REYXkgPSBpbnN0Lm9wdGlvbnMuZmlyc3REYXk7XG5cdFx0XHRmaXJzdERheSA9IChmaXJzdERheSA9PSBudWxsID8gY2FsZW5kYXIubG9jYWwuZmlyc3REYXkgOiBmaXJzdERheSk7XG5cdFx0XHR2YXIgbGVhZERheXMgPSAoY2FsZW5kYXIuZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBjYWxlbmRhci5taW5EYXkpIC1cblx0XHRcdFx0Zmlyc3REYXkgKyBjYWxlbmRhci5kYXlzSW5XZWVrKCkpICUgY2FsZW5kYXIuZGF5c0luV2VlaygpO1xuXHRcdFx0dmFyIG51bVdlZWtzID0gKGZpeGVkV2Vla3MgPyA2IDogTWF0aC5jZWlsKChsZWFkRGF5cyArIGRheXNJbk1vbnRoKSAvIGNhbGVuZGFyLmRheXNJbldlZWsoKSkpO1xuXHRcdFx0dmFyIHNlbGVjdE90aGVyTW9udGhzID0gaW5zdC5vcHRpb25zLnNlbGVjdE90aGVyTW9udGhzICYmIGluc3Qub3B0aW9ucy5zaG93T3RoZXJNb250aHM7XG5cdFx0XHR2YXIgbWluRGF0ZSA9IChpbnN0LnBpY2tpbmdSYW5nZSA/IGluc3Quc2VsZWN0ZWREYXRlc1swXSA6IGluc3QuZ2V0KCdtaW5EYXRlJykpO1xuXHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0dmFyIHNob3dXZWVrcyA9IHJlbmRlcmVyLndlZWsuaW5kZXhPZigne3dlZWtPZlllYXJ9JykgPiAtMTtcblx0XHRcdHZhciB0b2RheSA9IGNhbGVuZGFyLnRvZGF5KCk7XG5cdFx0XHR2YXIgZHJhd0RhdGUgPSBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCBjYWxlbmRhci5taW5EYXkpO1xuXHRcdFx0ZHJhd0RhdGUuYWRkKC1sZWFkRGF5cyAtIChmaXhlZFdlZWtzICYmXG5cdFx0XHRcdChkcmF3RGF0ZS5kYXlPZldlZWsoKSA9PT0gZmlyc3REYXkgfHwgZHJhd0RhdGUuZGF5c0luTW9udGgoKSA8IGNhbGVuZGFyLmRheXNJbldlZWsoKSk/XG5cdFx0XHRcdGNhbGVuZGFyLmRheXNJbldlZWsoKSA6IDApLCAnZCcpO1xuXHRcdFx0dmFyIGpkID0gZHJhd0RhdGUudG9KRCgpO1xuXHRcdFx0Ly8gR2VuZXJhdGUgd2Vla3Ncblx0XHRcdHZhciB3ZWVrcyA9ICcnO1xuXHRcdFx0Zm9yICh2YXIgd2VlayA9IDA7IHdlZWsgPCBudW1XZWVrczsgd2VlaysrKSB7XG5cdFx0XHRcdHZhciB3ZWVrT2ZZZWFyID0gKCFzaG93V2Vla3MgPyAnJyA6ICc8c3BhbiBjbGFzcz1cImpkJyArIGpkICsgJ1wiPicgK1xuXHRcdFx0XHRcdCgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLmNhbGN1bGF0ZVdlZWspID9cblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMuY2FsY3VsYXRlV2VlayhkcmF3RGF0ZSkgOiBkcmF3RGF0ZS53ZWVrT2ZZZWFyKCkpICsgJzwvc3Bhbj4nKTtcblx0XHRcdFx0dmFyIGRheXMgPSAnJztcblx0XHRcdFx0Zm9yICh2YXIgZGF5ID0gMDsgZGF5IDwgY2FsZW5kYXIuZGF5c0luV2VlaygpOyBkYXkrKykge1xuXHRcdFx0XHRcdHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgJiYgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVkID0gKGRyYXdEYXRlLmNvbXBhcmVUbyhpbnN0LnNlbGVjdGVkRGF0ZXNbMF0pICE9PSAtMSAmJlxuXHRcdFx0XHRcdFx0XHRkcmF3RGF0ZS5jb21wYXJlVG8oaW5zdC5zZWxlY3RlZERhdGVzWzFdKSAhPT0gKzEpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluc3Quc2VsZWN0ZWREYXRlc1tpXS5jb21wYXJlVG8oZHJhd0RhdGUpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBkYXRlSW5mbyA9ICghJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vbkRhdGUpID8ge30gOlxuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLm9uRGF0ZS5hcHBseShlbGVtLCBbZHJhd0RhdGUsIGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoXSkpO1xuXHRcdFx0XHRcdHZhciBzZWxlY3RhYmxlID0gKHNlbGVjdE90aGVyTW9udGhzIHx8IGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoKSAmJlxuXHRcdFx0XHRcdFx0dGhpcy5faXNTZWxlY3RhYmxlKGVsZW0sIGRyYXdEYXRlLCBkYXRlSW5mby5zZWxlY3RhYmxlLCBtaW5EYXRlLCBtYXhEYXRlKTtcblx0XHRcdFx0XHRkYXlzICs9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIuZGF5LCBpbnN0KS5yZXBsYWNlKC9cXHtkYXlcXH0vZyxcblx0XHRcdFx0XHRcdChzZWxlY3RhYmxlID8gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIicgOiAnPHNwYW4nKSArXG5cdFx0XHRcdFx0XHQnIGNsYXNzPVwiamQnICsgamQgKyAnICcgKyAoZGF0ZUluZm8uZGF0ZUNsYXNzIHx8ICcnKSArXG5cdFx0XHRcdFx0XHQoc2VsZWN0ZWQgJiYgKHNlbGVjdE90aGVyTW9udGhzIHx8IGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoKSA/XG5cdFx0XHRcdFx0XHQnICcgKyByZW5kZXJlci5zZWxlY3RlZENsYXNzIDogJycpICtcblx0XHRcdFx0XHRcdChzZWxlY3RhYmxlID8gJyAnICsgcmVuZGVyZXIuZGVmYXVsdENsYXNzIDogJycpICtcblx0XHRcdFx0XHRcdChkcmF3RGF0ZS53ZWVrRGF5KCkgPyAnJyA6ICcgJyArIHJlbmRlcmVyLndlZWtlbmRDbGFzcykgK1xuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID8gJycgOiAnICcgKyByZW5kZXJlci5vdGhlck1vbnRoQ2xhc3MpICtcblx0XHRcdFx0XHRcdChkcmF3RGF0ZS5jb21wYXJlVG8odG9kYXkpID09PSAwICYmIGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID9cblx0XHRcdFx0XHRcdCcgJyArIHJlbmRlcmVyLnRvZGF5Q2xhc3MgOiAnJykgK1xuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLmNvbXBhcmVUbyhpbnN0LmRyYXdEYXRlKSA9PT0gMCAmJiBkcmF3RGF0ZS5tb250aCgpID09PSBtb250aCA/XG5cdFx0XHRcdFx0XHQnICcgKyByZW5kZXJlci5oaWdobGlnaHRlZENsYXNzIDogJycpICsgJ1wiJyArXG5cdFx0XHRcdFx0XHQoZGF0ZUluZm8udGl0bGUgfHwgKGluc3Qub3B0aW9ucy5kYXlTdGF0dXMgJiYgc2VsZWN0YWJsZSkgPyAnIHRpdGxlPVwiJyArXG5cdFx0XHRcdFx0XHQoZGF0ZUluZm8udGl0bGUgfHwgZHJhd0RhdGUuZm9ybWF0RGF0ZShpbnN0Lm9wdGlvbnMuZGF5U3RhdHVzKSkgKyAnXCInIDogJycpICsgJz4nICtcblx0XHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMuc2hvd090aGVyTW9udGhzIHx8IGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID9cblx0XHRcdFx0XHRcdGRhdGVJbmZvLmNvbnRlbnQgfHwgZHJhd0RhdGUuZGF5KCkgOiAnJiMxNjA7JykgK1xuXHRcdFx0XHRcdFx0KHNlbGVjdGFibGUgPyAnPC9hPicgOiAnPC9zcGFuPicpKTtcblx0XHRcdFx0XHRkcmF3RGF0ZS5hZGQoMSwgJ2QnKTtcblx0XHRcdFx0XHRqZCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdlZWtzICs9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIud2VlaywgaW5zdCkucmVwbGFjZSgvXFx7ZGF5c1xcfS9nLCBkYXlzKS5cblx0XHRcdFx0XHRyZXBsYWNlKC9cXHt3ZWVrT2ZZZWFyXFx9L2csIHdlZWtPZlllYXIpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG1vbnRoSGVhZGVyID0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5tb250aCwgaW5zdCkubWF0Y2goL1xce21vbnRoSGVhZGVyKDpbXlxcfV0rKT9cXH0vKTtcblx0XHRcdG1vbnRoSGVhZGVyID0gKG1vbnRoSGVhZGVyWzBdLmxlbmd0aCA8PSAxMyA/ICdNTSB5eXl5JyA6XG5cdFx0XHRcdG1vbnRoSGVhZGVyWzBdLnN1YnN0cmluZygxMywgbW9udGhIZWFkZXJbMF0ubGVuZ3RoIC0gMSkpO1xuXHRcdFx0bW9udGhIZWFkZXIgPSAoZmlyc3QgPyB0aGlzLl9nZW5lcmF0ZU1vbnRoU2VsZWN0aW9uKFxuXHRcdFx0XHRpbnN0LCB5ZWFyLCBtb250aCwgbWluRGF0ZSwgbWF4RGF0ZSwgbW9udGhIZWFkZXIsIGNhbGVuZGFyLCByZW5kZXJlcikgOlxuXHRcdFx0XHRjYWxlbmRhci5mb3JtYXREYXRlKG1vbnRoSGVhZGVyLCBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCBjYWxlbmRhci5taW5EYXkpKSk7XG5cdFx0XHR2YXIgd2Vla0hlYWRlciA9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIud2Vla0hlYWRlciwgaW5zdCkuXG5cdFx0XHRcdHJlcGxhY2UoL1xce2RheXNcXH0vZywgdGhpcy5fZ2VuZXJhdGVEYXlIZWFkZXJzKGluc3QsIGNhbGVuZGFyLCByZW5kZXJlcikpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ByZXBhcmUocmVuZGVyZXIubW9udGgsIGluc3QpLnJlcGxhY2UoL1xce21vbnRoSGVhZGVyKDpbXlxcfV0rKT9cXH0vZywgbW9udGhIZWFkZXIpLlxuXHRcdFx0XHRyZXBsYWNlKC9cXHt3ZWVrSGVhZGVyXFx9L2csIHdlZWtIZWFkZXIpLnJlcGxhY2UoL1xce3dlZWtzXFx9L2csIHdlZWtzKTtcblx0XHR9LFxuXG5cdFx0LyoqIEdlbmVyYXRlIHRoZSBIVE1MIGZvciB0aGUgZGF5IGhlYWRlcnMuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIGN1cnJlbnQgY2FsZW5kYXIuXG5cdFx0XHRAcGFyYW0gcmVuZGVyZXIge29iamVjdH0gVGhlIHJlbmRlcmluZyB0ZW1wbGF0ZXMuXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IEEgd2VlaydzIHdvcnRoIG9mIGRheSBoZWFkZXJzLiAqL1xuXHRcdF9nZW5lcmF0ZURheUhlYWRlcnM6IGZ1bmN0aW9uKGluc3QsIGNhbGVuZGFyLCByZW5kZXJlcikge1xuXHRcdFx0dmFyIGZpcnN0RGF5ID0gaW5zdC5vcHRpb25zLmZpcnN0RGF5O1xuXHRcdFx0Zmlyc3REYXkgPSAoZmlyc3REYXkgPT0gbnVsbCA/IGNhbGVuZGFyLmxvY2FsLmZpcnN0RGF5IDogZmlyc3REYXkpO1xuXHRcdFx0dmFyIGhlYWRlciA9ICcnO1xuXHRcdFx0Zm9yICh2YXIgZGF5ID0gMDsgZGF5IDwgY2FsZW5kYXIuZGF5c0luV2VlaygpOyBkYXkrKykge1xuXHRcdFx0XHR2YXIgZG93ID0gKGRheSArIGZpcnN0RGF5KSAlIGNhbGVuZGFyLmRheXNJbldlZWsoKTtcblx0XHRcdFx0aGVhZGVyICs9IHRoaXMuX3ByZXBhcmUocmVuZGVyZXIuZGF5SGVhZGVyLCBpbnN0KS5yZXBsYWNlKC9cXHtkYXlcXH0vZyxcblx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCInICsgdGhpcy5fY3VyRG9XQ2xhc3MgKyBkb3cgKyAnXCIgdGl0bGU9XCInICtcblx0XHRcdFx0XHRjYWxlbmRhci5sb2NhbC5kYXlOYW1lc1tkb3ddICsgJ1wiPicgKyBjYWxlbmRhci5sb2NhbC5kYXlOYW1lc01pbltkb3ddICsgJzwvc3Bhbj4nKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoZWFkZXI7XG5cdFx0fSxcblxuXHRcdC8qKiBHZW5lcmF0ZSBzZWxlY3Rpb24gY29udHJvbHMgZm9yIG1vbnRoLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgdG8gZ2VuZXJhdGUuXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGdlbmVyYXRlLlxuXHRcdFx0QHBhcmFtIG1pbkRhdGUge0NEYXRlfSBUaGUgbWluaW11bSBkYXRlIGFsbG93ZWQuXG5cdFx0XHRAcGFyYW0gbWF4RGF0ZSB7Q0RhdGV9IFRoZSBtYXhpbXVtIGRhdGUgYWxsb3dlZC5cblx0XHRcdEBwYXJhbSBtb250aEhlYWRlciB7c3RyaW5nfSBUaGUgbW9udGgveWVhciBmb3JtYXQuXG5cdFx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIGN1cnJlbnQgY2FsZW5kYXIuXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBtb250aCBzZWxlY3Rpb24gY29udGVudC4gKi9cblx0XHRfZ2VuZXJhdGVNb250aFNlbGVjdGlvbjogZnVuY3Rpb24oaW5zdCwgeWVhciwgbW9udGgsIG1pbkRhdGUsIG1heERhdGUsIG1vbnRoSGVhZGVyLCBjYWxlbmRhcikge1xuXHRcdFx0aWYgKCFpbnN0Lm9wdGlvbnMuY2hhbmdlTW9udGgpIHtcblx0XHRcdFx0cmV0dXJuIGNhbGVuZGFyLmZvcm1hdERhdGUobW9udGhIZWFkZXIsIGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIDEpKTtcblx0XHRcdH1cblx0XHRcdC8vIE1vbnRoc1xuXHRcdFx0dmFyIG1vbnRoTmFtZXMgPSBjYWxlbmRhci5sb2NhbFtcblx0XHRcdFx0J21vbnRoTmFtZXMnICsgKG1vbnRoSGVhZGVyLm1hdGNoKC9tbS9pKSA/ICcnIDogJ1Nob3J0JyldO1xuXHRcdFx0dmFyIGh0bWwgPSBtb250aEhlYWRlci5yZXBsYWNlKC9tKy9pLCAnXFxcXHgyRScpLnJlcGxhY2UoL3krL2ksICdcXFxceDJGJyk7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSAnPHNlbGVjdCBjbGFzcz1cIicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArXG5cdFx0XHRcdCdcIiB0aXRsZT1cIicgKyBpbnN0Lm9wdGlvbnMubW9udGhTdGF0dXMgKyAnXCI+Jztcblx0XHRcdHZhciBtYXhNb250aCA9IGNhbGVuZGFyLm1vbnRoc0luWWVhcih5ZWFyKSArIGNhbGVuZGFyLm1pbk1vbnRoO1xuXHRcdFx0Zm9yICh2YXIgbSA9IGNhbGVuZGFyLm1pbk1vbnRoOyBtIDwgbWF4TW9udGg7IG0rKykge1xuXHRcdFx0XHRpZiAoKCFtaW5EYXRlIHx8IGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbSxcblx0XHRcdFx0XHRcdGNhbGVuZGFyLmRheXNJbk1vbnRoKHllYXIsIG0pIC0gMSArIGNhbGVuZGFyLm1pbkRheSkuXG5cdFx0XHRcdFx0XHRjb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxuXHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbSwgY2FsZW5kYXIubWluRGF5KS5cblx0XHRcdFx0XHRcdGNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpKSB7XG5cdFx0XHRcdFx0c2VsZWN0b3IgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgbSArICcvJyArIHllYXIgKyAnXCInICtcblx0XHRcdFx0XHRcdChtb250aCA9PT0gbSA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArICc+JyArXG5cdFx0XHRcdFx0XHRtb250aE5hbWVzW20gLSBjYWxlbmRhci5taW5Nb250aF0gKyAnPC9vcHRpb24+Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VsZWN0b3IgKz0gJzwvc2VsZWN0Pic7XG5cdFx0XHRodG1sID0gaHRtbC5yZXBsYWNlKC9cXFxceDJFLywgc2VsZWN0b3IpO1xuXHRcdFx0Ly8gWWVhcnNcblx0XHRcdHZhciB5ZWFyUmFuZ2UgPSBpbnN0Lm9wdGlvbnMueWVhclJhbmdlO1xuXHRcdFx0aWYgKHllYXJSYW5nZSA9PT0gJ2FueScpIHtcblx0XHRcdFx0c2VsZWN0b3IgPSAnPHNlbGVjdCBjbGFzcz1cIicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArICcgJyArIHRoaXMuX2FueVllYXJDbGFzcyArXG5cdFx0XHRcdFx0J1wiIHRpdGxlPVwiJyArIGluc3Qub3B0aW9ucy55ZWFyU3RhdHVzICsgJ1wiPicgK1xuXHRcdFx0XHRcdCc8b3B0aW9uPicgKyB5ZWFyICsgJzwvb3B0aW9uPjwvc2VsZWN0PicgK1xuXHRcdFx0XHRcdCc8aW5wdXQgY2xhc3M9XCInICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgKyAnICcgKyB0aGlzLl9jdXJNb250aENsYXNzICtcblx0XHRcdFx0XHRtb250aCArICdcIiB2YWx1ZT1cIicgKyB5ZWFyICsgJ1wiPic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0eWVhclJhbmdlID0geWVhclJhbmdlLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdHZhciB0b2RheVllYXIgPSBjYWxlbmRhci50b2RheSgpLnllYXIoKTtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gKHllYXJSYW5nZVswXS5tYXRjaCgnY1srLV0uKicpID8geWVhciArIHBhcnNlSW50KHllYXJSYW5nZVswXS5zdWJzdHJpbmcoMSksIDEwKSA6XG5cdFx0XHRcdFx0KCh5ZWFyUmFuZ2VbMF0ubWF0Y2goJ1srLV0uKicpID8gdG9kYXlZZWFyIDogMCkgKyBwYXJzZUludCh5ZWFyUmFuZ2VbMF0sIDEwKSkpO1xuXHRcdFx0XHR2YXIgZW5kID0gKHllYXJSYW5nZVsxXS5tYXRjaCgnY1srLV0uKicpID8geWVhciArIHBhcnNlSW50KHllYXJSYW5nZVsxXS5zdWJzdHJpbmcoMSksIDEwKSA6XG5cdFx0XHRcdFx0KCh5ZWFyUmFuZ2VbMV0ubWF0Y2goJ1srLV0uKicpID8gdG9kYXlZZWFyIDogMCkgKyBwYXJzZUludCh5ZWFyUmFuZ2VbMV0sIDEwKSkpO1xuXHRcdFx0XHRzZWxlY3RvciA9ICc8c2VsZWN0IGNsYXNzPVwiJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICtcblx0XHRcdFx0XHQnXCIgdGl0bGU9XCInICsgaW5zdC5vcHRpb25zLnllYXJTdGF0dXMgKyAnXCI+Jztcblx0XHRcdFx0c3RhcnQgPSBjYWxlbmRhci5uZXdEYXRlKHN0YXJ0ICsgMSwgY2FsZW5kYXIuZmlyc3RNb250aCwgY2FsZW5kYXIubWluRGF5KS5hZGQoLTEsICdkJyk7XG5cdFx0XHRcdGVuZCA9IGNhbGVuZGFyLm5ld0RhdGUoZW5kLCBjYWxlbmRhci5maXJzdE1vbnRoLCBjYWxlbmRhci5taW5EYXkpO1xuXHRcdFx0XHR2YXIgYWRkWWVhciA9IGZ1bmN0aW9uKHksIHlEaXNwbGF5KSB7XG5cdFx0XHRcdFx0aWYgKHkgIT09IDAgfHwgY2FsZW5kYXIuaGFzWWVhclplcm8pIHtcblx0XHRcdFx0XHRcdHNlbGVjdG9yICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArXG5cdFx0XHRcdFx0XHRcdE1hdGgubWluKG1vbnRoLCBjYWxlbmRhci5tb250aHNJblllYXIoeSkgLSAxICsgY2FsZW5kYXIubWluTW9udGgpICtcblx0XHRcdFx0XHRcdFx0Jy8nICsgeSArICdcIicgKyAoeWVhciA9PT0geSA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArICc+JyArXG5cdFx0XHRcdFx0XHRcdCh5RGlzcGxheSB8fCB5KSArICc8L29wdGlvbj4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKHN0YXJ0LnRvSkQoKSA8IGVuZC50b0pEKCkpIHtcblx0XHRcdFx0XHRzdGFydCA9IChtaW5EYXRlICYmIG1pbkRhdGUuY29tcGFyZVRvKHN0YXJ0KSA9PT0gKzEgPyBtaW5EYXRlIDogc3RhcnQpLnllYXIoKTtcblx0XHRcdFx0XHRlbmQgPSAobWF4RGF0ZSAmJiBtYXhEYXRlLmNvbXBhcmVUbyhlbmQpID09PSAtMSA/IG1heERhdGUgOiBlbmQpLnllYXIoKTtcblx0XHRcdFx0XHR2YXIgZWFybGllckxhdGVyID0gTWF0aC5mbG9vcigoZW5kIC0gc3RhcnQpIC8gMik7XG5cdFx0XHRcdFx0aWYgKCFtaW5EYXRlIHx8IG1pbkRhdGUueWVhcigpIDwgc3RhcnQpIHtcblx0XHRcdFx0XHRcdGFkZFllYXIoc3RhcnQgLSBlYXJsaWVyTGF0ZXIsIGluc3Qub3B0aW9ucy5lYXJsaWVyVGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAodmFyIHkgPSBzdGFydDsgeSA8PSBlbmQ7IHkrKykge1xuXHRcdFx0XHRcdFx0YWRkWWVhcih5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFtYXhEYXRlIHx8IG1heERhdGUueWVhcigpID4gZW5kKSB7XG5cdFx0XHRcdFx0XHRhZGRZZWFyKGVuZCArIGVhcmxpZXJMYXRlciwgaW5zdC5vcHRpb25zLmxhdGVyVGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHN0YXJ0ID0gKG1heERhdGUgJiYgbWF4RGF0ZS5jb21wYXJlVG8oc3RhcnQpID09PSAtMSA/IG1heERhdGUgOiBzdGFydCkueWVhcigpO1xuXHRcdFx0XHRcdGVuZCA9IChtaW5EYXRlICYmIG1pbkRhdGUuY29tcGFyZVRvKGVuZCkgPT09ICsxID8gbWluRGF0ZSA6IGVuZCkueWVhcigpO1xuXHRcdFx0XHRcdHZhciBlYXJsaWVyTGF0ZXIgPSBNYXRoLmZsb29yKChzdGFydCAtIGVuZCkgLyAyKTtcblx0XHRcdFx0XHRpZiAoIW1heERhdGUgfHwgbWF4RGF0ZS55ZWFyKCkgPiBzdGFydCkge1xuXHRcdFx0XHRcdFx0YWRkWWVhcihzdGFydCArIGVhcmxpZXJMYXRlciwgaW5zdC5vcHRpb25zLmVhcmxpZXJUZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9yICh2YXIgeSA9IHN0YXJ0OyB5ID49IGVuZDsgeS0tKSB7XG5cdFx0XHRcdFx0XHRhZGRZZWFyKHkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIW1pbkRhdGUgfHwgbWluRGF0ZS55ZWFyKCkgPCBlbmQpIHtcblx0XHRcdFx0XHRcdGFkZFllYXIoZW5kIC0gZWFybGllckxhdGVyLCBpbnN0Lm9wdGlvbnMubGF0ZXJUZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZWN0b3IgKz0gJzwvc2VsZWN0Pic7XG5cdFx0XHR9XG5cdFx0XHRodG1sID0gaHRtbC5yZXBsYWNlKC9cXFxceDJGLywgc2VsZWN0b3IpO1xuXHRcdFx0cmV0dXJuIGh0bWw7XG5cdFx0fSxcblxuXHRcdC8qKiBQcmVwYXJlIGEgcmVuZGVyIHRlbXBsYXRlIGZvciB1c2UuXG5cdFx0XHRFeGNsdWRlIHBvcHVwL2lubGluZSBzZWN0aW9ucyB0aGF0IGFyZSBub3QgYXBwbGljYWJsZS5cblx0XHRcdExvY2FsaXNlIHRleHQgb2YgdGhlIGZvcm06IHtsMTBuOm5hbWV9LlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSB0ZXh0IHtzdHJpbmd9IFRoZSB0ZXh0IHRvIGxvY2FsaXNlLlxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBsb2NhbGlzZWQgdGV4dC4gKi9cblx0XHRfcHJlcGFyZTogZnVuY3Rpb24odGV4dCwgaW5zdCkge1xuXHRcdFx0dmFyIHJlcGxhY2VTZWN0aW9uID0gZnVuY3Rpb24odHlwZSwgcmV0YWluKSB7XG5cdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gdGV4dC5pbmRleE9mKCd7JyArIHR5cGUgKyAnOnN0YXJ0fScpO1xuXHRcdFx0XHRcdGlmIChzdGFydCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGVuZCA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0KS5pbmRleE9mKCd7JyArIHR5cGUgKyAnOmVuZH0nKTtcblx0XHRcdFx0XHRpZiAoZW5kID4gLTEpIHtcblx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydCkgK1xuXHRcdFx0XHRcdFx0XHQocmV0YWluID8gdGV4dC5zdWJzdHIoc3RhcnQgKyB0eXBlLmxlbmd0aCArIDgsIGVuZCAtIHR5cGUubGVuZ3RoIC0gOCkgOiAnJykgK1xuXHRcdFx0XHRcdFx0XHR0ZXh0LnN1YnN0cmluZyhzdGFydCArIGVuZCArIHR5cGUubGVuZ3RoICsgNik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmVwbGFjZVNlY3Rpb24oJ2lubGluZScsIGluc3QuaW5saW5lKTtcblx0XHRcdHJlcGxhY2VTZWN0aW9uKCdwb3B1cCcsICFpbnN0LmlubGluZSk7XG5cdFx0XHR2YXIgcGF0dGVybiA9IC9cXHtsMTBuOihbXlxcfV0rKVxcfS87XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IG51bGw7XG5cdFx0XHR3aGlsZSAobWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyh0ZXh0KSkge1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKG1hdGNoZXNbMF0sIGluc3Qub3B0aW9uc1ttYXRjaGVzWzFdXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH0pO1xuXG5cdHZhciBwbHVnaW4gPSAkLmNhbGVuZGFyc1BpY2tlcjsgLy8gU2luZ2xldG9uIGluc3RhbmNlXG5cblx0JChmdW5jdGlvbigpIHtcblx0XHQkKGRvY3VtZW50KS5vbignbW91c2Vkb3duLicgKyBwbHVnaW5OYW1lLCBwbHVnaW4uX2NoZWNrRXh0ZXJuYWxDbGljaykuXG5cdFx0XHRvbigncmVzaXplLicgKyBwbHVnaW5OYW1lLCBmdW5jdGlvbigpIHsgcGx1Z2luLmhpZGUocGx1Z2luLmN1ckluc3QpOyB9KTtcblx0fSk7XG5cbn0pKGpRdWVyeSk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
