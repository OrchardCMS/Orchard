/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Mayan calendar for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	/** Implementation of the Mayan Long Count calendar.
		See also <a href="http://en.wikipedia.org/wiki/Mayan_calendar">http://en.wikipedia.org/wiki/Mayan_calendar</a>.
		@class MayanCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function MayanCalendar(language) {
		this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
	}

	MayanCalendar.prototype = new $.calendars.baseCalendar;

	$.extend(MayanCalendar.prototype, {
		/** The calendar name.
			@memberof MayanCalendar */
		name: 'Mayan',
		/** Julian date of start of Mayan epoch: 11 August 3114 BCE.
			@memberof MayanCalendar */
		jdEpoch: 584282.5,
		/** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof MayanCalendar */
		hasYearZero: true,
		/** The minimum month number.
			@memberof MayanCalendar */
		minMonth: 0,
		/** The first month in the year.
			@memberof MayanCalendar */
		firstMonth: 0,
		/** The minimum day number.
			@memberof MayanCalendar */
		minDay: 0,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof MayanCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left.
			@property haabMonths {string[]} The names of the Haab months.
			@property tzolkinMonths {string[]} The names of the Tzolkin months. */
		regionalOptions: { // Localisations
			'': {
				name: 'Mayan',
				epochs: ['', ''],
				monthNames: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17'],
				monthNamesShort: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17'],
				dayNames: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
				dayNamesShort: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
				dayNamesMin: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
				dateFormat: 'YYYY.m.d',
				firstDay: 0,
				isRTL: false,
				haabMonths: ['Pop', 'Uo', 'Zip', 'Zotz', 'Tzec', 'Xul', 'Yaxkin', 'Mol', 'Chen', 'Yax',
				'Zac', 'Ceh', 'Mac', 'Kankin', 'Muan', 'Pax', 'Kayab', 'Cumku', 'Uayeb'],
				tzolkinMonths: ['Imix', 'Ik', 'Akbal', 'Kan', 'Chicchan', 'Cimi', 'Manik', 'Lamat', 'Muluc', 'Oc',
				'Chuen', 'Eb', 'Ben', 'Ix', 'Men', 'Cib', 'Caban', 'Etznab', 'Cauac', 'Ahau']
			}
		},

		/** Determine whether this date is in a leap year.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			return false;
		},

		/** Format the year, if not a simple sequential number.
			@memberof MayanCalendar
			@param year {CDate|number} The date to format or the year to format.
			@return {string} The formatted year.
			@throws Error if an invalid year or a different calendar used. */
		formatYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			year = date.year();
			var baktun = Math.floor(year / 400);
			year = year % 400;
			year += (year < 0 ? 400 : 0);
			var katun = Math.floor(year / 20);
			return baktun + '.' + katun + '.' + (year % 20);
		},

		/** Convert from the formatted year back to a single number.
			@memberof MayanCalendar
			@param years {string} The year as n.n.n.
			@return {number} The sequential year.
			@throws Error if an invalid value is supplied. */
		forYear: function(years) {
			years = years.split('.');
			if (years.length < 3) {
				throw 'Invalid Mayan year';
			}
			var year = 0;
			for (var i = 0; i < years.length; i++) {
				var y = parseInt(years[i], 10);
				if (Math.abs(y) > 19 || (i > 0 && y < 0)) {
					throw 'Invalid Mayan year';
				}
				year = year * 20 + y;
			}
			return year;
		},

		/** Retrieve the number of months in a year.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of months.
			@throws Error if an invalid year or a different calendar used. */
		monthsInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			return 18;
		},

		/** Determine the week of the year for a date.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			this._validate(year, month, day, $.calendars.local.invalidDate);
			return 0;
		},

		/** Retrieve the number of days in a year.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of days.
			@throws Error if an invalid year or a different calendar used. */
		daysInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			return 360;
		},

		/** Retrieve the number of days in a month.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			this._validate(year, month, this.minDay, $.calendars.local.invalidMonth);
			return 20;
		},

		/** Retrieve the number of days in a week.
			@memberof MayanCalendar
			@return {number} The number of days. */
		daysInWeek: function() {
			return 5; // Just for formatting
		},

		/** Retrieve the day of the week for a date.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The day of the week: 0 to number of days - 1.
			@throws Error if an invalid date or a different calendar used. */
		dayOfWeek: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			return date.day();
		},

		/** Determine whether this date is a week day.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			this._validate(year, month, day, $.calendars.local.invalidDate);
			return true;
		},

		/** Retrieve additional information about a date - Haab and Tzolkin equivalents.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {object} Additional information - contents depends on calendar.
			@throws Error if an invalid date or a different calendar used. */
		extraInfo: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			var jd = date.toJD();
			var haab = this._toHaab(jd);
			var tzolkin = this._toTzolkin(jd);
			return {haabMonthName: this.local.haabMonths[haab[0] - 1],
				haabMonth: haab[0], haabDay: haab[1],
				tzolkinDayName: this.local.tzolkinMonths[tzolkin[0] - 1],
				tzolkinDay: tzolkin[0], tzolkinTrecena: tzolkin[1]};
		},

		/** Retrieve Haab date from a Julian date.
			@memberof MayanCalendar
			@private
			@param jd  {number} The Julian date.
			@return {number[]} Corresponding Haab month and day. */
		_toHaab: function(jd) {
			jd -= this.jdEpoch;
			var day = mod(jd + 8 + ((18 - 1) * 20), 365);
			return [Math.floor(day / 20) + 1, mod(day, 20)];
		},

		/** Retrieve Tzolkin date from a Julian date.
			@memberof MayanCalendar
			@private
			@param jd {number} The Julian date.
			@return {number[]} Corresponding Tzolkin day and trecena. */
		_toTzolkin: function(jd) {
			jd -= this.jdEpoch;
			return [amod(jd + 20, 20), amod(jd + 4, 13)];
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof MayanCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			return date.day() + (date.month() * 20) + (date.year() * 360) + this.jdEpoch;
		},

		/** Create a new date from a Julian date.
			@memberof MayanCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			jd = Math.floor(jd) + 0.5 - this.jdEpoch;
			var year = Math.floor(jd / 360);
			jd = jd % 360;
			jd += (jd < 0 ? 360 : 0);
			var month = Math.floor(jd / 20);
			var day = jd % 20;
			return this.newDate(year, month, day);
		}
	});

	// Modulus function which works for non-integers.
	function mod(a, b) {
		return a - (b * Math.floor(a / b));
	}

	// Modulus function which returns numerator if modulus is zero.
	function amod(a, b) {
		return mod(a - 1, b) + 1;
	}

	// Mayan calendar implementation
	$.calendars.calendars.mayan = MayanCalendar;

})(jQuery);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMubWF5YW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LmNhbGVuZGFycy5tYXlhbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvY2FsZW5kYXJzLmh0bWxcbiAgIE1heWFuIGNhbGVuZGFyIGZvciBqUXVlcnkgdjIuMC4xLlxuICAgV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSBBdWd1c3QgMjAwOS5cbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwOi8va2VpdGgtd29vZC5uYW1lL2xpY2VuY2UuaHRtbCkgbGljZW5zZS4gXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cblxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxuXG5cdC8qKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgTWF5YW4gTG9uZyBDb3VudCBjYWxlbmRhci5cblx0XHRTZWUgYWxzbyA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXlhbl9jYWxlbmRhclwiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF5YW5fY2FsZW5kYXI8L2E+LlxuXHRcdEBjbGFzcyBNYXlhbkNhbGVuZGFyXG5cdFx0QHBhcmFtIFtsYW5ndWFnZT0nJ10ge3N0cmluZ30gVGhlIGxhbmd1YWdlIGNvZGUgKGRlZmF1bHQgRW5nbGlzaCkgZm9yIGxvY2FsaXNhdGlvbi4gKi9cblx0ZnVuY3Rpb24gTWF5YW5DYWxlbmRhcihsYW5ndWFnZSkge1xuXHRcdHRoaXMubG9jYWwgPSB0aGlzLnJlZ2lvbmFsT3B0aW9uc1tsYW5ndWFnZSB8fCAnJ10gfHwgdGhpcy5yZWdpb25hbE9wdGlvbnNbJyddO1xuXHR9XG5cblx0TWF5YW5DYWxlbmRhci5wcm90b3R5cGUgPSBuZXcgJC5jYWxlbmRhcnMuYmFzZUNhbGVuZGFyO1xuXG5cdCQuZXh0ZW5kKE1heWFuQ2FsZW5kYXIucHJvdG90eXBlLCB7XG5cdFx0LyoqIFRoZSBjYWxlbmRhciBuYW1lLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXIgKi9cblx0XHRuYW1lOiAnTWF5YW4nLFxuXHRcdC8qKiBKdWxpYW4gZGF0ZSBvZiBzdGFydCBvZiBNYXlhbiBlcG9jaDogMTEgQXVndXN0IDMxMTQgQkNFLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXIgKi9cblx0XHRqZEVwb2NoOiA1ODQyODIuNSxcblx0XHQvKiogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgaGFzIGEgeWVhciB6ZXJvLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXIgKi9cblx0XHRoYXNZZWFyWmVybzogdHJ1ZSxcblx0XHQvKiogVGhlIG1pbmltdW0gbW9udGggbnVtYmVyLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXIgKi9cblx0XHRtaW5Nb250aDogMCxcblx0XHQvKiogVGhlIGZpcnN0IG1vbnRoIGluIHRoZSB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXIgKi9cblx0XHRmaXJzdE1vbnRoOiAwLFxuXHRcdC8qKiBUaGUgbWluaW11bSBkYXkgbnVtYmVyLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXIgKi9cblx0XHRtaW5EYXk6IDAsXG5cblx0XHQvKiogTG9jYWxpc2F0aW9ucyBmb3IgdGhlIHBsdWdpbi5cblx0XHRcdEVudHJpZXMgYXJlIG9iamVjdHMgaW5kZXhlZCBieSB0aGUgbGFuZ3VhZ2UgY29kZSAoJycgYmVpbmcgdGhlIGRlZmF1bHQgVVMvRW5nbGlzaCkuXG5cdFx0XHRFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcblx0XHRcdEBwcm9wZXJ0eSBuYW1lIHtzdHJpbmd9IFRoZSBjYWxlbmRhciBuYW1lLlxuXHRcdFx0QHByb3BlcnR5IGVwb2NocyB7c3RyaW5nW119IFRoZSBlcG9jaCBuYW1lcy5cblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzIHtzdHJpbmdbXX0gVGhlIGxvbmcgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lcyB7c3RyaW5nW119IFRoZSBsb25nIG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXNNaW4ge3N0cmluZ1tdfSBUaGUgbWluaW1hbCBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cblx0XHRcdEBwcm9wZXJ0eSBkYXRlRm9ybWF0IHtzdHJpbmd9IFRoZSBkYXRlIGZvcm1hdCBmb3IgdGhpcyBjYWxlbmRhci5cblx0XHRcdFx0XHRTZWUgdGhlIG9wdGlvbnMgb24gPGEgaHJlZj1cIkJhc2VDYWxlbmRhci5odG1sI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4gZm9yIGRldGFpbHMuXG5cdFx0XHRAcHJvcGVydHkgZmlyc3REYXkge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBzdGFydGluZyBhdCAwLlxuXHRcdFx0QHByb3BlcnR5IGlzUlRMIHtudW1iZXJ9IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgbG9jYWxpc2F0aW9uIHJlYWRzIHJpZ2h0LXRvLWxlZnQuXG5cdFx0XHRAcHJvcGVydHkgaGFhYk1vbnRocyB7c3RyaW5nW119IFRoZSBuYW1lcyBvZiB0aGUgSGFhYiBtb250aHMuXG5cdFx0XHRAcHJvcGVydHkgdHpvbGtpbk1vbnRocyB7c3RyaW5nW119IFRoZSBuYW1lcyBvZiB0aGUgVHpvbGtpbiBtb250aHMuICovXG5cdFx0cmVnaW9uYWxPcHRpb25zOiB7IC8vIExvY2FsaXNhdGlvbnNcblx0XHRcdCcnOiB7XG5cdFx0XHRcdG5hbWU6ICdNYXlhbicsXG5cdFx0XHRcdGVwb2NoczogWycnLCAnJ10sXG5cdFx0XHRcdG1vbnRoTmFtZXM6IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG5cdFx0XHRcdCcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNyddLFxuXHRcdFx0XHRtb250aE5hbWVzU2hvcnQ6IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG5cdFx0XHRcdCcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNyddLFxuXHRcdFx0XHRkYXlOYW1lczogWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5Jyxcblx0XHRcdFx0JzEwJywgJzExJywgJzEyJywgJzEzJywgJzE0JywgJzE1JywgJzE2JywgJzE3JywgJzE4JywgJzE5J10sXG5cdFx0XHRcdGRheU5hbWVzU2hvcnQ6IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG5cdFx0XHRcdCcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOSddLFxuXHRcdFx0XHRkYXlOYW1lc01pbjogWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5Jyxcblx0XHRcdFx0JzEwJywgJzExJywgJzEyJywgJzEzJywgJzE0JywgJzE1JywgJzE2JywgJzE3JywgJzE4JywgJzE5J10sXG5cdFx0XHRcdGRhdGVGb3JtYXQ6ICdZWVlZLm0uZCcsXG5cdFx0XHRcdGZpcnN0RGF5OiAwLFxuXHRcdFx0XHRpc1JUTDogZmFsc2UsXG5cdFx0XHRcdGhhYWJNb250aHM6IFsnUG9wJywgJ1VvJywgJ1ppcCcsICdab3R6JywgJ1R6ZWMnLCAnWHVsJywgJ1lheGtpbicsICdNb2wnLCAnQ2hlbicsICdZYXgnLFxuXHRcdFx0XHQnWmFjJywgJ0NlaCcsICdNYWMnLCAnS2Fua2luJywgJ011YW4nLCAnUGF4JywgJ0theWFiJywgJ0N1bWt1JywgJ1VheWViJ10sXG5cdFx0XHRcdHR6b2xraW5Nb250aHM6IFsnSW1peCcsICdJaycsICdBa2JhbCcsICdLYW4nLCAnQ2hpY2NoYW4nLCAnQ2ltaScsICdNYW5paycsICdMYW1hdCcsICdNdWx1YycsICdPYycsXG5cdFx0XHRcdCdDaHVlbicsICdFYicsICdCZW4nLCAnSXgnLCAnTWVuJywgJ0NpYicsICdDYWJhbicsICdFdHpuYWInLCAnQ2F1YWMnLCAnQWhhdSddXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGRhdGUgaXMgaW4gYSBsZWFwIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBpcyBhIGxlYXAgeWVhciwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0bGVhcFllYXI6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHRoaXMuX3ZhbGlkYXRlKHllYXIsIHRoaXMubWluTW9udGgsIHRoaXMubWluRGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkWWVhcik7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKiBGb3JtYXQgdGhlIHllYXIsIGlmIG5vdCBhIHNpbXBsZSBzZXF1ZW50aWFsIG51bWJlci5cblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBmb3JtYXQgb3IgdGhlIHllYXIgdG8gZm9ybWF0LlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHllYXIuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdGZvcm1hdFllYXI6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyKTtcblx0XHRcdHllYXIgPSBkYXRlLnllYXIoKTtcblx0XHRcdHZhciBiYWt0dW4gPSBNYXRoLmZsb29yKHllYXIgLyA0MDApO1xuXHRcdFx0eWVhciA9IHllYXIgJSA0MDA7XG5cdFx0XHR5ZWFyICs9ICh5ZWFyIDwgMCA/IDQwMCA6IDApO1xuXHRcdFx0dmFyIGthdHVuID0gTWF0aC5mbG9vcih5ZWFyIC8gMjApO1xuXHRcdFx0cmV0dXJuIGJha3R1biArICcuJyArIGthdHVuICsgJy4nICsgKHllYXIgJSAyMCk7XG5cdFx0fSxcblxuXHRcdC8qKiBDb252ZXJ0IGZyb20gdGhlIGZvcm1hdHRlZCB5ZWFyIGJhY2sgdG8gYSBzaW5nbGUgbnVtYmVyLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFycyB7c3RyaW5nfSBUaGUgeWVhciBhcyBuLm4ubi5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHNlcXVlbnRpYWwgeWVhci5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB2YWx1ZSBpcyBzdXBwbGllZC4gKi9cblx0XHRmb3JZZWFyOiBmdW5jdGlvbih5ZWFycykge1xuXHRcdFx0eWVhcnMgPSB5ZWFycy5zcGxpdCgnLicpO1xuXHRcdFx0aWYgKHllYXJzLmxlbmd0aCA8IDMpIHtcblx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgTWF5YW4geWVhcic7XG5cdFx0XHR9XG5cdFx0XHR2YXIgeWVhciA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHllYXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB5ID0gcGFyc2VJbnQoeWVhcnNbaV0sIDEwKTtcblx0XHRcdFx0aWYgKE1hdGguYWJzKHkpID4gMTkgfHwgKGkgPiAwICYmIHkgPCAwKSkge1xuXHRcdFx0XHRcdHRocm93ICdJbnZhbGlkIE1heWFuIHllYXInO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHllYXIgPSB5ZWFyICogMjAgKyB5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHllYXI7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIG1vbnRocyBpbiBhIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1vbnRocy5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0bW9udGhzSW5ZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIpO1xuXHRcdFx0cmV0dXJuIDE4O1xuXHRcdH0sXG5cblx0XHQvKiogRGV0ZXJtaW5lIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGZvciBhIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgd2VlayBvZiB0aGUgeWVhci5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0d2Vla09mWWVhcjogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUpO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRkYXlzSW5ZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIpO1xuXHRcdFx0cmV0dXJuIDM2MDtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgb2YgdGhlIG1vbnRoLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBtb250aC5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBtb250aC95ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZGF5c0luTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgdGhpcy5taW5EYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRNb250aCk7XG5cdFx0XHRyZXR1cm4gMjA7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB3ZWVrLlxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzLiAqL1xuXHRcdGRheXNJbldlZWs6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIDU7IC8vIEp1c3QgZm9yIGZvcm1hdHRpbmdcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGEgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBkYXkgb2YgdGhlIHdlZWs6IDAgdG8gbnVtYmVyIG9mIGRheXMgLSAxLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRkYXlPZldlZWs6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUpO1xuXHRcdFx0cmV0dXJuIGRhdGUuZGF5KCk7XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGRhdGUgaXMgYSB3ZWVrIGRheS5cblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR3ZWVrRGF5OiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlIC0gSGFhYiBhbmQgVHpvbGtpbiBlcXVpdmFsZW50cy5cblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gLSBjb250ZW50cyBkZXBlbmRzIG9uIGNhbGVuZGFyLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRleHRyYUluZm86IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUpO1xuXHRcdFx0dmFyIGpkID0gZGF0ZS50b0pEKCk7XG5cdFx0XHR2YXIgaGFhYiA9IHRoaXMuX3RvSGFhYihqZCk7XG5cdFx0XHR2YXIgdHpvbGtpbiA9IHRoaXMuX3RvVHpvbGtpbihqZCk7XG5cdFx0XHRyZXR1cm4ge2hhYWJNb250aE5hbWU6IHRoaXMubG9jYWwuaGFhYk1vbnRoc1toYWFiWzBdIC0gMV0sXG5cdFx0XHRcdGhhYWJNb250aDogaGFhYlswXSwgaGFhYkRheTogaGFhYlsxXSxcblx0XHRcdFx0dHpvbGtpbkRheU5hbWU6IHRoaXMubG9jYWwudHpvbGtpbk1vbnRoc1t0em9sa2luWzBdIC0gMV0sXG5cdFx0XHRcdHR6b2xraW5EYXk6IHR6b2xraW5bMF0sIHR6b2xraW5UcmVjZW5hOiB0em9sa2luWzFdfTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIEhhYWIgZGF0ZSBmcm9tIGEgSnVsaWFuIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBqZCAge251bWJlcn0gVGhlIEp1bGlhbiBkYXRlLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyW119IENvcnJlc3BvbmRpbmcgSGFhYiBtb250aCBhbmQgZGF5LiAqL1xuXHRcdF90b0hhYWI6IGZ1bmN0aW9uKGpkKSB7XG5cdFx0XHRqZCAtPSB0aGlzLmpkRXBvY2g7XG5cdFx0XHR2YXIgZGF5ID0gbW9kKGpkICsgOCArICgoMTggLSAxKSAqIDIwKSwgMzY1KTtcblx0XHRcdHJldHVybiBbTWF0aC5mbG9vcihkYXkgLyAyMCkgKyAxLCBtb2QoZGF5LCAyMCldO1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgVHpvbGtpbiBkYXRlIGZyb20gYSBKdWxpYW4gZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGpkIHtudW1iZXJ9IFRoZSBKdWxpYW4gZGF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcltdfSBDb3JyZXNwb25kaW5nIFR6b2xraW4gZGF5IGFuZCB0cmVjZW5hLiAqL1xuXHRcdF90b1R6b2xraW46IGZ1bmN0aW9uKGpkKSB7XG5cdFx0XHRqZCAtPSB0aGlzLmpkRXBvY2g7XG5cdFx0XHRyZXR1cm4gW2Ftb2QoamQgKyAyMCwgMjApLCBhbW9kKGpkICsgNCwgMTMpXTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBKdWxpYW4gZGF0ZSBlcXVpdmFsZW50IGZvciB0aGlzIGRhdGUsXG5cdFx0XHRpLmUuIGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbi5cblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb252ZXJ0IG9yIHRoZSB5ZWFyIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gY29udmVydC5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBlcXVpdmFsZW50IEp1bGlhbiBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR0b0pEOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlKTtcblx0XHRcdHJldHVybiBkYXRlLmRheSgpICsgKGRhdGUubW9udGgoKSAqIDIwKSArIChkYXRlLnllYXIoKSAqIDM2MCkgKyB0aGlzLmpkRXBvY2g7XG5cdFx0fSxcblxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmcm9tIGEgSnVsaWFuIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIGpkIHtudW1iZXJ9IFRoZSBKdWxpYW4gZGF0ZSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXG5cdFx0ZnJvbUpEOiBmdW5jdGlvbihqZCkge1xuXHRcdFx0amQgPSBNYXRoLmZsb29yKGpkKSArIDAuNSAtIHRoaXMuamRFcG9jaDtcblx0XHRcdHZhciB5ZWFyID0gTWF0aC5mbG9vcihqZCAvIDM2MCk7XG5cdFx0XHRqZCA9IGpkICUgMzYwO1xuXHRcdFx0amQgKz0gKGpkIDwgMCA/IDM2MCA6IDApO1xuXHRcdFx0dmFyIG1vbnRoID0gTWF0aC5mbG9vcihqZCAvIDIwKTtcblx0XHRcdHZhciBkYXkgPSBqZCAlIDIwO1xuXHRcdFx0cmV0dXJuIHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIE1vZHVsdXMgZnVuY3Rpb24gd2hpY2ggd29ya3MgZm9yIG5vbi1pbnRlZ2Vycy5cblx0ZnVuY3Rpb24gbW9kKGEsIGIpIHtcblx0XHRyZXR1cm4gYSAtIChiICogTWF0aC5mbG9vcihhIC8gYikpO1xuXHR9XG5cblx0Ly8gTW9kdWx1cyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIG51bWVyYXRvciBpZiBtb2R1bHVzIGlzIHplcm8uXG5cdGZ1bmN0aW9uIGFtb2QoYSwgYikge1xuXHRcdHJldHVybiBtb2QoYSAtIDEsIGIpICsgMTtcblx0fVxuXG5cdC8vIE1heWFuIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uXG5cdCQuY2FsZW5kYXJzLmNhbGVuZGFycy5tYXlhbiA9IE1heWFuQ2FsZW5kYXI7XG5cbn0pKGpRdWVyeSk7Il0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
