/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Mayan calendar for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	/** Implementation of the Mayan Long Count calendar.
		See also <a href="http://en.wikipedia.org/wiki/Mayan_calendar">http://en.wikipedia.org/wiki/Mayan_calendar</a>.
		@class MayanCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function MayanCalendar(language) {
		this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
	}

	MayanCalendar.prototype = new $.calendars.baseCalendar;

	$.extend(MayanCalendar.prototype, {
		/** The calendar name.
			@memberof MayanCalendar */
		name: 'Mayan',
		/** Julian date of start of Mayan epoch: 11 August 3114 BCE.
			@memberof MayanCalendar */
		jdEpoch: 584282.5,
		/** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof MayanCalendar */
		hasYearZero: true,
		/** The minimum month number.
			@memberof MayanCalendar */
		minMonth: 0,
		/** The first month in the year.
			@memberof MayanCalendar */
		firstMonth: 0,
		/** The minimum day number.
			@memberof MayanCalendar */
		minDay: 0,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof MayanCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left.
			@property haabMonths {string[]} The names of the Haab months.
			@property tzolkinMonths {string[]} The names of the Tzolkin months. */
		regionalOptions: { // Localisations
			'': {
				name: 'Mayan',
				epochs: ['', ''],
				monthNames: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17'],
				monthNamesShort: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17'],
				dayNames: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
				dayNamesShort: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
				dayNamesMin: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
				dateFormat: 'YYYY.m.d',
				firstDay: 0,
				isRTL: false,
				haabMonths: ['Pop', 'Uo', 'Zip', 'Zotz', 'Tzec', 'Xul', 'Yaxkin', 'Mol', 'Chen', 'Yax',
				'Zac', 'Ceh', 'Mac', 'Kankin', 'Muan', 'Pax', 'Kayab', 'Cumku', 'Uayeb'],
				tzolkinMonths: ['Imix', 'Ik', 'Akbal', 'Kan', 'Chicchan', 'Cimi', 'Manik', 'Lamat', 'Muluc', 'Oc',
				'Chuen', 'Eb', 'Ben', 'Ix', 'Men', 'Cib', 'Caban', 'Etznab', 'Cauac', 'Ahau']
			}
		},

		/** Determine whether this date is in a leap year.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			return false;
		},

		/** Format the year, if not a simple sequential number.
			@memberof MayanCalendar
			@param year {CDate|number} The date to format or the year to format.
			@return {string} The formatted year.
			@throws Error if an invalid year or a different calendar used. */
		formatYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			year = date.year();
			var baktun = Math.floor(year / 400);
			year = year % 400;
			year += (year < 0 ? 400 : 0);
			var katun = Math.floor(year / 20);
			return baktun + '.' + katun + '.' + (year % 20);
		},

		/** Convert from the formatted year back to a single number.
			@memberof MayanCalendar
			@param years {string} The year as n.n.n.
			@return {number} The sequential year.
			@throws Error if an invalid value is supplied. */
		forYear: function(years) {
			years = years.split('.');
			if (years.length < 3) {
				throw 'Invalid Mayan year';
			}
			var year = 0;
			for (var i = 0; i < years.length; i++) {
				var y = parseInt(years[i], 10);
				if (Math.abs(y) > 19 || (i > 0 && y < 0)) {
					throw 'Invalid Mayan year';
				}
				year = year * 20 + y;
			}
			return year;
		},

		/** Retrieve the number of months in a year.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of months.
			@throws Error if an invalid year or a different calendar used. */
		monthsInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			return 18;
		},

		/** Determine the week of the year for a date.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			this._validate(year, month, day, $.calendars.local.invalidDate);
			return 0;
		},

		/** Retrieve the number of days in a year.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of days.
			@throws Error if an invalid year or a different calendar used. */
		daysInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay, $.calendars.local.invalidYear);
			return 360;
		},

		/** Retrieve the number of days in a month.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			this._validate(year, month, this.minDay, $.calendars.local.invalidMonth);
			return 20;
		},

		/** Retrieve the number of days in a week.
			@memberof MayanCalendar
			@return {number} The number of days. */
		daysInWeek: function() {
			return 5; // Just for formatting
		},

		/** Retrieve the day of the week for a date.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The day of the week: 0 to number of days - 1.
			@throws Error if an invalid date or a different calendar used. */
		dayOfWeek: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			return date.day();
		},

		/** Determine whether this date is a week day.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			this._validate(year, month, day, $.calendars.local.invalidDate);
			return true;
		},

		/** Retrieve additional information about a date - Haab and Tzolkin equivalents.
			@memberof MayanCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {object} Additional information - contents depends on calendar.
			@throws Error if an invalid date or a different calendar used. */
		extraInfo: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			var jd = date.toJD();
			var haab = this._toHaab(jd);
			var tzolkin = this._toTzolkin(jd);
			return {haabMonthName: this.local.haabMonths[haab[0] - 1],
				haabMonth: haab[0], haabDay: haab[1],
				tzolkinDayName: this.local.tzolkinMonths[tzolkin[0] - 1],
				tzolkinDay: tzolkin[0], tzolkinTrecena: tzolkin[1]};
		},

		/** Retrieve Haab date from a Julian date.
			@memberof MayanCalendar
			@private
			@param jd  {number} The Julian date.
			@return {number[]} Corresponding Haab month and day. */
		_toHaab: function(jd) {
			jd -= this.jdEpoch;
			var day = mod(jd + 8 + ((18 - 1) * 20), 365);
			return [Math.floor(day / 20) + 1, mod(day, 20)];
		},

		/** Retrieve Tzolkin date from a Julian date.
			@memberof MayanCalendar
			@private
			@param jd {number} The Julian date.
			@return {number[]} Corresponding Tzolkin day and trecena. */
		_toTzolkin: function(jd) {
			jd -= this.jdEpoch;
			return [amod(jd + 20, 20), amod(jd + 4, 13)];
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof MayanCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day, $.calendars.local.invalidDate);
			return date.day() + (date.month() * 20) + (date.year() * 360) + this.jdEpoch;
		},

		/** Create a new date from a Julian date.
			@memberof MayanCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			jd = Math.floor(jd) + 0.5 - this.jdEpoch;
			var year = Math.floor(jd / 360);
			jd = jd % 360;
			jd += (jd < 0 ? 360 : 0);
			var month = Math.floor(jd / 20);
			var day = jd % 20;
			return this.newDate(year, month, day);
		}
	});

	// Modulus function which works for non-integers.
	function mod(a, b) {
		return a - (b * Math.floor(a / b));
	}

	// Modulus function which returns numerator if modulus is zero.
	function amod(a, b) {
		return mod(a - 1, b) + 1;
	}

	// Mayan calendar implementation
	$.calendars.calendars.mayan = MayanCalendar;

})(jQuery);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMubWF5YW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LmNhbGVuZGFycy5tYXlhbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvY2FsZW5kYXJzLmh0bWxcclxuICAgTWF5YW4gY2FsZW5kYXIgZm9yIGpRdWVyeSB2Mi4wLjEuXHJcbiAgIFdyaXR0ZW4gYnkgS2VpdGggV29vZCAoa2J3b29ke2F0fWlpbmV0LmNvbS5hdSkgQXVndXN0IDIwMDkuXHJcbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwOi8va2VpdGgtd29vZC5uYW1lL2xpY2VuY2UuaHRtbCkgbGljZW5zZS4gXHJcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xyXG5cclxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxyXG5cclxuXHQvKiogSW1wbGVtZW50YXRpb24gb2YgdGhlIE1heWFuIExvbmcgQ291bnQgY2FsZW5kYXIuXHJcblx0XHRTZWUgYWxzbyA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXlhbl9jYWxlbmRhclwiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF5YW5fY2FsZW5kYXI8L2E+LlxyXG5cdFx0QGNsYXNzIE1heWFuQ2FsZW5kYXJcclxuXHRcdEBwYXJhbSBbbGFuZ3VhZ2U9JyddIHtzdHJpbmd9IFRoZSBsYW5ndWFnZSBjb2RlIChkZWZhdWx0IEVuZ2xpc2gpIGZvciBsb2NhbGlzYXRpb24uICovXHJcblx0ZnVuY3Rpb24gTWF5YW5DYWxlbmRhcihsYW5ndWFnZSkge1xyXG5cdFx0dGhpcy5sb2NhbCA9IHRoaXMucmVnaW9uYWxPcHRpb25zW2xhbmd1YWdlIHx8ICcnXSB8fCB0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ107XHJcblx0fVxyXG5cclxuXHRNYXlhbkNhbGVuZGFyLnByb3RvdHlwZSA9IG5ldyAkLmNhbGVuZGFycy5iYXNlQ2FsZW5kYXI7XHJcblxyXG5cdCQuZXh0ZW5kKE1heWFuQ2FsZW5kYXIucHJvdG90eXBlLCB7XHJcblx0XHQvKiogVGhlIGNhbGVuZGFyIG5hbWUuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyICovXHJcblx0XHRuYW1lOiAnTWF5YW4nLFxyXG5cdFx0LyoqIEp1bGlhbiBkYXRlIG9mIHN0YXJ0IG9mIE1heWFuIGVwb2NoOiAxMSBBdWd1c3QgMzExNCBCQ0UuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyICovXHJcblx0XHRqZEVwb2NoOiA1ODQyODIuNSxcclxuXHRcdC8qKiA8Y29kZT50cnVlPC9jb2RlPiBpZiBoYXMgYSB5ZWFyIHplcm8sIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyICovXHJcblx0XHRoYXNZZWFyWmVybzogdHJ1ZSxcclxuXHRcdC8qKiBUaGUgbWluaW11bSBtb250aCBudW1iZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyICovXHJcblx0XHRtaW5Nb250aDogMCxcclxuXHRcdC8qKiBUaGUgZmlyc3QgbW9udGggaW4gdGhlIHllYXIuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyICovXHJcblx0XHRmaXJzdE1vbnRoOiAwLFxyXG5cdFx0LyoqIFRoZSBtaW5pbXVtIGRheSBudW1iZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyICovXHJcblx0XHRtaW5EYXk6IDAsXHJcblxyXG5cdFx0LyoqIExvY2FsaXNhdGlvbnMgZm9yIHRoZSBwbHVnaW4uXHJcblx0XHRcdEVudHJpZXMgYXJlIG9iamVjdHMgaW5kZXhlZCBieSB0aGUgbGFuZ3VhZ2UgY29kZSAoJycgYmVpbmcgdGhlIGRlZmF1bHQgVVMvRW5nbGlzaCkuXHJcblx0XHRcdEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXHJcblx0XHRcdEBwcm9wZXJ0eSBuYW1lIHtzdHJpbmd9IFRoZSBjYWxlbmRhciBuYW1lLlxyXG5cdFx0XHRAcHJvcGVydHkgZXBvY2hzIHtzdHJpbmdbXX0gVGhlIGVwb2NoIG5hbWVzLlxyXG5cdFx0XHRAcHJvcGVydHkgbW9udGhOYW1lcyB7c3RyaW5nW119IFRoZSBsb25nIG5hbWVzIG9mIHRoZSBtb250aHMgb2YgdGhlIHllYXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cclxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzIHtzdHJpbmdbXX0gVGhlIGxvbmcgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lc1Nob3J0IHtzdHJpbmdbXX0gVGhlIHNob3J0IG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxyXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXNNaW4ge3N0cmluZ1tdfSBUaGUgbWluaW1hbCBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cclxuXHRcdFx0QHByb3BlcnR5IGRhdGVGb3JtYXQge3N0cmluZ30gVGhlIGRhdGUgZm9ybWF0IGZvciB0aGlzIGNhbGVuZGFyLlxyXG5cdFx0XHRcdFx0U2VlIHRoZSBvcHRpb25zIG9uIDxhIGhyZWY9XCJCYXNlQ2FsZW5kYXIuaHRtbCNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+IGZvciBkZXRhaWxzLlxyXG5cdFx0XHRAcHJvcGVydHkgZmlyc3REYXkge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBzdGFydGluZyBhdCAwLlxyXG5cdFx0XHRAcHJvcGVydHkgaXNSVEwge251bWJlcn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBsb2NhbGlzYXRpb24gcmVhZHMgcmlnaHQtdG8tbGVmdC5cclxuXHRcdFx0QHByb3BlcnR5IGhhYWJNb250aHMge3N0cmluZ1tdfSBUaGUgbmFtZXMgb2YgdGhlIEhhYWIgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgdHpvbGtpbk1vbnRocyB7c3RyaW5nW119IFRoZSBuYW1lcyBvZiB0aGUgVHpvbGtpbiBtb250aHMuICovXHJcblx0XHRyZWdpb25hbE9wdGlvbnM6IHsgLy8gTG9jYWxpc2F0aW9uc1xyXG5cdFx0XHQnJzoge1xyXG5cdFx0XHRcdG5hbWU6ICdNYXlhbicsXHJcblx0XHRcdFx0ZXBvY2hzOiBbJycsICcnXSxcclxuXHRcdFx0XHRtb250aE5hbWVzOiBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxyXG5cdFx0XHRcdCcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNyddLFxyXG5cdFx0XHRcdG1vbnRoTmFtZXNTaG9ydDogWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcclxuXHRcdFx0XHQnMTAnLCAnMTEnLCAnMTInLCAnMTMnLCAnMTQnLCAnMTUnLCAnMTYnLCAnMTcnXSxcclxuXHRcdFx0XHRkYXlOYW1lczogWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcclxuXHRcdFx0XHQnMTAnLCAnMTEnLCAnMTInLCAnMTMnLCAnMTQnLCAnMTUnLCAnMTYnLCAnMTcnLCAnMTgnLCAnMTknXSxcclxuXHRcdFx0XHRkYXlOYW1lc1Nob3J0OiBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxyXG5cdFx0XHRcdCcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOSddLFxyXG5cdFx0XHRcdGRheU5hbWVzTWluOiBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxyXG5cdFx0XHRcdCcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOSddLFxyXG5cdFx0XHRcdGRhdGVGb3JtYXQ6ICdZWVlZLm0uZCcsXHJcblx0XHRcdFx0Zmlyc3REYXk6IDAsXHJcblx0XHRcdFx0aXNSVEw6IGZhbHNlLFxyXG5cdFx0XHRcdGhhYWJNb250aHM6IFsnUG9wJywgJ1VvJywgJ1ppcCcsICdab3R6JywgJ1R6ZWMnLCAnWHVsJywgJ1lheGtpbicsICdNb2wnLCAnQ2hlbicsICdZYXgnLFxyXG5cdFx0XHRcdCdaYWMnLCAnQ2VoJywgJ01hYycsICdLYW5raW4nLCAnTXVhbicsICdQYXgnLCAnS2F5YWInLCAnQ3Vta3UnLCAnVWF5ZWInXSxcclxuXHRcdFx0XHR0em9sa2luTW9udGhzOiBbJ0ltaXgnLCAnSWsnLCAnQWtiYWwnLCAnS2FuJywgJ0NoaWNjaGFuJywgJ0NpbWknLCAnTWFuaWsnLCAnTGFtYXQnLCAnTXVsdWMnLCAnT2MnLFxyXG5cdFx0XHRcdCdDaHVlbicsICdFYicsICdCZW4nLCAnSXgnLCAnTWVuJywgJ0NpYicsICdDYWJhbicsICdFdHpuYWInLCAnQ2F1YWMnLCAnQWhhdSddXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBpbiBhIGxlYXAgeWVhci5cclxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGlzIGEgbGVhcCB5ZWFyLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0bGVhcFllYXI6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRm9ybWF0IHRoZSB5ZWFyLCBpZiBub3QgYSBzaW1wbGUgc2VxdWVudGlhbCBudW1iZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGZvcm1hdCBvciB0aGUgeWVhciB0byBmb3JtYXQuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB5ZWFyLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0Zm9ybWF0WWVhcjogZnVuY3Rpb24oeWVhcikge1xyXG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIHRoaXMubWluTW9udGgsIHRoaXMubWluRGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkWWVhcik7XHJcblx0XHRcdHllYXIgPSBkYXRlLnllYXIoKTtcclxuXHRcdFx0dmFyIGJha3R1biA9IE1hdGguZmxvb3IoeWVhciAvIDQwMCk7XHJcblx0XHRcdHllYXIgPSB5ZWFyICUgNDAwO1xyXG5cdFx0XHR5ZWFyICs9ICh5ZWFyIDwgMCA/IDQwMCA6IDApO1xyXG5cdFx0XHR2YXIga2F0dW4gPSBNYXRoLmZsb29yKHllYXIgLyAyMCk7XHJcblx0XHRcdHJldHVybiBiYWt0dW4gKyAnLicgKyBrYXR1biArICcuJyArICh5ZWFyICUgMjApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29udmVydCBmcm9tIHRoZSBmb3JtYXR0ZWQgeWVhciBiYWNrIHRvIGEgc2luZ2xlIG51bWJlci5cclxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcclxuXHRcdFx0QHBhcmFtIHllYXJzIHtzdHJpbmd9IFRoZSB5ZWFyIGFzIG4ubi5uLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBzZXF1ZW50aWFsIHllYXIuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB2YWx1ZSBpcyBzdXBwbGllZC4gKi9cclxuXHRcdGZvclllYXI6IGZ1bmN0aW9uKHllYXJzKSB7XHJcblx0XHRcdHllYXJzID0geWVhcnMuc3BsaXQoJy4nKTtcclxuXHRcdFx0aWYgKHllYXJzLmxlbmd0aCA8IDMpIHtcclxuXHRcdFx0XHR0aHJvdyAnSW52YWxpZCBNYXlhbiB5ZWFyJztcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgeWVhciA9IDA7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeWVhcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgeSA9IHBhcnNlSW50KHllYXJzW2ldLCAxMCk7XHJcblx0XHRcdFx0aWYgKE1hdGguYWJzKHkpID4gMTkgfHwgKGkgPiAwICYmIHkgPCAwKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgTWF5YW4geWVhcic7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHllYXIgPSB5ZWFyICogMjAgKyB5O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB5ZWFyO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBtb250aHMgaW4gYSB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBtb250aHMuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRtb250aHNJblllYXI6IGZ1bmN0aW9uKHllYXIpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyKTtcclxuXHRcdFx0cmV0dXJuIDE4O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGZvciBhIGRhdGUuXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHdlZWsgb2YgdGhlIHllYXIuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHR3ZWVrT2ZZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksICQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlKTtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB5ZWFyLlxyXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZGF5c0luWWVhcjogZnVuY3Rpb24oeWVhcikge1xyXG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIpO1xyXG5cdFx0XHRyZXR1cm4gMzYwO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGguXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgb2YgdGhlIG1vbnRoLlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGguXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgbW9udGguXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBtb250aC95ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHRkYXlzSW5Nb250aDogZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcclxuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkTW9udGgpO1xyXG5cdFx0XHRyZXR1cm4gMjA7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB3ZWVrLlxyXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cy4gKi9cclxuXHRcdGRheXNJbldlZWs6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gNTsgLy8gSnVzdCBmb3IgZm9ybWF0dGluZ1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGRheSBvZiB0aGUgd2VlayBmb3IgYSBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBkYXkgb2YgdGhlIHdlZWs6IDAgdG8gbnVtYmVyIG9mIGRheXMgLSAxLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZGF5T2ZXZWVrOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUpO1xyXG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXkoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBhIHdlZWsgZGF5LlxyXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0d2Vla0RheTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xyXG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCBhIGRhdGUgLSBIYWFiIGFuZCBUem9sa2luIGVxdWl2YWxlbnRzLlxyXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXHJcblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gLSBjb250ZW50cyBkZXBlbmRzIG9uIGNhbGVuZGFyLlxyXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xyXG5cdFx0ZXh0cmFJbmZvOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUpO1xyXG5cdFx0XHR2YXIgamQgPSBkYXRlLnRvSkQoKTtcclxuXHRcdFx0dmFyIGhhYWIgPSB0aGlzLl90b0hhYWIoamQpO1xyXG5cdFx0XHR2YXIgdHpvbGtpbiA9IHRoaXMuX3RvVHpvbGtpbihqZCk7XHJcblx0XHRcdHJldHVybiB7aGFhYk1vbnRoTmFtZTogdGhpcy5sb2NhbC5oYWFiTW9udGhzW2hhYWJbMF0gLSAxXSxcclxuXHRcdFx0XHRoYWFiTW9udGg6IGhhYWJbMF0sIGhhYWJEYXk6IGhhYWJbMV0sXHJcblx0XHRcdFx0dHpvbGtpbkRheU5hbWU6IHRoaXMubG9jYWwudHpvbGtpbk1vbnRoc1t0em9sa2luWzBdIC0gMV0sXHJcblx0XHRcdFx0dHpvbGtpbkRheTogdHpvbGtpblswXSwgdHpvbGtpblRyZWNlbmE6IHR6b2xraW5bMV19O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgSGFhYiBkYXRlIGZyb20gYSBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGpkICB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcltdfSBDb3JyZXNwb25kaW5nIEhhYWIgbW9udGggYW5kIGRheS4gKi9cclxuXHRcdF90b0hhYWI6IGZ1bmN0aW9uKGpkKSB7XHJcblx0XHRcdGpkIC09IHRoaXMuamRFcG9jaDtcclxuXHRcdFx0dmFyIGRheSA9IG1vZChqZCArIDggKyAoKDE4IC0gMSkgKiAyMCksIDM2NSk7XHJcblx0XHRcdHJldHVybiBbTWF0aC5mbG9vcihkYXkgLyAyMCkgKyAxLCBtb2QoZGF5LCAyMCldO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgVHpvbGtpbiBkYXRlIGZyb20gYSBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QG1lbWJlcm9mIE1heWFuQ2FsZW5kYXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGpkIHtudW1iZXJ9IFRoZSBKdWxpYW4gZGF0ZS5cclxuXHRcdFx0QHJldHVybiB7bnVtYmVyW119IENvcnJlc3BvbmRpbmcgVHpvbGtpbiBkYXkgYW5kIHRyZWNlbmEuICovXHJcblx0XHRfdG9Uem9sa2luOiBmdW5jdGlvbihqZCkge1xyXG5cdFx0XHRqZCAtPSB0aGlzLmpkRXBvY2g7XHJcblx0XHRcdHJldHVybiBbYW1vZChqZCArIDIwLCAyMCksIGFtb2QoamQgKyA0LCAxMyldO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIEp1bGlhbiBkYXRlIGVxdWl2YWxlbnQgZm9yIHRoaXMgZGF0ZSxcclxuXHRcdFx0aS5lLiBkYXlzIHNpbmNlIEphbnVhcnkgMSwgNDcxMyBCQ0UgR3JlZW53aWNoIG5vb24uXHJcblx0XHRcdEBtZW1iZXJvZiBNYXlhbkNhbGVuZGFyXHJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvbnZlcnQgb3IgdGhlIHllYXIgdG8gY29udmVydC5cclxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGVxdWl2YWxlbnQgSnVsaWFuIGRhdGUuXHJcblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXHJcblx0XHR0b0pEOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSwgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUpO1xyXG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXkoKSArIChkYXRlLm1vbnRoKCkgKiAyMCkgKyAoZGF0ZS55ZWFyKCkgKiAzNjApICsgdGhpcy5qZEVwb2NoO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgZnJvbSBhIEp1bGlhbiBkYXRlLlxyXG5cdFx0XHRAbWVtYmVyb2YgTWF5YW5DYWxlbmRhclxyXG5cdFx0XHRAcGFyYW0gamQge251bWJlcn0gVGhlIEp1bGlhbiBkYXRlIHRvIGNvbnZlcnQuXHJcblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZXF1aXZhbGVudCBkYXRlLiAqL1xyXG5cdFx0ZnJvbUpEOiBmdW5jdGlvbihqZCkge1xyXG5cdFx0XHRqZCA9IE1hdGguZmxvb3IoamQpICsgMC41IC0gdGhpcy5qZEVwb2NoO1xyXG5cdFx0XHR2YXIgeWVhciA9IE1hdGguZmxvb3IoamQgLyAzNjApO1xyXG5cdFx0XHRqZCA9IGpkICUgMzYwO1xyXG5cdFx0XHRqZCArPSAoamQgPCAwID8gMzYwIDogMCk7XHJcblx0XHRcdHZhciBtb250aCA9IE1hdGguZmxvb3IoamQgLyAyMCk7XHJcblx0XHRcdHZhciBkYXkgPSBqZCAlIDIwO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5uZXdEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBNb2R1bHVzIGZ1bmN0aW9uIHdoaWNoIHdvcmtzIGZvciBub24taW50ZWdlcnMuXHJcblx0ZnVuY3Rpb24gbW9kKGEsIGIpIHtcclxuXHRcdHJldHVybiBhIC0gKGIgKiBNYXRoLmZsb29yKGEgLyBiKSk7XHJcblx0fVxyXG5cclxuXHQvLyBNb2R1bHVzIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgbnVtZXJhdG9yIGlmIG1vZHVsdXMgaXMgemVyby5cclxuXHRmdW5jdGlvbiBhbW9kKGEsIGIpIHtcclxuXHRcdHJldHVybiBtb2QoYSAtIDEsIGIpICsgMTtcclxuXHR9XHJcblxyXG5cdC8vIE1heWFuIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uXHJcblx0JC5jYWxlbmRhcnMuY2FsZW5kYXJzLm1heWFuID0gTWF5YW5DYWxlbmRhcjtcclxuXHJcbn0pKGpRdWVyeSk7Il0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
