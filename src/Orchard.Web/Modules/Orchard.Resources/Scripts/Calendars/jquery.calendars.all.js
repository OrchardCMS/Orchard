/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	function Calendars() {
		this.regionalOptions = [];
		this.regionalOptions[''] = {
			invalidCalendar: 'Calendar {0} not found',
			invalidDate: 'Invalid {0} date',
			invalidMonth: 'Invalid {0} month',
			invalidYear: 'Invalid {0} year',
			differentCalendars: 'Cannot mix {0} and {1} dates'
		};
		this.local = this.regionalOptions[''];
		this.calendars = {};
		this._localCals = {};
	}

	/** Create the calendars plugin.
		<p>Provides support for various world calendars in a consistent manner.</p>
	 	@class Calendars
		@example $.calendars.instance('julian').newDate(2014, 12, 25) */
	$.extend(Calendars.prototype, {

		/** Obtain a calendar implementation and localisation.
			@memberof Calendars
			@param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
			@param [language=''] {string} The language code to use for localisation (default is English).
			@return {Calendar} The calendar and localisation.
			@throws Error if calendar not found. */
		instance: function(name, language) {
			name = (name || 'gregorian').toLowerCase();
			language = language || '';
			var cal = this._localCals[name + '-' + language];
			if (!cal && this.calendars[name]) {
				cal = new this.calendars[name](language);
				this._localCals[name + '-' + language] = cal;
			}
			if (!cal) {
				throw (this.local.invalidCalendar || this.regionalOptions[''].invalidCalendar).
					replace(/\{0\}/, name);
			}
			return cal;
		},

		/** Create a new date - for today if no other parameters given.
			@memberof Calendars
			@param year {CDate|number} The date to copy or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
			@param [language=''] {string} The language to use for localisation (default English).
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day, calendar, language) {
			calendar = (year != null && year.year ? year.calendar() : (typeof calendar === 'string' ?
				this.instance(calendar, language) : calendar)) || this.instance();
			return calendar.newDate(year, month, day);
		}
	});

	/** Generic date, based on a particular calendar.
		@class CDate
		@param calendar {BaseCalendar} The underlying calendar implementation.
		@param year {number} The year for this date.
		@param month {number} The month for this date.
		@param day {number} The day for this date.
		@return {CDate} The date object.
		@throws Error if an invalid date. */
	function CDate(calendar, year, month, day) {
		this._calendar = calendar;
		this._year = year;
		this._month = month;
		this._day = day;
		if (this._calendar._validateLevel === 0 &&
				!this._calendar.isValid(this._year, this._month, this._day)) {
			throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
				replace(/\{0\}/, this._calendar.local.name);
		}
	}

	/** Pad a numeric value with leading zeroes.
		@private
		@param value {number} The number to format.
		@param length {number} The minimum length.
		@return {string} The formatted number. */
	function pad(value, length) {
		value = '' + value;
		return '000000'.substring(0, length - value.length) + value;
	}

	$.extend(CDate.prototype, {

		/** Create a new date.
			@memberof CDate
			@param [year] {CDate|number} The date to copy or the year for the date (default this date).
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if an invalid date. */
		newDate: function(year, month, day) {
			return this._calendar.newDate((year == null ? this : year), month, day);
		},

		/** Set or retrieve the year for this date.
			@memberof CDate
			@param [year] {number} The year for the date.
			@return {number|CDate} The date's year (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		year: function(year) {
			return (arguments.length === 0 ? this._year : this.set(year, 'y'));
		},

		/** Set or retrieve the month for this date.
			@memberof CDate
			@param [month] {number} The month for the date.
			@return {number|CDate} The date's month (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		month: function(month) {
			return (arguments.length === 0 ? this._month : this.set(month, 'm'));
		},

		/** Set or retrieve the day for this date.
			@memberof CDate
			@param [day] {number} The day for the date.
			@return {number|CData} The date's day (if no parameter) or the updated date.
			@throws Error if an invalid date. */
		day: function(day) {
			return (arguments.length === 0 ? this._day : this.set(day, 'd'));
		},

		/** Set new values for this date.
			@memberof CDate
			@param year {number} The year for the date.
			@param month {number} The month for the date.
			@param day {number} The day for the date.
			@return {CDate} The updated date.
			@throws Error if an invalid date. */
		date: function(year, month, day) {
			if (!this._calendar.isValid(year, month, day)) {
				throw ($.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate).
					replace(/\{0\}/, this._calendar.local.name);
			}
			this._year = year;
			this._month = month;
			this._day = day;
			return this;
		},

		/** Determine whether this date is in a leap year.
			@memberof CDate
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
		leapYear: function() {
			return this._calendar.leapYear(this);
		},

		/** Retrieve the epoch designator for this date, e.g. BCE or CE.
			@memberof CDate
			@return {string} The current epoch. */
		epoch: function() {
			return this._calendar.epoch(this);
		},

		/** Format the year, if not a simple sequential number.
			@memberof CDate
			@return {string} The formatted year. */
		formatYear: function() {
			return this._calendar.formatYear(this);
		},

		/** Retrieve the month of the year for this date,
			i.e. the month's position within a numbered year.
			@memberof CDate
			@return {number} The month of the year: <code>minMonth</code> to months per year. */
		monthOfYear: function() {
			return this._calendar.monthOfYear(this);
		},

		/** Retrieve the week of the year for this date.
			@memberof CDate
			@return {number} The week of the year: 1 to weeks per year. */
		weekOfYear: function() {
			return this._calendar.weekOfYear(this);
		},

		/** Retrieve the number of days in the year for this date.
			@memberof CDate
			@return {number} The number of days in this year. */
		daysInYear: function() {
			return this._calendar.daysInYear(this);
		},

		/** Retrieve the day of the year for this date.
			@memberof CDate
			@return {number} The day of the year: 1 to days per year. */
		dayOfYear: function() {
			return this._calendar.dayOfYear(this);
		},

		/** Retrieve the number of days in the month for this date.
			@memberof CDate
			@return {number} The number of days. */
		daysInMonth: function() {
			return this._calendar.daysInMonth(this);
		},

		/** Retrieve the day of the week for this date.
			@memberof CDate
			@return {number} The day of the week: 0 to number of days - 1. */
		dayOfWeek: function() {
			return this._calendar.dayOfWeek(this);
		},

		/** Determine whether this date is a week day.
			@memberof CDate
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
		weekDay: function() {
			return this._calendar.weekDay(this);
		},

		/** Retrieve additional information about this date.
			@memberof CDate
			@return {object} Additional information - contents depends on calendar. */
		extraInfo: function() {
			return this._calendar.extraInfo(this);
		},

		/** Add period(s) to a date.
			@memberof CDate
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		add: function(offset, period) {
			return this._calendar.add(this, offset, period);
		},

		/** Set a portion of the date.
			@memberof CDate
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if not a valid date. */
		set: function(value, period) {
			return this._calendar.set(this, value, period);
		},

		/** Compare this date to another date.
			@memberof CDate
			@param date {CDate} The other date.
			@return {number} -1 if this date is before the other date,
					0 if they are equal, or +1 if this date is after the other date. */
		compareTo: function(date) {
			if (this._calendar.name !== date._calendar.name) {
				throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
					replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
			}
			var c = (this._year !== date._year ? this._year - date._year :
				this._month !== date._month ? this.monthOfYear() - date.monthOfYear() :
				this._day - date._day);
			return (c === 0 ? 0 : (c < 0 ? -1 : +1));
		},

		/** Retrieve the calendar backing this date.
			@memberof CDate
			@return {BaseCalendar} The calendar implementation. */
		calendar: function() {
			return this._calendar;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof CDate
			@return {number} The equivalent Julian date. */
		toJD: function() {
			return this._calendar.toJD(this);
		},

		/** Create a new date from a Julian date.
			@memberof CDate
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			return this._calendar.fromJD(jd);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@return {Date} The equivalent JavaScript date. */
		toJSDate: function() {
			return this._calendar.toJSDate(this);
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof CDate
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this._calendar.fromJSDate(jsd);
		},

		/** Convert to a string for display.
			@memberof CDate
			@return {string} This date as a string. */
		toString: function() {
			return (this.year() < 0 ? '-' : '') + pad(Math.abs(this.year()), 4) +
				'-' + pad(this.month(), 2) + '-' + pad(this.day(), 2);
		}
	});

	/** Basic functionality for all calendars.
		Other calendars should extend this:
		<pre>OtherCalendar.prototype = new BaseCalendar;</pre>
		@class BaseCalendar */
	function BaseCalendar() {
		this.shortYearCutoff = '+10';
	}

	$.extend(BaseCalendar.prototype, {
		_validateLevel: 0, // "Stack" to turn validation on/off

		/** Create a new date within this calendar - today if no parameters given.
			@memberof BaseCalendar
			@param year {CDate|number} The date to duplicate or the year for the date.
			@param [month] {number} The month for the date.
			@param [day] {number} The day for the date.
			@return {CDate} The new date.
			@throws Error if not a valid date or a different calendar used. */
		newDate: function(year, month, day) {
			if (year == null) {
				return this.today();
			}
			if (year.year) {
				this._validate(year, month, day,
					$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
				day = year.day();
				month = year.month();
				year = year.year();
			}
			return new CDate(this, year, month, day);
		},

		/** Create a new date for today.
			@memberof BaseCalendar
			@return {CDate} Today's date. */
		today: function() {
			return this.fromJSDate(new Date());
		},

		/** Retrieve the epoch designator for this date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {string} The current epoch.
			@throws Error if an invalid year or a different calendar used. */
		epoch: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1]);
		},

		/** Format the year, if not a simple sequential number
			@memberof BaseCalendar
			@param year {CDate|number} The date to format or the year to format.
			@return {string} The formatted year.
			@throws Error if an invalid year or a different calendar used. */
		formatYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (date.year() < 0 ? '-' : '') + pad(Math.abs(date.year()), 4)
		},

		/** Retrieve the number of months in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of months.
			@throws Error if an invalid year or a different calendar used. */
		monthsInYear: function(year) {
			this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return 12;
		},

		/** Calculate the month's ordinal position within the year -
			for those calendars that don't start at month 1!
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param month {number} The month to examine.
			@return {number} The ordinal position, starting from <code>minMonth</code>.
			@throws Error if an invalid year/month or a different calendar used. */
		monthOfYear: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return (date.month() + this.monthsInYear(date) - this.firstMonth) %
				this.monthsInYear(date) + this.minMonth;
		},

		/** Calculate actual month from ordinal position, starting from minMonth.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param ord {number} The month's ordinal position.
			@return {number} The month's number.
			@throws Error if an invalid year/month. */
		fromMonthOfYear: function(year, ord) {
			var m = (ord + this.firstMonth - 2 * this.minMonth) %
				this.monthsInYear(year) + this.minMonth;
			this._validate(year, m, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return m;
		},

		/** Retrieve the number of days in a year.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {number} The number of days.
			@throws Error if an invalid year or a different calendar used. */
		daysInYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			return (this.leapYear(date) ? 366 : 365);
		},

		/** Retrieve the day of the year for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The day of the year.
			@throws Error if an invalid date or a different calendar used. */
		dayOfYear: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return date.toJD() - this.newDate(date.year(),
				this.fromMonthOfYear(date.year(), this.minMonth), this.minDay).toJD() + 1;
		},

		/** Retrieve the number of days in a week.
			@memberof BaseCalendar
			@return {number} The number of days. */
		daysInWeek: function() {
			return 7;
		},

		/** Retrieve the day of the week for a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The day of the week: 0 to number of days - 1.
			@throws Error if an invalid date or a different calendar used. */
		dayOfWeek: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
		},

		/** Retrieve additional information about a date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {object} Additional information - contents depends on calendar.
			@throws Error if an invalid date or a different calendar used. */
		extraInfo: function(year, month, day) {
			this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return {};
		},

		/** Add period(s) to a date.
			Cater for no year zero.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if a different calendar used. */
		add: function(date, offset, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return this._correctAdd(date, this._add(date, offset, period), offset, period);
		},

		/** Add period(s) to a date.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_add: function(date, offset, period) {
			this._validateLevel++;
			if (period === 'd' || period === 'w') {
				var jd = date.toJD() + offset * (period === 'w' ? this.daysInWeek() : 1);
				var d = date.calendar().fromJD(jd);
				this._validateLevel--;
				return [d.year(), d.month(), d.day()];
			}
			try {
				var y = date.year() + (period === 'y' ? offset : 0);
				var m = date.monthOfYear() + (period === 'm' ? offset : 0);
				var d = date.day();// + (period === 'd' ? offset : 0) +
					//(period === 'w' ? offset * this.daysInWeek() : 0);
				var resyncYearMonth = function(calendar) {
					while (m < calendar.minMonth) {
						y--;
						m += calendar.monthsInYear(y);
					}
					var yearMonths = calendar.monthsInYear(y);
					while (m > yearMonths - 1 + calendar.minMonth) {
						y++;
						m -= yearMonths;
						yearMonths = calendar.monthsInYear(y);
					}
				};
				if (period === 'y') {
					if (date.month() !== this.fromMonthOfYear(y, m)) { // Hebrew
						m = this.newDate(y, date.month(), this.minDay).monthOfYear();
					}
					m = Math.min(m, this.monthsInYear(y));
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				else if (period === 'm') {
					resyncYearMonth(this);
					d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
				}
				var ymd = [y, this.fromMonthOfYear(y, m), d];
				this._validateLevel--;
				return ymd;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		},

		/** Correct a candidate date after adding period(s) to a date.
			Handle no year zero if necessary.
			@memberof BaseCalendar
			@private
			@param date {CDate} The starting date.
			@param ymd {number[]} The added date.
			@param offset {number} The number of periods to adjust by.
			@param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
			@return {CDate} The updated date. */
		_correctAdd: function(date, ymd, offset, period) {
			if (!this.hasYearZero && (period === 'y' || period === 'm')) {
				if (ymd[0] === 0 || // In year zero
						(date.year() > 0) !== (ymd[0] > 0)) { // Crossed year zero
					var adj = {y: [1, 1, 'y'], m: [1, this.monthsInYear(-1), 'm'],
						w: [this.daysInWeek(), this.daysInYear(-1), 'd'],
						d: [1, this.daysInYear(-1), 'd']}[period];
					var dir = (offset < 0 ? -1 : +1);
					ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
				}
			}
			return date.date(ymd[0], ymd[1], ymd[2]);
		},

		/** Set a portion of the date.
			@memberof BaseCalendar
			@param date {CDate} The starting date.
			@param value {number} The new value for the period.
			@param period {string} One of 'y' for year, 'm' for month, 'd' for day.
			@return {CDate} The updated date.
			@throws Error if an invalid date or a different calendar used. */
		set: function(date, value, period) {
			this._validate(date, this.minMonth, this.minDay,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var y = (period === 'y' ? value : date.year());
			var m = (period === 'm' ? value : date.month());
			var d = (period === 'd' ? value : date.day());
			if (period === 'y' || period === 'm') {
				d = Math.min(d, this.daysInMonth(y, m));
			}
			return date.date(y, m, d);
		},

		/** Determine whether a date is valid for this calendar.
			@memberof BaseCalendar
			@param year {number} The year to examine.
			@param month {number} The month to examine.
			@param day {number} The day to examine.
			@return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
		isValid: function(year, month, day) {
			this._validateLevel++;
			var valid = (this.hasYearZero || year !== 0);
			if (valid) {
				var date = this.newDate(year, month, this.minDay);
				valid = (month >= this.minMonth && month - this.minMonth < this.monthsInYear(date)) &&
					(day >= this.minDay && day - this.minDay < this.daysInMonth(date));
			}
			this._validateLevel--;
			return valid;
		},

		/** Convert the date to a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			return $.calendars.instance().fromJD(this.toJD(date)).toJSDate();
		},

		/** Convert the date from a standard (Gregorian) JavaScript Date.
			@memberof BaseCalendar
			@param jsd {Date} The JavaScript date.
			@return {CDate} The equivalent calendar date. */
		fromJSDate: function(jsd) {
			return this.fromJD($.calendars.instance().fromJSDate(jsd).toJD());
		},

		/** Check that a candidate date is from the same calendar and is valid.
			@memberof BaseCalendar
			@private
			@param year {CDate|number} The date to validate or the year to validate.
			@param [month] {number} The month to validate.
			@param [day] {number} The day to validate.
			@param error {string} Rrror message if invalid.
			@throws Error if different calendars used or invalid date. */
		_validate: function(year, month, day, error) {
			if (year.year) {
				if (this._validateLevel === 0 && this.name !== year.calendar().name) {
					throw ($.calendars.local.differentCalendars || $.calendars.regionalOptions[''].differentCalendars).
						replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
				}
				return year;
			}
			try {
				this._validateLevel++;
				if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
					throw error.replace(/\{0\}/, this.local.name);
				}
				var date = this.newDate(year, month, day);
				this._validateLevel--;
				return date;
			}
			catch (e) {
				this._validateLevel--;
				throw e;
			}
		}
	});

	/** Implementation of the Proleptic Gregorian Calendar.
		See <a href=":http://en.wikipedia.org/wiki/Gregorian_calendar">http://en.wikipedia.org/wiki/Gregorian_calendar</a>
		and <a href="http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar</a>.
		@class GregorianCalendar
		@augments BaseCalendar
		@param [language=''] {string} The language code (default English) for localisation. */
	function GregorianCalendar(language) {
		this.local = this.regionalOptions[language] || this.regionalOptions[''];
	}

	GregorianCalendar.prototype = new BaseCalendar;

	$.extend(GregorianCalendar.prototype, {
		/** The calendar name.
			@memberof GregorianCalendar */
		name: 'Gregorian',
		 /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
			@memberof GregorianCalendar */
		jdEpoch: 1721425.5,
		 /** Days per month in a common year.
			@memberof GregorianCalendar */
		daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		 /** <code>true</code> if has a year zero, <code>false</code> if not.
			@memberof GregorianCalendar */
		hasYearZero: false,
		/** The minimum month number.
			@memberof GregorianCalendar */
		minMonth: 1,
		/** The first month in the year.
			@memberof GregorianCalendar */
		firstMonth: 1,
		 /** The minimum day number.
			@memberof GregorianCalendar */
		minDay: 1,

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof GregorianCalendar
			@property name {string} The calendar name.
			@property epochs {string[]} The epoch names.
			@property monthNames {string[]} The long names of the months of the year.
			@property monthNamesShort {string[]} The short names of the months of the year.
			@property dayNames {string[]} The long names of the days of the week.
			@property dayNamesShort {string[]} The short names of the days of the week.
			@property dayNamesMin {string[]} The minimal names of the days of the week.
			@property dateFormat {string} The date format for this calendar.
					See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
			@property firstDay {number} The number of the first day of the week, starting at 0.
			@property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
		regionalOptions: { // Localisations
			'': {
				name: 'Gregorian',
				epochs: ['BCE', 'CE'],
				monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
				'July', 'August', 'September', 'October', 'November', 'December'],
				monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
				dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
				dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
				dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
				dateFormat: 'mm/dd/yyyy',
				firstDay: 0,
				isRTL: false
			}
		},
		
		/** Determine whether this date is in a leap year.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
			@throws Error if an invalid year or a different calendar used. */
		leapYear: function(year) {
			var date = this._validate(year, this.minMonth, this.minDay,
				$.calendars.local.invalidYear || $.calendars.regionalOptions[''].invalidYear);
			var year = date.year() + (date.year() < 0 ? 1 : 0); // No year zero
			return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
		},

		/** Determine the week of the year for a date - ISO 8601.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {number} The week of the year, starting from 1.
			@throws Error if an invalid date or a different calendar used. */
		weekOfYear: function(year, month, day) {
			// Find Thursday of this week starting on Monday
			var checkDate = this.newDate(year, month, day);
			checkDate.add(4 - (checkDate.dayOfWeek() || 7), 'd');
			return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
		},

		/** Retrieve the number of days in a month.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year of the month.
			@param [month] {number} The month.
			@return {number} The number of days in this month.
			@throws Error if an invalid month/year or a different calendar used. */
		daysInMonth: function(year, month) {
			var date = this._validate(year, month, this.minDay,
				$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);
			return this.daysPerMonth[date.month() - 1] +
				(date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
		},

		/** Determine whether this date is a week day.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to examine or the year to examine.
			@param [month] {number} The month to examine.
			@param [day] {number} The day to examine.
			@return {boolean} <code>true</code> if a week day, <code>false</code> if not.
			@throws Error if an invalid date or a different calendar used. */
		weekDay: function(year, month, day) {
			return (this.dayOfWeek(year, month, day) || 7) < 6;
		},

		/** Retrieve the Julian date equivalent for this date,
			i.e. days since January 1, 4713 BCE Greenwich noon.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {number} The equivalent Julian date.
			@throws Error if an invalid date or a different calendar used. */
		toJD: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			year = date.year();
			month = date.month();
			day = date.day();
			if (year < 0) { year++; } // No year zero
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			if (month < 3) {
				month += 12;
				year--;
			}
			var a = Math.floor(year / 100);
			var b = 2 - a + Math.floor(a / 4);
			return Math.floor(365.25 * (year + 4716)) +
				Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
		},

		/** Create a new date from a Julian date.
			@memberof GregorianCalendar
			@param jd {number} The Julian date to convert.
			@return {CDate} The equivalent date. */
		fromJD: function(jd) {
			// Jean Meeus algorithm, "Astronomical Algorithms", 1991
			var z = Math.floor(jd + 0.5);
			var a = Math.floor((z - 1867216.25) / 36524.25);
			a = z + 1 + a - Math.floor(a / 4);
			var b = a + 1524;
			var c = Math.floor((b - 122.1) / 365.25);
			var d = Math.floor(365.25 * c);
			var e = Math.floor((b - d) / 30.6001);
			var day = b - d - Math.floor(e * 30.6001);
			var month = e - (e > 13.5 ? 13 : 1);
			var year = c - (month > 2.5 ? 4716 : 4715);
			if (year <= 0) { year--; } // No year zero
			return this.newDate(year, month, day);
		},

		/** Convert this date to a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param year {CDate|number} The date to convert or the year to convert.
			@param [month] {number} The month to convert.
			@param [day] {number} The day to convert.
			@return {Date} The equivalent JavaScript date.
			@throws Error if an invalid date or a different calendar used. */
		toJSDate: function(year, month, day) {
			var date = this._validate(year, month, day,
				$.calendars.local.invalidDate || $.calendars.regionalOptions[''].invalidDate);
			var jsd = new Date(date.year(), date.month() - 1, date.day());
			jsd.setHours(0);
			jsd.setMinutes(0);
			jsd.setSeconds(0);
			jsd.setMilliseconds(0);
			// Hours may be non-zero on daylight saving cut-over:
			// > 12 when midnight changeover, but then cannot generate
			// midnight datetime, so jump to 1AM, otherwise reset.
			jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
			return jsd;
		},

		/** Create a new date from a standard (Gregorian) JavaScript Date.
			@memberof GregorianCalendar
			@param jsd {Date} The JavaScript date to convert.
			@return {CDate} The equivalent date. */
		fromJSDate: function(jsd) {
			return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
		}
	});

	// Singleton manager
	$.calendars = new Calendars();

	// Date template
	$.calendars.cdate = CDate;

	// Base calendar template
	$.calendars.baseCalendar = BaseCalendar;

	// Gregorian calendar implementation
	$.calendars.calendars.gregorian = GregorianCalendar;

})(jQuery);
/* http://keith-wood.name/calendars.html
   Calendars extras for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	$.extend($.calendars.regionalOptions[''], {
		invalidArguments: 'Invalid arguments',
		invalidFormat: 'Cannot format a date from another calendar',
		missingNumberAt: 'Missing number at position {0}',
		unknownNameAt: 'Unknown name at position {0}',
		unexpectedLiteralAt: 'Unexpected literal at position {0}',
		unexpectedText: 'Additional text found at end'
	});
	$.calendars.local = $.calendars.regionalOptions[''];

	$.extend($.calendars.cdate.prototype, {

		/** Format this date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof CDate
			@param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
			@return {string} The formatted date. */
		formatDate: function(format) {
			return this._calendar.formatDate(format || '', this);
		}
	});

	$.extend($.calendars.baseCalendar.prototype, {

		UNIX_EPOCH: $.calendars.instance().newDate(1970, 1, 1).toJD(),
		SECS_PER_DAY: 24 * 60 * 60,
		TICKS_EPOCH: $.calendars.instance().jdEpoch, // 1 January 0001 CE
		TICKS_PER_DAY: 24 * 60 * 60 * 10000000,

		/** Date form for ATOM (RFC 3339/ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ATOM: 'yyyy-mm-dd',
		/** Date form for cookies.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		COOKIE: 'D, dd M yyyy',
		/** Date form for full date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		FULL: 'DD, MM d, yyyy',
		/** Date form for ISO 8601.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		ISO_8601: 'yyyy-mm-dd',
		/** Date form for Julian date.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		JULIAN: 'J',
		/** Date form for RFC 822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_822: 'D, d M yy',
		/** Date form for RFC 850.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_850: 'DD, dd-M-yy',
		/** Date form for RFC 1036.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1036: 'D, d M yy',
		/** Date form for RFC 1123.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_1123: 'D, d M yyyy',
		/** Date form for RFC 2822.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RFC_2822: 'D, d M yyyy',
		/** Date form for RSS (RFC 822).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		RSS: 'D, d M yy',
		/** Date form for Windows ticks.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TICKS: '!',
		/** Date form for Unix timestamp.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		TIMESTAMP: '@',
		/** Date form for W3c (ISO 8601).
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar */
		W3C: 'yyyy-mm-dd',

		/** Format a date object into a string value.
			The format can be combinations of the following:
			<ul>
			<li>d  - day of month (no leading zero)</li>
			<li>dd - day of month (two digit)</li>
			<li>o  - day of year (no leading zeros)</li>
			<li>oo - day of year (three digit)</li>
			<li>D  - day name short</li>
			<li>DD - day name long</li>
			<li>w  - week of year (no leading zero)</li>
			<li>ww - week of year (two digit)</li>
			<li>m  - month of year (no leading zero)</li>
			<li>mm - month of year (two digit)</li>
			<li>M  - month name short</li>
			<li>MM - month name long</li>
			<li>yy - year (two digit)</li>
			<li>yyyy - year (four digit)</li>
			<li>YYYY - formatted year</li>
			<li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
			<li>@  - Unix timestamp (s since 01/01/1970)</li>
			<li>!  - Windows ticks (100ns since 01/01/0001)</li>
			<li>'...' - literal text</li>
			<li>'' - single quote</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param [format] {string} The desired format of the date (defaults to calendar format).
			@param date {CDate} The date value to format.
			@param [settings] {object} Addition options, whose attributes include:
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
			@return {string} The date in the above format.
			@throws Errors if the date is from a different calendar. */
		formatDate: function(format, date, settings) {
			if (typeof format !== 'string') {
				settings = date;
				date = format;
				format = '';
			}
			if (!date) {
				return '';
			}
			if (date.calendar() !== this) {
				throw $.calendars.local.invalidFormat || $.calendars.regionalOptions[''].invalidFormat;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Format a number, with leading zeroes if necessary
			var formatNumber = function(match, value, len, step) {
				var num = '' + value;
				if (doubled(match, step)) {
					while (num.length < len) {
						num = '0' + num;
					}
				}
				return num;
			};
			// Format a name, short or long as requested
			var formatName = function(match, value, shortNames, longNames) {
				return (doubled(match) ? longNames[value] : shortNames[value]);
			};
			var output = '';
			var literal = false;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						output += format.charAt(iFormat);
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': output += formatNumber('d', date.day(), 2); break;
						case 'D': output += formatName('D', date.dayOfWeek(),
							dayNamesShort, dayNames); break;
						case 'o': output += formatNumber('o', date.dayOfYear(), 3); break;
						case 'w': output += formatNumber('w', date.weekOfYear(), 2); break;
						case 'm': output += formatNumber('m', date.month(), 2); break;
						case 'M': output += formatName('M', date.month() - this.minMonth,
							monthNamesShort, monthNames); break;
						case 'y':
							output += (doubled('y', 2) ? date.year() :
								(date.year() % 100 < 10 ? '0' : '') + date.year() % 100);
							break;
						case 'Y':
							doubled('Y', 2);
							output += date.formatYear();
							break;
						case 'J': output += date.toJD(); break;
						case '@': output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY; break;
						case '!': output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY; break;
						case "'":
							if (doubled("'")) {
								output += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
			return output;
		},

		/** Parse a string value into a date object.
			See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
			<ul>
			<li>* - ignore rest of string</li>
			</ul>
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param format {string} The expected format of the date ('' for default calendar format).
			@param value {string} The date in the above format.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The extracted date value or <code>null</code> if value is blank.
			@throws Errors if the format and/or value are missing,
					if the value doesn't match the format, or if the date is invalid. */
		parseDate: function(format, value, settings) {
			if (value == null) {
				throw $.calendars.local.invalidArguments || $.calendars.regionalOptions[''].invalidArguments;
			}
			value = (typeof value === 'object' ? value.toString() : value + '');
			if (value === '') {
				return null;
			}
			format = format || this.local.dateFormat;
			settings = settings || {};
			var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
			shortYearCutoff = (typeof shortYearCutoff !== 'string' ? shortYearCutoff :
				this.today().year() % 100 + parseInt(shortYearCutoff, 10));
			var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
			var dayNames = settings.dayNames || this.local.dayNames;
			var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
			var monthNames = settings.monthNames || this.local.monthNames;
			var jd = -1;
			var year = -1;
			var month = -1;
			var day = -1;
			var doy = -1;
			var shortYear = false;
			var literal = false;
			// Check whether a format character is doubled
			var doubled = function(match, step) {
				var matches = 1;
				while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
					matches++;
				}
				iFormat += matches - 1;
				return Math.floor(matches / (step || 1)) > 1;
			};
			// Extract a number from the string value
			var getNumber = function(match, step) {
				var isDoubled = doubled(match, step);
				var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]['oyYJ@!'.indexOf(match) + 1];
				var digits = new RegExp('^-?\\d{1,' + size + '}');
				var num = value.substring(iValue).match(digits);
				if (!num) {
					throw ($.calendars.local.missingNumberAt || $.calendars.regionalOptions[''].missingNumberAt).
						replace(/\{0\}/, iValue);
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			};
			// Extract a name from the string value and convert to an index
			var calendar = this;
			var getName = function(match, shortNames, longNames, step) {
				var names = (doubled(match, step) ? longNames : shortNames);
				for (var i = 0; i < names.length; i++) {
					if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
						iValue += names[i].length;
						return i + calendar.minMonth;
					}
				}
				throw ($.calendars.local.unknownNameAt || $.calendars.regionalOptions[''].unknownNameAt).
					replace(/\{0\}/, iValue);
			};
			// Confirm that a literal character matches the string value
			var checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw ($.calendars.local.unexpectedLiteralAt ||
						$.calendars.regionalOptions[''].unexpectedLiteralAt).replace(/\{0\}/, iValue);
				}
				iValue++;
			};
			var iValue = 0;
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !doubled("'")) {
						literal = false;
					}
					else {
						checkLiteral();
					}
				}
				else {
					switch (format.charAt(iFormat)) {
						case 'd': day = getNumber('d'); break;
						case 'D': getName('D', dayNamesShort, dayNames); break;
						case 'o': doy = getNumber('o'); break;
						case 'w': getNumber('w'); break;
						case 'm': month = getNumber('m'); break;
						case 'M': month = getName('M', monthNamesShort, monthNames); break;
						case 'y':
							var iSave = iFormat;
							shortYear = !doubled('y', 2);
							iFormat = iSave;
							year = getNumber('y', 2);
							break;
						case 'Y': year = getNumber('Y', 2); break;
						case 'J':
							jd = getNumber('J') + 0.5;
							if (value.charAt(iValue) === '.') {
								iValue++;
								getNumber('J');
							}
							break;
						case '@': jd = getNumber('@') / this.SECS_PER_DAY + this.UNIX_EPOCH; break;
						case '!': jd = getNumber('!') / this.TICKS_PER_DAY + this.TICKS_EPOCH; break;
						case '*': iValue = value.length; break;
						case "'":
							if (doubled("'")) {
								checkLiteral();
							}
							else {
								literal = true;
							}
							break;
						default: checkLiteral();
					}
				}
			}
			if (iValue < value.length) {
				throw $.calendars.local.unexpectedText || $.calendars.regionalOptions[''].unexpectedText;
			}
			if (year === -1) {
				year = this.today().year();
			}
			else if (year < 100 && shortYear) {
				year += (shortYearCutoff === -1 ? 1900 : this.today().year() -
					this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100));
			}
			if (doy > -1) {
				month = 1;
				day = doy;
				for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
					month++;
					day -= dim;
				}
			}
			return (jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day));
		},

		/** A date may be specified as an exact value or a relative one.
			Found in the <code>jquery.calendars.plus.js</code> module.
			@memberof BaseCalendar
			@param dateSpec {CDate|number|string} The date as an object or string in the given format or
					an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
			@param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
			@param currentDate {CDate} The current date as a possible basis for relative dates,
					if <code>null</code> today is used (optional)
			@param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
			@param [settings] {object} Additional options whose attributes include:
			@property [shortYearCutoff] {number} The cutoff year for determining the century.
			@property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
			@property [dayNames] {string[]} Names of the days from Sunday.
			@property [monthNamesShort] {string[]} Abbreviated names of the months.
			@property [monthNames] {string[]} Names of the months.
			@return {CDate} The decoded date. */
		determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
			if (currentDate && typeof currentDate !== 'object') {
				settings = dateFormat;
				dateFormat = currentDate;
				currentDate = null;
			}
			if (typeof dateFormat !== 'string') {
				settings = dateFormat;
				dateFormat = '';
			}
			var calendar = this;
			var offsetString = function(offset) {
				try {
					return calendar.parseDate(dateFormat, offset, settings);
				}
				catch (e) {
					// Ignore
				}
				offset = offset.toLowerCase();
				var date = (offset.match(/^c/) && currentDate ?
					currentDate.newDate() : null) || calendar.today();
				var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
				var matches = pattern.exec(offset);
				while (matches) {
					date.add(parseInt(matches[1], 10), matches[2] || 'd');
					matches = pattern.exec(offset);
				}
				return date;
			};
			defaultDate = (defaultDate ? defaultDate.newDate() : null);
			dateSpec = (dateSpec == null ? defaultDate :
				(typeof dateSpec === 'string' ? offsetString(dateSpec) : (typeof dateSpec === 'number' ?
				(isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate :
				calendar.today().add(dateSpec, 'd')) : calendar.newDate(dateSpec))));
			return dateSpec;
		}
	});

})(jQuery);
/* http://keith-wood.name/calendars.html
   Calendars date picker for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'calendarsPicker';


	/** Create the calendars datepicker plugin.
		<p>Sets an input field to popup a calendar for date entry,
			or a <code>div</code> or <code>span</code> to show an inline calendar.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;input type="text"> or &lt;div>&lt;/div></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;input type="text" data-calendarsPicker="name: 'value'"/></pre>
	 	@class CalendarsPicker
		@augments JQPlugin
		@example $(selector).calendarsPicker()
 $(selector).calendarsPicker({minDate: 0, maxDate: '+1m +1w'}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin.
			@memberof CalendarsPicker */
		name: pluginName,
		
		/** Default template for generating a datepicker.
			Insert anywhere:
			<ul>
			<li>'{l10n:name}' to insert localised value for name,</li>
			<li>'{link:name}' to insert a link trigger for command name,</li>
			<li>'{button:name}' to insert a button trigger for command name,</li>
			<li>'{popup:start}...{popup:end}' to mark a section for inclusion in a popup datepicker only,</li>
			<li>'{inline:start}...{inline:end}' to mark a section for inclusion in an inline datepicker only.</li>
			</ul>
			@memberof CalendarsPicker
			@property picker {string} Overall structure: '{months}' to insert calendar months.
			@property monthRow {string} One row of months: '{months}' to insert calendar months.
			@property month {string} A single month: '{monthHeader<em>:dateFormat</em>}' to insert the month header -
						<em>dateFormat</em> is optional and defaults to 'MM yyyy',
						'{weekHeader}' to insert a week header, '{weeks}' to insert the month's weeks.
			@property weekHeader {string} A week header: '{days}' to insert individual day names.
			@property dayHeader {string} Individual day header: '{day}' to insert day name.
			@property week {string} One week of the month: '{days}' to insert the week's days,
						'{weekOfYear}' to insert week of year.
			@property day {string} An individual day: '{day}' to insert day value.
			@property monthSelector {string} jQuery selector, relative to picker, for a single month.
			@property daySelector {string} jQuery selector, relative to picker, for individual days.
			@property rtlClass {string} Class for right-to-left (RTL) languages.
			@property multiClass {string} Class for multi-month datepickers.
			@property defaultClass {string} Class for selectable dates.
			@property selectedClass {string} Class for currently selected dates.
			@property highlightedClass {string} Class for highlighted dates.
			@property todayClass {string} Class for today.
			@property otherMonthClass {string} Class for days from other months.
			@property weekendClass {string} Class for days on weekends.
			@property commandClass {string} Class prefix for commands.
			@property commandButtonClass {string} Extra class(es) for commands that are buttons.
			@property commandLinkClass {string} Extra class(es) for commands that are links.
			@property disabledClass {string} Class for disabled commands. */
		defaultRenderer: {
			picker: '<div class="calendars">' +
			'<div class="calendars-nav">{link:prev}{link:today}{link:next}</div>{months}' +
			'{popup:start}<div class="calendars-ctrl">{link:clear}{link:close}</div>{popup:end}' +
			'<div class="calendars-clear-fix"></div></div>',
			monthRow: '<div class="calendars-month-row">{months}</div>',
			month: '<div class="calendars-month"><div class="calendars-month-header">{monthHeader}</div>' +
			'<table><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
			weekHeader: '<tr>{days}</tr>',
			dayHeader: '<th>{day}</th>',
			week: '<tr>{days}</tr>',
			day: '<td>{day}</td>',
			monthSelector: '.calendars-month',
			daySelector: 'td',
			rtlClass: 'calendars-rtl',
			multiClass: 'calendars-multi',
			defaultClass: '',
			selectedClass: 'calendars-selected',
			highlightedClass: 'calendars-highlight',
			todayClass: 'calendars-today',
			otherMonthClass: 'calendars-other-month',
			weekendClass: 'calendars-weekend',
			commandClass: 'calendars-cmd',
			commandButtonClass: '',
			commandLinkClass: '',
			disabledClass: 'calendars-disabled'
		},
	
		/** Command actions that may be added to a layout by name.
			<ul>
			<li>prev - Show the previous month (based on <code>monthsToStep</code> option) - <em>PageUp</em></li>
			<li>prevJump - Show the previous year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageUp</em></li>
			<li>next - Show the next month (based on <code>monthsToStep</code> option) - <em>PageDown</em></li>
			<li>nextJump - Show the next year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageDown</em></li>
			<li>current - Show the currently selected month or today's if none selected - <em>Ctrl+Home</em></li>
			<li>today - Show today's month - <em>Ctrl+Home</em></li>
			<li>clear - Erase the date and close the datepicker popup - <em>Ctrl+End</em></li>
			<li>close - Close the datepicker popup - <em>Esc</em></li>
			<li>prevWeek - Move the cursor to the previous week - <em>Ctrl+Up</em></li>
			<li>prevDay - Move the cursor to the previous day - <em>Ctrl+Left</em></li>
			<li>nextDay - Move the cursor to the next day - <em>Ctrl+Right</em></li>
			<li>nextWeek - Move the cursor to the next week - <em>Ctrl+Down</em></li>
			</ul>
			The command name is the key name and is used to add the command to a layout
			with '{button:name}' or '{link:name}'. Each has the following attributes.
			@memberof CalendarsPicker
			@property text {string} The field in the regional settings for the displayed text.
			@property status {string} The field in the regional settings for the status text.
			@property keystroke {object} The keystroke to trigger the action, with attributes:
				<code>keyCode</code> {number} the code for the keystroke,
				<code>ctrlKey</code> {boolean} <code>true</code> if <em>Ctrl</em> is required,
				<code>altKey</code> {boolean} <code>true</code> if <em>Alt</em> is required,
				<code>shiftKey</code> {boolean} <code>true</code> if <em>Shift</em> is required.
			@property enabled {CalendarsPickerCommandEnabled} The function that indicates the command is enabled.
			@property date {CalendarsPickerCommandDate} The function to get the date associated with this action.
			@property action {CalendarsPickerCommandAction} The function that implements the action. */
		commands: {
			prev: {text: 'prevText', status: 'prevStatus', // Previous month
				keystroke: {keyCode: 33}, // Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToStep); }
			},
			prevJump: {text: 'prevJumpText', status: 'prevJumpStatus', // Previous year
				keystroke: {keyCode: 33, ctrlKey: true}, // Ctrl + Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToJump); }
			},
			next: {text: 'nextText', status: 'nextStatus', // Next month
				keystroke: {keyCode: 34}, // Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToStep); }
			},
			nextJump: {text: 'nextJumpText', status: 'nextJumpStatus', // Next year
				keystroke: {keyCode: 34, ctrlKey: true}, // Ctrl + Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1);	},
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToJump); }
			},
			current: {text: 'currentText', status: 'currentStatus', // Current month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					return (!minDate || curDate.compareTo(minDate) !== -1) &&
						(!maxDate || curDate.compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.selectedDates[0] || inst.options.calendar.today(); },
				action: function(inst) {
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					plugin.showMonth(this, curDate.year(), curDate.month()); }
			},
			today: {text: 'todayText', status: 'todayStatus', // Today's month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					return (!minDate || inst.options.calendar.today().compareTo(minDate) !== -1) &&
						(!maxDate || inst.options.calendar.today().compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.options.calendar.today(); },
				action: function(inst) { plugin.showMonth(this); }
			},
			clear: {text: 'clearText', status: 'clearStatus', // Clear the datepicker
				keystroke: {keyCode: 35, ctrlKey: true}, // Ctrl + End
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.clear(this); }
			},
			close: {text: 'closeText', status: 'closeStatus', // Close the datepicker
				keystroke: {keyCode: 27}, // Escape
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.hide(this); }
			},
			prevWeek: {text: 'prevWeekText', status: 'prevWeekStatus', // Previous week
				keystroke: {keyCode: 38, ctrlKey: true}, // Ctrl + Up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(-inst.options.calendar.daysInWeek(), 'd').compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(-inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, -inst.options.calendar.daysInWeek()); }
			},
			prevDay: {text: 'prevDayText', status: 'prevDayStatus', // Previous day
				keystroke: {keyCode: 37, ctrlKey: true}, // Ctrl + Left
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().add(-1, 'd').
						compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().add(-1, 'd'); },
				action: function(inst) { plugin.changeDay(this, -1); }
			},
			nextDay: {text: 'nextDayText', status: 'nextDayStatus', // Next day
				keystroke: {keyCode: 39, ctrlKey: true}, // Ctrl + Right
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().add(1, 'd').
						compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().add(1, 'd'); },
				action: function(inst) { plugin.changeDay(this, 1); }
			},
			nextWeek: {text: 'nextWeekText', status: 'nextWeekStatus', // Next week
				keystroke: {keyCode: 40, ctrlKey: true}, // Ctrl + Down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.calendar.daysInWeek(), 'd').compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, inst.options.calendar.daysInWeek()); }
			}
		},

		/** Determine whether a command is enabled.
			@callback CalendarsPickerCommandEnabled
			@param inst {object} The current instance settings.
			@return {boolean} <code>true</code> if this command is enabled, <code>false</code> if not.
			@example enabled: function(inst) {
	return !!inst.curMinDate();
 } */

		/** Calculate the representative date for a command.
			@callback CalendarsPickerCommandDate
			@param inst {object} The current instance settings.
			@return {CDate} A date appropriate for this command.
			@example date: function(inst) {
	return inst.curMinDate();
 } */

		/** Perform the action for a command.
			@callback CalendarsPickerCommandAction
			@param inst {object} The current instance settings.
			@example date: function(inst) {
	$.datepick.setDate(inst.elem, inst.curMinDate());
 } */

		/** Calculate the week of the year for a date.
			@callback CalendarsPickerCalculateWeek
			@param date {CDate} The date to evaluate.
			@return {number} The week of the year.
			@example calculateWeek: function(date) {
	var startYear = $.calendars.newDate(date.year(), 1, 1);
	return Math.floor((date.dayOfYear() - startYear.dayOfYear()) / 7) + 1;
 } */

		/** Provide information about an individual date shown in the calendar.
			@callback CalendarsPickerOnDate
			@param date {CDate} The date to evaluate.
			@return {object} Information about that date, with the properties above.
			@property selectable {boolean} <code>true</code> if this date can be selected.
			@property dateClass {string} Class(es) to be applied to the date.
			@property content {string} The date cell content.
			@property tooltip {string} A popup tooltip for the date.
			@example onDate: function(date) {
	return {selectable: date.day() > 0 && date.day() &lt; 5,
		dateClass: date.day() === 4 ? 'last-day' : ''};
 } */

		/** Update the datepicker display.
			@callback CalendarsPickerOnShow
			@param picker {jQuery} The datepicker <code>div</code> to be shown.
			@param inst {object} The current instance settings.
			@example onShow: function(picker, inst) {
	picker.append('&lt;button type="button">Hi&lt;/button>').
		find('button:last').click(function() {
			alert('Hi!');
		});
 } */

		/** React to navigating through the months/years.
			@callback CalendarsPickerOnChangeMonthYear
			@param year {number} The new year.
			@param month {number} The new month (1 to 12).
			@example onChangeMonthYear: function(year, month) {
	alert('Now in ' + month + '/' + year);
 } */
			
		/** Datepicker on select callback.
			Triggered when a date is selected.
			@callback CalendarsPickerOnSelect
			@param dates {CDate[]} The selected date(s).
			@example onSelect: function(dates) {
 	alert('Selected ' + dates);
 } */
			
		/** Datepicker on close callback.
			Triggered when a popup calendar is closed.
			@callback CalendarsPickerOnClose
			@param dates {CDate[]} The selected date(s).
			@example onClose: function(dates) {
 	alert('Selected ' + dates);
 } */
		
		/** Default settings for the plugin.
			@memberof CalendarsPicker
			@property [calendar=$.calendars.instance()] {Calendar} The calendar for this datepicker.
			@property [pickerClass=''] {string} CSS class to add to this instance of the datepicker.
			@property [showOnFocus=true] {boolean} <code>true</code> for popup on focus, <code>false</code> for not.
			@property [showTrigger=null] {string|Element|jQuery} Element to be cloned for a trigger, <code>null</code> for none.
			@property [showAnim='show'] {string} Name of jQuery animation for popup, '' for no animation.
			@property [showOptions=null] {object} Options for enhanced animations.
			@property [showSpeed='normal'] {string} Duration of display/closure.
			@property [popupContainer=null] {string|Element|jQuery} The element to which a popup calendar is added, <code>null</code> for body.
			@property [alignment='bottom'] {string} Alignment of popup - with nominated corner of input:
						'top' or 'bottom' aligns depending on language direction,
						'topLeft', 'topRight', 'bottomLeft', 'bottomRight'.
			@property [fixedWeeks=false] {boolean} <code>true</code> to always show 6 weeks, <code>false</code> to only show as many as are needed.
			@property [firstDay=null] {number} First day of the week, 0 = Sunday, 1 = Monday, etc., <code>null</code> for <code>calendar</code> default.
			@property [calculateWeek=null] {CalendarsPickerCalculateWeek} Calculate week of the year from a date, <code>null</code> for <code>calendar</code> default.
			@property [monthsToShow=1] {number|number[]} How many months to show, cols or [rows, cols].
			@property [monthsOffset=0] {number} How many months to offset the primary month by;
						may be a function that takes the date and returns the offset.
			@property [monthsToStep=1] {number} How many months to move when prev/next clicked.
			@property [monthsToJump=12] {number} How many months to move when large prev/next clicked.
			@property [useMouseWheel=true] {boolean} <code>true</code> to use mousewheel if available, <code>false</code> to never use it.
			@property [changeMonth=true] {boolean} <code>true</code> to change month/year via drop-down, <code>false</code> for navigation only.
			@property [yearRange='c-10:c+10'] {string} Range of years to show in drop-down: 'any' for direct text entry
						or 'start:end', where start/end are '+-nn' for relative to today
						or 'c+-nn' for relative to the currently selected date
						or 'nnnn' for an absolute year.
			@property [showOtherMonths=false] {boolean} <code>true</code> to show dates from other months, <code>false</code> to not show them.
			@property [selectOtherMonths=false] {boolean} <code>true</code> to allow selection of dates from other months too.
			@property [defaultDate=null] {string|number|CDate} Date to show if no other selected.
			@property [selectDefaultDate=false] {boolean} <code>true</code> to pre-select the default date if no other is chosen.
			@property [minDate=null] {string|number|CDate} The minimum selectable date.
			@property [maxDate=null] {string|number|CDate} The maximum selectable date.
			@property [dateFormat='mm/dd/yyyy'] {string} Format for dates.
			@property [autoSize=false] {boolean} <code>true</code> to size the input field according to the date format.
			@property [rangeSelect=false] {boolean} Allows for selecting a date range on one date picker.
			@property [rangeSeparator=' - '] {string} Text between two dates in a range.
			@property [multiSelect=0] {number} Maximum number of selectable dates, zero for single select.
			@property [multiSeparator=','] {string} Text between multiple dates.
			@property [onDate=null] {CalendarsPickerOnDate} Callback as a date is added to the datepicker.
			@property [onShow=null] {CalendarsPickerOnShow} Callback just before a datepicker is shown.
			@property [onChangeMonthYear=null] {CalendarsPickerOnChangeMonthYear} Callback when a new month/year is selected.
			@property [onSelect=null] {CalendarsPickerOnSelect} Callback when a date is selected.
			@property [onClose=null] {CalendarsPickerOnClose} Callback when a datepicker is closed.
			@property [altField=null] {string|Element|jQuery} Alternate field to update in synch with the datepicker.
			@property [altFormat=null] {string} Date format for alternate field, defaults to <code>dateFormat</code>.
			@property [constrainInput=true] {boolean} <code>true</code> to constrain typed input to <code>dateFormat</code> allowed characters.
			@property [commandsAsDateFormat=false] {boolean} <code>true</code> to apply
						<code><a href="#formatDate">formatDate</a></code> to the command texts.
			@property [commands=this.commands] {object} Command actions that may be added to a layout by name. */
		defaultOptions: {
			calendar: $.calendars.instance(),
			pickerClass: '',
			showOnFocus: true,
			showTrigger: null,
			showAnim: 'show',
			showOptions: {},
			showSpeed: 'normal',
			popupContainer: null,
			alignment: 'bottom',
			fixedWeeks: false,
			firstDay: null,
			calculateWeek: null,
			monthsToShow: 1,
			monthsOffset: 0,
			monthsToStep: 1,
			monthsToJump: 12,
			useMouseWheel: true,
			changeMonth: true,
			yearRange: 'c-10:c+10',
			showOtherMonths: false,
			selectOtherMonths: false,
			defaultDate: null,
			selectDefaultDate: false,
			minDate: null,
			maxDate: null,
			dateFormat: null,
			autoSize: false,
			rangeSelect: false,
			rangeSeparator: ' - ',
			multiSelect: 0,
			multiSeparator: ',',
			onDate: null,
			onShow: null,
			onChangeMonthYear: null,
			onSelect: null,
			onClose: null,
			altField: null,
			altFormat: null,
			constrainInput: true,
			commandsAsDateFormat: false,
			commands: {} // this.commands
		},

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof CalendarsPicker
			@property [renderer=this.defaultRenderer] {string} The rendering templates.
			@property [prevText='&lt;Prev'] {string} Text for the previous month command.
			@property [prevStatus='Show the previous month'] {string} Status text for the previous month command.
			@property [prevJumpText='&lt;&lt;'] {string} Text for the previous year command.
			@property [prevJumpStatus='Show the previous year'] {string} Status text for the previous year command.
			@property [nextText='Next&gt;'] {string} Text for the next month command.
			@property [nextStatus='Show the next month'] {string} Status text for the next month command.
			@property [nextJumpText='&gt;&gt;'] {string} Text for the next year command.
			@property [nextJumpStatus='Show the next year'] {string} Status text for the next year command.
			@property [currentText='Current'] {string} Text for the current month command.
			@property [currentStatus='Show the current month'] {string} Status text for the current month command.
			@property [todayText='Today'] {string} Text for the today's month command.
			@property [todayStatus='Show today\'s month'] {string} Status text for the today's month command.
			@property [clearText='Clear'] {string} Text for the clear command.
			@property [clearStatus='Clear all the dates'] {string} Status text for the clear command.
			@property [closeText='Close'] {string} Text for the close command.
			@property [closeStatus='Close the datepicker'] {string} Status text for the close command.
			@property [yearStatus='Change the year'] {string} Status text for year selection.
			@property [earlierText='&#160;&#160;▲'] {string} Text for earlier years.
			@property [laterText='&#160;&#160;▼'] {string} Text for later years.
			@property [monthStatus='Change the month'] {string} Status text for month selection.
			@property [weekText='Wk'] {string} Text for week of the year column header.
			@property [weekStatus='Week of the year'] {string} Status text for week of the year column header.
			@property [dayStatus='Select DD,&#160;M&#160;d,&#160;yyyy'] {string} Status text for selectable days.
			@property [defaultStatus='Select a date'] {string} Status text shown by default.
			@property [isRTL=false] {boolean} <code>true</code> if language is right-to-left. */
		regionalOptions: { // Available regional settings, indexed by language/country code
			'': { // Default regional settings - English/US
				renderer: {}, // this.defaultRenderer
				prevText: '&lt;Prev',
				prevStatus: 'Show the previous month',
				prevJumpText: '&lt;&lt;',
				prevJumpStatus: 'Show the previous year',
				nextText: 'Next&gt;',
				nextStatus: 'Show the next month',
				nextJumpText: '&gt;&gt;',
				nextJumpStatus: 'Show the next year',
				currentText: 'Current',
				currentStatus: 'Show the current month',
				todayText: 'Today',
				todayStatus: 'Show today\'s month',
				clearText: 'Clear',
				clearStatus: 'Clear all the dates',
				closeText: 'Close',
				closeStatus: 'Close the datepicker',
				yearStatus: 'Change the year',
				earlierText: '&#160;&#160;▲',
				laterText: '&#160;&#160;▼',
				monthStatus: 'Change the month',
				weekText: 'Wk',
				weekStatus: 'Week of the year',
				dayStatus: 'Select DD, M d, yyyy',
				defaultStatus: 'Select a date',
				isRTL: false
			}
		},
		
		/** Names of getter methods - those that can't be chained.
			@memberof CalendarsPicker */
		_getters: ['getDate', 'isDisabled', 'isSelectable', 'retrieveDate'],

		_disabled: [],
		
		_popupClass: 'calendars-popup', // Marker for popup division
		_triggerClass: 'calendars-trigger', // Marker for trigger element
		_disableClass: 'calendars-disable', // Marker for disabled element
		_monthYearClass: 'calendars-month-year', // Marker for month/year inputs
		_curMonthClass: 'calendars-month-', // Marker for current month/year
		_anyYearClass: 'calendars-any-year', // Marker for year direct input
		_curDoWClass: 'calendars-dow-', // Marker for day of week

		_init: function() {
			this.defaultOptions.commands = this.commands;
			this.regionalOptions[''].renderer = this.defaultRenderer;
			this._super();
		},

		_instSettings: function(elem, options) {
			return {selectedDates: [], drawDate: null, pickingRange: false,
				inline: ($.inArray(elem[0].nodeName.toLowerCase(), ['div', 'span']) > -1),
				get: function(name) { // Get a setting value, computing if necessary
					if ($.inArray(name, ['defaultDate', 'minDate', 'maxDate']) > -1) { // Decode date settings
						return this.options.calendar.determineDate(this.options[name], null,
							this.selectedDates[0], this.get('dateFormat'), this.getConfig());
					}
					if (name === 'dateFormat') {
						return this.options.dateFormat || this.options.calendar.local.dateFormat;
					}
					return this.options[name];
				},
				curMinDate: function() {
					return (this.pickingRange ? this.selectedDates[0] : this.get('minDate'));
				},
				getConfig: function() {
					return {dayNamesShort: this.options.dayNamesShort, dayNames: this.options.dayNames,
						monthNamesShort: this.options.monthNamesShort, monthNames: this.options.monthNames,
						calculateWeek: this.options.calculateWeek, shortYearCutoff: this.options.shortYearCutoff};
				}
			};
		},

		_postAttach: function(elem, inst) {
			if (inst.inline) {
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				this._update(elem[0]);
				if ($.fn.mousewheel) {
					elem.mousewheel(this._doMouseWheel);
				}
			}
			else {
				this._attachments(elem, inst);
				elem.on('keydown.' + inst.name, this._keyDown).on('keypress.' + inst.name, this._keyPress).
					on('keyup.' + inst.name, this._keyUp);
				if (elem.attr('disabled')) {
					this.disable(elem[0]);
				}
			}
		},

		_optionsChanged: function(elem, inst, options) {
			if (options.calendar && options.calendar !== inst.options.calendar) {
				var discardDate = function(name) {
					return (typeof inst.options[name] === 'object' ? null : inst.options[name]);
				};
				options = $.extend({defaultDate: discardDate('defaultDate'),
					minDate: discardDate('minDate'), maxDate: discardDate('maxDate')}, options);
				inst.selectedDates = [];
				inst.drawDate = null;
			}
			var dates = inst.selectedDates;
			$.extend(inst.options, options);
			this.setDate(elem[0], dates, null, false, true);
			inst.pickingRange = false;
			var calendar = inst.options.calendar;
			var defaultDate = inst.get('defaultDate');
			inst.drawDate = this._checkMinMax((defaultDate ? defaultDate : inst.drawDate) ||
				defaultDate || calendar.today(), inst).newDate();
			if (!inst.inline) {
				this._attachments(elem, inst);
			}
			if (inst.inline || inst.div) {
				this._update(elem[0]);
			}
		},

		/** Attach events and trigger, if necessary.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_attachments: function(elem, inst) {
			elem.off('focus.' + inst.name);
			if (inst.options.showOnFocus) {
				elem.on('focus.' + inst.name, this.show);
			}
			if (inst.trigger) {
				inst.trigger.remove();
			}
			var trigger = inst.options.showTrigger;
			inst.trigger = (!trigger ? $([]) :
				$(trigger).clone().removeAttr('id').addClass(this._triggerClass)
					[inst.options.isRTL ? 'insertBefore' : 'insertAfter'](elem).
					click(function() {
						if (!plugin.isDisabled(elem[0])) {
							plugin[plugin.curInst === inst ? 'hide' : 'show'](elem[0]);
						}
					}));
			this._autoSize(elem, inst);
			var dates = this._extractDates(inst, elem.val());
			if (dates) {
				this.setDate(elem[0], dates, null, true);
			}
			var defaultDate = inst.get('defaultDate');
			if (inst.options.selectDefaultDate && defaultDate && inst.selectedDates.length === 0) {
				this.setDate(elem[0], (defaultDate || inst.options.calendar.today()).newDate());
			}
		},

		/** Apply the maximum length for the date format.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_autoSize: function(elem, inst) {
			if (inst.options.autoSize && !inst.inline) {
				var calendar = inst.options.calendar;
				var date = calendar.newDate(2009, 10, 20); // Ensure double digits
				var dateFormat = inst.get('dateFormat');
				if (dateFormat.match(/[DM]/)) {
					var findMax = function(names) {
						var max = 0;
						var maxI = 0;
						for (var i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.month(findMax(calendar.local[dateFormat.match(/MM/) ? // Longest month
						'monthNames' : 'monthNamesShort']) + 1);
					date.day(findMax(calendar.local[dateFormat.match(/DD/) ? // Longest day
						'dayNames' : 'dayNamesShort']) + 20 - date.dayOfWeek());
				}
				inst.elem.attr('size', date.formatDate(dateFormat).length);
			}
		},

		_preDestroy: function(elem, inst) {
			if (inst.trigger) {
				inst.trigger.remove();
			}
			elem.empty().off('.' + inst.name);
			if (inst.inline && $.fn.mousewheel) {
				elem.unmousewheel();
			}
			if (!inst.inline && inst.options.autoSize) {
				elem.removeAttr('size');
			}
		},

		/** Apply multiple event functions.
			@memberof CalendarsPicker
			@param fns {function} The functions to apply.
			@example onShow: multipleEvents(fn1, fn2, ...) */
		multipleEvents: function(fns) {
			var funcs = arguments;
			return function(args) {
				for (var i = 0; i < funcs.length; i++) {
					funcs[i].apply(this, arguments);
				}
			};
		},

		/** Enable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('enable') */
		enable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				elem.children('.' + this._disableClass).remove().end().
					find('button,select').prop('disabled', false).end().
					find('a').attr('href', 'javascript:void(0)');
			}
			else {
				elem.prop('disabled', false);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', false).end().
					filter('img.' + this._triggerClass).css({opacity: '1.0', cursor: ''});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
		},

		/** Disable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('disable') */
		disable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				var inline = elem.children(':last');
				var offset = inline.offset();
				var relOffset = {left: 0, top: 0};
				inline.parents().each(function() {
					if ($(this).css('position') === 'relative') {
						relOffset = $(this).offset();
						return false;
					}
				});
				var zIndex = elem.css('zIndex');
				zIndex = (zIndex === 'auto' ? 0 : parseInt(zIndex, 10)) + 1;
				elem.prepend('<div class="' + this._disableClass + '" style="' +
					'width: ' + inline.outerWidth() + 'px; height: ' + inline.outerHeight() +
					'px; left: ' + (offset.left - relOffset.left) + 'px; top: ' +
					(offset.top - relOffset.top) + 'px; z-index: ' + zIndex + '"></div>').
					find('button,select').prop('disabled', true).end().
					find('a').removeAttr('href');
			}
			else {
				elem.prop('disabled', true);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', true).end().
					filter('img.' + this._triggerClass).css({opacity: '0.5', cursor: 'default'});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
			this._disabled.push(elem[0]);
		},

		/** Is the first field in a jQuery collection disabled as a datepicker?
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {boolean} <code>true</code> if disabled, <code>false</code> if enabled.
			@example if ($(selector).datepick('isDisabled')) {...} */
		isDisabled: function(elem) {
			return (elem && $.inArray(elem, this._disabled) > -1);
		},

		/** Show a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Event|Element} a focus event or the control to use.
			@example $(selector).datepick('show') */
		show: function(elem) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (plugin.curInst === inst) {
				return;
			}
			if (plugin.curInst) {
				plugin.hide(plugin.curInst, true);
			}
			if (!$.isEmptyObject(inst)) {
				// Retrieve existing date(s)
				inst.lastVal = null;
				inst.selectedDates = plugin._extractDates(inst, elem.val());
				inst.pickingRange = false;
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				plugin.curInst = inst;
				// Generate content
				plugin._update(elem[0], true);
				// Adjust position before showing
				var offset = plugin._checkOffset(inst);
				inst.div.css({left: offset.left, top: offset.top});
				// And display
				var showAnim = inst.options.showAnim;
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					var data = inst.div.data(); // Update old effects data
					for (var key in data) {
						if (key.match(/^ec\.storage\./)) {
							data[key] = inst._mainDiv.css(key.replace(/ec\.storage\./, ''));
						}
					}
					inst.div.data(data).show(showAnim, inst.options.showOptions, showSpeed);
				}
				else {
					inst.div[showAnim || 'show'](showAnim ? showSpeed : 0);
				}
			}
		},

		/** Extract possible dates from a string.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param text {string} The text to extract from.
			@return {CDate[]} The extracted dates. */
		_extractDates: function(inst, datesText) {
			if (datesText === inst.lastVal) {
				return;
			}
			inst.lastVal = datesText;
			datesText = datesText.split(inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : '\x00'));
			var dates = [];
			for (var i = 0; i < datesText.length; i++) {
				try {
					var date = inst.options.calendar.parseDate(inst.get('dateFormat'), datesText[i]);
					if (date) {
						var found = false;
						for (var j = 0; j < dates.length; j++) {
							if (dates[j].compareTo(date) === 0) {
								found = true;
								break;
							}
						}
						if (!found) {
							dates.push(date);
						}
					}
				}
				catch (e) {
					// Ignore
				}
			}
			dates.splice(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1), dates.length);
			if (inst.options.rangeSelect && dates.length === 1) {
				dates[1] = dates[0];
			}
			return dates;
		},

		/** Update the datepicker display.
			@memberof CalendarsPicker
			@private
			@param elem {Event|Element} a focus event or the control to use.
			@param hidden {boolean} <code>true</code> to initially hide the datepicker. */
		_update: function(elem, hidden) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (inst.inline || plugin.curInst === inst) {
					if ($.isFunction(inst.options.onChangeMonthYear) && (!inst.prevDate ||
							inst.prevDate.year() !== inst.drawDate.year() ||
							inst.prevDate.month() !== inst.drawDate.month())) {
						inst.options.onChangeMonthYear.apply(elem[0],
							[inst.drawDate.year(), inst.drawDate.month()]);
					}
				}
				if (inst.inline) {
					var index = $('a, :input', elem).index($(':focus', elem));
					elem.html(this._generateContent(elem[0], inst));
					var focus = elem.find('a, :input');
					focus.eq(Math.max(Math.min(index, focus.length - 1), 0)).focus();
				}
				else if (plugin.curInst === inst) {
					if (!inst.div) {
						inst.div = $('<div></div>').addClass(this._popupClass).
							css({display: (hidden ? 'none' : 'static'), position: 'absolute',
								left: elem.offset().left, top: elem.offset().top + elem.outerHeight()}).
							appendTo($(inst.options.popupContainer || 'body'));
						if ($.fn.mousewheel) {
							inst.div.mousewheel(this._doMouseWheel);
						}
					}
					inst.div.html(this._generateContent(elem[0], inst));
					elem.focus();
				}
			}
		},

		/** Update the input field and any alternate field with the current dates.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to use.
			@param keyUp {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal). */
		_updateInput: function(elem, keyUp) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var value = '';
				var altValue = '';
				var sep = (inst.options.multiSelect ? inst.options.multiSeparator :
					inst.options.rangeSeparator);
				var calendar = inst.options.calendar;
				var dateFormat = inst.get('dateFormat');
				var altFormat = inst.options.altFormat || dateFormat;
				for (var i = 0; i < inst.selectedDates.length; i++) {
					value += (keyUp ? '' : (i > 0 ? sep : '') +
						calendar.formatDate(dateFormat, inst.selectedDates[i]));
					altValue += (i > 0 ? sep : '') +
						calendar.formatDate(altFormat, inst.selectedDates[i]);
				}
				if (!inst.inline && !keyUp) {
					$(elem).val(value);
				}
				$(inst.options.altField).val(altValue);
				if ($.isFunction(inst.options.onSelect) && !keyUp && !inst.inSelect) {
					inst.inSelect = true; // Prevent endless loops
					inst.options.onSelect.apply(elem, [inst.selectedDates]);
					inst.inSelect = false;
				}
			}
		},

		/** Retrieve the size of left and top borders for an element.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The element of interest.
			@return {number[]} The left and top borders. */
		_getBorders: function(elem) {
			var convert = function(value) {
				return {thin: 1, medium: 3, thick: 5}[value] || value;
			};
			return [parseFloat(convert(elem.css('border-left-width'))),
				parseFloat(convert(elem.css('border-top-width')))];
		},

		/** Check positioning to remain on the screen.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {object} The updated offset for the datepicker. */
		_checkOffset: function(inst) {
			var base = (inst.elem.is(':hidden') && inst.trigger ? inst.trigger : inst.elem);
			var offset = base.offset();
			var browserWidth = $(window).width();
			var browserHeight = $(window).height();
			if (browserWidth === 0) {
				return offset;
			}
			var isFixed = false;
			$(inst.elem).parents().each(function() {
				isFixed |= $(this).css('position') === 'fixed';
				return !isFixed;
			});
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			var above = offset.top - (isFixed ? scrollY : 0) - inst.div.outerHeight();
			var below = offset.top - (isFixed ? scrollY : 0) + base.outerHeight();
			var alignL = offset.left - (isFixed ? scrollX : 0);
			var alignR = offset.left - (isFixed ? scrollX : 0) + base.outerWidth() - inst.div.outerWidth();
			var tooWide = (offset.left - scrollX + inst.div.outerWidth()) > browserWidth;
			var tooHigh = (offset.top - scrollY + inst.elem.outerHeight() +
				inst.div.outerHeight()) > browserHeight;
			inst.div.css('position', isFixed ? 'fixed' : 'absolute');
			var alignment = inst.options.alignment;
			if (alignment === 'topLeft') {
				offset = {left: alignL, top: above};
			}
			else if (alignment === 'topRight') {
				offset = {left: alignR, top: above};
			}
			else if (alignment === 'bottomLeft') {
				offset = {left: alignL, top: below};
			}
			else if (alignment === 'bottomRight') {
				offset = {left: alignR, top: below};
			}
			else if (alignment === 'top') {
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL), top: above};
			}
			else { // bottom
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL),
					top: (tooHigh ? above : below)};
			}
			offset.left = Math.max((isFixed ? 0 : scrollX), offset.left);
			offset.top = Math.max((isFixed ? 0 : scrollY), offset.top);
			return offset;
		},

		/** Close date picker if clicked elsewhere.
			@memberof CalendarsPicker
			@private
			@param event {MouseEvent} The mouse click to check. */
		_checkExternalClick: function(event) {
			if (!plugin.curInst) {
				return;
			}
			var elem = $(event.target);
			if (elem.closest('.' + plugin._popupClass + ',.' + plugin._triggerClass).length === 0 &&
					!elem.hasClass(plugin._getMarker())) {
				plugin.hide(plugin.curInst);
			}
		},

		/** Hide a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element|object} The control to use or the current instance settings.
			@param immediate {boolean} <code>true</code> to close immediately without animation (internal).
			@example $(selector).datepick('hide') */
		hide: function(elem, immediate) {
			if (!elem) {
				return;
			}
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				inst = elem;
			}
			if (inst && inst === plugin.curInst) {
				var showAnim = (immediate ? '' : inst.options.showAnim);
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				var postProcess = function() {
					if (!inst.div) {
						return;
					}
					inst.div.remove();
					inst.div = null;
					plugin.curInst = null;
					if ($.isFunction(inst.options.onClose)) {
						inst.options.onClose.apply(elem, [inst.selectedDates]);
					}
				};
				inst.div.stop();
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					inst.div.hide(showAnim, inst.options.showOptions, showSpeed, postProcess);
				}
				else {
					var hideAnim = (showAnim === 'slideDown' ? 'slideUp' :
						(showAnim === 'fadeIn' ? 'fadeOut' : 'hide'));
					inst.div[hideAnim]((showAnim ? showSpeed : ''), postProcess);
				}
				if (!showAnim) {
					postProcess();
				}
			}
		},

		/** Handle keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if not handled, <code>false</code> if handled. */
		_keyDown: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			var handled = false;
			if (inst.inline || inst.div) {
				if (event.keyCode === 9) { // Tab - close
					plugin.hide(elem);
				}
				else if (event.keyCode === 13) { // Enter - select
					plugin.selectDate(elem,
						$('a.' + inst.options.renderer.highlightedClass, inst.div)[0]);
					handled = true;
				}
				else { // Command keystrokes
					var commands = inst.options.commands;
					for (var name in commands) {
						var command = commands[name];
						if (command.keystroke.keyCode === event.keyCode &&
								!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
								!!command.keystroke.altKey === event.altKey &&
								!!command.keystroke.shiftKey === event.shiftKey) {
							plugin.performAction(elem, name);
							handled = true;
							break;
						}
					}
				}
			}
			else { // Show on 'current' keystroke
				var command = inst.options.commands.current;
				if (command.keystroke.keyCode === event.keyCode &&
						!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
						!!command.keystroke.altKey === event.altKey &&
						!!command.keystroke.shiftKey === event.shiftKey) {
					plugin.show(elem);
					handled = true;
				}
			}
			inst.ctrlKey = ((event.keyCode < 48 && event.keyCode !== 32) || event.ctrlKey || event.metaKey);
			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
			return !handled;
		},

		/** Filter keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyPress: function(event) {
			var inst = plugin._getInst((event.data && event.data.elem) || event.target);
			if (!$.isEmptyObject(inst) && inst.options.constrainInput) {
				var ch = String.fromCharCode(event.keyCode || event.charCode);
				var allowedChars = plugin._allowedChars(inst);
				return (event.metaKey || inst.ctrlKey || ch < ' ' ||
					!allowedChars || allowedChars.indexOf(ch) > -1);
			}
			return true;
		},

		/** Determine the set of characters allowed by the date format.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {string} The set of allowed characters, or <code>null</code> if anything allowed. */
		_allowedChars: function(inst) {
			var allowedChars = (inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : ''));
			var literal = false;
			var hasNum = false;
			var dateFormat = inst.get('dateFormat');
			for (var i = 0; i < dateFormat.length; i++) {
				var ch = dateFormat.charAt(i);
				if (literal) {
					if (ch === "'" && dateFormat.charAt(i + 1) !== "'") {
						literal = false;
					}
					else {
						allowedChars += ch;
					}
				}
				else {
					switch (ch) {
						case 'd': case 'm': case 'o': case 'w':
							allowedChars += (hasNum ? '' : '0123456789'); hasNum = true; break;
						case 'y': case '@': case '!':
							allowedChars += (hasNum ? '' : '0123456789') + '-'; hasNum = true; break;
						case 'J':
							allowedChars += (hasNum ? '' : '0123456789') + '-.'; hasNum = true; break;
						case 'D': case 'M': case 'Y':
							return null; // Accept anything
						case "'":
							if (dateFormat.charAt(i + 1) === "'") {
								allowedChars += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							allowedChars += ch;
					}
				}
			}
			return allowedChars;
		},

		/** Synchronise datepicker with the field.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyUp: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst) && !inst.ctrlKey && inst.lastVal !== inst.elem.val()) {
				try {
					var dates = plugin._extractDates(inst, inst.elem.val());
					if (dates.length > 0) {
						plugin.setDate(elem, dates, null, true);
					}
				}
				catch (event) {
					// Ignore
				}
			}
			return true;
		},

		/** Increment/decrement month/year on mouse wheel activity.
			@memberof CalendarsPicker
			@private
			@param event {event} The mouse wheel event.
			@param delta {number} The amount of change. */
		_doMouseWheel: function(event, delta) {
			var elem = (plugin.curInst && plugin.curInst.elem[0]) ||
				$(event.target).closest('.' + plugin._getMarker())[0];
			if (plugin.isDisabled(elem)) {
				return;
			}
			var inst = plugin._getInst(elem);
			if (inst.options.useMouseWheel) {
				delta = (delta < 0 ? -1 : +1);
				plugin.changeMonth(elem, -inst.options[event.ctrlKey ? 'monthsToJump' : 'monthsToStep'] * delta);
			}
			event.preventDefault();
		},

		/** Clear an input and close a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to use.
			@example $(selector).datepick('clear') */
		clear: function(elem) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				inst.selectedDates = [];
				this.hide(elem);
				var defaultDate = inst.get('defaultDate');
				if (inst.options.selectDefaultDate && defaultDate) {
					this.setDate(elem, (defaultDate || inst.options.calendar.today()).newDate());
				}
				else {
					this._updateInput(elem);
				}
			}
		},

		/** Retrieve the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {CDate[]} The selected date(s).
			@example var dates = $(selector).datepick('getDate') */
		getDate: function(elem) {
			var inst = this._getInst(elem);
			return (!$.isEmptyObject(inst) ? inst.selectedDates : []);
		},

		/** Set the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} the control to examine.
			@param dates {CDate|number|string|array} the selected date(s).
			@param [endDate] {CDate|number|string} the ending date for a range.
			@param [keyUp] {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal).
			@param [setOpt] {boolean} <code>true</code> if coming from option processing (internal).
			@example $(selector).datepick('setDate', new Date(2014, 12-1, 25))
 $(selector).datepick('setDate', '12/25/2014', '01/01/2015')
 $(selector).datepick('setDate', [date1, date2, date3]) */
		setDate: function(elem, dates, endDate, keyUp, setOpt) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (!$.isArray(dates)) {
					dates = [dates];
					if (endDate) {
						dates.push(endDate);
					}
				}
				var minDate = inst.get('minDate');
				var maxDate = inst.get('maxDate');
				var curDate = inst.selectedDates[0];
				inst.selectedDates = [];
				for (var i = 0; i < dates.length; i++) {
					var date = inst.options.calendar.determineDate(
						dates[i], null, curDate, inst.get('dateFormat'), inst.getConfig());
					if (date) {
						if ((!minDate || date.compareTo(minDate) !== -1) &&
								(!maxDate || date.compareTo(maxDate) !== +1)) {
							var found = false;
							for (var j = 0; j < inst.selectedDates.length; j++) {
								if (inst.selectedDates[j].compareTo(date) === 0) {
									found = true;
									break;
								}
							}
							if (!found) {
								inst.selectedDates.push(date);
							}
						}
					}
				}
				inst.selectedDates.splice(inst.options.multiSelect ||
					(inst.options.rangeSelect ? 2 : 1), inst.selectedDates.length);
				if (inst.options.rangeSelect) {
					switch (inst.selectedDates.length) {
						case 1: inst.selectedDates[1] = inst.selectedDates[0]; break;
						case 2: inst.selectedDates[1] =
							(inst.selectedDates[0].compareTo(inst.selectedDates[1]) === +1 ?
							inst.selectedDates[0] : inst.selectedDates[1]); break;
					}
					inst.pickingRange = false;
				}
				inst.prevDate = (inst.drawDate ? inst.drawDate.newDate() : null);
				inst.drawDate = this._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				if (!setOpt) {
					this._update(elem);
					this._updateInput(elem, keyUp);
				}
			}
		},

		/** Determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to check.
			@param date {CDate|string|number} The date to check.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not.
			@example var selectable = $(selector).datepick('isSelectable', date) */
		isSelectable: function(elem, date) {
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				return false;
			}
			date = inst.options.calendar.determineDate(date,
				inst.selectedDates[0] || inst.options.calendar.today(), null,
				inst.options.dateFormat, inst.getConfig());
			return this._isSelectable(elem, date, inst.options.onDate,
				inst.get('minDate'), inst.get('maxDate'));
		},

		/** Internally determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} the control to check.
			@param date {CDate} The date to check.
			@param onDate {function|boolean} Any <code>onDate</code> callback or <code>callback.selectable</code>.
			@param minDate {CDate} The minimum allowed date.
			@param maxDate {CDate} The maximum allowed date.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not. */
		_isSelectable: function(elem, date, onDate, minDate, maxDate) {
			var dateInfo = (typeof onDate === 'boolean' ? {selectable: onDate} :
				(!$.isFunction(onDate) ? {} : onDate.apply(elem, [date, true])));
			return (dateInfo.selectable !== false) &&
				(!minDate || date.toJD() >= minDate.toJD()) && (!maxDate || date.toJD() <= maxDate.toJD());
		},

		/** Perform a named action for a datepicker.
			@memberof CalendarsPicker
			@param elem {element} The control to affect.
			@param action {string} The name of the action. */
		performAction: function(elem, action) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var commands = inst.options.commands;
				if (commands[action] && commands[action].enabled.apply(elem, [inst])) {
					commands[action].action.apply(elem, [inst]);
				}
			}
		},

		/** Set the currently shown month, defaulting to today's.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param [year] {number} The year to show.
			@param [month] {number} The month to show (1-12).
			@param [day] {number} The day to show.
			@example $(selector).datepick('showMonth', 2014, 12, 25) */
		showMonth: function(elem, year, month, day) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && (day != null ||
					(inst.drawDate.year() !== year || inst.drawDate.month() !== month))) {
				inst.prevDate = inst.drawDate.newDate();
				var calendar = inst.options.calendar;
				var show = this._checkMinMax((year != null ?
					calendar.newDate(year, month, 1) : calendar.today()), inst);
				inst.drawDate.date(show.year(), show.month(), 
					(day != null ? day : Math.min(inst.drawDate.day(),
					calendar.daysInMonth(show.year(), show.month()))));
				this._update(elem);
			}
		},

		/** Adjust the currently shown month.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of months to change by.
			@example $(selector).datepick('changeMonth', 2)*/
		changeMonth: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'm');
				this.showMonth(elem, date.year(), date.month());
			}
		},

		/** Adjust the currently shown day.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of days to change by.
			@example $(selector).datepick('changeDay', 7)*/
		changeDay: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'd');
				this.showMonth(elem, date.year(), date.month(), date.day());
			}
		},

		/** Restrict a date to the minimum/maximum specified.
			@memberof CalendarsPicker
			@private
			@param date {CDate} The date to check.
			@param inst {object} The current instance settings. */
		_checkMinMax: function(date, inst) {
			var minDate = inst.get('minDate');
			var maxDate = inst.get('maxDate');
			date = (minDate && date.compareTo(minDate) === -1 ? minDate.newDate() : date);
			date = (maxDate && date.compareTo(maxDate) === +1 ? maxDate.newDate() : date);
			return date;
		},

		/** Retrieve the date associated with an entry in the datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@return {CDate} The corresponding date, or <code>null</code>.			
			@example var date = $(selector).datepick('retrieveDate', $('div.datepick-popup a:contains(10)')[0]) */
		retrieveDate: function(elem, target) {
			var inst = this._getInst(elem);
			return ($.isEmptyObject(inst) ? null : inst.options.calendar.fromJD(
				parseFloat(target.className.replace(/^.*jd(\d+\.5).*$/, '$1'))));
		},

		/** Select a date for this datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@example $(selector).datepick('selectDate', $('div.datepick-popup a:contains(10)')[0]) */
		selectDate: function(elem, target) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var date = this.retrieveDate(elem, target);
				if (inst.options.multiSelect) {
					var found = false;
					for (var i = 0; i < inst.selectedDates.length; i++) {
						if (date.compareTo(inst.selectedDates[i]) === 0) {
							inst.selectedDates.splice(i, 1);
							found = true;
							break;
						}
					}
					if (!found && inst.selectedDates.length < inst.options.multiSelect) {
						inst.selectedDates.push(date);
					}
				}
				else if (inst.options.rangeSelect) {
					if (inst.pickingRange) {
						inst.selectedDates[1] = date;
					}
					else {
						inst.selectedDates = [date, date];
					}
					inst.pickingRange = !inst.pickingRange;
				}
				else {
					inst.selectedDates = [date];
				}
				inst.prevDate = inst.drawDate = date.newDate();
				this._updateInput(elem);
				if (inst.inline || inst.pickingRange || inst.selectedDates.length <
						(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1))) {
					this._update(elem);
				}
				else {
					this.hide(elem);
				}
			}
		},

		/** Generate the datepicker content for this control.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@return {jQuery} The datepicker content */
		_generateContent: function(elem, inst) {
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			inst.drawDate = this._checkMinMax(
				inst.drawDate || inst.get('defaultDate') || inst.options.calendar.today(), inst);
			var drawDate = inst.drawDate.newDate().add(-inst.options.monthsOffset, 'm');
			// Generate months
			var monthRows = '';
			for (var row = 0; row < monthsToShow[0]; row++) {
				var months = '';
				for (var col = 0; col < monthsToShow[1]; col++) {
					months += this._generateMonth(elem, inst, drawDate.year(),
						drawDate.month(), inst.options.calendar, inst.options.renderer, (row === 0 && col === 0));
					drawDate.add(1, 'm');
				}
				monthRows += this._prepare(inst.options.renderer.monthRow, inst).replace(/\{months\}/, months);
			}
			var picker = this._prepare(inst.options.renderer.picker, inst).replace(/\{months\}/, monthRows).
				replace(/\{weekHeader\}/g, this._generateDayHeaders(inst, inst.options.calendar, inst.options.renderer));
			// Add commands
			var addCommand = function(type, open, close, name, classes) {
				if (picker.indexOf('{' + type + ':' + name + '}') === -1) {
					return;
				}
				var command = inst.options.commands[name];
				var date = (inst.options.commandsAsDateFormat ? command.date.apply(elem, [inst]) : null);
				picker = picker.replace(new RegExp('\\{' + type + ':' + name + '\\}', 'g'),
					'<' + open + (command.status ? ' title="' + inst.options[command.status] + '"' : '') +
					' class="' + inst.options.renderer.commandClass + ' ' +
					inst.options.renderer.commandClass + '-' + name + ' ' + classes +
					(command.enabled(inst) ? '' : ' ' + inst.options.renderer.disabledClass) + '">' +
					(date ? date.formatDate(inst.options[command.text]) :
					inst.options[command.text]) + '</' + close + '>');
			};
			for (var name in inst.options.commands) {
				addCommand('button', 'button type="button"', 'button', name,
					inst.options.renderer.commandButtonClass);
				addCommand('link', 'a href="javascript:void(0)"', 'a', name,
					inst.options.renderer.commandLinkClass);
			}
			picker = $(picker);
			if (monthsToShow[1] > 1) {
				var count = 0;
				$(inst.options.renderer.monthSelector, picker).each(function() {
					var nth = ++count % monthsToShow[1];
					$(this).addClass(nth === 1 ? 'first' : (nth === 0 ? 'last' : ''));
				});
			}
			// Add datepicker behaviour
			var self = this;
			function removeHighlight() {
				(inst.inline ? $(this).closest('.' + self._getMarker()) : inst.div).
					find(inst.options.renderer.daySelector + ' a').
					removeClass(inst.options.renderer.highlightedClass);
			}
			picker.find(inst.options.renderer.daySelector + ' a').hover(
					function() {
						removeHighlight.apply(this);
						$(this).addClass(inst.options.renderer.highlightedClass);
					},
					removeHighlight).
				click(function() {
					self.selectDate(elem, this);
				}).end().
				find('select.' + this._monthYearClass + ':not(.' + this._anyYearClass + ')').
				change(function() {
					var monthYear = $(this).val().split('/');
					self.showMonth(elem, parseInt(monthYear[1], 10), parseInt(monthYear[0], 10));
				}).end().
				find('select.' + this._anyYearClass).click(function() {
					$(this).css('visibility', 'hidden').
						next('input').css({left: this.offsetLeft, top: this.offsetTop,
						width: this.offsetWidth, height: this.offsetHeight}).show().focus();
				}).end().
				find('input.' + self._monthYearClass).change(function() {
					try {
						var year = parseInt($(this).val(), 10);
						year = (isNaN(year) ? inst.drawDate.year() : year);
						self.showMonth(elem, year, inst.drawDate.month(), inst.drawDate.day());
					}
					catch (e) {
						alert(e);
					}
				}).keydown(function(event) {
					if (event.keyCode === 13) { // Enter
						$(event.elem).change();
					}
					else if (event.keyCode === 27) { // Escape
						$(event.elem).hide().prev('select').css('visibility', 'visible');
						inst.elem.focus();
					}
				});
			// Add keyboard handling
			var data = {elem: inst.elem[0]};
			picker.keydown(data, this._keyDown).keypress(data, this._keyPress).keyup(data, this._keyUp);
			// Add command behaviour
			picker.find('.' + inst.options.renderer.commandClass).click(function() {
					if (!$(this).hasClass(inst.options.renderer.disabledClass)) {
						var action = this.className.replace(
							new RegExp('^.*' + inst.options.renderer.commandClass + '-([^ ]+).*$'), '$1');
						plugin.performAction(elem, action);
					}
				});
			// Add classes
			if (inst.options.isRTL) {
				picker.addClass(inst.options.renderer.rtlClass);
			}
			if (monthsToShow[0] * monthsToShow[1] > 1) {
				picker.addClass(inst.options.renderer.multiClass);
			}
			if (inst.options.pickerClass) {
				picker.addClass(inst.options.pickerClass);
			}
			// Resize
			$('body').append(picker);
			var width = 0;
			picker.find(inst.options.renderer.monthSelector).each(function() {
				width += $(this).outerWidth();
			});
			picker.width(width / monthsToShow[0]);
			// Pre-show customisation
			if ($.isFunction(inst.options.onShow)) {
				inst.options.onShow.apply(elem, [picker, inst.options.calendar, inst]);
			}
			return picker;
		},

		/** Generate the content for a single month.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@param first {boolean} <code>true</code> if first of multiple months.
			@return {string} The month content. */
		_generateMonth: function(elem, inst, year, month, calendar, renderer, first) {
			var daysInMonth = calendar.daysInMonth(year, month);
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			var fixedWeeks = inst.options.fixedWeeks || (monthsToShow[0] * monthsToShow[1] > 1);
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var leadDays = (calendar.dayOfWeek(year, month, calendar.minDay) -
				firstDay + calendar.daysInWeek()) % calendar.daysInWeek();
			var numWeeks = (fixedWeeks ? 6 : Math.ceil((leadDays + daysInMonth) / calendar.daysInWeek()));
			var selectOtherMonths = inst.options.selectOtherMonths && inst.options.showOtherMonths;
			var minDate = (inst.pickingRange ? inst.selectedDates[0] : inst.get('minDate'));
			var maxDate = inst.get('maxDate');
			var showWeeks = renderer.week.indexOf('{weekOfYear}') > -1;
			var today = calendar.today();
			var drawDate = calendar.newDate(year, month, calendar.minDay);
			drawDate.add(-leadDays - (fixedWeeks &&
				(drawDate.dayOfWeek() === firstDay || drawDate.daysInMonth() < calendar.daysInWeek())?
				calendar.daysInWeek() : 0), 'd');
			var jd = drawDate.toJD();
			// Generate weeks
			var weeks = '';
			for (var week = 0; week < numWeeks; week++) {
				var weekOfYear = (!showWeeks ? '' : '<span class="jd' + jd + '">' +
					($.isFunction(inst.options.calculateWeek) ?
					inst.options.calculateWeek(drawDate) : drawDate.weekOfYear()) + '</span>');
				var days = '';
				for (var day = 0; day < calendar.daysInWeek(); day++) {
					var selected = false;
					if (inst.options.rangeSelect && inst.selectedDates.length > 0) {
						selected = (drawDate.compareTo(inst.selectedDates[0]) !== -1 &&
							drawDate.compareTo(inst.selectedDates[1]) !== +1)
					}
					else {
						for (var i = 0; i < inst.selectedDates.length; i++) {
							if (inst.selectedDates[i].compareTo(drawDate) === 0) {
								selected = true;
								break;
							}
						}
					}
					var dateInfo = (!$.isFunction(inst.options.onDate) ? {} :
						inst.options.onDate.apply(elem, [drawDate, drawDate.month() === month]));
					var selectable = (selectOtherMonths || drawDate.month() === month) &&
						this._isSelectable(elem, drawDate, dateInfo.selectable, minDate, maxDate);
					days += this._prepare(renderer.day, inst).replace(/\{day\}/g,
						(selectable ? '<a href="javascript:void(0)"' : '<span') +
						' class="jd' + jd + ' ' + (dateInfo.dateClass || '') +
						(selected && (selectOtherMonths || drawDate.month() === month) ?
						' ' + renderer.selectedClass : '') +
						(selectable ? ' ' + renderer.defaultClass : '') +
						(drawDate.weekDay() ? '' : ' ' + renderer.weekendClass) +
						(drawDate.month() === month ? '' : ' ' + renderer.otherMonthClass) +
						(drawDate.compareTo(today) === 0 && drawDate.month() === month ?
						' ' + renderer.todayClass : '') +
						(drawDate.compareTo(inst.drawDate) === 0 && drawDate.month() === month ?
						' ' + renderer.highlightedClass : '') + '"' +
						(dateInfo.title || (inst.options.dayStatus && selectable) ? ' title="' +
						(dateInfo.title || drawDate.formatDate(inst.options.dayStatus)) + '"' : '') + '>' +
						(inst.options.showOtherMonths || drawDate.month() === month ?
						dateInfo.content || drawDate.day() : '&#160;') +
						(selectable ? '</a>' : '</span>'));
					drawDate.add(1, 'd');
					jd++;
				}
				weeks += this._prepare(renderer.week, inst).replace(/\{days\}/g, days).
					replace(/\{weekOfYear\}/g, weekOfYear);
			}
			var monthHeader = this._prepare(renderer.month, inst).match(/\{monthHeader(:[^\}]+)?\}/);
			monthHeader = (monthHeader[0].length <= 13 ? 'MM yyyy' :
				monthHeader[0].substring(13, monthHeader[0].length - 1));
			monthHeader = (first ? this._generateMonthSelection(
				inst, year, month, minDate, maxDate, monthHeader, calendar, renderer) :
				calendar.formatDate(monthHeader, calendar.newDate(year, month, calendar.minDay)));
			var weekHeader = this._prepare(renderer.weekHeader, inst).
				replace(/\{days\}/g, this._generateDayHeaders(inst, calendar, renderer));
			return this._prepare(renderer.month, inst).replace(/\{monthHeader(:[^\}]+)?\}/g, monthHeader).
				replace(/\{weekHeader\}/g, weekHeader).replace(/\{weeks\}/g, weeks);
		},

		/** Generate the HTML for the day headers.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@return {string} A week's worth of day headers. */
		_generateDayHeaders: function(inst, calendar, renderer) {
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var header = '';
			for (var day = 0; day < calendar.daysInWeek(); day++) {
				var dow = (day + firstDay) % calendar.daysInWeek();
				header += this._prepare(renderer.dayHeader, inst).replace(/\{day\}/g,
					'<span class="' + this._curDoWClass + dow + '" title="' +
					calendar.local.dayNames[dow] + '">' + calendar.local.dayNamesMin[dow] + '</span>');
			}
			return header;
		},

		/** Generate selection controls for month.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param minDate {CDate} The minimum date allowed.
			@param maxDate {CDate} The maximum date allowed.
			@param monthHeader {string} The month/year format.
			@param calendar {BaseCalendar} The current calendar.
			@return {string} The month selection content. */
		_generateMonthSelection: function(inst, year, month, minDate, maxDate, monthHeader, calendar) {
			if (!inst.options.changeMonth) {
				return calendar.formatDate(monthHeader, calendar.newDate(year, month, 1));
			}
			// Months
			var monthNames = calendar.local[
				'monthNames' + (monthHeader.match(/mm/i) ? '' : 'Short')];
			var html = monthHeader.replace(/m+/i, '\\x2E').replace(/y+/i, '\\x2F');
			var selector = '<select class="' + this._monthYearClass +
				'" title="' + inst.options.monthStatus + '">';
			var maxMonth = calendar.monthsInYear(year) + calendar.minMonth;
			for (var m = calendar.minMonth; m < maxMonth; m++) {
				if ((!minDate || calendar.newDate(year, m,
						calendar.daysInMonth(year, m) - 1 + calendar.minDay).
						compareTo(minDate) !== -1) &&
						(!maxDate || calendar.newDate(year, m, calendar.minDay).
						compareTo(maxDate) !== +1)) {
					selector += '<option value="' + m + '/' + year + '"' +
						(month === m ? ' selected="selected"' : '') + '>' +
						monthNames[m - calendar.minMonth] + '</option>';
				}
			}
			selector += '</select>';
			html = html.replace(/\\x2E/, selector);
			// Years
			var yearRange = inst.options.yearRange;
			if (yearRange === 'any') {
				selector = '<select class="' + this._monthYearClass + ' ' + this._anyYearClass +
					'" title="' + inst.options.yearStatus + '">' +
					'<option>' + year + '</option></select>' +
					'<input class="' + this._monthYearClass + ' ' + this._curMonthClass +
					month + '" value="' + year + '">';
			}
			else {
				yearRange = yearRange.split(':');
				var todayYear = calendar.today().year();
				var start = (yearRange[0].match('c[+-].*') ? year + parseInt(yearRange[0].substring(1), 10) :
					((yearRange[0].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[0], 10)));
				var end = (yearRange[1].match('c[+-].*') ? year + parseInt(yearRange[1].substring(1), 10) :
					((yearRange[1].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[1], 10)));
				selector = '<select class="' + this._monthYearClass +
					'" title="' + inst.options.yearStatus + '">';
				start = calendar.newDate(start + 1, calendar.firstMonth, calendar.minDay).add(-1, 'd');
				end = calendar.newDate(end, calendar.firstMonth, calendar.minDay);
				var addYear = function(y, yDisplay) {
					if (y !== 0 || calendar.hasYearZero) {
						selector += '<option value="' +
							Math.min(month, calendar.monthsInYear(y) - 1 + calendar.minMonth) +
							'/' + y + '"' + (year === y ? ' selected="selected"' : '') + '>' +
							(yDisplay || y) + '</option>';
					}
				};
				if (start.toJD() < end.toJD()) {
					start = (minDate && minDate.compareTo(start) === +1 ? minDate : start).year();
					end = (maxDate && maxDate.compareTo(end) === -1 ? maxDate : end).year();
					var earlierLater = Math.floor((end - start) / 2);
					if (!minDate || minDate.year() < start) {
						addYear(start - earlierLater, inst.options.earlierText);
					}
					for (var y = start; y <= end; y++) {
						addYear(y);
					}
					if (!maxDate || maxDate.year() > end) {
						addYear(end + earlierLater, inst.options.laterText);
					}
				}
				else {
					start = (maxDate && maxDate.compareTo(start) === -1 ? maxDate : start).year();
					end = (minDate && minDate.compareTo(end) === +1 ? minDate : end).year();
					var earlierLater = Math.floor((start - end) / 2);
					if (!maxDate || maxDate.year() > start) {
						addYear(start + earlierLater, inst.options.earlierText);
					}
					for (var y = start; y >= end; y--) {
						addYear(y);
					}
					if (!minDate || minDate.year() < end) {
						addYear(end - earlierLater, inst.options.laterText);
					}
				}
				selector += '</select>';
			}
			html = html.replace(/\\x2F/, selector);
			return html;
		},

		/** Prepare a render template for use.
			Exclude popup/inline sections that are not applicable.
			Localise text of the form: {l10n:name}.
			@memberof CalendarsPicker
			@private
			@param text {string} The text to localise.
			@param inst {object} The current instance settings.
			@return {string} The localised text. */
		_prepare: function(text, inst) {
			var replaceSection = function(type, retain) {
				while (true) {
					var start = text.indexOf('{' + type + ':start}');
					if (start === -1) {
						return;
					}
					var end = text.substring(start).indexOf('{' + type + ':end}');
					if (end > -1) {
						text = text.substring(0, start) +
							(retain ? text.substr(start + type.length + 8, end - type.length - 8) : '') +
							text.substring(start + end + type.length + 6);
					}
				}
			};
			replaceSection('inline', inst.inline);
			replaceSection('popup', !inst.inline);
			var pattern = /\{l10n:([^\}]+)\}/;
			var matches = null;
			while (matches = pattern.exec(text)) {
				text = text.replace(matches[0], inst.options[matches[1]]);
			}
			return text;
		}
	});

	var plugin = $.calendarsPicker; // Singleton instance

	$(function() {
		$(document).on('mousedown.' + pluginName, plugin._checkExternalClick).
			on('resize.' + pluginName, function() { plugin.hide(plugin.curInst); });
	});

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMuYWxsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxBQUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LmNhbGVuZGFycy5hbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXG4gICBDYWxlbmRhcnMgZm9yIGpRdWVyeSB2Mi4wLjEuXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEF1Z3VzdCAyMDA5LlxuICAgQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvbGljZW5jZS5odG1sKSBsaWNlbnNlLiBcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xuXG4oZnVuY3Rpb24oJCkgeyAvLyBIaWRlIHNjb3BlLCBubyAkIGNvbmZsaWN0XG5cblx0ZnVuY3Rpb24gQ2FsZW5kYXJzKCkge1xuXHRcdHRoaXMucmVnaW9uYWxPcHRpb25zID0gW107XG5cdFx0dGhpcy5yZWdpb25hbE9wdGlvbnNbJyddID0ge1xuXHRcdFx0aW52YWxpZENhbGVuZGFyOiAnQ2FsZW5kYXIgezB9IG5vdCBmb3VuZCcsXG5cdFx0XHRpbnZhbGlkRGF0ZTogJ0ludmFsaWQgezB9IGRhdGUnLFxuXHRcdFx0aW52YWxpZE1vbnRoOiAnSW52YWxpZCB7MH0gbW9udGgnLFxuXHRcdFx0aW52YWxpZFllYXI6ICdJbnZhbGlkIHswfSB5ZWFyJyxcblx0XHRcdGRpZmZlcmVudENhbGVuZGFyczogJ0Nhbm5vdCBtaXggezB9IGFuZCB7MX0gZGF0ZXMnXG5cdFx0fTtcblx0XHR0aGlzLmxvY2FsID0gdGhpcy5yZWdpb25hbE9wdGlvbnNbJyddO1xuXHRcdHRoaXMuY2FsZW5kYXJzID0ge307XG5cdFx0dGhpcy5fbG9jYWxDYWxzID0ge307XG5cdH1cblxuXHQvKiogQ3JlYXRlIHRoZSBjYWxlbmRhcnMgcGx1Z2luLlxuXHRcdDxwPlByb3ZpZGVzIHN1cHBvcnQgZm9yIHZhcmlvdXMgd29ybGQgY2FsZW5kYXJzIGluIGEgY29uc2lzdGVudCBtYW5uZXIuPC9wPlxuXHQgXHRAY2xhc3MgQ2FsZW5kYXJzXG5cdFx0QGV4YW1wbGUgJC5jYWxlbmRhcnMuaW5zdGFuY2UoJ2p1bGlhbicpLm5ld0RhdGUoMjAxNCwgMTIsIDI1KSAqL1xuXHQkLmV4dGVuZChDYWxlbmRhcnMucHJvdG90eXBlLCB7XG5cblx0XHQvKiogT2J0YWluIGEgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24gYW5kIGxvY2FsaXNhdGlvbi5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNcblx0XHRcdEBwYXJhbSBbbmFtZT0nZ3JlZ29yaWFuJ10ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLCBlLmcuICdncmVnb3JpYW4nLCAncGVyc2lhbicsICdpc2xhbWljJy5cblx0XHRcdEBwYXJhbSBbbGFuZ3VhZ2U9JyddIHtzdHJpbmd9IFRoZSBsYW5ndWFnZSBjb2RlIHRvIHVzZSBmb3IgbG9jYWxpc2F0aW9uIChkZWZhdWx0IGlzIEVuZ2xpc2gpLlxuXHRcdFx0QHJldHVybiB7Q2FsZW5kYXJ9IFRoZSBjYWxlbmRhciBhbmQgbG9jYWxpc2F0aW9uLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBjYWxlbmRhciBub3QgZm91bmQuICovXG5cdFx0aW5zdGFuY2U6IGZ1bmN0aW9uKG5hbWUsIGxhbmd1YWdlKSB7XG5cdFx0XHRuYW1lID0gKG5hbWUgfHwgJ2dyZWdvcmlhbicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRsYW5ndWFnZSA9IGxhbmd1YWdlIHx8ICcnO1xuXHRcdFx0dmFyIGNhbCA9IHRoaXMuX2xvY2FsQ2Fsc1tuYW1lICsgJy0nICsgbGFuZ3VhZ2VdO1xuXHRcdFx0aWYgKCFjYWwgJiYgdGhpcy5jYWxlbmRhcnNbbmFtZV0pIHtcblx0XHRcdFx0Y2FsID0gbmV3IHRoaXMuY2FsZW5kYXJzW25hbWVdKGxhbmd1YWdlKTtcblx0XHRcdFx0dGhpcy5fbG9jYWxDYWxzW25hbWUgKyAnLScgKyBsYW5ndWFnZV0gPSBjYWw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNhbCkge1xuXHRcdFx0XHR0aHJvdyAodGhpcy5sb2NhbC5pbnZhbGlkQ2FsZW5kYXIgfHwgdGhpcy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRDYWxlbmRhcikuXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbDtcblx0XHR9LFxuXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIC0gZm9yIHRvZGF5IGlmIG5vIG90aGVyIHBhcmFtZXRlcnMgZ2l2ZW4uXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb3B5IG9yIHRoZSB5ZWFyIGZvciB0aGUgZGF0ZS5cblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gW2NhbGVuZGFyPSdncmVnb3JpYW4nXSB7QmFzZUNhbGVuZGFyfHN0cmluZ30gVGhlIHVuZGVybHlpbmcgY2FsZW5kYXIgb3IgdGhlIG5hbWUgb2YgdGhlIGNhbGVuZGFyLlxuXHRcdFx0QHBhcmFtIFtsYW5ndWFnZT0nJ10ge3N0cmluZ30gVGhlIGxhbmd1YWdlIHRvIHVzZSBmb3IgbG9jYWxpc2F0aW9uIChkZWZhdWx0IEVuZ2xpc2gpLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdG5ld0RhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXksIGNhbGVuZGFyLCBsYW5ndWFnZSkge1xuXHRcdFx0Y2FsZW5kYXIgPSAoeWVhciAhPSBudWxsICYmIHllYXIueWVhciA/IHllYXIuY2FsZW5kYXIoKSA6ICh0eXBlb2YgY2FsZW5kYXIgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0dGhpcy5pbnN0YW5jZShjYWxlbmRhciwgbGFuZ3VhZ2UpIDogY2FsZW5kYXIpKSB8fCB0aGlzLmluc3RhbmNlKCk7XG5cdFx0XHRyZXR1cm4gY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKiBHZW5lcmljIGRhdGUsIGJhc2VkIG9uIGEgcGFydGljdWxhciBjYWxlbmRhci5cblx0XHRAY2xhc3MgQ0RhdGVcblx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIHVuZGVybHlpbmcgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24uXG5cdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgZm9yIHRoaXMgZGF0ZS5cblx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXG5cdFx0QHBhcmFtIGRheSB7bnVtYmVyfSBUaGUgZGF5IGZvciB0aGlzIGRhdGUuXG5cdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBkYXRlIG9iamVjdC5cblx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cblx0ZnVuY3Rpb24gQ0RhdGUoY2FsZW5kYXIsIHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHR0aGlzLl9jYWxlbmRhciA9IGNhbGVuZGFyO1xuXHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xuXHRcdHRoaXMuX21vbnRoID0gbW9udGg7XG5cdFx0dGhpcy5fZGF5ID0gZGF5O1xuXHRcdGlmICh0aGlzLl9jYWxlbmRhci5fdmFsaWRhdGVMZXZlbCA9PT0gMCAmJlxuXHRcdFx0XHQhdGhpcy5fY2FsZW5kYXIuaXNWYWxpZCh0aGlzLl95ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5fZGF5KSkge1xuXHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpLlxuXHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIFBhZCBhIG51bWVyaWMgdmFsdWUgd2l0aCBsZWFkaW5nIHplcm9lcy5cblx0XHRAcHJpdmF0ZVxuXHRcdEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBUaGUgbnVtYmVyIHRvIGZvcm1hdC5cblx0XHRAcGFyYW0gbGVuZ3RoIHtudW1iZXJ9IFRoZSBtaW5pbXVtIGxlbmd0aC5cblx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgbnVtYmVyLiAqL1xuXHRmdW5jdGlvbiBwYWQodmFsdWUsIGxlbmd0aCkge1xuXHRcdHZhbHVlID0gJycgKyB2YWx1ZTtcblx0XHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIHZhbHVlLmxlbmd0aCkgKyB2YWx1ZTtcblx0fVxuXG5cdCQuZXh0ZW5kKENEYXRlLnByb3RvdHlwZSwge1xuXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGNvcHkgb3IgdGhlIHllYXIgZm9yIHRoZSBkYXRlIChkZWZhdWx0IHRoaXMgZGF0ZSkuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdG5ld0RhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5uZXdEYXRlKCh5ZWFyID09IG51bGwgPyB0aGlzIDogeWVhciksIG1vbnRoLCBkYXkpO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IG9yIHJldHJpZXZlIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEBwYXJhbSBbeWVhcl0ge251bWJlcn0gVGhlIHllYXIgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfENEYXRlfSBUaGUgZGF0ZSdzIHllYXIgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdHllYXI6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHRoaXMuX3llYXIgOiB0aGlzLnNldCh5ZWFyLCAneScpKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgbW9udGggZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIGZvciB0aGUgZGF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0ZX0gVGhlIGRhdGUncyBtb250aCAoaWYgbm8gcGFyYW1ldGVyKSBvciB0aGUgdXBkYXRlZCBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUuICovXG5cdFx0bW9udGg6IGZ1bmN0aW9uKG1vbnRoKSB7XG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9tb250aCA6IHRoaXMuc2V0KG1vbnRoLCAnbScpKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNldCBvciByZXRyaWV2ZSB0aGUgZGF5IGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IGZvciB0aGUgZGF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcnxDRGF0YX0gVGhlIGRhdGUncyBkYXkgKGlmIG5vIHBhcmFtZXRlcikgb3IgdGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlLiAqL1xuXHRcdGRheTogZnVuY3Rpb24oZGF5KSB7XG5cdFx0XHRyZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLl9kYXkgOiB0aGlzLnNldChkYXksICdkJykpO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IG5ldyB2YWx1ZXMgZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gZGF5IHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZS4gKi9cblx0XHRkYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHRpZiAoIXRoaXMuX2NhbGVuZGFyLmlzVmFsaWQoeWVhciwgbW9udGgsIGRheSkpIHtcblx0XHRcdFx0dGhyb3cgKCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpLlxuXHRcdFx0XHRcdHJlcGxhY2UoL1xcezBcXH0vLCB0aGlzLl9jYWxlbmRhci5sb2NhbC5uYW1lKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3llYXIgPSB5ZWFyO1xuXHRcdFx0dGhpcy5fbW9udGggPSBtb250aDtcblx0XHRcdHRoaXMuX2RheSA9IGRheTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGlzIGEgbGVhcCB5ZWFyLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xuXHRcdGxlYXBZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5sZWFwWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBlcG9jaCBkZXNpZ25hdG9yIGZvciB0aGlzIGRhdGUsIGUuZy4gQkNFIG9yIENFLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IGVwb2NoLiAqL1xuXHRcdGVwb2NoOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5lcG9jaCh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIEZvcm1hdCB0aGUgeWVhciwgaWYgbm90IGEgc2ltcGxlIHNlcXVlbnRpYWwgbnVtYmVyLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgeWVhci4gKi9cblx0XHRmb3JtYXRZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mb3JtYXRZZWFyKHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIG1vbnRoIG9mIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUsXG5cdFx0XHRpLmUuIHRoZSBtb250aCdzIHBvc2l0aW9uIHdpdGhpbiBhIG51bWJlcmVkIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG1vbnRoIG9mIHRoZSB5ZWFyOiA8Y29kZT5taW5Nb250aDwvY29kZT4gdG8gbW9udGhzIHBlciB5ZWFyLiAqL1xuXHRcdG1vbnRoT2ZZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5tb250aE9mWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHdlZWsgb2YgdGhlIHllYXI6IDEgdG8gd2Vla3MgcGVyIHllYXIuICovXG5cdFx0d2Vla09mWWVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIud2Vla09mWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgeWVhciBmb3IgdGhpcyBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIHllYXIuICovXG5cdFx0ZGF5c0luWWVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZGF5c0luWWVhcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHllYXIgZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyOiAxIHRvIGRheXMgcGVyIHllYXIuICovXG5cdFx0ZGF5T2ZZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlPZlllYXIodGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzLiAqL1xuXHRcdGRheXNJbk1vbnRoOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5kYXlzSW5Nb250aCh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB3ZWVrOiAwIHRvIG51bWJlciBvZiBkYXlzIC0gMS4gKi9cblx0XHRkYXlPZldlZWs6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmRheU9mV2Vlayh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBhIHdlZWsgZGF5LlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xuXHRcdHdlZWtEYXk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLndlZWtEYXkodGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7b2JqZWN0fSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIC0gY29udGVudHMgZGVwZW5kcyBvbiBjYWxlbmRhci4gKi9cblx0XHRleHRyYUluZm86IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLmV4dHJhSW5mbyh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcGVyaW9kcyB0byBhZGp1c3QgYnkuXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS4gKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuYWRkKHRoaXMsIG9mZnNldCwgcGVyaW9kKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNldCBhIHBvcnRpb24gb2YgdGhlIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgcGVyaW9kLlxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAnZCcgZm9yIGRheS5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBub3QgYSB2YWxpZCBkYXRlLiAqL1xuXHRcdHNldDogZnVuY3Rpb24odmFsdWUsIHBlcmlvZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLnNldCh0aGlzLCB2YWx1ZSwgcGVyaW9kKTtcblx0XHR9LFxuXG5cdFx0LyoqIENvbXBhcmUgdGhpcyBkYXRlIHRvIGFub3RoZXIgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgb3RoZXIgZGF0ZS5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gLTEgaWYgdGhpcyBkYXRlIGlzIGJlZm9yZSB0aGUgb3RoZXIgZGF0ZSxcblx0XHRcdFx0XHQwIGlmIHRoZXkgYXJlIGVxdWFsLCBvciArMSBpZiB0aGlzIGRhdGUgaXMgYWZ0ZXIgdGhlIG90aGVyIGRhdGUuICovXG5cdFx0Y29tcGFyZVRvOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0XHRpZiAodGhpcy5fY2FsZW5kYXIubmFtZSAhPT0gZGF0ZS5fY2FsZW5kYXIubmFtZSkge1xuXHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwuZGlmZmVyZW50Q2FsZW5kYXJzIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uZGlmZmVyZW50Q2FsZW5kYXJzKS5cblx0XHRcdFx0XHRyZXBsYWNlKC9cXHswXFx9LywgdGhpcy5fY2FsZW5kYXIubG9jYWwubmFtZSkucmVwbGFjZSgvXFx7MVxcfS8sIGRhdGUuX2NhbGVuZGFyLmxvY2FsLm5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGMgPSAodGhpcy5feWVhciAhPT0gZGF0ZS5feWVhciA/IHRoaXMuX3llYXIgLSBkYXRlLl95ZWFyIDpcblx0XHRcdFx0dGhpcy5fbW9udGggIT09IGRhdGUuX21vbnRoID8gdGhpcy5tb250aE9mWWVhcigpIC0gZGF0ZS5tb250aE9mWWVhcigpIDpcblx0XHRcdFx0dGhpcy5fZGF5IC0gZGF0ZS5fZGF5KTtcblx0XHRcdHJldHVybiAoYyA9PT0gMCA/IDAgOiAoYyA8IDAgPyAtMSA6ICsxKSk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgY2FsZW5kYXIgYmFja2luZyB0aGlzIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQ0RhdGVcblx0XHRcdEByZXR1cm4ge0Jhc2VDYWxlbmRhcn0gVGhlIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uLiAqL1xuXHRcdGNhbGVuZGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhcjtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBKdWxpYW4gZGF0ZSBlcXVpdmFsZW50IGZvciB0aGlzIGRhdGUsXG5cdFx0XHRpLmUuIGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbi5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBKdWxpYW4gZGF0ZS4gKi9cblx0XHR0b0pEOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci50b0pEKHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgZnJvbSBhIEp1bGlhbiBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcGFyYW0gamQge251bWJlcn0gVGhlIEp1bGlhbiBkYXRlIHRvIGNvbnZlcnQuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGVxdWl2YWxlbnQgZGF0ZS4gKi9cblx0XHRmcm9tSkQ6IGZ1bmN0aW9uKGpkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZnJvbUpEKGpkKTtcblx0XHR9LFxuXG5cdFx0LyoqIENvbnZlcnQgdGhpcyBkYXRlIHRvIGEgc3RhbmRhcmQgKEdyZWdvcmlhbikgSmF2YVNjcmlwdCBEYXRlLlxuXHRcdFx0QG1lbWJlcm9mIENEYXRlXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuICovXG5cdFx0dG9KU0RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGVuZGFyLnRvSlNEYXRlKHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgZnJvbSBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXG5cdFx0ZnJvbUpTRGF0ZTogZnVuY3Rpb24oanNkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsZW5kYXIuZnJvbUpTRGF0ZShqc2QpO1xuXHRcdH0sXG5cblx0XHQvKiogQ29udmVydCB0byBhIHN0cmluZyBmb3IgZGlzcGxheS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGlzIGRhdGUgYXMgYSBzdHJpbmcuICovXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLnllYXIoKSA8IDAgPyAnLScgOiAnJykgKyBwYWQoTWF0aC5hYnModGhpcy55ZWFyKCkpLCA0KSArXG5cdFx0XHRcdCctJyArIHBhZCh0aGlzLm1vbnRoKCksIDIpICsgJy0nICsgcGFkKHRoaXMuZGF5KCksIDIpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGFsbCBjYWxlbmRhcnMuXG5cdFx0T3RoZXIgY2FsZW5kYXJzIHNob3VsZCBleHRlbmQgdGhpczpcblx0XHQ8cHJlPk90aGVyQ2FsZW5kYXIucHJvdG90eXBlID0gbmV3IEJhc2VDYWxlbmRhcjs8L3ByZT5cblx0XHRAY2xhc3MgQmFzZUNhbGVuZGFyICovXG5cdGZ1bmN0aW9uIEJhc2VDYWxlbmRhcigpIHtcblx0XHR0aGlzLnNob3J0WWVhckN1dG9mZiA9ICcrMTAnO1xuXHR9XG5cblx0JC5leHRlbmQoQmFzZUNhbGVuZGFyLnByb3RvdHlwZSwge1xuXHRcdF92YWxpZGF0ZUxldmVsOiAwLCAvLyBcIlN0YWNrXCIgdG8gdHVybiB2YWxpZGF0aW9uIG9uL29mZlxuXG5cdFx0LyoqIENyZWF0ZSBhIG5ldyBkYXRlIHdpdGhpbiB0aGlzIGNhbGVuZGFyIC0gdG9kYXkgaWYgbm8gcGFyYW1ldGVycyBnaXZlbi5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGR1cGxpY2F0ZSBvciB0aGUgeWVhciBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgZm9yIHRoZSBkYXRlLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBuZXcgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgbm90IGEgdmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdG5ld0RhdGU6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdGlmICh5ZWFyID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudG9kYXkoKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyLnllYXIpIHtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcblx0XHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdFx0ZGF5ID0geWVhci5kYXkoKTtcblx0XHRcdFx0bW9udGggPSB5ZWFyLm1vbnRoKCk7XG5cdFx0XHRcdHllYXIgPSB5ZWFyLnllYXIoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgQ0RhdGUodGhpcywgeWVhciwgbW9udGgsIGRheSk7XG5cdFx0fSxcblxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmb3IgdG9kYXkuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVG9kYXkncyBkYXRlLiAqL1xuXHRcdHRvZGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZyb21KU0RhdGUobmV3IERhdGUoKSk7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgZXBvY2ggZGVzaWduYXRvciBmb3IgdGhpcyBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgY3VycmVudCBlcG9jaC5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZXBvY2g6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZFllYXIpO1xuXHRcdFx0cmV0dXJuIChkYXRlLnllYXIoKSA8IDAgPyB0aGlzLmxvY2FsLmVwb2Noc1swXSA6IHRoaXMubG9jYWwuZXBvY2hzWzFdKTtcblx0XHR9LFxuXG5cdFx0LyoqIEZvcm1hdCB0aGUgeWVhciwgaWYgbm90IGEgc2ltcGxlIHNlcXVlbnRpYWwgbnVtYmVyXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBmb3JtYXQgb3IgdGhlIHllYXIgdG8gZm9ybWF0LlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHllYXIuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhciBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdGZvcm1hdFllYXI6IGZ1bmN0aW9uKHllYXIpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgdGhpcy5taW5Nb250aCwgdGhpcy5taW5EYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRZZWFyIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZFllYXIpO1xuXHRcdFx0cmV0dXJuIChkYXRlLnllYXIoKSA8IDAgPyAnLScgOiAnJykgKyBwYWQoTWF0aC5hYnMoZGF0ZS55ZWFyKCkpLCA0KVxuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIG51bWJlciBvZiBtb250aHMgaW4gYSB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1vbnRocy5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0bW9udGhzSW5ZZWFyOiBmdW5jdGlvbih5ZWFyKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XG5cdFx0XHRyZXR1cm4gMTI7XG5cdFx0fSxcblxuXHRcdC8qKiBDYWxjdWxhdGUgdGhlIG1vbnRoJ3Mgb3JkaW5hbCBwb3NpdGlvbiB3aXRoaW4gdGhlIHllYXIgLVxuXHRcdFx0Zm9yIHRob3NlIGNhbGVuZGFycyB0aGF0IGRvbid0IHN0YXJ0IGF0IG1vbnRoIDEhXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBvcmRpbmFsIHBvc2l0aW9uLCBzdGFydGluZyBmcm9tIDxjb2RlPm1pbk1vbnRoPC9jb2RlPi5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyL21vbnRoIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0bW9udGhPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZE1vbnRoIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZE1vbnRoKTtcblx0XHRcdHJldHVybiAoZGF0ZS5tb250aCgpICsgdGhpcy5tb250aHNJblllYXIoZGF0ZSkgLSB0aGlzLmZpcnN0TW9udGgpICVcblx0XHRcdFx0dGhpcy5tb250aHNJblllYXIoZGF0ZSkgKyB0aGlzLm1pbk1vbnRoO1xuXHRcdH0sXG5cblx0XHQvKiogQ2FsY3VsYXRlIGFjdHVhbCBtb250aCBmcm9tIG9yZGluYWwgcG9zaXRpb24sIHN0YXJ0aW5nIGZyb20gbWluTW9udGguXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7bnVtYmVyfSBUaGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIG9yZCB7bnVtYmVyfSBUaGUgbW9udGgncyBvcmRpbmFsIHBvc2l0aW9uLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbW9udGgncyBudW1iZXIuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgeWVhci9tb250aC4gKi9cblx0XHRmcm9tTW9udGhPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG9yZCkge1xuXHRcdFx0dmFyIG0gPSAob3JkICsgdGhpcy5maXJzdE1vbnRoIC0gMiAqIHRoaXMubWluTW9udGgpICVcblx0XHRcdFx0dGhpcy5tb250aHNJblllYXIoeWVhcikgKyB0aGlzLm1pbk1vbnRoO1xuXHRcdFx0dGhpcy5fdmFsaWRhdGUoeWVhciwgbSwgdGhpcy5taW5EYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWRNb250aCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRNb250aCk7XG5cdFx0XHRyZXR1cm4gbTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cy5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCB5ZWFyIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZGF5c0luWWVhcjogZnVuY3Rpb24oeWVhcikge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XG5cdFx0XHRyZXR1cm4gKHRoaXMubGVhcFllYXIoZGF0ZSkgPyAzNjYgOiAzNjUpO1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIGRheSBvZiB0aGUgeWVhciBmb3IgYSBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZGF5IG9mIHRoZSB5ZWFyLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRkYXlPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XG5cdFx0XHRyZXR1cm4gZGF0ZS50b0pEKCkgLSB0aGlzLm5ld0RhdGUoZGF0ZS55ZWFyKCksXG5cdFx0XHRcdHRoaXMuZnJvbU1vbnRoT2ZZZWFyKGRhdGUueWVhcigpLCB0aGlzLm1pbk1vbnRoKSwgdGhpcy5taW5EYXkpLnRvSkQoKSArIDE7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSB3ZWVrLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMuICovXG5cdFx0ZGF5c0luV2VlazogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gNztcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGEgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIGV4YW1pbmUgb3IgdGhlIHllYXIgdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbbW9udGhdIHtudW1iZXJ9IFRoZSBtb250aCB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIGRheSBvZiB0aGUgd2VlazogMCB0byBudW1iZXIgb2YgZGF5cyAtIDEuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdGRheU9mV2VlazogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHJldHVybiAoTWF0aC5mbG9vcih0aGlzLnRvSkQoZGF0ZSkpICsgMikgJSB0aGlzLmRheXNJbldlZWsoKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBleGFtaW5lLlxuXHRcdFx0QHJldHVybiB7b2JqZWN0fSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIC0gY29udGVudHMgZGVwZW5kcyBvbiBjYWxlbmRhci5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0ZXh0cmFJbmZvOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9LFxuXG5cdFx0LyoqIEFkZCBwZXJpb2QocykgdG8gYSBkYXRlLlxuXHRcdFx0Q2F0ZXIgZm9yIG5vIHllYXIgemVyby5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcGVyaW9kcyB0byBhZGp1c3QgYnkuXG5cdFx0XHRAcGFyYW0gcGVyaW9kIHtzdHJpbmd9IE9uZSBvZiAneScgZm9yIHllYXIsICdtJyBmb3IgbW9udGgsICd3JyBmb3Igd2VlaywgJ2QnIGZvciBkYXkuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKGRhdGUsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZShkYXRlLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29ycmVjdEFkZChkYXRlLCB0aGlzLl9hZGQoZGF0ZSwgb2Zmc2V0LCBwZXJpb2QpLCBvZmZzZXQsIHBlcmlvZCk7XG5cdFx0fSxcblxuXHRcdC8qKiBBZGQgcGVyaW9kKHMpIHRvIGEgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBzdGFydGluZyBkYXRlLlxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBlcmlvZHMgdG8gYWRqdXN0IGJ5LlxuXHRcdFx0QHBhcmFtIHBlcmlvZCB7c3RyaW5nfSBPbmUgb2YgJ3knIGZvciB5ZWFyLCAnbScgZm9yIG1vbnRoLCAndycgZm9yIHdlZWssICdkJyBmb3IgZGF5LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSB1cGRhdGVkIGRhdGUuICovXG5cdFx0X2FkZDogZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0LCBwZXJpb2QpIHtcblx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwrKztcblx0XHRcdGlmIChwZXJpb2QgPT09ICdkJyB8fCBwZXJpb2QgPT09ICd3Jykge1xuXHRcdFx0XHR2YXIgamQgPSBkYXRlLnRvSkQoKSArIG9mZnNldCAqIChwZXJpb2QgPT09ICd3JyA/IHRoaXMuZGF5c0luV2VlaygpIDogMSk7XG5cdFx0XHRcdHZhciBkID0gZGF0ZS5jYWxlbmRhcigpLmZyb21KRChqZCk7XG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcblx0XHRcdFx0cmV0dXJuIFtkLnllYXIoKSwgZC5tb250aCgpLCBkLmRheSgpXTtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB5ID0gZGF0ZS55ZWFyKCkgKyAocGVyaW9kID09PSAneScgPyBvZmZzZXQgOiAwKTtcblx0XHRcdFx0dmFyIG0gPSBkYXRlLm1vbnRoT2ZZZWFyKCkgKyAocGVyaW9kID09PSAnbScgPyBvZmZzZXQgOiAwKTtcblx0XHRcdFx0dmFyIGQgPSBkYXRlLmRheSgpOy8vICsgKHBlcmlvZCA9PT0gJ2QnID8gb2Zmc2V0IDogMCkgK1xuXHRcdFx0XHRcdC8vKHBlcmlvZCA9PT0gJ3cnID8gb2Zmc2V0ICogdGhpcy5kYXlzSW5XZWVrKCkgOiAwKTtcblx0XHRcdFx0dmFyIHJlc3luY1llYXJNb250aCA9IGZ1bmN0aW9uKGNhbGVuZGFyKSB7XG5cdFx0XHRcdFx0d2hpbGUgKG0gPCBjYWxlbmRhci5taW5Nb250aCkge1xuXHRcdFx0XHRcdFx0eS0tO1xuXHRcdFx0XHRcdFx0bSArPSBjYWxlbmRhci5tb250aHNJblllYXIoeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB5ZWFyTW9udGhzID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHkpO1xuXHRcdFx0XHRcdHdoaWxlIChtID4geWVhck1vbnRocyAtIDEgKyBjYWxlbmRhci5taW5Nb250aCkge1xuXHRcdFx0XHRcdFx0eSsrO1xuXHRcdFx0XHRcdFx0bSAtPSB5ZWFyTW9udGhzO1xuXHRcdFx0XHRcdFx0eWVhck1vbnRocyA9IGNhbGVuZGFyLm1vbnRoc0luWWVhcih5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChwZXJpb2QgPT09ICd5Jykge1xuXHRcdFx0XHRcdGlmIChkYXRlLm1vbnRoKCkgIT09IHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pKSB7IC8vIEhlYnJld1xuXHRcdFx0XHRcdFx0bSA9IHRoaXMubmV3RGF0ZSh5LCBkYXRlLm1vbnRoKCksIHRoaXMubWluRGF5KS5tb250aE9mWWVhcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtID0gTWF0aC5taW4obSwgdGhpcy5tb250aHNJblllYXIoeSkpO1xuXHRcdFx0XHRcdGQgPSBNYXRoLm1pbihkLCB0aGlzLmRheXNJbk1vbnRoKHksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocGVyaW9kID09PSAnbScpIHtcblx0XHRcdFx0XHRyZXN5bmNZZWFyTW9udGgodGhpcyk7XG5cdFx0XHRcdFx0ZCA9IE1hdGgubWluKGQsIHRoaXMuZGF5c0luTW9udGgoeSwgdGhpcy5mcm9tTW9udGhPZlllYXIoeSwgbSkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgeW1kID0gW3ksIHRoaXMuZnJvbU1vbnRoT2ZZZWFyKHksIG0pLCBkXTtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xuXHRcdFx0XHRyZXR1cm4geW1kO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xuXHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogQ29ycmVjdCBhIGNhbmRpZGF0ZSBkYXRlIGFmdGVyIGFkZGluZyBwZXJpb2QocykgdG8gYSBkYXRlLlxuXHRcdFx0SGFuZGxlIG5vIHllYXIgemVybyBpZiBuZWNlc3NhcnkuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgc3RhcnRpbmcgZGF0ZS5cblx0XHRcdEBwYXJhbSB5bWQge251bWJlcltdfSBUaGUgYWRkZWQgZGF0ZS5cblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIG51bWJlciBvZiBwZXJpb2RzIHRvIGFkanVzdCBieS5cblx0XHRcdEBwYXJhbSBwZXJpb2Qge3N0cmluZ30gT25lIG9mICd5JyBmb3IgeWVhciwgJ20nIGZvciBtb250aCwgJ3cnIGZvciB3ZWVrLCAnZCcgZm9yIGRheS5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgdXBkYXRlZCBkYXRlLiAqL1xuXHRcdF9jb3JyZWN0QWRkOiBmdW5jdGlvbihkYXRlLCB5bWQsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0XHRpZiAoIXRoaXMuaGFzWWVhclplcm8gJiYgKHBlcmlvZCA9PT0gJ3knIHx8IHBlcmlvZCA9PT0gJ20nKSkge1xuXHRcdFx0XHRpZiAoeW1kWzBdID09PSAwIHx8IC8vIEluIHllYXIgemVyb1xuXHRcdFx0XHRcdFx0KGRhdGUueWVhcigpID4gMCkgIT09ICh5bWRbMF0gPiAwKSkgeyAvLyBDcm9zc2VkIHllYXIgemVyb1xuXHRcdFx0XHRcdHZhciBhZGogPSB7eTogWzEsIDEsICd5J10sIG06IFsxLCB0aGlzLm1vbnRoc0luWWVhcigtMSksICdtJ10sXG5cdFx0XHRcdFx0XHR3OiBbdGhpcy5kYXlzSW5XZWVrKCksIHRoaXMuZGF5c0luWWVhcigtMSksICdkJ10sXG5cdFx0XHRcdFx0XHRkOiBbMSwgdGhpcy5kYXlzSW5ZZWFyKC0xKSwgJ2QnXX1bcGVyaW9kXTtcblx0XHRcdFx0XHR2YXIgZGlyID0gKG9mZnNldCA8IDAgPyAtMSA6ICsxKTtcblx0XHRcdFx0XHR5bWQgPSB0aGlzLl9hZGQoZGF0ZSwgb2Zmc2V0ICogYWRqWzBdICsgZGlyICogYWRqWzFdLCBhZGpbMl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0ZS5kYXRlKHltZFswXSwgeW1kWzFdLCB5bWRbMl0pO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IGEgcG9ydGlvbiBvZiB0aGUgZGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIHN0YXJ0aW5nIGRhdGUuXG5cdFx0XHRAcGFyYW0gdmFsdWUge251bWJlcn0gVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHBlcmlvZC5cblx0XHRcdEBwYXJhbSBwZXJpb2Qge3N0cmluZ30gT25lIG9mICd5JyBmb3IgeWVhciwgJ20nIGZvciBtb250aCwgJ2QnIGZvciBkYXkuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIHVwZGF0ZWQgZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0c2V0OiBmdW5jdGlvbihkYXRlLCB2YWx1ZSwgcGVyaW9kKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZShkYXRlLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZERhdGUgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkRGF0ZSk7XG5cdFx0XHR2YXIgeSA9IChwZXJpb2QgPT09ICd5JyA/IHZhbHVlIDogZGF0ZS55ZWFyKCkpO1xuXHRcdFx0dmFyIG0gPSAocGVyaW9kID09PSAnbScgPyB2YWx1ZSA6IGRhdGUubW9udGgoKSk7XG5cdFx0XHR2YXIgZCA9IChwZXJpb2QgPT09ICdkJyA/IHZhbHVlIDogZGF0ZS5kYXkoKSk7XG5cdFx0XHRpZiAocGVyaW9kID09PSAneScgfHwgcGVyaW9kID09PSAnbScpIHtcblx0XHRcdFx0ZCA9IE1hdGgubWluKGQsIHRoaXMuZGF5c0luTW9udGgoeSwgbSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGUuZGF0ZSh5LCBtLCBkKTtcblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIGEgZGF0ZSBpcyB2YWxpZCBmb3IgdGhpcyBjYWxlbmRhci5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSB5ZWFyIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gZGF5IHtudW1iZXJ9IFRoZSBkYXkgdG8gZXhhbWluZS5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGEgdmFsaWQgZGF0ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cblx0XHRpc1ZhbGlkOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsKys7XG5cdFx0XHR2YXIgdmFsaWQgPSAodGhpcy5oYXNZZWFyWmVybyB8fCB5ZWFyICE9PSAwKTtcblx0XHRcdGlmICh2YWxpZCkge1xuXHRcdFx0XHR2YXIgZGF0ZSA9IHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgdGhpcy5taW5EYXkpO1xuXHRcdFx0XHR2YWxpZCA9IChtb250aCA+PSB0aGlzLm1pbk1vbnRoICYmIG1vbnRoIC0gdGhpcy5taW5Nb250aCA8IHRoaXMubW9udGhzSW5ZZWFyKGRhdGUpKSAmJlxuXHRcdFx0XHRcdChkYXkgPj0gdGhpcy5taW5EYXkgJiYgZGF5IC0gdGhpcy5taW5EYXkgPCB0aGlzLmRheXNJbk1vbnRoKGRhdGUpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwtLTtcblx0XHRcdHJldHVybiB2YWxpZDtcblx0XHR9LFxuXG5cdFx0LyoqIENvbnZlcnQgdGhlIGRhdGUgdG8gYSBzdGFuZGFyZCAoR3JlZ29yaWFuKSBKYXZhU2NyaXB0IERhdGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBjb252ZXJ0IG9yIHRoZSB5ZWFyIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gY29udmVydC5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGNvbnZlcnQuXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgZXF1aXZhbGVudCBKYXZhU2NyaXB0IGRhdGUuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdHRvSlNEYXRlOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX3ZhbGlkYXRlKHllYXIsIG1vbnRoLCBkYXksXG5cdFx0XHRcdCQuY2FsZW5kYXJzLmxvY2FsLmludmFsaWREYXRlIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZERhdGUpO1xuXHRcdFx0cmV0dXJuICQuY2FsZW5kYXJzLmluc3RhbmNlKCkuZnJvbUpEKHRoaXMudG9KRChkYXRlKSkudG9KU0RhdGUoKTtcblx0XHR9LFxuXG5cdFx0LyoqIENvbnZlcnQgdGhlIGRhdGUgZnJvbSBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBqc2Qge0RhdGV9IFRoZSBKYXZhU2NyaXB0IGRhdGUuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGVxdWl2YWxlbnQgY2FsZW5kYXIgZGF0ZS4gKi9cblx0XHRmcm9tSlNEYXRlOiBmdW5jdGlvbihqc2QpIHtcblx0XHRcdHJldHVybiB0aGlzLmZyb21KRCgkLmNhbGVuZGFycy5pbnN0YW5jZSgpLmZyb21KU0RhdGUoanNkKS50b0pEKCkpO1xuXHRcdH0sXG5cblx0XHQvKiogQ2hlY2sgdGhhdCBhIGNhbmRpZGF0ZSBkYXRlIGlzIGZyb20gdGhlIHNhbWUgY2FsZW5kYXIgYW5kIGlzIHZhbGlkLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSB5ZWFyIHtDRGF0ZXxudW1iZXJ9IFRoZSBkYXRlIHRvIHZhbGlkYXRlIG9yIHRoZSB5ZWFyIHRvIHZhbGlkYXRlLlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIHZhbGlkYXRlLlxuXHRcdFx0QHBhcmFtIFtkYXldIHtudW1iZXJ9IFRoZSBkYXkgdG8gdmFsaWRhdGUuXG5cdFx0XHRAcGFyYW0gZXJyb3Ige3N0cmluZ30gUnJyb3IgbWVzc2FnZSBpZiBpbnZhbGlkLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBkaWZmZXJlbnQgY2FsZW5kYXJzIHVzZWQgb3IgaW52YWxpZCBkYXRlLiAqL1xuXHRcdF92YWxpZGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgZXJyb3IpIHtcblx0XHRcdGlmICh5ZWFyLnllYXIpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3ZhbGlkYXRlTGV2ZWwgPT09IDAgJiYgdGhpcy5uYW1lICE9PSB5ZWFyLmNhbGVuZGFyKCkubmFtZSkge1xuXHRcdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC5kaWZmZXJlbnRDYWxlbmRhcnMgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5kaWZmZXJlbnRDYWxlbmRhcnMpLlxuXHRcdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIHRoaXMubG9jYWwubmFtZSkucmVwbGFjZSgvXFx7MVxcfS8sIHllYXIuY2FsZW5kYXIoKS5sb2NhbC5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geWVhcjtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3ZhbGlkYXRlTGV2ZWwrKztcblx0XHRcdFx0aWYgKHRoaXMuX3ZhbGlkYXRlTGV2ZWwgPT09IDEgJiYgIXRoaXMuaXNWYWxpZCh5ZWFyLCBtb250aCwgZGF5KSkge1xuXHRcdFx0XHRcdHRocm93IGVycm9yLnJlcGxhY2UoL1xcezBcXH0vLCB0aGlzLmxvY2FsLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBkYXRlID0gdGhpcy5uZXdEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuXHRcdFx0XHR0aGlzLl92YWxpZGF0ZUxldmVsLS07XG5cdFx0XHRcdHJldHVybiBkYXRlO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0dGhpcy5fdmFsaWRhdGVMZXZlbC0tO1xuXHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyLlxuXHRcdFNlZSA8YSBocmVmPVwiOmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JlZ29yaWFuX2NhbGVuZGFyXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmVnb3JpYW5fY2FsZW5kYXI8L2E+XG5cdFx0YW5kIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2xlcHRpY19HcmVnb3JpYW5fY2FsZW5kYXJcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2xlcHRpY19HcmVnb3JpYW5fY2FsZW5kYXI8L2E+LlxuXHRcdEBjbGFzcyBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdEBhdWdtZW50cyBCYXNlQ2FsZW5kYXJcblx0XHRAcGFyYW0gW2xhbmd1YWdlPScnXSB7c3RyaW5nfSBUaGUgbGFuZ3VhZ2UgY29kZSAoZGVmYXVsdCBFbmdsaXNoKSBmb3IgbG9jYWxpc2F0aW9uLiAqL1xuXHRmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhcihsYW5ndWFnZSkge1xuXHRcdHRoaXMubG9jYWwgPSB0aGlzLnJlZ2lvbmFsT3B0aW9uc1tsYW5ndWFnZV0gfHwgdGhpcy5yZWdpb25hbE9wdGlvbnNbJyddO1xuXHR9XG5cblx0R3JlZ29yaWFuQ2FsZW5kYXIucHJvdG90eXBlID0gbmV3IEJhc2VDYWxlbmRhcjtcblxuXHQkLmV4dGVuZChHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUsIHtcblx0XHQvKiogVGhlIGNhbGVuZGFyIG5hbWUuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRuYW1lOiAnR3JlZ29yaWFuJyxcblx0XHQgLyoqIEp1bGlhbiBkYXRlIG9mIHN0YXJ0IG9mIEdyZWdvcmlhbiBlcG9jaDogMSBKYW51YXJ5IDAwMDEgQ0UuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRqZEVwb2NoOiAxNzIxNDI1LjUsXG5cdFx0IC8qKiBEYXlzIHBlciBtb250aCBpbiBhIGNvbW1vbiB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyICovXG5cdFx0ZGF5c1Blck1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG5cdFx0IC8qKiA8Y29kZT50cnVlPC9jb2RlPiBpZiBoYXMgYSB5ZWFyIHplcm8sIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRoYXNZZWFyWmVybzogZmFsc2UsXG5cdFx0LyoqIFRoZSBtaW5pbXVtIG1vbnRoIG51bWJlci5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhciAqL1xuXHRcdG1pbk1vbnRoOiAxLFxuXHRcdC8qKiBUaGUgZmlyc3QgbW9udGggaW4gdGhlIHllYXIuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXIgKi9cblx0XHRmaXJzdE1vbnRoOiAxLFxuXHRcdCAvKiogVGhlIG1pbmltdW0gZGF5IG51bWJlci5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhciAqL1xuXHRcdG1pbkRheTogMSxcblxuXHRcdC8qKiBMb2NhbGlzYXRpb25zIGZvciB0aGUgcGx1Z2luLlxuXHRcdFx0RW50cmllcyBhcmUgb2JqZWN0cyBpbmRleGVkIGJ5IHRoZSBsYW5ndWFnZSBjb2RlICgnJyBiZWluZyB0aGUgZGVmYXVsdCBVUy9FbmdsaXNoKS5cblx0XHRcdEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcblx0XHRcdEBwcm9wZXJ0eSBuYW1lIHtzdHJpbmd9IFRoZSBjYWxlbmRhciBuYW1lLlxuXHRcdFx0QHByb3BlcnR5IGVwb2NocyB7c3RyaW5nW119IFRoZSBlcG9jaCBuYW1lcy5cblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzIHtzdHJpbmdbXX0gVGhlIGxvbmcgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBtb250aE5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIG1vbnRocyBvZiB0aGUgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBkYXlOYW1lcyB7c3RyaW5nW119IFRoZSBsb25nIG5hbWVzIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuXHRcdFx0QHByb3BlcnR5IGRheU5hbWVzU2hvcnQge3N0cmluZ1tdfSBUaGUgc2hvcnQgbmFtZXMgb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsuXG5cdFx0XHRAcHJvcGVydHkgZGF5TmFtZXNNaW4ge3N0cmluZ1tdfSBUaGUgbWluaW1hbCBuYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cblx0XHRcdEBwcm9wZXJ0eSBkYXRlRm9ybWF0IHtzdHJpbmd9IFRoZSBkYXRlIGZvcm1hdCBmb3IgdGhpcyBjYWxlbmRhci5cblx0XHRcdFx0XHRTZWUgdGhlIG9wdGlvbnMgb24gPGEgaHJlZj1cIkJhc2VDYWxlbmRhci5odG1sI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4gZm9yIGRldGFpbHMuXG5cdFx0XHRAcHJvcGVydHkgZmlyc3REYXkge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBzdGFydGluZyBhdCAwLlxuXHRcdFx0QHByb3BlcnR5IGlzUlRMIHtudW1iZXJ9IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgbG9jYWxpc2F0aW9uIHJlYWRzIHJpZ2h0LXRvLWxlZnQuICovXG5cdFx0cmVnaW9uYWxPcHRpb25zOiB7IC8vIExvY2FsaXNhdGlvbnNcblx0XHRcdCcnOiB7XG5cdFx0XHRcdG5hbWU6ICdHcmVnb3JpYW4nLFxuXHRcdFx0XHRlcG9jaHM6IFsnQkNFJywgJ0NFJ10sXG5cdFx0XHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsXG5cdFx0XHRcdCdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuXHRcdFx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRcdFx0ZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcblx0XHRcdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcblx0XHRcdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcblx0XHRcdFx0ZGF0ZUZvcm1hdDogJ21tL2RkL3l5eXknLFxuXHRcdFx0XHRmaXJzdERheTogMCxcblx0XHRcdFx0aXNSVEw6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBkYXRlIGlzIGluIGEgbGVhcCB5ZWFyLlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGlzIGEgbGVhcCB5ZWFyLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIHllYXIgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRsZWFwWWVhcjogZnVuY3Rpb24oeWVhcikge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCB0aGlzLm1pbk1vbnRoLCB0aGlzLm1pbkRheSxcblx0XHRcdFx0JC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZFllYXIgfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkWWVhcik7XG5cdFx0XHR2YXIgeWVhciA9IGRhdGUueWVhcigpICsgKGRhdGUueWVhcigpIDwgMCA/IDEgOiAwKTsgLy8gTm8geWVhciB6ZXJvXG5cdFx0XHRyZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZSAtIElTTyA4NjAxLlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSB3ZWVrIG9mIHRoZSB5ZWFyLCBzdGFydGluZyBmcm9tIDEuXG5cdFx0XHRAdGhyb3dzIEVycm9yIGlmIGFuIGludmFsaWQgZGF0ZSBvciBhIGRpZmZlcmVudCBjYWxlbmRhciB1c2VkLiAqL1xuXHRcdHdlZWtPZlllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdC8vIEZpbmQgVGh1cnNkYXkgb2YgdGhpcyB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxuXHRcdFx0dmFyIGNoZWNrRGF0ZSA9IHRoaXMubmV3RGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHRcdGNoZWNrRGF0ZS5hZGQoNCAtIChjaGVja0RhdGUuZGF5T2ZXZWVrKCkgfHwgNyksICdkJyk7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigoY2hlY2tEYXRlLmRheU9mWWVhcigpIC0gMSkgLyA3KSArIDE7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aC5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gZXhhbWluZSBvciB0aGUgeWVhciBvZiB0aGUgbW9udGguXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGguXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIG1vbnRoLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIG1vbnRoL3llYXIgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHRkYXlzSW5Nb250aDogZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fdmFsaWRhdGUoeWVhciwgbW9udGgsIHRoaXMubWluRGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkTW9udGggfHwgJC5jYWxlbmRhcnMucmVnaW9uYWxPcHRpb25zWycnXS5pbnZhbGlkTW9udGgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF5c1Blck1vbnRoW2RhdGUubW9udGgoKSAtIDFdICtcblx0XHRcdFx0KGRhdGUubW9udGgoKSA9PT0gMiAmJiB0aGlzLmxlYXBZZWFyKGRhdGUueWVhcigpKSA/IDEgOiAwKTtcblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB3aGV0aGVyIHRoaXMgZGF0ZSBpcyBhIHdlZWsgZGF5LlxuXHRcdFx0QG1lbWJlcm9mIEdyZWdvcmlhbkNhbGVuZGFyXG5cdFx0XHRAcGFyYW0geWVhciB7Q0RhdGV8bnVtYmVyfSBUaGUgZGF0ZSB0byBleGFtaW5lIG9yIHRoZSB5ZWFyIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gZXhhbWluZS5cblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhIHdlZWsgZGF5LCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR3ZWVrRGF5OiBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHx8IDcpIDwgNjtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBKdWxpYW4gZGF0ZSBlcXVpdmFsZW50IGZvciB0aGlzIGRhdGUsXG5cdFx0XHRpLmUuIGRheXMgc2luY2UgSmFudWFyeSAxLCA0NzEzIEJDRSBHcmVlbndpY2ggbm9vbi5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBKdWxpYW4gZGF0ZS5cblx0XHRcdEB0aHJvd3MgRXJyb3IgaWYgYW4gaW52YWxpZCBkYXRlIG9yIGEgZGlmZmVyZW50IGNhbGVuZGFyIHVzZWQuICovXG5cdFx0dG9KRDogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHllYXIgPSBkYXRlLnllYXIoKTtcblx0XHRcdG1vbnRoID0gZGF0ZS5tb250aCgpO1xuXHRcdFx0ZGF5ID0gZGF0ZS5kYXkoKTtcblx0XHRcdGlmICh5ZWFyIDwgMCkgeyB5ZWFyKys7IH0gLy8gTm8geWVhciB6ZXJvXG5cdFx0XHQvLyBKZWFuIE1lZXVzIGFsZ29yaXRobSwgXCJBc3Ryb25vbWljYWwgQWxnb3JpdGhtc1wiLCAxOTkxXG5cdFx0XHRpZiAobW9udGggPCAzKSB7XG5cdFx0XHRcdG1vbnRoICs9IDEyO1xuXHRcdFx0XHR5ZWFyLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IE1hdGguZmxvb3IoeWVhciAvIDEwMCk7XG5cdFx0XHR2YXIgYiA9IDIgLSBhICsgTWF0aC5mbG9vcihhIC8gNCk7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigzNjUuMjUgKiAoeWVhciArIDQ3MTYpKSArXG5cdFx0XHRcdE1hdGguZmxvb3IoMzAuNjAwMSAqIChtb250aCArIDEpKSArIGRheSArIGIgLSAxNTI0LjU7XG5cdFx0fSxcblxuXHRcdC8qKiBDcmVhdGUgYSBuZXcgZGF0ZSBmcm9tIGEgSnVsaWFuIGRhdGUuXG5cdFx0XHRAbWVtYmVyb2YgR3JlZ29yaWFuQ2FsZW5kYXJcblx0XHRcdEBwYXJhbSBqZCB7bnVtYmVyfSBUaGUgSnVsaWFuIGRhdGUgdG8gY29udmVydC5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBUaGUgZXF1aXZhbGVudCBkYXRlLiAqL1xuXHRcdGZyb21KRDogZnVuY3Rpb24oamQpIHtcblx0XHRcdC8vIEplYW4gTWVldXMgYWxnb3JpdGhtLCBcIkFzdHJvbm9taWNhbCBBbGdvcml0aG1zXCIsIDE5OTFcblx0XHRcdHZhciB6ID0gTWF0aC5mbG9vcihqZCArIDAuNSk7XG5cdFx0XHR2YXIgYSA9IE1hdGguZmxvb3IoKHogLSAxODY3MjE2LjI1KSAvIDM2NTI0LjI1KTtcblx0XHRcdGEgPSB6ICsgMSArIGEgLSBNYXRoLmZsb29yKGEgLyA0KTtcblx0XHRcdHZhciBiID0gYSArIDE1MjQ7XG5cdFx0XHR2YXIgYyA9IE1hdGguZmxvb3IoKGIgLSAxMjIuMSkgLyAzNjUuMjUpO1xuXHRcdFx0dmFyIGQgPSBNYXRoLmZsb29yKDM2NS4yNSAqIGMpO1xuXHRcdFx0dmFyIGUgPSBNYXRoLmZsb29yKChiIC0gZCkgLyAzMC42MDAxKTtcblx0XHRcdHZhciBkYXkgPSBiIC0gZCAtIE1hdGguZmxvb3IoZSAqIDMwLjYwMDEpO1xuXHRcdFx0dmFyIG1vbnRoID0gZSAtIChlID4gMTMuNSA/IDEzIDogMSk7XG5cdFx0XHR2YXIgeWVhciA9IGMgLSAobW9udGggPiAyLjUgPyA0NzE2IDogNDcxNSk7XG5cdFx0XHRpZiAoeWVhciA8PSAwKSB7IHllYXItLTsgfSAvLyBObyB5ZWFyIHplcm9cblx0XHRcdHJldHVybiB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSk7XG5cdFx0fSxcblxuXHRcdC8qKiBDb252ZXJ0IHRoaXMgZGF0ZSB0byBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIHllYXIge0NEYXRlfG51bWJlcn0gVGhlIGRhdGUgdG8gY29udmVydCBvciB0aGUgeWVhciB0byBjb252ZXJ0LlxuXHRcdFx0QHBhcmFtIFttb250aF0ge251bWJlcn0gVGhlIG1vbnRoIHRvIGNvbnZlcnQuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7RGF0ZX0gVGhlIGVxdWl2YWxlbnQgSmF2YVNjcmlwdCBkYXRlLlxuXHRcdFx0QHRocm93cyBFcnJvciBpZiBhbiBpbnZhbGlkIGRhdGUgb3IgYSBkaWZmZXJlbnQgY2FsZW5kYXIgdXNlZC4gKi9cblx0XHR0b0pTRGF0ZTogZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSkge1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5LFxuXHRcdFx0XHQkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkRGF0ZSB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWREYXRlKTtcblx0XHRcdHZhciBqc2QgPSBuZXcgRGF0ZShkYXRlLnllYXIoKSwgZGF0ZS5tb250aCgpIC0gMSwgZGF0ZS5kYXkoKSk7XG5cdFx0XHRqc2Quc2V0SG91cnMoMCk7XG5cdFx0XHRqc2Quc2V0TWludXRlcygwKTtcblx0XHRcdGpzZC5zZXRTZWNvbmRzKDApO1xuXHRcdFx0anNkLnNldE1pbGxpc2Vjb25kcygwKTtcblx0XHRcdC8vIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XG5cdFx0XHQvLyA+IDEyIHdoZW4gbWlkbmlnaHQgY2hhbmdlb3ZlciwgYnV0IHRoZW4gY2Fubm90IGdlbmVyYXRlXG5cdFx0XHQvLyBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cblx0XHRcdGpzZC5zZXRIb3Vycyhqc2QuZ2V0SG91cnMoKSA+IDEyID8ganNkLmdldEhvdXJzKCkgKyAyIDogMCk7XG5cdFx0XHRyZXR1cm4ganNkO1xuXHRcdH0sXG5cblx0XHQvKiogQ3JlYXRlIGEgbmV3IGRhdGUgZnJvbSBhIHN0YW5kYXJkIChHcmVnb3JpYW4pIEphdmFTY3JpcHQgRGF0ZS5cblx0XHRcdEBtZW1iZXJvZiBHcmVnb3JpYW5DYWxlbmRhclxuXHRcdFx0QHBhcmFtIGpzZCB7RGF0ZX0gVGhlIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBlcXVpdmFsZW50IGRhdGUuICovXG5cdFx0ZnJvbUpTRGF0ZTogZnVuY3Rpb24oanNkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5uZXdEYXRlKGpzZC5nZXRGdWxsWWVhcigpLCBqc2QuZ2V0TW9udGgoKSArIDEsIGpzZC5nZXREYXRlKCkpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gU2luZ2xldG9uIG1hbmFnZXJcblx0JC5jYWxlbmRhcnMgPSBuZXcgQ2FsZW5kYXJzKCk7XG5cblx0Ly8gRGF0ZSB0ZW1wbGF0ZVxuXHQkLmNhbGVuZGFycy5jZGF0ZSA9IENEYXRlO1xuXG5cdC8vIEJhc2UgY2FsZW5kYXIgdGVtcGxhdGVcblx0JC5jYWxlbmRhcnMuYmFzZUNhbGVuZGFyID0gQmFzZUNhbGVuZGFyO1xuXG5cdC8vIEdyZWdvcmlhbiBjYWxlbmRhciBpbXBsZW1lbnRhdGlvblxuXHQkLmNhbGVuZGFycy5jYWxlbmRhcnMuZ3JlZ29yaWFuID0gR3JlZ29yaWFuQ2FsZW5kYXI7XG5cbn0pKGpRdWVyeSk7XG4vKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXG4gICBDYWxlbmRhcnMgZXh0cmFzIGZvciBqUXVlcnkgdjIuMC4xLlxuICAgV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSBBdWd1c3QgMjAwOS5cbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwOi8va2VpdGgtd29vZC5uYW1lL2xpY2VuY2UuaHRtbCkgbGljZW5zZS4gXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cblxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxuXG5cdCQuZXh0ZW5kKCQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10sIHtcblx0XHRpbnZhbGlkQXJndW1lbnRzOiAnSW52YWxpZCBhcmd1bWVudHMnLFxuXHRcdGludmFsaWRGb3JtYXQ6ICdDYW5ub3QgZm9ybWF0IGEgZGF0ZSBmcm9tIGFub3RoZXIgY2FsZW5kYXInLFxuXHRcdG1pc3NpbmdOdW1iZXJBdDogJ01pc3NpbmcgbnVtYmVyIGF0IHBvc2l0aW9uIHswfScsXG5cdFx0dW5rbm93bk5hbWVBdDogJ1Vua25vd24gbmFtZSBhdCBwb3NpdGlvbiB7MH0nLFxuXHRcdHVuZXhwZWN0ZWRMaXRlcmFsQXQ6ICdVbmV4cGVjdGVkIGxpdGVyYWwgYXQgcG9zaXRpb24gezB9Jyxcblx0XHR1bmV4cGVjdGVkVGV4dDogJ0FkZGl0aW9uYWwgdGV4dCBmb3VuZCBhdCBlbmQnXG5cdH0pO1xuXHQkLmNhbGVuZGFycy5sb2NhbCA9ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ107XG5cblx0JC5leHRlbmQoJC5jYWxlbmRhcnMuY2RhdGUucHJvdG90eXBlLCB7XG5cblx0XHQvKiogRm9ybWF0IHRoaXMgZGF0ZS5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBDRGF0ZVxuXHRcdFx0QHBhcmFtIFtmb3JtYXRdIHtzdHJpbmd9IFRoZSBkYXRlIGZvcm1hdCB0byB1c2UgKHNlZSA8YSBocmVmPVwiQmFzZUNhbGVuZGFyLmh0bWwjZm9ybWF0RGF0ZVwiPjxjb2RlPmZvcm1hdERhdGU8L2NvZGU+PC9hPikuXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgZGF0ZS4gKi9cblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWxlbmRhci5mb3JtYXREYXRlKGZvcm1hdCB8fCAnJywgdGhpcyk7XG5cdFx0fVxuXHR9KTtcblxuXHQkLmV4dGVuZCgkLmNhbGVuZGFycy5iYXNlQ2FsZW5kYXIucHJvdG90eXBlLCB7XG5cblx0XHRVTklYX0VQT0NIOiAkLmNhbGVuZGFycy5pbnN0YW5jZSgpLm5ld0RhdGUoMTk3MCwgMSwgMSkudG9KRCgpLFxuXHRcdFNFQ1NfUEVSX0RBWTogMjQgKiA2MCAqIDYwLFxuXHRcdFRJQ0tTX0VQT0NIOiAkLmNhbGVuZGFycy5pbnN0YW5jZSgpLmpkRXBvY2gsIC8vIDEgSmFudWFyeSAwMDAxIENFXG5cdFx0VElDS1NfUEVSX0RBWTogMjQgKiA2MCAqIDYwICogMTAwMDAwMDAsXG5cblx0XHQvKiogRGF0ZSBmb3JtIGZvciBBVE9NIChSRkMgMzMzOS9JU08gODYwMSkuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0QVRPTTogJ3l5eXktbW0tZGQnLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIGNvb2tpZXMuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0Q09PS0lFOiAnRCwgZGQgTSB5eXl5Jyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBmdWxsIGRhdGUuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0RlVMTDogJ0RELCBNTSBkLCB5eXl5Jyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBJU08gODYwMS5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRJU09fODYwMTogJ3l5eXktbW0tZGQnLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIEp1bGlhbiBkYXRlLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdEpVTElBTjogJ0onLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFJGQyA4MjIuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyICovXG5cdFx0UkZDXzgyMjogJ0QsIGQgTSB5eScsXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgUkZDIDg1MC5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRSRkNfODUwOiAnREQsIGRkLU0teXknLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFJGQyAxMDM2LlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdFJGQ18xMDM2OiAnRCwgZCBNIHl5Jyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgMTEyMy5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRSRkNfMTEyMzogJ0QsIGQgTSB5eXl5Jyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSRkMgMjgyMi5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRSRkNfMjgyMjogJ0QsIGQgTSB5eXl5Jyxcblx0XHQvKiogRGF0ZSBmb3JtIGZvciBSU1MgKFJGQyA4MjIpLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdFJTUzogJ0QsIGQgTSB5eScsXG5cdFx0LyoqIERhdGUgZm9ybSBmb3IgV2luZG93cyB0aWNrcy5cblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBsdXMuanM8L2NvZGU+IG1vZHVsZS5cblx0XHRcdEBtZW1iZXJvZiBCYXNlQ2FsZW5kYXIgKi9cblx0XHRUSUNLUzogJyEnLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFVuaXggdGltZXN0YW1wLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdFRJTUVTVEFNUDogJ0AnLFxuXHRcdC8qKiBEYXRlIGZvcm0gZm9yIFczYyAoSVNPIDg2MDEpLlxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGx1cy5qczwvY29kZT4gbW9kdWxlLlxuXHRcdFx0QG1lbWJlcm9mIEJhc2VDYWxlbmRhciAqL1xuXHRcdFczQzogJ3l5eXktbW0tZGQnLFxuXG5cdFx0LyoqIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXG5cdFx0XHRUaGUgZm9ybWF0IGNhbiBiZSBjb21iaW5hdGlvbnMgb2YgdGhlIGZvbGxvd2luZzpcblx0XHRcdDx1bD5cblx0XHRcdDxsaT5kICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKTwvbGk+XG5cdFx0XHQ8bGk+ZGQgLSBkYXkgb2YgbW9udGggKHR3byBkaWdpdCk8L2xpPlxuXHRcdFx0PGxpPm8gIC0gZGF5IG9mIHllYXIgKG5vIGxlYWRpbmcgemVyb3MpPC9saT5cblx0XHRcdDxsaT5vbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdCk8L2xpPlxuXHRcdFx0PGxpPkQgIC0gZGF5IG5hbWUgc2hvcnQ8L2xpPlxuXHRcdFx0PGxpPkREIC0gZGF5IG5hbWUgbG9uZzwvbGk+XG5cdFx0XHQ8bGk+dyAgLSB3ZWVrIG9mIHllYXIgKG5vIGxlYWRpbmcgemVybyk8L2xpPlxuXHRcdFx0PGxpPnd3IC0gd2VlayBvZiB5ZWFyICh0d28gZGlnaXQpPC9saT5cblx0XHRcdDxsaT5tICAtIG1vbnRoIG9mIHllYXIgKG5vIGxlYWRpbmcgemVybyk8L2xpPlxuXHRcdFx0PGxpPm1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KTwvbGk+XG5cdFx0XHQ8bGk+TSAgLSBtb250aCBuYW1lIHNob3J0PC9saT5cblx0XHRcdDxsaT5NTSAtIG1vbnRoIG5hbWUgbG9uZzwvbGk+XG5cdFx0XHQ8bGk+eXkgLSB5ZWFyICh0d28gZGlnaXQpPC9saT5cblx0XHRcdDxsaT55eXl5IC0geWVhciAoZm91ciBkaWdpdCk8L2xpPlxuXHRcdFx0PGxpPllZWVkgLSBmb3JtYXR0ZWQgeWVhcjwvbGk+XG5cdFx0XHQ8bGk+SiAgLSBKdWxpYW4gZGF0ZSAoZGF5cyBzaW5jZSBKYW51YXJ5IDEsIDQ3MTMgQkNFIEdyZWVud2ljaCBub29uKTwvbGk+XG5cdFx0XHQ8bGk+QCAgLSBVbml4IHRpbWVzdGFtcCAocyBzaW5jZSAwMS8wMS8xOTcwKTwvbGk+XG5cdFx0XHQ8bGk+ISAgLSBXaW5kb3dzIHRpY2tzICgxMDBucyBzaW5jZSAwMS8wMS8wMDAxKTwvbGk+XG5cdFx0XHQ8bGk+Jy4uLicgLSBsaXRlcmFsIHRleHQ8L2xpPlxuXHRcdFx0PGxpPicnIC0gc2luZ2xlIHF1b3RlPC9saT5cblx0XHRcdDwvdWw+XG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0gW2Zvcm1hdF0ge3N0cmluZ30gVGhlIGRlc2lyZWQgZm9ybWF0IG9mIHRoZSBkYXRlIChkZWZhdWx0cyB0byBjYWxlbmRhciBmb3JtYXQpLlxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXQuXG5cdFx0XHRAcGFyYW0gW3NldHRpbmdzXSB7b2JqZWN0fSBBZGRpdGlvbiBvcHRpb25zLCB3aG9zZSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxuXHRcdFx0QHByb3BlcnR5IFttb250aE5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocy5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc10ge3N0cmluZ1tdfSBOYW1lcyBvZiB0aGUgbW9udGhzLlxuXHRcdFx0QHByb3BlcnR5IFtjYWxjdWxhdGVXZWVrXSB7Q2FsZW5kYXJzUGlja2VyQ2FsY3VsYXRlV2Vla30gRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdlZWsgb2YgdGhlIHllYXIuXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXQuXG5cdFx0XHRAdGhyb3dzIEVycm9ycyBpZiB0aGUgZGF0ZSBpcyBmcm9tIGEgZGlmZmVyZW50IGNhbGVuZGFyLiAqL1xuXHRcdGZvcm1hdERhdGU6IGZ1bmN0aW9uKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRzZXR0aW5ncyA9IGRhdGU7XG5cdFx0XHRcdGRhdGUgPSBmb3JtYXQ7XG5cdFx0XHRcdGZvcm1hdCA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFkYXRlKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblx0XHRcdGlmIChkYXRlLmNhbGVuZGFyKCkgIT09IHRoaXMpIHtcblx0XHRcdFx0dGhyb3cgJC5jYWxlbmRhcnMubG9jYWwuaW52YWxpZEZvcm1hdCB8fCAkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLmludmFsaWRGb3JtYXQ7XG5cdFx0XHR9XG5cdFx0XHRmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5sb2NhbC5kYXRlRm9ybWF0O1xuXHRcdFx0c2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcblx0XHRcdHZhciBkYXlOYW1lc1Nob3J0ID0gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCB8fCB0aGlzLmxvY2FsLmRheU5hbWVzU2hvcnQ7XG5cdFx0XHR2YXIgZGF5TmFtZXMgPSBzZXR0aW5ncy5kYXlOYW1lcyB8fCB0aGlzLmxvY2FsLmRheU5hbWVzO1xuXHRcdFx0dmFyIG1vbnRoTmFtZXNTaG9ydCA9IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCB8fCB0aGlzLmxvY2FsLm1vbnRoTmFtZXNTaG9ydDtcblx0XHRcdHZhciBtb250aE5hbWVzID0gc2V0dGluZ3MubW9udGhOYW1lcyB8fCB0aGlzLmxvY2FsLm1vbnRoTmFtZXM7XG5cdFx0XHR2YXIgY2FsY3VsYXRlV2VlayA9IHNldHRpbmdzLmNhbGN1bGF0ZVdlZWsgfHwgdGhpcy5sb2NhbC5jYWxjdWxhdGVXZWVrO1xuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0dmFyIGRvdWJsZWQgPSBmdW5jdGlvbihtYXRjaCwgc3RlcCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IDE7XG5cdFx0XHRcdHdoaWxlIChpRm9ybWF0ICsgbWF0Y2hlcyA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgbWF0Y2hlcykgPT09IG1hdGNoKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcysrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlGb3JtYXQgKz0gbWF0Y2hlcyAtIDE7XG5cdFx0XHRcdHJldHVybiBNYXRoLmZsb29yKG1hdGNoZXMgLyAoc3RlcCB8fCAxKSkgPiAxO1xuXHRcdFx0fTtcblx0XHRcdC8vIEZvcm1hdCBhIG51bWJlciwgd2l0aCBsZWFkaW5nIHplcm9lcyBpZiBuZWNlc3Nhcnlcblx0XHRcdHZhciBmb3JtYXROdW1iZXIgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIGxlbiwgc3RlcCkge1xuXHRcdFx0XHR2YXIgbnVtID0gJycgKyB2YWx1ZTtcblx0XHRcdFx0aWYgKGRvdWJsZWQobWF0Y2gsIHN0ZXApKSB7XG5cdFx0XHRcdFx0d2hpbGUgKG51bS5sZW5ndGggPCBsZW4pIHtcblx0XHRcdFx0XHRcdG51bSA9ICcwJyArIG51bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bTtcblx0XHRcdH07XG5cdFx0XHQvLyBGb3JtYXQgYSBuYW1lLCBzaG9ydCBvciBsb25nIGFzIHJlcXVlc3RlZFxuXHRcdFx0dmFyIGZvcm1hdE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcykge1xuXHRcdFx0XHRyZXR1cm4gKGRvdWJsZWQobWF0Y2gpID8gbG9uZ05hbWVzW3ZhbHVlXSA6IHNob3J0TmFtZXNbdmFsdWVdKTtcblx0XHRcdH07XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0Zm9yICh2YXIgaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcblx0XHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWRvdWJsZWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnZCc6IG91dHB1dCArPSBmb3JtYXROdW1iZXIoJ2QnLCBkYXRlLmRheSgpLCAyKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdEJzogb3V0cHV0ICs9IGZvcm1hdE5hbWUoJ0QnLCBkYXRlLmRheU9mV2VlaygpLFxuXHRcdFx0XHRcdFx0XHRkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbyc6IG91dHB1dCArPSBmb3JtYXROdW1iZXIoJ28nLCBkYXRlLmRheU9mWWVhcigpLCAzKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd3Jzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcigndycsIGRhdGUud2Vla09mWWVhcigpLCAyKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtJzogb3V0cHV0ICs9IGZvcm1hdE51bWJlcignbScsIGRhdGUubW9udGgoKSwgMik7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTSc6IG91dHB1dCArPSBmb3JtYXROYW1lKCdNJywgZGF0ZS5tb250aCgpIC0gdGhpcy5taW5Nb250aCxcblx0XHRcdFx0XHRcdFx0bW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IChkb3VibGVkKCd5JywgMikgPyBkYXRlLnllYXIoKSA6XG5cdFx0XHRcdFx0XHRcdFx0KGRhdGUueWVhcigpICUgMTAwIDwgMTAgPyAnMCcgOiAnJykgKyBkYXRlLnllYXIoKSAlIDEwMCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnWSc6XG5cdFx0XHRcdFx0XHRcdGRvdWJsZWQoJ1knLCAyKTtcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZm9ybWF0WWVhcigpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0onOiBvdXRwdXQgKz0gZGF0ZS50b0pEKCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnQCc6IG91dHB1dCArPSAoZGF0ZS50b0pEKCkgLSB0aGlzLlVOSVhfRVBPQ0gpICogdGhpcy5TRUNTX1BFUl9EQVk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnISc6IG91dHB1dCArPSAoZGF0ZS50b0pEKCkgLSB0aGlzLlRJQ0tTX0VQT0NIKSAqIHRoaXMuVElDS1NfUEVSX0RBWTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRcdFx0XHRpZiAoZG91YmxlZChcIidcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSxcblxuXHRcdC8qKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXG5cdFx0XHRTZWUgPGEgaHJlZj1cIiNmb3JtYXREYXRlXCI+PGNvZGU+Zm9ybWF0RGF0ZTwvY29kZT48L2E+IGZvciB0aGUgcG9zc2libGUgZm9ybWF0cywgcGx1czpcblx0XHRcdDx1bD5cblx0XHRcdDxsaT4qIC0gaWdub3JlIHJlc3Qgb2Ygc3RyaW5nPC9saT5cblx0XHRcdDwvdWw+XG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0gZm9ybWF0IHtzdHJpbmd9IFRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIGRhdGUgKCcnIGZvciBkZWZhdWx0IGNhbGVuZGFyIGZvcm1hdCkuXG5cdFx0XHRAcGFyYW0gdmFsdWUge3N0cmluZ30gVGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdC5cblx0XHRcdEBwYXJhbSBbc2V0dGluZ3NdIHtvYmplY3R9IEFkZGl0aW9uYWwgb3B0aW9ucyB3aG9zZSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdFx0XHRAcHJvcGVydHkgW3Nob3J0WWVhckN1dG9mZl0ge251bWJlcn0gVGhlIGN1dG9mZiB5ZWFyIGZvciBkZXRlcm1pbmluZyB0aGUgY2VudHVyeS5cblx0XHRcdEBwcm9wZXJ0eSBbZGF5TmFtZXNTaG9ydF0ge3N0cmluZ1tdfSBBYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheS5cblx0XHRcdEBwcm9wZXJ0eSBbZGF5TmFtZXNdIHtzdHJpbmdbXX0gTmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoTmFtZXNTaG9ydF0ge3N0cmluZ1tdfSBBYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzLlxuXHRcdFx0QHByb3BlcnR5IFttb250aE5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBtb250aHMuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGV4dHJhY3RlZCBkYXRlIHZhbHVlIG9yIDxjb2RlPm51bGw8L2NvZGU+IGlmIHZhbHVlIGlzIGJsYW5rLlxuXHRcdFx0QHRocm93cyBFcnJvcnMgaWYgdGhlIGZvcm1hdCBhbmQvb3IgdmFsdWUgYXJlIG1pc3NpbmcsXG5cdFx0XHRcdFx0aWYgdGhlIHZhbHVlIGRvZXNuJ3QgbWF0Y2ggdGhlIGZvcm1hdCwgb3IgaWYgdGhlIGRhdGUgaXMgaW52YWxpZC4gKi9cblx0XHRwYXJzZURhdGU6IGZ1bmN0aW9uKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyAkLmNhbGVuZGFycy5sb2NhbC5pbnZhbGlkQXJndW1lbnRzIHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10uaW52YWxpZEFyZ3VtZW50cztcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgKyAnJyk7XG5cdFx0XHRpZiAodmFsdWUgPT09ICcnKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Zm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMubG9jYWwuZGF0ZUZvcm1hdDtcblx0XHRcdHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG5cdFx0XHR2YXIgc2hvcnRZZWFyQ3V0b2ZmID0gc2V0dGluZ3Muc2hvcnRZZWFyQ3V0b2ZmIHx8IHRoaXMuc2hvcnRZZWFyQ3V0b2ZmO1xuXHRcdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT09ICdzdHJpbmcnID8gc2hvcnRZZWFyQ3V0b2ZmIDpcblx0XHRcdFx0dGhpcy50b2RheSgpLnllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZiwgMTApKTtcblx0XHRcdHZhciBkYXlOYW1lc1Nob3J0ID0gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCB8fCB0aGlzLmxvY2FsLmRheU5hbWVzU2hvcnQ7XG5cdFx0XHR2YXIgZGF5TmFtZXMgPSBzZXR0aW5ncy5kYXlOYW1lcyB8fCB0aGlzLmxvY2FsLmRheU5hbWVzO1xuXHRcdFx0dmFyIG1vbnRoTmFtZXNTaG9ydCA9IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCB8fCB0aGlzLmxvY2FsLm1vbnRoTmFtZXNTaG9ydDtcblx0XHRcdHZhciBtb250aE5hbWVzID0gc2V0dGluZ3MubW9udGhOYW1lcyB8fCB0aGlzLmxvY2FsLm1vbnRoTmFtZXM7XG5cdFx0XHR2YXIgamQgPSAtMTtcblx0XHRcdHZhciB5ZWFyID0gLTE7XG5cdFx0XHR2YXIgbW9udGggPSAtMTtcblx0XHRcdHZhciBkYXkgPSAtMTtcblx0XHRcdHZhciBkb3kgPSAtMTtcblx0XHRcdHZhciBzaG9ydFllYXIgPSBmYWxzZTtcblx0XHRcdHZhciBsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHR2YXIgZG91YmxlZCA9IGZ1bmN0aW9uKG1hdGNoLCBzdGVwKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gMTtcblx0XHRcdFx0d2hpbGUgKGlGb3JtYXQgKyBtYXRjaGVzIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyBtYXRjaGVzKSA9PT0gbWF0Y2gpIHtcblx0XHRcdFx0XHRtYXRjaGVzKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0aUZvcm1hdCArPSBtYXRjaGVzIC0gMTtcblx0XHRcdFx0cmV0dXJuIE1hdGguZmxvb3IobWF0Y2hlcyAvIChzdGVwIHx8IDEpKSA+IDE7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdHZhciBnZXROdW1iZXIgPSBmdW5jdGlvbihtYXRjaCwgc3RlcCkge1xuXHRcdFx0XHR2YXIgaXNEb3VibGVkID0gZG91YmxlZChtYXRjaCwgc3RlcCk7XG5cdFx0XHRcdHZhciBzaXplID0gWzIsIDMsIGlzRG91YmxlZCA/IDQgOiAyLCBpc0RvdWJsZWQgPyA0IDogMiwgMTAsIDExLCAyMF1bJ295WUpAIScuaW5kZXhPZihtYXRjaCkgKyAxXTtcblx0XHRcdFx0dmFyIGRpZ2l0cyA9IG5ldyBSZWdFeHAoJ14tP1xcXFxkezEsJyArIHNpemUgKyAnfScpO1xuXHRcdFx0XHR2YXIgbnVtID0gdmFsdWUuc3Vic3RyaW5nKGlWYWx1ZSkubWF0Y2goZGlnaXRzKTtcblx0XHRcdFx0aWYgKCFudW0pIHtcblx0XHRcdFx0XHR0aHJvdyAoJC5jYWxlbmRhcnMubG9jYWwubWlzc2luZ051bWJlckF0IHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10ubWlzc2luZ051bWJlckF0KS5cblx0XHRcdFx0XHRcdHJlcGxhY2UoL1xcezBcXH0vLCBpVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlWYWx1ZSArPSBudW1bMF0ubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQobnVtWzBdLCAxMCk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gRXh0cmFjdCBhIG5hbWUgZnJvbSB0aGUgc3RyaW5nIHZhbHVlIGFuZCBjb252ZXJ0IHRvIGFuIGluZGV4XG5cdFx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzO1xuXHRcdFx0dmFyIGdldE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzLCBzdGVwKSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IChkb3VibGVkKG1hdGNoLCBzdGVwKSA/IGxvbmdOYW1lcyA6IHNob3J0TmFtZXMpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWVzW2ldLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZXNbaV0udG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdFx0aVZhbHVlICs9IG5hbWVzW2ldLmxlbmd0aDtcblx0XHRcdFx0XHRcdHJldHVybiBpICsgY2FsZW5kYXIubWluTW9udGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC51bmtub3duTmFtZUF0IHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10udW5rbm93bk5hbWVBdCkuXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7MFxcfS8sIGlWYWx1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gQ29uZmlybSB0aGF0IGEgbGl0ZXJhbCBjaGFyYWN0ZXIgbWF0Y2hlcyB0aGUgc3RyaW5nIHZhbHVlXG5cdFx0XHR2YXIgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh2YWx1ZS5jaGFyQXQoaVZhbHVlKSAhPT0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdHRocm93ICgkLmNhbGVuZGFycy5sb2NhbC51bmV4cGVjdGVkTGl0ZXJhbEF0IHx8XG5cdFx0XHRcdFx0XHQkLmNhbGVuZGFycy5yZWdpb25hbE9wdGlvbnNbJyddLnVuZXhwZWN0ZWRMaXRlcmFsQXQpLnJlcGxhY2UoL1xcezBcXH0vLCBpVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlWYWx1ZSsrO1xuXHRcdFx0fTtcblx0XHRcdHZhciBpVmFsdWUgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcblx0XHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWRvdWJsZWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnZCc6IGRheSA9IGdldE51bWJlcignZCcpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0QnOiBnZXROYW1lKCdEJywgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ28nOiBkb3kgPSBnZXROdW1iZXIoJ28nKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd3JzogZ2V0TnVtYmVyKCd3Jyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbSc6IG1vbnRoID0gZ2V0TnVtYmVyKCdtJyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTSc6IG1vbnRoID0gZ2V0TmFtZSgnTScsIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAneSc6XG5cdFx0XHRcdFx0XHRcdHZhciBpU2F2ZSA9IGlGb3JtYXQ7XG5cdFx0XHRcdFx0XHRcdHNob3J0WWVhciA9ICFkb3VibGVkKCd5JywgMik7XG5cdFx0XHRcdFx0XHRcdGlGb3JtYXQgPSBpU2F2ZTtcblx0XHRcdFx0XHRcdFx0eWVhciA9IGdldE51bWJlcigneScsIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ1knOiB5ZWFyID0gZ2V0TnVtYmVyKCdZJywgMik7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnSic6XG5cdFx0XHRcdFx0XHRcdGpkID0gZ2V0TnVtYmVyKCdKJykgKyAwLjU7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZS5jaGFyQXQoaVZhbHVlKSA9PT0gJy4nKSB7XG5cdFx0XHRcdFx0XHRcdFx0aVZhbHVlKys7XG5cdFx0XHRcdFx0XHRcdFx0Z2V0TnVtYmVyKCdKJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdAJzogamQgPSBnZXROdW1iZXIoJ0AnKSAvIHRoaXMuU0VDU19QRVJfREFZICsgdGhpcy5VTklYX0VQT0NIOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJyEnOiBqZCA9IGdldE51bWJlcignIScpIC8gdGhpcy5USUNLU19QRVJfREFZICsgdGhpcy5USUNLU19FUE9DSDsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICcqJzogaVZhbHVlID0gdmFsdWUubGVuZ3RoOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRcdGlmIChkb3VibGVkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDogY2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRcdHRocm93ICQuY2FsZW5kYXJzLmxvY2FsLnVuZXhwZWN0ZWRUZXh0IHx8ICQuY2FsZW5kYXJzLnJlZ2lvbmFsT3B0aW9uc1snJ10udW5leHBlY3RlZFRleHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA9PT0gLTEpIHtcblx0XHRcdFx0eWVhciA9IHRoaXMudG9kYXkoKS55ZWFyKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh5ZWFyIDwgMTAwICYmIHNob3J0WWVhcikge1xuXHRcdFx0XHR5ZWFyICs9IChzaG9ydFllYXJDdXRvZmYgPT09IC0xID8gMTkwMCA6IHRoaXMudG9kYXkoKS55ZWFyKCkgLVxuXHRcdFx0XHRcdHRoaXMudG9kYXkoKS55ZWFyKCkgJSAxMDAgLSAoeWVhciA8PSBzaG9ydFllYXJDdXRvZmYgPyAwIDogMTAwKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG95ID4gLTEpIHtcblx0XHRcdFx0bW9udGggPSAxO1xuXHRcdFx0XHRkYXkgPSBkb3k7XG5cdFx0XHRcdGZvciAodmFyIGRpbSA9IHRoaXMuZGF5c0luTW9udGgoeWVhciwgbW9udGgpOyBkYXkgPiBkaW07IGRpbSA9IHRoaXMuZGF5c0luTW9udGgoeWVhciwgbW9udGgpKSB7XG5cdFx0XHRcdFx0bW9udGgrKztcblx0XHRcdFx0XHRkYXkgLT0gZGltO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKGpkID4gLTEgPyB0aGlzLmZyb21KRChqZCkgOiB0aGlzLm5ld0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xuXHRcdH0sXG5cblx0XHQvKiogQSBkYXRlIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gZXhhY3QgdmFsdWUgb3IgYSByZWxhdGl2ZSBvbmUuXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5wbHVzLmpzPC9jb2RlPiBtb2R1bGUuXG5cdFx0XHRAbWVtYmVyb2YgQmFzZUNhbGVuZGFyXG5cdFx0XHRAcGFyYW0gZGF0ZVNwZWMge0NEYXRlfG51bWJlcnxzdHJpbmd9IFRoZSBkYXRlIGFzIGFuIG9iamVjdCBvciBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdCBvclxuXHRcdFx0XHRcdGFuIG9mZnNldCAtIG51bWVyaWMgZGF5cyBmcm9tIHRvZGF5LCBvciBzdHJpbmcgYW1vdW50cyBhbmQgcGVyaW9kcywgZS5nLiAnKzFtICsydycuXG5cdFx0XHRAcGFyYW0gZGVmYXVsdERhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byB1c2UgaWYgbm8gb3RoZXIgc3VwcGxpZWQsIG1heSBiZSA8Y29kZT5udWxsPC9jb2RlPi5cblx0XHRcdEBwYXJhbSBjdXJyZW50RGF0ZSB7Q0RhdGV9IFRoZSBjdXJyZW50IGRhdGUgYXMgYSBwb3NzaWJsZSBiYXNpcyBmb3IgcmVsYXRpdmUgZGF0ZXMsXG5cdFx0XHRcdFx0aWYgPGNvZGU+bnVsbDwvY29kZT4gdG9kYXkgaXMgdXNlZCAob3B0aW9uYWwpXG5cdFx0XHRAcGFyYW0gW2RhdGVGb3JtYXRdIHtzdHJpbmd9IFRoZSBleHBlY3RlZCBkYXRlIGZvcm1hdCAtIHNlZSA8YSBocmVmPVwiI2Zvcm1hdERhdGVcIj48Y29kZT5mb3JtYXREYXRlPC9jb2RlPjwvYT4uXG5cdFx0XHRAcGFyYW0gW3NldHRpbmdzXSB7b2JqZWN0fSBBZGRpdGlvbmFsIG9wdGlvbnMgd2hvc2UgYXR0cmlidXRlcyBpbmNsdWRlOlxuXHRcdFx0QHByb3BlcnR5IFtzaG9ydFllYXJDdXRvZmZdIHtudW1iZXJ9IFRoZSBjdXRvZmYgeWVhciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGNlbnR1cnkuXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkuXG5cdFx0XHRAcHJvcGVydHkgW2RheU5hbWVzXSB7c3RyaW5nW119IE5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5LlxuXHRcdFx0QHByb3BlcnR5IFttb250aE5hbWVzU2hvcnRdIHtzdHJpbmdbXX0gQWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocy5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhOYW1lc10ge3N0cmluZ1tdfSBOYW1lcyBvZiB0aGUgbW9udGhzLlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBkZWNvZGVkIGRhdGUuICovXG5cdFx0ZGV0ZXJtaW5lRGF0ZTogZnVuY3Rpb24oZGF0ZVNwZWMsIGRlZmF1bHREYXRlLCBjdXJyZW50RGF0ZSwgZGF0ZUZvcm1hdCwgc2V0dGluZ3MpIHtcblx0XHRcdGlmIChjdXJyZW50RGF0ZSAmJiB0eXBlb2YgY3VycmVudERhdGUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHNldHRpbmdzID0gZGF0ZUZvcm1hdDtcblx0XHRcdFx0ZGF0ZUZvcm1hdCA9IGN1cnJlbnREYXRlO1xuXHRcdFx0XHRjdXJyZW50RGF0ZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGRhdGVGb3JtYXQgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHNldHRpbmdzID0gZGF0ZUZvcm1hdDtcblx0XHRcdFx0ZGF0ZUZvcm1hdCA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNhbGVuZGFyID0gdGhpcztcblx0XHRcdHZhciBvZmZzZXRTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gY2FsZW5kYXIucGFyc2VEYXRlKGRhdGVGb3JtYXQsIG9mZnNldCwgc2V0dGluZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly8gSWdub3JlXG5cdFx0XHRcdH1cblx0XHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHZhciBkYXRlID0gKG9mZnNldC5tYXRjaCgvXmMvKSAmJiBjdXJyZW50RGF0ZSA/XG5cdFx0XHRcdFx0Y3VycmVudERhdGUubmV3RGF0ZSgpIDogbnVsbCkgfHwgY2FsZW5kYXIudG9kYXkoKTtcblx0XHRcdFx0dmFyIHBhdHRlcm4gPSAvKFsrLV0/WzAtOV0rKVxccyooZHx3fG18eSk/L2c7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cdFx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0ZGF0ZS5hZGQocGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLCBtYXRjaGVzWzJdIHx8ICdkJyk7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkYXRlO1xuXHRcdFx0fTtcblx0XHRcdGRlZmF1bHREYXRlID0gKGRlZmF1bHREYXRlID8gZGVmYXVsdERhdGUubmV3RGF0ZSgpIDogbnVsbCk7XG5cdFx0XHRkYXRlU3BlYyA9IChkYXRlU3BlYyA9PSBudWxsID8gZGVmYXVsdERhdGUgOlxuXHRcdFx0XHQodHlwZW9mIGRhdGVTcGVjID09PSAnc3RyaW5nJyA/IG9mZnNldFN0cmluZyhkYXRlU3BlYykgOiAodHlwZW9mIGRhdGVTcGVjID09PSAnbnVtYmVyJyA/XG5cdFx0XHRcdChpc05hTihkYXRlU3BlYykgfHwgZGF0ZVNwZWMgPT09IEluZmluaXR5IHx8IGRhdGVTcGVjID09PSAtSW5maW5pdHkgPyBkZWZhdWx0RGF0ZSA6XG5cdFx0XHRcdGNhbGVuZGFyLnRvZGF5KCkuYWRkKGRhdGVTcGVjLCAnZCcpKSA6IGNhbGVuZGFyLm5ld0RhdGUoZGF0ZVNwZWMpKSkpO1xuXHRcdFx0cmV0dXJuIGRhdGVTcGVjO1xuXHRcdH1cblx0fSk7XG5cbn0pKGpRdWVyeSk7XG4vKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXG4gICBDYWxlbmRhcnMgZGF0ZSBwaWNrZXIgZm9yIGpRdWVyeSB2Mi4wLjEuXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEF1Z3VzdCAyMDA5LlxuICAgQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvbGljZW5jZS5odG1sKSBsaWNlbnNlLiBcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xuXG4oZnVuY3Rpb24oJCkgeyAvLyBIaWRlIHNjb3BlLCBubyAkIGNvbmZsaWN0XG5cblx0dmFyIHBsdWdpbk5hbWUgPSAnY2FsZW5kYXJzUGlja2VyJztcblxuXG5cdC8qKiBDcmVhdGUgdGhlIGNhbGVuZGFycyBkYXRlcGlja2VyIHBsdWdpbi5cblx0XHQ8cD5TZXRzIGFuIGlucHV0IGZpZWxkIHRvIHBvcHVwIGEgY2FsZW5kYXIgZm9yIGRhdGUgZW50cnksXG5cdFx0XHRvciBhIDxjb2RlPmRpdjwvY29kZT4gb3IgPGNvZGU+c3BhbjwvY29kZT4gdG8gc2hvdyBhbiBpbmxpbmUgY2FsZW5kYXIuPC9wPlxuXHRcdDxwPkV4cGVjdHMgSFRNTCBsaWtlOjwvcD5cblx0XHQ8cHJlPiZsdDtpbnB1dCB0eXBlPVwidGV4dFwiPiBvciAmbHQ7ZGl2PiZsdDsvZGl2PjwvcHJlPlxuXHRcdDxwPlByb3ZpZGUgaW5saW5lIGNvbmZpZ3VyYXRpb24gbGlrZTo8L3A+XG5cdFx0PHByZT4mbHQ7aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWNhbGVuZGFyc1BpY2tlcj1cIm5hbWU6ICd2YWx1ZSdcIi8+PC9wcmU+XG5cdCBcdEBjbGFzcyBDYWxlbmRhcnNQaWNrZXJcblx0XHRAYXVnbWVudHMgSlFQbHVnaW5cblx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5jYWxlbmRhcnNQaWNrZXIoKVxuICQoc2VsZWN0b3IpLmNhbGVuZGFyc1BpY2tlcih7bWluRGF0ZTogMCwgbWF4RGF0ZTogJysxbSArMXcnfSkgKi9cblx0JC5KUVBsdWdpbi5jcmVhdGVQbHVnaW4oe1xuXHRcblx0XHQvKiogVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXIgKi9cblx0XHRuYW1lOiBwbHVnaW5OYW1lLFxuXHRcdFxuXHRcdC8qKiBEZWZhdWx0IHRlbXBsYXRlIGZvciBnZW5lcmF0aW5nIGEgZGF0ZXBpY2tlci5cblx0XHRcdEluc2VydCBhbnl3aGVyZTpcblx0XHRcdDx1bD5cblx0XHRcdDxsaT4ne2wxMG46bmFtZX0nIHRvIGluc2VydCBsb2NhbGlzZWQgdmFsdWUgZm9yIG5hbWUsPC9saT5cblx0XHRcdDxsaT4ne2xpbms6bmFtZX0nIHRvIGluc2VydCBhIGxpbmsgdHJpZ2dlciBmb3IgY29tbWFuZCBuYW1lLDwvbGk+XG5cdFx0XHQ8bGk+J3tidXR0b246bmFtZX0nIHRvIGluc2VydCBhIGJ1dHRvbiB0cmlnZ2VyIGZvciBjb21tYW5kIG5hbWUsPC9saT5cblx0XHRcdDxsaT4ne3BvcHVwOnN0YXJ0fS4uLntwb3B1cDplbmR9JyB0byBtYXJrIGEgc2VjdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcG9wdXAgZGF0ZXBpY2tlciBvbmx5LDwvbGk+XG5cdFx0XHQ8bGk+J3tpbmxpbmU6c3RhcnR9Li4ue2lubGluZTplbmR9JyB0byBtYXJrIGEgc2VjdGlvbiBmb3IgaW5jbHVzaW9uIGluIGFuIGlubGluZSBkYXRlcGlja2VyIG9ubHkuPC9saT5cblx0XHRcdDwvdWw+XG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJvcGVydHkgcGlja2VyIHtzdHJpbmd9IE92ZXJhbGwgc3RydWN0dXJlOiAne21vbnRoc30nIHRvIGluc2VydCBjYWxlbmRhciBtb250aHMuXG5cdFx0XHRAcHJvcGVydHkgbW9udGhSb3cge3N0cmluZ30gT25lIHJvdyBvZiBtb250aHM6ICd7bW9udGhzfScgdG8gaW5zZXJ0IGNhbGVuZGFyIG1vbnRocy5cblx0XHRcdEBwcm9wZXJ0eSBtb250aCB7c3RyaW5nfSBBIHNpbmdsZSBtb250aDogJ3ttb250aEhlYWRlcjxlbT46ZGF0ZUZvcm1hdDwvZW0+fScgdG8gaW5zZXJ0IHRoZSBtb250aCBoZWFkZXIgLVxuXHRcdFx0XHRcdFx0PGVtPmRhdGVGb3JtYXQ8L2VtPiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ01NIHl5eXknLFxuXHRcdFx0XHRcdFx0J3t3ZWVrSGVhZGVyfScgdG8gaW5zZXJ0IGEgd2VlayBoZWFkZXIsICd7d2Vla3N9JyB0byBpbnNlcnQgdGhlIG1vbnRoJ3Mgd2Vla3MuXG5cdFx0XHRAcHJvcGVydHkgd2Vla0hlYWRlciB7c3RyaW5nfSBBIHdlZWsgaGVhZGVyOiAne2RheXN9JyB0byBpbnNlcnQgaW5kaXZpZHVhbCBkYXkgbmFtZXMuXG5cdFx0XHRAcHJvcGVydHkgZGF5SGVhZGVyIHtzdHJpbmd9IEluZGl2aWR1YWwgZGF5IGhlYWRlcjogJ3tkYXl9JyB0byBpbnNlcnQgZGF5IG5hbWUuXG5cdFx0XHRAcHJvcGVydHkgd2VlayB7c3RyaW5nfSBPbmUgd2VlayBvZiB0aGUgbW9udGg6ICd7ZGF5c30nIHRvIGluc2VydCB0aGUgd2VlaydzIGRheXMsXG5cdFx0XHRcdFx0XHQne3dlZWtPZlllYXJ9JyB0byBpbnNlcnQgd2VlayBvZiB5ZWFyLlxuXHRcdFx0QHByb3BlcnR5IGRheSB7c3RyaW5nfSBBbiBpbmRpdmlkdWFsIGRheTogJ3tkYXl9JyB0byBpbnNlcnQgZGF5IHZhbHVlLlxuXHRcdFx0QHByb3BlcnR5IG1vbnRoU2VsZWN0b3Ige3N0cmluZ30galF1ZXJ5IHNlbGVjdG9yLCByZWxhdGl2ZSB0byBwaWNrZXIsIGZvciBhIHNpbmdsZSBtb250aC5cblx0XHRcdEBwcm9wZXJ0eSBkYXlTZWxlY3RvciB7c3RyaW5nfSBqUXVlcnkgc2VsZWN0b3IsIHJlbGF0aXZlIHRvIHBpY2tlciwgZm9yIGluZGl2aWR1YWwgZGF5cy5cblx0XHRcdEBwcm9wZXJ0eSBydGxDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgcmlnaHQtdG8tbGVmdCAoUlRMKSBsYW5ndWFnZXMuXG5cdFx0XHRAcHJvcGVydHkgbXVsdGlDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgbXVsdGktbW9udGggZGF0ZXBpY2tlcnMuXG5cdFx0XHRAcHJvcGVydHkgZGVmYXVsdENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBzZWxlY3RhYmxlIGRhdGVzLlxuXHRcdFx0QHByb3BlcnR5IHNlbGVjdGVkQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlcy5cblx0XHRcdEBwcm9wZXJ0eSBoaWdobGlnaHRlZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBoaWdobGlnaHRlZCBkYXRlcy5cblx0XHRcdEBwcm9wZXJ0eSB0b2RheUNsYXNzIHtzdHJpbmd9IENsYXNzIGZvciB0b2RheS5cblx0XHRcdEBwcm9wZXJ0eSBvdGhlck1vbnRoQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGRheXMgZnJvbSBvdGhlciBtb250aHMuXG5cdFx0XHRAcHJvcGVydHkgd2Vla2VuZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBkYXlzIG9uIHdlZWtlbmRzLlxuXHRcdFx0QHByb3BlcnR5IGNvbW1hbmRDbGFzcyB7c3RyaW5nfSBDbGFzcyBwcmVmaXggZm9yIGNvbW1hbmRzLlxuXHRcdFx0QHByb3BlcnR5IGNvbW1hbmRCdXR0b25DbGFzcyB7c3RyaW5nfSBFeHRyYSBjbGFzcyhlcykgZm9yIGNvbW1hbmRzIHRoYXQgYXJlIGJ1dHRvbnMuXG5cdFx0XHRAcHJvcGVydHkgY29tbWFuZExpbmtDbGFzcyB7c3RyaW5nfSBFeHRyYSBjbGFzcyhlcykgZm9yIGNvbW1hbmRzIHRoYXQgYXJlIGxpbmtzLlxuXHRcdFx0QHByb3BlcnR5IGRpc2FibGVkQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIGRpc2FibGVkIGNvbW1hbmRzLiAqL1xuXHRcdGRlZmF1bHRSZW5kZXJlcjoge1xuXHRcdFx0cGlja2VyOiAnPGRpdiBjbGFzcz1cImNhbGVuZGFyc1wiPicgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtbmF2XCI+e2xpbms6cHJldn17bGluazp0b2RheX17bGluazpuZXh0fTwvZGl2Pnttb250aHN9JyArXG5cdFx0XHQne3BvcHVwOnN0YXJ0fTxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtY3RybFwiPntsaW5rOmNsZWFyfXtsaW5rOmNsb3NlfTwvZGl2Pntwb3B1cDplbmR9JyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImNhbGVuZGFycy1jbGVhci1maXhcIj48L2Rpdj48L2Rpdj4nLFxuXHRcdFx0bW9udGhSb3c6ICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLW1vbnRoLXJvd1wiPnttb250aHN9PC9kaXY+Jyxcblx0XHRcdG1vbnRoOiAnPGRpdiBjbGFzcz1cImNhbGVuZGFycy1tb250aFwiPjxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtbW9udGgtaGVhZGVyXCI+e21vbnRoSGVhZGVyfTwvZGl2PicgK1xuXHRcdFx0Jzx0YWJsZT48dGhlYWQ+e3dlZWtIZWFkZXJ9PC90aGVhZD48dGJvZHk+e3dlZWtzfTwvdGJvZHk+PC90YWJsZT48L2Rpdj4nLFxuXHRcdFx0d2Vla0hlYWRlcjogJzx0cj57ZGF5c308L3RyPicsXG5cdFx0XHRkYXlIZWFkZXI6ICc8dGg+e2RheX08L3RoPicsXG5cdFx0XHR3ZWVrOiAnPHRyPntkYXlzfTwvdHI+Jyxcblx0XHRcdGRheTogJzx0ZD57ZGF5fTwvdGQ+Jyxcblx0XHRcdG1vbnRoU2VsZWN0b3I6ICcuY2FsZW5kYXJzLW1vbnRoJyxcblx0XHRcdGRheVNlbGVjdG9yOiAndGQnLFxuXHRcdFx0cnRsQ2xhc3M6ICdjYWxlbmRhcnMtcnRsJyxcblx0XHRcdG11bHRpQ2xhc3M6ICdjYWxlbmRhcnMtbXVsdGknLFxuXHRcdFx0ZGVmYXVsdENsYXNzOiAnJyxcblx0XHRcdHNlbGVjdGVkQ2xhc3M6ICdjYWxlbmRhcnMtc2VsZWN0ZWQnLFxuXHRcdFx0aGlnaGxpZ2h0ZWRDbGFzczogJ2NhbGVuZGFycy1oaWdobGlnaHQnLFxuXHRcdFx0dG9kYXlDbGFzczogJ2NhbGVuZGFycy10b2RheScsXG5cdFx0XHRvdGhlck1vbnRoQ2xhc3M6ICdjYWxlbmRhcnMtb3RoZXItbW9udGgnLFxuXHRcdFx0d2Vla2VuZENsYXNzOiAnY2FsZW5kYXJzLXdlZWtlbmQnLFxuXHRcdFx0Y29tbWFuZENsYXNzOiAnY2FsZW5kYXJzLWNtZCcsXG5cdFx0XHRjb21tYW5kQnV0dG9uQ2xhc3M6ICcnLFxuXHRcdFx0Y29tbWFuZExpbmtDbGFzczogJycsXG5cdFx0XHRkaXNhYmxlZENsYXNzOiAnY2FsZW5kYXJzLWRpc2FibGVkJ1xuXHRcdH0sXG5cdFxuXHRcdC8qKiBDb21tYW5kIGFjdGlvbnMgdGhhdCBtYXkgYmUgYWRkZWQgdG8gYSBsYXlvdXQgYnkgbmFtZS5cblx0XHRcdDx1bD5cblx0XHRcdDxsaT5wcmV2IC0gU2hvdyB0aGUgcHJldmlvdXMgbW9udGggKGJhc2VkIG9uIDxjb2RlPm1vbnRoc1RvU3RlcDwvY29kZT4gb3B0aW9uKSAtIDxlbT5QYWdlVXA8L2VtPjwvbGk+XG5cdFx0XHQ8bGk+cHJldkp1bXAgLSBTaG93IHRoZSBwcmV2aW91cyB5ZWFyIChiYXNlZCBvbiA8Y29kZT5tb250aHNUb0p1bXA8L2NvZGU+IG9wdGlvbikgLSA8ZW0+Q3RybCtQYWdlVXA8L2VtPjwvbGk+XG5cdFx0XHQ8bGk+bmV4dCAtIFNob3cgdGhlIG5leHQgbW9udGggKGJhc2VkIG9uIDxjb2RlPm1vbnRoc1RvU3RlcDwvY29kZT4gb3B0aW9uKSAtIDxlbT5QYWdlRG93bjwvZW0+PC9saT5cblx0XHRcdDxsaT5uZXh0SnVtcCAtIFNob3cgdGhlIG5leHQgeWVhciAoYmFzZWQgb24gPGNvZGU+bW9udGhzVG9KdW1wPC9jb2RlPiBvcHRpb24pIC0gPGVtPkN0cmwrUGFnZURvd248L2VtPjwvbGk+XG5cdFx0XHQ8bGk+Y3VycmVudCAtIFNob3cgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBtb250aCBvciB0b2RheSdzIGlmIG5vbmUgc2VsZWN0ZWQgLSA8ZW0+Q3RybCtIb21lPC9lbT48L2xpPlxuXHRcdFx0PGxpPnRvZGF5IC0gU2hvdyB0b2RheSdzIG1vbnRoIC0gPGVtPkN0cmwrSG9tZTwvZW0+PC9saT5cblx0XHRcdDxsaT5jbGVhciAtIEVyYXNlIHRoZSBkYXRlIGFuZCBjbG9zZSB0aGUgZGF0ZXBpY2tlciBwb3B1cCAtIDxlbT5DdHJsK0VuZDwvZW0+PC9saT5cblx0XHRcdDxsaT5jbG9zZSAtIENsb3NlIHRoZSBkYXRlcGlja2VyIHBvcHVwIC0gPGVtPkVzYzwvZW0+PC9saT5cblx0XHRcdDxsaT5wcmV2V2VlayAtIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgcHJldmlvdXMgd2VlayAtIDxlbT5DdHJsK1VwPC9lbT48L2xpPlxuXHRcdFx0PGxpPnByZXZEYXkgLSBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIHByZXZpb3VzIGRheSAtIDxlbT5DdHJsK0xlZnQ8L2VtPjwvbGk+XG5cdFx0XHQ8bGk+bmV4dERheSAtIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgbmV4dCBkYXkgLSA8ZW0+Q3RybCtSaWdodDwvZW0+PC9saT5cblx0XHRcdDxsaT5uZXh0V2VlayAtIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgbmV4dCB3ZWVrIC0gPGVtPkN0cmwrRG93bjwvZW0+PC9saT5cblx0XHRcdDwvdWw+XG5cdFx0XHRUaGUgY29tbWFuZCBuYW1lIGlzIHRoZSBrZXkgbmFtZSBhbmQgaXMgdXNlZCB0byBhZGQgdGhlIGNvbW1hbmQgdG8gYSBsYXlvdXRcblx0XHRcdHdpdGggJ3tidXR0b246bmFtZX0nIG9yICd7bGluazpuYW1lfScuIEVhY2ggaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcy5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcm9wZXJ0eSB0ZXh0IHtzdHJpbmd9IFRoZSBmaWVsZCBpbiB0aGUgcmVnaW9uYWwgc2V0dGluZ3MgZm9yIHRoZSBkaXNwbGF5ZWQgdGV4dC5cblx0XHRcdEBwcm9wZXJ0eSBzdGF0dXMge3N0cmluZ30gVGhlIGZpZWxkIGluIHRoZSByZWdpb25hbCBzZXR0aW5ncyBmb3IgdGhlIHN0YXR1cyB0ZXh0LlxuXHRcdFx0QHByb3BlcnR5IGtleXN0cm9rZSB7b2JqZWN0fSBUaGUga2V5c3Ryb2tlIHRvIHRyaWdnZXIgdGhlIGFjdGlvbiwgd2l0aCBhdHRyaWJ1dGVzOlxuXHRcdFx0XHQ8Y29kZT5rZXlDb2RlPC9jb2RlPiB7bnVtYmVyfSB0aGUgY29kZSBmb3IgdGhlIGtleXN0cm9rZSxcblx0XHRcdFx0PGNvZGU+Y3RybEtleTwvY29kZT4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIDxlbT5DdHJsPC9lbT4gaXMgcmVxdWlyZWQsXG5cdFx0XHRcdDxjb2RlPmFsdEtleTwvY29kZT4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIDxlbT5BbHQ8L2VtPiBpcyByZXF1aXJlZCxcblx0XHRcdFx0PGNvZGU+c2hpZnRLZXk8L2NvZGU+IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8ZW0+U2hpZnQ8L2VtPiBpcyByZXF1aXJlZC5cblx0XHRcdEBwcm9wZXJ0eSBlbmFibGVkIHtDYWxlbmRhcnNQaWNrZXJDb21tYW5kRW5hYmxlZH0gVGhlIGZ1bmN0aW9uIHRoYXQgaW5kaWNhdGVzIHRoZSBjb21tYW5kIGlzIGVuYWJsZWQuXG5cdFx0XHRAcHJvcGVydHkgZGF0ZSB7Q2FsZW5kYXJzUGlja2VyQ29tbWFuZERhdGV9IFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGRhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYWN0aW9uLlxuXHRcdFx0QHByb3BlcnR5IGFjdGlvbiB7Q2FsZW5kYXJzUGlja2VyQ29tbWFuZEFjdGlvbn0gVGhlIGZ1bmN0aW9uIHRoYXQgaW1wbGVtZW50cyB0aGUgYWN0aW9uLiAqL1xuXHRcdGNvbW1hbmRzOiB7XG5cdFx0XHRwcmV2OiB7dGV4dDogJ3ByZXZUZXh0Jywgc3RhdHVzOiAncHJldlN0YXR1cycsIC8vIFByZXZpb3VzIG1vbnRoXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDMzfSwgLy8gUGFnZSB1cFxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKDEgLSBpbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KS5hZGQoLTEsICdkJykuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSk7IH0sXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0XHRhZGQoLWluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgodGhpcywgLWluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXApOyB9XG5cdFx0XHR9LFxuXHRcdFx0cHJldkp1bXA6IHt0ZXh0OiAncHJldkp1bXBUZXh0Jywgc3RhdHVzOiAncHJldkp1bXBTdGF0dXMnLCAvLyBQcmV2aW91cyB5ZWFyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDMzLCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIFBhZ2UgdXBcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cblx0XHRcdFx0XHRcdGFkZCgxIC0gaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuYWRkKC0xLCAnZCcpLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpOyB9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKC1pbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KTsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKHRoaXMsIC1pbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wKTsgfVxuXHRcdFx0fSxcblx0XHRcdG5leHQ6IHt0ZXh0OiAnbmV4dFRleHQnLCBzdGF0dXM6ICduZXh0U3RhdHVzJywgLy8gTmV4dCBtb250aFxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNH0sIC8vIFBhZ2UgZG93blxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSk7IH0sXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aCh0aGlzLCBpbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwKTsgfVxuXHRcdFx0fSxcblx0XHRcdG5leHRKdW1wOiB7dGV4dDogJ25leHRKdW1wVGV4dCcsIHN0YXR1czogJ25leHRKdW1wU3RhdHVzJywgLy8gTmV4dCB5ZWFyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM0LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIFBhZ2UgZG93blxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7XHR9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgodGhpcywgaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCk7IH1cblx0XHRcdH0sXG5cdFx0XHRjdXJyZW50OiB7dGV4dDogJ2N1cnJlbnRUZXh0Jywgc3RhdHVzOiAnY3VycmVudFN0YXR1cycsIC8vIEN1cnJlbnQgbW9udGhcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzYsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgSG9tZVxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XG5cdFx0XHRcdFx0dmFyIGN1ckRhdGUgPSBpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCk7XG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBjdXJEYXRlLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXG5cdFx0XHRcdFx0XHQoIW1heERhdGUgfHwgY3VyRGF0ZS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHJldHVybiBpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCk7IH0sXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBjdXJEYXRlID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpO1xuXHRcdFx0XHRcdHBsdWdpbi5zaG93TW9udGgodGhpcywgY3VyRGF0ZS55ZWFyKCksIGN1ckRhdGUubW9udGgoKSk7IH1cblx0XHRcdH0sXG5cdFx0XHR0b2RheToge3RleHQ6ICd0b2RheVRleHQnLCBzdGF0dXM6ICd0b2RheVN0YXR1cycsIC8vIFRvZGF5J3MgbW9udGhcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzYsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgSG9tZVxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcblx0XHRcdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKSAmJlxuXHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpOyB9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKTsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5zaG93TW9udGgodGhpcyk7IH1cblx0XHRcdH0sXG5cdFx0XHRjbGVhcjoge3RleHQ6ICdjbGVhclRleHQnLCBzdGF0dXM6ICdjbGVhclN0YXR1cycsIC8vIENsZWFyIHRoZSBkYXRlcGlja2VyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM1LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIEVuZFxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiB0cnVlOyB9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBudWxsOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNsZWFyKHRoaXMpOyB9XG5cdFx0XHR9LFxuXHRcdFx0Y2xvc2U6IHt0ZXh0OiAnY2xvc2VUZXh0Jywgc3RhdHVzOiAnY2xvc2VTdGF0dXMnLCAvLyBDbG9zZSB0aGUgZGF0ZXBpY2tlclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAyN30sIC8vIEVzY2FwZVxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiB0cnVlOyB9LFxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBudWxsOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmhpZGUodGhpcyk7IH1cblx0XHRcdH0sXG5cdFx0XHRwcmV2V2Vlazoge3RleHQ6ICdwcmV2V2Vla1RleHQnLCBzdGF0dXM6ICdwcmV2V2Vla1N0YXR1cycsIC8vIFByZXZpb3VzIHdlZWtcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMzgsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgVXBcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XG5cdFx0XHRcdFx0cmV0dXJuICghbWluRGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cblx0XHRcdFx0XHRcdGFkZCgtaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSwgJ2QnKS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0YWRkKC1pbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpLCAnZCcpOyB9LFxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNoYW5nZURheSh0aGlzLCAtaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSk7IH1cblx0XHRcdH0sXG5cdFx0XHRwcmV2RGF5OiB7dGV4dDogJ3ByZXZEYXlUZXh0Jywgc3RhdHVzOiAncHJldkRheVN0YXR1cycsIC8vIFByZXZpb3VzIGRheVxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNywgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBMZWZ0XG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKC0xLCAnZCcpLlxuXHRcdFx0XHRcdFx0Y29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSk7IH0sXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgtMSwgJ2QnKTsgfSxcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jaGFuZ2VEYXkodGhpcywgLTEpOyB9XG5cdFx0XHR9LFxuXHRcdFx0bmV4dERheToge3RleHQ6ICduZXh0RGF5VGV4dCcsIHN0YXR1czogJ25leHREYXlTdGF0dXMnLCAvLyBOZXh0IGRheVxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzOSwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBSaWdodFxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKDEsICdkJykuXG5cdFx0XHRcdFx0XHRjb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKDEsICdkJyk7IH0sXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2hhbmdlRGF5KHRoaXMsIDEpOyB9XG5cdFx0XHR9LFxuXHRcdFx0bmV4dFdlZWs6IHt0ZXh0OiAnbmV4dFdlZWtUZXh0Jywgc3RhdHVzOiAnbmV4dFdlZWtTdGF0dXMnLCAvLyBOZXh0IHdlZWtcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogNDAsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgRG93blxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSwgJ2QnKS5jb21wYXJlVG8obWF4RGF0ZSkgIT09ICsxKTsgfSxcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkgeyByZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXG5cdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCksICdkJyk7IH0sXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2hhbmdlRGF5KHRoaXMsIGluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCkpOyB9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgZW5hYmxlZC5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDb21tYW5kRW5hYmxlZFxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGNvbW1hbmQgaXMgZW5hYmxlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC5cblx0XHRcdEBleGFtcGxlIGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcblx0cmV0dXJuICEhaW5zdC5jdXJNaW5EYXRlKCk7XG4gfSAqL1xuXG5cdFx0LyoqIENhbGN1bGF0ZSB0aGUgcmVwcmVzZW50YXRpdmUgZGF0ZSBmb3IgYSBjb21tYW5kLlxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlckNvbW1hbmREYXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEByZXR1cm4ge0NEYXRlfSBBIGRhdGUgYXBwcm9wcmlhdGUgZm9yIHRoaXMgY29tbWFuZC5cblx0XHRcdEBleGFtcGxlIGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0cmV0dXJuIGluc3QuY3VyTWluRGF0ZSgpO1xuIH0gKi9cblxuXHRcdC8qKiBQZXJmb3JtIHRoZSBhY3Rpb24gZm9yIGEgY29tbWFuZC5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDb21tYW5kQWN0aW9uXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBleGFtcGxlIGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0JC5kYXRlcGljay5zZXREYXRlKGluc3QuZWxlbSwgaW5zdC5jdXJNaW5EYXRlKCkpO1xuIH0gKi9cblxuXHRcdC8qKiBDYWxjdWxhdGUgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZS5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDYWxjdWxhdGVXZWVrXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBkYXRlIHRvIGV2YWx1YXRlLlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgd2VlayBvZiB0aGUgeWVhci5cblx0XHRcdEBleGFtcGxlIGNhbGN1bGF0ZVdlZWs6IGZ1bmN0aW9uKGRhdGUpIHtcblx0dmFyIHN0YXJ0WWVhciA9ICQuY2FsZW5kYXJzLm5ld0RhdGUoZGF0ZS55ZWFyKCksIDEsIDEpO1xuXHRyZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5kYXlPZlllYXIoKSAtIHN0YXJ0WWVhci5kYXlPZlllYXIoKSkgLyA3KSArIDE7XG4gfSAqL1xuXG5cdFx0LyoqIFByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kaXZpZHVhbCBkYXRlIHNob3duIGluIHRoZSBjYWxlbmRhci5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPbkRhdGVcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gZXZhbHVhdGUuXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEluZm9ybWF0aW9uIGFib3V0IHRoYXQgZGF0ZSwgd2l0aCB0aGUgcHJvcGVydGllcyBhYm92ZS5cblx0XHRcdEBwcm9wZXJ0eSBzZWxlY3RhYmxlIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGRhdGUgY2FuIGJlIHNlbGVjdGVkLlxuXHRcdFx0QHByb3BlcnR5IGRhdGVDbGFzcyB7c3RyaW5nfSBDbGFzcyhlcykgdG8gYmUgYXBwbGllZCB0byB0aGUgZGF0ZS5cblx0XHRcdEBwcm9wZXJ0eSBjb250ZW50IHtzdHJpbmd9IFRoZSBkYXRlIGNlbGwgY29udGVudC5cblx0XHRcdEBwcm9wZXJ0eSB0b29sdGlwIHtzdHJpbmd9IEEgcG9wdXAgdG9vbHRpcCBmb3IgdGhlIGRhdGUuXG5cdFx0XHRAZXhhbXBsZSBvbkRhdGU6IGZ1bmN0aW9uKGRhdGUpIHtcblx0cmV0dXJuIHtzZWxlY3RhYmxlOiBkYXRlLmRheSgpID4gMCAmJiBkYXRlLmRheSgpICZsdDsgNSxcblx0XHRkYXRlQ2xhc3M6IGRhdGUuZGF5KCkgPT09IDQgPyAnbGFzdC1kYXknIDogJyd9O1xuIH0gKi9cblxuXHRcdC8qKiBVcGRhdGUgdGhlIGRhdGVwaWNrZXIgZGlzcGxheS5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPblNob3dcblx0XHRcdEBwYXJhbSBwaWNrZXIge2pRdWVyeX0gVGhlIGRhdGVwaWNrZXIgPGNvZGU+ZGl2PC9jb2RlPiB0byBiZSBzaG93bi5cblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QGV4YW1wbGUgb25TaG93OiBmdW5jdGlvbihwaWNrZXIsIGluc3QpIHtcblx0cGlja2VyLmFwcGVuZCgnJmx0O2J1dHRvbiB0eXBlPVwiYnV0dG9uXCI+SGkmbHQ7L2J1dHRvbj4nKS5cblx0XHRmaW5kKCdidXR0b246bGFzdCcpLmNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0YWxlcnQoJ0hpIScpO1xuXHRcdH0pO1xuIH0gKi9cblxuXHRcdC8qKiBSZWFjdCB0byBuYXZpZ2F0aW5nIHRocm91Z2ggdGhlIG1vbnRocy95ZWFycy5cblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPbkNoYW5nZU1vbnRoWWVhclxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIG5ldyB5ZWFyLlxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBuZXcgbW9udGggKDEgdG8gMTIpLlxuXHRcdFx0QGV4YW1wbGUgb25DaGFuZ2VNb250aFllYXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdGFsZXJ0KCdOb3cgaW4gJyArIG1vbnRoICsgJy8nICsgeWVhcik7XG4gfSAqL1xuXHRcdFx0XG5cdFx0LyoqIERhdGVwaWNrZXIgb24gc2VsZWN0IGNhbGxiYWNrLlxuXHRcdFx0VHJpZ2dlcmVkIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkLlxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlck9uU2VsZWN0XG5cdFx0XHRAcGFyYW0gZGF0ZXMge0NEYXRlW119IFRoZSBzZWxlY3RlZCBkYXRlKHMpLlxuXHRcdFx0QGV4YW1wbGUgb25TZWxlY3Q6IGZ1bmN0aW9uKGRhdGVzKSB7XG4gXHRhbGVydCgnU2VsZWN0ZWQgJyArIGRhdGVzKTtcbiB9ICovXG5cdFx0XHRcblx0XHQvKiogRGF0ZXBpY2tlciBvbiBjbG9zZSBjYWxsYmFjay5cblx0XHRcdFRyaWdnZXJlZCB3aGVuIGEgcG9wdXAgY2FsZW5kYXIgaXMgY2xvc2VkLlxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlck9uQ2xvc2Vcblx0XHRcdEBwYXJhbSBkYXRlcyB7Q0RhdGVbXX0gVGhlIHNlbGVjdGVkIGRhdGUocykuXG5cdFx0XHRAZXhhbXBsZSBvbkNsb3NlOiBmdW5jdGlvbihkYXRlcykge1xuIFx0YWxlcnQoJ1NlbGVjdGVkICcgKyBkYXRlcyk7XG4gfSAqL1xuXHRcdFxuXHRcdC8qKiBEZWZhdWx0IHNldHRpbmdzIGZvciB0aGUgcGx1Z2luLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByb3BlcnR5IFtjYWxlbmRhcj0kLmNhbGVuZGFycy5pbnN0YW5jZSgpXSB7Q2FsZW5kYXJ9IFRoZSBjYWxlbmRhciBmb3IgdGhpcyBkYXRlcGlja2VyLlxuXHRcdFx0QHByb3BlcnR5IFtwaWNrZXJDbGFzcz0nJ10ge3N0cmluZ30gQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGlzIGluc3RhbmNlIG9mIHRoZSBkYXRlcGlja2VyLlxuXHRcdFx0QHByb3BlcnR5IFtzaG93T25Gb2N1cz10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gZm9yIHBvcHVwIG9uIGZvY3VzLCA8Y29kZT5mYWxzZTwvY29kZT4gZm9yIG5vdC5cblx0XHRcdEBwcm9wZXJ0eSBbc2hvd1RyaWdnZXI9bnVsbF0ge3N0cmluZ3xFbGVtZW50fGpRdWVyeX0gRWxlbWVudCB0byBiZSBjbG9uZWQgZm9yIGEgdHJpZ2dlciwgPGNvZGU+bnVsbDwvY29kZT4gZm9yIG5vbmUuXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dBbmltPSdzaG93J10ge3N0cmluZ30gTmFtZSBvZiBqUXVlcnkgYW5pbWF0aW9uIGZvciBwb3B1cCwgJycgZm9yIG5vIGFuaW1hdGlvbi5cblx0XHRcdEBwcm9wZXJ0eSBbc2hvd09wdGlvbnM9bnVsbF0ge29iamVjdH0gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9ucy5cblx0XHRcdEBwcm9wZXJ0eSBbc2hvd1NwZWVkPSdub3JtYWwnXSB7c3RyaW5nfSBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmUuXG5cdFx0XHRAcHJvcGVydHkgW3BvcHVwQ29udGFpbmVyPW51bGxdIHtzdHJpbmd8RWxlbWVudHxqUXVlcnl9IFRoZSBlbGVtZW50IHRvIHdoaWNoIGEgcG9wdXAgY2FsZW5kYXIgaXMgYWRkZWQsIDxjb2RlPm51bGw8L2NvZGU+IGZvciBib2R5LlxuXHRcdFx0QHByb3BlcnR5IFthbGlnbm1lbnQ9J2JvdHRvbSddIHtzdHJpbmd9IEFsaWdubWVudCBvZiBwb3B1cCAtIHdpdGggbm9taW5hdGVkIGNvcm5lciBvZiBpbnB1dDpcblx0XHRcdFx0XHRcdCd0b3AnIG9yICdib3R0b20nIGFsaWducyBkZXBlbmRpbmcgb24gbGFuZ3VhZ2UgZGlyZWN0aW9uLFxuXHRcdFx0XHRcdFx0J3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCcuXG5cdFx0XHRAcHJvcGVydHkgW2ZpeGVkV2Vla3M9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBhbHdheXMgc2hvdyA2IHdlZWtzLCA8Y29kZT5mYWxzZTwvY29kZT4gdG8gb25seSBzaG93IGFzIG1hbnkgYXMgYXJlIG5lZWRlZC5cblx0XHRcdEBwcm9wZXJ0eSBbZmlyc3REYXk9bnVsbF0ge251bWJlcn0gRmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCAwID0gU3VuZGF5LCAxID0gTW9uZGF5LCBldGMuLCA8Y29kZT5udWxsPC9jb2RlPiBmb3IgPGNvZGU+Y2FsZW5kYXI8L2NvZGU+IGRlZmF1bHQuXG5cdFx0XHRAcHJvcGVydHkgW2NhbGN1bGF0ZVdlZWs9bnVsbF0ge0NhbGVuZGFyc1BpY2tlckNhbGN1bGF0ZVdlZWt9IENhbGN1bGF0ZSB3ZWVrIG9mIHRoZSB5ZWFyIGZyb20gYSBkYXRlLCA8Y29kZT5udWxsPC9jb2RlPiBmb3IgPGNvZGU+Y2FsZW5kYXI8L2NvZGU+IGRlZmF1bHQuXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoc1RvU2hvdz0xXSB7bnVtYmVyfG51bWJlcltdfSBIb3cgbWFueSBtb250aHMgdG8gc2hvdywgY29scyBvciBbcm93cywgY29sc10uXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoc09mZnNldD0wXSB7bnVtYmVyfSBIb3cgbWFueSBtb250aHMgdG8gb2Zmc2V0IHRoZSBwcmltYXJ5IG1vbnRoIGJ5O1xuXHRcdFx0XHRcdFx0bWF5IGJlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgZGF0ZSBhbmQgcmV0dXJucyB0aGUgb2Zmc2V0LlxuXHRcdFx0QHByb3BlcnR5IFttb250aHNUb1N0ZXA9MV0ge251bWJlcn0gSG93IG1hbnkgbW9udGhzIHRvIG1vdmUgd2hlbiBwcmV2L25leHQgY2xpY2tlZC5cblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhzVG9KdW1wPTEyXSB7bnVtYmVyfSBIb3cgbWFueSBtb250aHMgdG8gbW92ZSB3aGVuIGxhcmdlIHByZXYvbmV4dCBjbGlja2VkLlxuXHRcdFx0QHByb3BlcnR5IFt1c2VNb3VzZVdoZWVsPXRydWVdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byB1c2UgbW91c2V3aGVlbCBpZiBhdmFpbGFibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBuZXZlciB1c2UgaXQuXG5cdFx0XHRAcHJvcGVydHkgW2NoYW5nZU1vbnRoPXRydWVdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBjaGFuZ2UgbW9udGgveWVhciB2aWEgZHJvcC1kb3duLCA8Y29kZT5mYWxzZTwvY29kZT4gZm9yIG5hdmlnYXRpb24gb25seS5cblx0XHRcdEBwcm9wZXJ0eSBbeWVhclJhbmdlPSdjLTEwOmMrMTAnXSB7c3RyaW5nfSBSYW5nZSBvZiB5ZWFycyB0byBzaG93IGluIGRyb3AtZG93bjogJ2FueScgZm9yIGRpcmVjdCB0ZXh0IGVudHJ5XG5cdFx0XHRcdFx0XHRvciAnc3RhcnQ6ZW5kJywgd2hlcmUgc3RhcnQvZW5kIGFyZSAnKy1ubicgZm9yIHJlbGF0aXZlIHRvIHRvZGF5XG5cdFx0XHRcdFx0XHRvciAnYystbm4nIGZvciByZWxhdGl2ZSB0byB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGVcblx0XHRcdFx0XHRcdG9yICdubm5uJyBmb3IgYW4gYWJzb2x1dGUgeWVhci5cblx0XHRcdEBwcm9wZXJ0eSBbc2hvd090aGVyTW9udGhzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gc2hvdyBkYXRlcyBmcm9tIG90aGVyIG1vbnRocywgPGNvZGU+ZmFsc2U8L2NvZGU+IHRvIG5vdCBzaG93IHRoZW0uXG5cdFx0XHRAcHJvcGVydHkgW3NlbGVjdE90aGVyTW9udGhzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGZyb20gb3RoZXIgbW9udGhzIHRvby5cblx0XHRcdEBwcm9wZXJ0eSBbZGVmYXVsdERhdGU9bnVsbF0ge3N0cmluZ3xudW1iZXJ8Q0RhdGV9IERhdGUgdG8gc2hvdyBpZiBubyBvdGhlciBzZWxlY3RlZC5cblx0XHRcdEBwcm9wZXJ0eSBbc2VsZWN0RGVmYXVsdERhdGU9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBwcmUtc2VsZWN0IHRoZSBkZWZhdWx0IGRhdGUgaWYgbm8gb3RoZXIgaXMgY2hvc2VuLlxuXHRcdFx0QHByb3BlcnR5IFttaW5EYXRlPW51bGxdIHtzdHJpbmd8bnVtYmVyfENEYXRlfSBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuXG5cdFx0XHRAcHJvcGVydHkgW21heERhdGU9bnVsbF0ge3N0cmluZ3xudW1iZXJ8Q0RhdGV9IFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS5cblx0XHRcdEBwcm9wZXJ0eSBbZGF0ZUZvcm1hdD0nbW0vZGQveXl5eSddIHtzdHJpbmd9IEZvcm1hdCBmb3IgZGF0ZXMuXG5cdFx0XHRAcHJvcGVydHkgW2F1dG9TaXplPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gc2l6ZSB0aGUgaW5wdXQgZmllbGQgYWNjb3JkaW5nIHRvIHRoZSBkYXRlIGZvcm1hdC5cblx0XHRcdEBwcm9wZXJ0eSBbcmFuZ2VTZWxlY3Q9ZmFsc2VdIHtib29sZWFufSBBbGxvd3MgZm9yIHNlbGVjdGluZyBhIGRhdGUgcmFuZ2Ugb24gb25lIGRhdGUgcGlja2VyLlxuXHRcdFx0QHByb3BlcnR5IFtyYW5nZVNlcGFyYXRvcj0nIC0gJ10ge3N0cmluZ30gVGV4dCBiZXR3ZWVuIHR3byBkYXRlcyBpbiBhIHJhbmdlLlxuXHRcdFx0QHByb3BlcnR5IFttdWx0aVNlbGVjdD0wXSB7bnVtYmVyfSBNYXhpbXVtIG51bWJlciBvZiBzZWxlY3RhYmxlIGRhdGVzLCB6ZXJvIGZvciBzaW5nbGUgc2VsZWN0LlxuXHRcdFx0QHByb3BlcnR5IFttdWx0aVNlcGFyYXRvcj0nLCddIHtzdHJpbmd9IFRleHQgYmV0d2VlbiBtdWx0aXBsZSBkYXRlcy5cblx0XHRcdEBwcm9wZXJ0eSBbb25EYXRlPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPbkRhdGV9IENhbGxiYWNrIGFzIGEgZGF0ZSBpcyBhZGRlZCB0byB0aGUgZGF0ZXBpY2tlci5cblx0XHRcdEBwcm9wZXJ0eSBbb25TaG93PW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPblNob3d9IENhbGxiYWNrIGp1c3QgYmVmb3JlIGEgZGF0ZXBpY2tlciBpcyBzaG93bi5cblx0XHRcdEBwcm9wZXJ0eSBbb25DaGFuZ2VNb250aFllYXI9bnVsbF0ge0NhbGVuZGFyc1BpY2tlck9uQ2hhbmdlTW9udGhZZWFyfSBDYWxsYmFjayB3aGVuIGEgbmV3IG1vbnRoL3llYXIgaXMgc2VsZWN0ZWQuXG5cdFx0XHRAcHJvcGVydHkgW29uU2VsZWN0PW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPblNlbGVjdH0gQ2FsbGJhY2sgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWQuXG5cdFx0XHRAcHJvcGVydHkgW29uQ2xvc2U9bnVsbF0ge0NhbGVuZGFyc1BpY2tlck9uQ2xvc2V9IENhbGxiYWNrIHdoZW4gYSBkYXRlcGlja2VyIGlzIGNsb3NlZC5cblx0XHRcdEBwcm9wZXJ0eSBbYWx0RmllbGQ9bnVsbF0ge3N0cmluZ3xFbGVtZW50fGpRdWVyeX0gQWx0ZXJuYXRlIGZpZWxkIHRvIHVwZGF0ZSBpbiBzeW5jaCB3aXRoIHRoZSBkYXRlcGlja2VyLlxuXHRcdFx0QHByb3BlcnR5IFthbHRGb3JtYXQ9bnVsbF0ge3N0cmluZ30gRGF0ZSBmb3JtYXQgZm9yIGFsdGVybmF0ZSBmaWVsZCwgZGVmYXVsdHMgdG8gPGNvZGU+ZGF0ZUZvcm1hdDwvY29kZT4uXG5cdFx0XHRAcHJvcGVydHkgW2NvbnN0cmFpbklucHV0PXRydWVdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBjb25zdHJhaW4gdHlwZWQgaW5wdXQgdG8gPGNvZGU+ZGF0ZUZvcm1hdDwvY29kZT4gYWxsb3dlZCBjaGFyYWN0ZXJzLlxuXHRcdFx0QHByb3BlcnR5IFtjb21tYW5kc0FzRGF0ZUZvcm1hdD1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGFwcGx5XG5cdFx0XHRcdFx0XHQ8Y29kZT48YSBocmVmPVwiI2Zvcm1hdERhdGVcIj5mb3JtYXREYXRlPC9hPjwvY29kZT4gdG8gdGhlIGNvbW1hbmQgdGV4dHMuXG5cdFx0XHRAcHJvcGVydHkgW2NvbW1hbmRzPXRoaXMuY29tbWFuZHNdIHtvYmplY3R9IENvbW1hbmQgYWN0aW9ucyB0aGF0IG1heSBiZSBhZGRlZCB0byBhIGxheW91dCBieSBuYW1lLiAqL1xuXHRcdGRlZmF1bHRPcHRpb25zOiB7XG5cdFx0XHRjYWxlbmRhcjogJC5jYWxlbmRhcnMuaW5zdGFuY2UoKSxcblx0XHRcdHBpY2tlckNsYXNzOiAnJyxcblx0XHRcdHNob3dPbkZvY3VzOiB0cnVlLFxuXHRcdFx0c2hvd1RyaWdnZXI6IG51bGwsXG5cdFx0XHRzaG93QW5pbTogJ3Nob3cnLFxuXHRcdFx0c2hvd09wdGlvbnM6IHt9LFxuXHRcdFx0c2hvd1NwZWVkOiAnbm9ybWFsJyxcblx0XHRcdHBvcHVwQ29udGFpbmVyOiBudWxsLFxuXHRcdFx0YWxpZ25tZW50OiAnYm90dG9tJyxcblx0XHRcdGZpeGVkV2Vla3M6IGZhbHNlLFxuXHRcdFx0Zmlyc3REYXk6IG51bGwsXG5cdFx0XHRjYWxjdWxhdGVXZWVrOiBudWxsLFxuXHRcdFx0bW9udGhzVG9TaG93OiAxLFxuXHRcdFx0bW9udGhzT2Zmc2V0OiAwLFxuXHRcdFx0bW9udGhzVG9TdGVwOiAxLFxuXHRcdFx0bW9udGhzVG9KdW1wOiAxMixcblx0XHRcdHVzZU1vdXNlV2hlZWw6IHRydWUsXG5cdFx0XHRjaGFuZ2VNb250aDogdHJ1ZSxcblx0XHRcdHllYXJSYW5nZTogJ2MtMTA6YysxMCcsXG5cdFx0XHRzaG93T3RoZXJNb250aHM6IGZhbHNlLFxuXHRcdFx0c2VsZWN0T3RoZXJNb250aHM6IGZhbHNlLFxuXHRcdFx0ZGVmYXVsdERhdGU6IG51bGwsXG5cdFx0XHRzZWxlY3REZWZhdWx0RGF0ZTogZmFsc2UsXG5cdFx0XHRtaW5EYXRlOiBudWxsLFxuXHRcdFx0bWF4RGF0ZTogbnVsbCxcblx0XHRcdGRhdGVGb3JtYXQ6IG51bGwsXG5cdFx0XHRhdXRvU2l6ZTogZmFsc2UsXG5cdFx0XHRyYW5nZVNlbGVjdDogZmFsc2UsXG5cdFx0XHRyYW5nZVNlcGFyYXRvcjogJyAtICcsXG5cdFx0XHRtdWx0aVNlbGVjdDogMCxcblx0XHRcdG11bHRpU2VwYXJhdG9yOiAnLCcsXG5cdFx0XHRvbkRhdGU6IG51bGwsXG5cdFx0XHRvblNob3c6IG51bGwsXG5cdFx0XHRvbkNoYW5nZU1vbnRoWWVhcjogbnVsbCxcblx0XHRcdG9uU2VsZWN0OiBudWxsLFxuXHRcdFx0b25DbG9zZTogbnVsbCxcblx0XHRcdGFsdEZpZWxkOiBudWxsLFxuXHRcdFx0YWx0Rm9ybWF0OiBudWxsLFxuXHRcdFx0Y29uc3RyYWluSW5wdXQ6IHRydWUsXG5cdFx0XHRjb21tYW5kc0FzRGF0ZUZvcm1hdDogZmFsc2UsXG5cdFx0XHRjb21tYW5kczoge30gLy8gdGhpcy5jb21tYW5kc1xuXHRcdH0sXG5cblx0XHQvKiogTG9jYWxpc2F0aW9ucyBmb3IgdGhlIHBsdWdpbi5cblx0XHRcdEVudHJpZXMgYXJlIG9iamVjdHMgaW5kZXhlZCBieSB0aGUgbGFuZ3VhZ2UgY29kZSAoJycgYmVpbmcgdGhlIGRlZmF1bHQgVVMvRW5nbGlzaCkuXG5cdFx0XHRFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByb3BlcnR5IFtyZW5kZXJlcj10aGlzLmRlZmF1bHRSZW5kZXJlcl0ge3N0cmluZ30gVGhlIHJlbmRlcmluZyB0ZW1wbGF0ZXMuXG5cdFx0XHRAcHJvcGVydHkgW3ByZXZUZXh0PScmbHQ7UHJldiddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBwcmV2aW91cyBtb250aCBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFtwcmV2U3RhdHVzPSdTaG93IHRoZSBwcmV2aW91cyBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgcHJldmlvdXMgbW9udGggY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbcHJldkp1bXBUZXh0PScmbHQ7Jmx0OyddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBwcmV2aW91cyB5ZWFyIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW3ByZXZKdW1wU3RhdHVzPSdTaG93IHRoZSBwcmV2aW91cyB5ZWFyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBwcmV2aW91cyB5ZWFyIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW25leHRUZXh0PSdOZXh0Jmd0OyddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBuZXh0IG1vbnRoIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW25leHRTdGF0dXM9J1Nob3cgdGhlIG5leHQgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIG5leHQgbW9udGggY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbbmV4dEp1bXBUZXh0PScmZ3Q7Jmd0OyddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBuZXh0IHllYXIgY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbbmV4dEp1bXBTdGF0dXM9J1Nob3cgdGhlIG5leHQgeWVhciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgbmV4dCB5ZWFyIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW2N1cnJlbnRUZXh0PSdDdXJyZW50J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIGN1cnJlbnQgbW9udGggY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbY3VycmVudFN0YXR1cz0nU2hvdyB0aGUgY3VycmVudCBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB0aGUgY3VycmVudCBtb250aCBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFt0b2RheVRleHQ9J1RvZGF5J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIHRvZGF5J3MgbW9udGggY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbdG9kYXlTdGF0dXM9J1Nob3cgdG9kYXlcXCdzIG1vbnRoJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSB0b2RheSdzIG1vbnRoIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW2NsZWFyVGV4dD0nQ2xlYXInXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgY2xlYXIgY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbY2xlYXJTdGF0dXM9J0NsZWFyIGFsbCB0aGUgZGF0ZXMnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIGNsZWFyIGNvbW1hbmQuXG5cdFx0XHRAcHJvcGVydHkgW2Nsb3NlVGV4dD0nQ2xvc2UnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgY2xvc2UgY29tbWFuZC5cblx0XHRcdEBwcm9wZXJ0eSBbY2xvc2VTdGF0dXM9J0Nsb3NlIHRoZSBkYXRlcGlja2VyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBjbG9zZSBjb21tYW5kLlxuXHRcdFx0QHByb3BlcnR5IFt5ZWFyU3RhdHVzPSdDaGFuZ2UgdGhlIHllYXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgeWVhciBzZWxlY3Rpb24uXG5cdFx0XHRAcHJvcGVydHkgW2VhcmxpZXJUZXh0PScmIzE2MDsmIzE2MDvilrInXSB7c3RyaW5nfSBUZXh0IGZvciBlYXJsaWVyIHllYXJzLlxuXHRcdFx0QHByb3BlcnR5IFtsYXRlclRleHQ9JyYjMTYwOyYjMTYwO+KWvCddIHtzdHJpbmd9IFRleHQgZm9yIGxhdGVyIHllYXJzLlxuXHRcdFx0QHByb3BlcnR5IFttb250aFN0YXR1cz0nQ2hhbmdlIHRoZSBtb250aCddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciBtb250aCBzZWxlY3Rpb24uXG5cdFx0XHRAcHJvcGVydHkgW3dlZWtUZXh0PSdXayddIHtzdHJpbmd9IFRleHQgZm9yIHdlZWsgb2YgdGhlIHllYXIgY29sdW1uIGhlYWRlci5cblx0XHRcdEBwcm9wZXJ0eSBbd2Vla1N0YXR1cz0nV2VlayBvZiB0aGUgeWVhciddIHtzdHJpbmd9IFN0YXR1cyB0ZXh0IGZvciB3ZWVrIG9mIHRoZSB5ZWFyIGNvbHVtbiBoZWFkZXIuXG5cdFx0XHRAcHJvcGVydHkgW2RheVN0YXR1cz0nU2VsZWN0IERELCYjMTYwO00mIzE2MDtkLCYjMTYwO3l5eXknXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3Igc2VsZWN0YWJsZSBkYXlzLlxuXHRcdFx0QHByb3BlcnR5IFtkZWZhdWx0U3RhdHVzPSdTZWxlY3QgYSBkYXRlJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgc2hvd24gYnkgZGVmYXVsdC5cblx0XHRcdEBwcm9wZXJ0eSBbaXNSVEw9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBsYW5ndWFnZSBpcyByaWdodC10by1sZWZ0LiAqL1xuXHRcdHJlZ2lvbmFsT3B0aW9uczogeyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UvY291bnRyeSBjb2RlXG5cdFx0XHQnJzogeyAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzIC0gRW5nbGlzaC9VU1xuXHRcdFx0XHRyZW5kZXJlcjoge30sIC8vIHRoaXMuZGVmYXVsdFJlbmRlcmVyXG5cdFx0XHRcdHByZXZUZXh0OiAnJmx0O1ByZXYnLFxuXHRcdFx0XHRwcmV2U3RhdHVzOiAnU2hvdyB0aGUgcHJldmlvdXMgbW9udGgnLFxuXHRcdFx0XHRwcmV2SnVtcFRleHQ6ICcmbHQ7Jmx0OycsXG5cdFx0XHRcdHByZXZKdW1wU3RhdHVzOiAnU2hvdyB0aGUgcHJldmlvdXMgeWVhcicsXG5cdFx0XHRcdG5leHRUZXh0OiAnTmV4dCZndDsnLFxuXHRcdFx0XHRuZXh0U3RhdHVzOiAnU2hvdyB0aGUgbmV4dCBtb250aCcsXG5cdFx0XHRcdG5leHRKdW1wVGV4dDogJyZndDsmZ3Q7Jyxcblx0XHRcdFx0bmV4dEp1bXBTdGF0dXM6ICdTaG93IHRoZSBuZXh0IHllYXInLFxuXHRcdFx0XHRjdXJyZW50VGV4dDogJ0N1cnJlbnQnLFxuXHRcdFx0XHRjdXJyZW50U3RhdHVzOiAnU2hvdyB0aGUgY3VycmVudCBtb250aCcsXG5cdFx0XHRcdHRvZGF5VGV4dDogJ1RvZGF5Jyxcblx0XHRcdFx0dG9kYXlTdGF0dXM6ICdTaG93IHRvZGF5XFwncyBtb250aCcsXG5cdFx0XHRcdGNsZWFyVGV4dDogJ0NsZWFyJyxcblx0XHRcdFx0Y2xlYXJTdGF0dXM6ICdDbGVhciBhbGwgdGhlIGRhdGVzJyxcblx0XHRcdFx0Y2xvc2VUZXh0OiAnQ2xvc2UnLFxuXHRcdFx0XHRjbG9zZVN0YXR1czogJ0Nsb3NlIHRoZSBkYXRlcGlja2VyJyxcblx0XHRcdFx0eWVhclN0YXR1czogJ0NoYW5nZSB0aGUgeWVhcicsXG5cdFx0XHRcdGVhcmxpZXJUZXh0OiAnJiMxNjA7JiMxNjA74payJyxcblx0XHRcdFx0bGF0ZXJUZXh0OiAnJiMxNjA7JiMxNjA74pa8Jyxcblx0XHRcdFx0bW9udGhTdGF0dXM6ICdDaGFuZ2UgdGhlIG1vbnRoJyxcblx0XHRcdFx0d2Vla1RleHQ6ICdXaycsXG5cdFx0XHRcdHdlZWtTdGF0dXM6ICdXZWVrIG9mIHRoZSB5ZWFyJyxcblx0XHRcdFx0ZGF5U3RhdHVzOiAnU2VsZWN0IERELCBNIGQsIHl5eXknLFxuXHRcdFx0XHRkZWZhdWx0U3RhdHVzOiAnU2VsZWN0IGEgZGF0ZScsXG5cdFx0XHRcdGlzUlRMOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqIE5hbWVzIG9mIGdldHRlciBtZXRob2RzIC0gdGhvc2UgdGhhdCBjYW4ndCBiZSBjaGFpbmVkLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlciAqL1xuXHRcdF9nZXR0ZXJzOiBbJ2dldERhdGUnLCAnaXNEaXNhYmxlZCcsICdpc1NlbGVjdGFibGUnLCAncmV0cmlldmVEYXRlJ10sXG5cblx0XHRfZGlzYWJsZWQ6IFtdLFxuXHRcdFxuXHRcdF9wb3B1cENsYXNzOiAnY2FsZW5kYXJzLXBvcHVwJywgLy8gTWFya2VyIGZvciBwb3B1cCBkaXZpc2lvblxuXHRcdF90cmlnZ2VyQ2xhc3M6ICdjYWxlbmRhcnMtdHJpZ2dlcicsIC8vIE1hcmtlciBmb3IgdHJpZ2dlciBlbGVtZW50XG5cdFx0X2Rpc2FibGVDbGFzczogJ2NhbGVuZGFycy1kaXNhYmxlJywgLy8gTWFya2VyIGZvciBkaXNhYmxlZCBlbGVtZW50XG5cdFx0X21vbnRoWWVhckNsYXNzOiAnY2FsZW5kYXJzLW1vbnRoLXllYXInLCAvLyBNYXJrZXIgZm9yIG1vbnRoL3llYXIgaW5wdXRzXG5cdFx0X2N1ck1vbnRoQ2xhc3M6ICdjYWxlbmRhcnMtbW9udGgtJywgLy8gTWFya2VyIGZvciBjdXJyZW50IG1vbnRoL3llYXJcblx0XHRfYW55WWVhckNsYXNzOiAnY2FsZW5kYXJzLWFueS15ZWFyJywgLy8gTWFya2VyIGZvciB5ZWFyIGRpcmVjdCBpbnB1dFxuXHRcdF9jdXJEb1dDbGFzczogJ2NhbGVuZGFycy1kb3ctJywgLy8gTWFya2VyIGZvciBkYXkgb2Ygd2Vla1xuXG5cdFx0X2luaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5kZWZhdWx0T3B0aW9ucy5jb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG5cdFx0XHR0aGlzLnJlZ2lvbmFsT3B0aW9uc1snJ10ucmVuZGVyZXIgPSB0aGlzLmRlZmF1bHRSZW5kZXJlcjtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblxuXHRcdF9pbnN0U2V0dGluZ3M6IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB7c2VsZWN0ZWREYXRlczogW10sIGRyYXdEYXRlOiBudWxsLCBwaWNraW5nUmFuZ2U6IGZhbHNlLFxuXHRcdFx0XHRpbmxpbmU6ICgkLmluQXJyYXkoZWxlbVswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBbJ2RpdicsICdzcGFuJ10pID4gLTEpLFxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHsgLy8gR2V0IGEgc2V0dGluZyB2YWx1ZSwgY29tcHV0aW5nIGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICgkLmluQXJyYXkobmFtZSwgWydkZWZhdWx0RGF0ZScsICdtaW5EYXRlJywgJ21heERhdGUnXSkgPiAtMSkgeyAvLyBEZWNvZGUgZGF0ZSBzZXR0aW5nc1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jYWxlbmRhci5kZXRlcm1pbmVEYXRlKHRoaXMub3B0aW9uc1tuYW1lXSwgbnVsbCxcblx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZERhdGVzWzBdLCB0aGlzLmdldCgnZGF0ZUZvcm1hdCcpLCB0aGlzLmdldENvbmZpZygpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdkYXRlRm9ybWF0Jykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5kYXRlRm9ybWF0IHx8IHRoaXMub3B0aW9ucy5jYWxlbmRhci5sb2NhbC5kYXRlRm9ybWF0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjdXJNaW5EYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gKHRoaXMucGlja2luZ1JhbmdlID8gdGhpcy5zZWxlY3RlZERhdGVzWzBdIDogdGhpcy5nZXQoJ21pbkRhdGUnKSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldENvbmZpZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtkYXlOYW1lc1Nob3J0OiB0aGlzLm9wdGlvbnMuZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXM6IHRoaXMub3B0aW9ucy5kYXlOYW1lcyxcblx0XHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydDogdGhpcy5vcHRpb25zLm1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lczogdGhpcy5vcHRpb25zLm1vbnRoTmFtZXMsXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVXZWVrOiB0aGlzLm9wdGlvbnMuY2FsY3VsYXRlV2Vlaywgc2hvcnRZZWFyQ3V0b2ZmOiB0aGlzLm9wdGlvbnMuc2hvcnRZZWFyQ3V0b2ZmfTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0X3Bvc3RBdHRhY2g6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcblx0XHRcdGlmIChpbnN0LmlubGluZSkge1xuXHRcdFx0XHRpbnN0LmRyYXdEYXRlID0gcGx1Z2luLl9jaGVja01pbk1heCgoaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8XG5cdFx0XHRcdFx0aW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSwgaW5zdCk7XG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW1bMF0pO1xuXHRcdFx0XHRpZiAoJC5mbi5tb3VzZXdoZWVsKSB7XG5cdFx0XHRcdFx0ZWxlbS5tb3VzZXdoZWVsKHRoaXMuX2RvTW91c2VXaGVlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9hdHRhY2htZW50cyhlbGVtLCBpbnN0KTtcblx0XHRcdFx0ZWxlbS5vbigna2V5ZG93bi4nICsgaW5zdC5uYW1lLCB0aGlzLl9rZXlEb3duKS5vbigna2V5cHJlc3MuJyArIGluc3QubmFtZSwgdGhpcy5fa2V5UHJlc3MpLlxuXHRcdFx0XHRcdG9uKCdrZXl1cC4nICsgaW5zdC5uYW1lLCB0aGlzLl9rZXlVcCk7XG5cdFx0XHRcdGlmIChlbGVtLmF0dHIoJ2Rpc2FibGVkJykpIHtcblx0XHRcdFx0XHR0aGlzLmRpc2FibGUoZWxlbVswXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X29wdGlvbnNDaGFuZ2VkOiBmdW5jdGlvbihlbGVtLCBpbnN0LCBvcHRpb25zKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5jYWxlbmRhciAmJiBvcHRpb25zLmNhbGVuZGFyICE9PSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIpIHtcblx0XHRcdFx0dmFyIGRpc2NhcmREYXRlID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiAodHlwZW9mIGluc3Qub3B0aW9uc1tuYW1lXSA9PT0gJ29iamVjdCcgPyBudWxsIDogaW5zdC5vcHRpb25zW25hbWVdKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHtkZWZhdWx0RGF0ZTogZGlzY2FyZERhdGUoJ2RlZmF1bHREYXRlJyksXG5cdFx0XHRcdFx0bWluRGF0ZTogZGlzY2FyZERhdGUoJ21pbkRhdGUnKSwgbWF4RGF0ZTogZGlzY2FyZERhdGUoJ21heERhdGUnKX0sIG9wdGlvbnMpO1xuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbXTtcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZGF0ZXMgPSBpbnN0LnNlbGVjdGVkRGF0ZXM7XG5cdFx0XHQkLmV4dGVuZChpbnN0Lm9wdGlvbnMsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5zZXREYXRlKGVsZW1bMF0sIGRhdGVzLCBudWxsLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9IGZhbHNlO1xuXHRcdFx0dmFyIGNhbGVuZGFyID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyO1xuXHRcdFx0dmFyIGRlZmF1bHREYXRlID0gaW5zdC5nZXQoJ2RlZmF1bHREYXRlJyk7XG5cdFx0XHRpbnN0LmRyYXdEYXRlID0gdGhpcy5fY2hlY2tNaW5NYXgoKGRlZmF1bHREYXRlID8gZGVmYXVsdERhdGUgOiBpbnN0LmRyYXdEYXRlKSB8fFxuXHRcdFx0XHRkZWZhdWx0RGF0ZSB8fCBjYWxlbmRhci50b2RheSgpLCBpbnN0KS5uZXdEYXRlKCk7XG5cdFx0XHRpZiAoIWluc3QuaW5saW5lKSB7XG5cdFx0XHRcdHRoaXMuX2F0dGFjaG1lbnRzKGVsZW0sIGluc3QpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluc3QuaW5saW5lIHx8IGluc3QuZGl2KSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShlbGVtWzBdKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEF0dGFjaCBldmVudHMgYW5kIHRyaWdnZXIsIGlmIG5lY2Vzc2FyeS5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZWxlbSB7alF1ZXJ5fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy4gKi9cblx0XHRfYXR0YWNobWVudHM6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcblx0XHRcdGVsZW0ub2ZmKCdmb2N1cy4nICsgaW5zdC5uYW1lKTtcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuc2hvd09uRm9jdXMpIHtcblx0XHRcdFx0ZWxlbS5vbignZm9jdXMuJyArIGluc3QubmFtZSwgdGhpcy5zaG93KTtcblx0XHRcdH1cblx0XHRcdGlmIChpbnN0LnRyaWdnZXIpIHtcblx0XHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRyaWdnZXIgPSBpbnN0Lm9wdGlvbnMuc2hvd1RyaWdnZXI7XG5cdFx0XHRpbnN0LnRyaWdnZXIgPSAoIXRyaWdnZXIgPyAkKFtdKSA6XG5cdFx0XHRcdCQodHJpZ2dlcikuY2xvbmUoKS5yZW1vdmVBdHRyKCdpZCcpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcylcblx0XHRcdFx0XHRbaW5zdC5vcHRpb25zLmlzUlRMID8gJ2luc2VydEJlZm9yZScgOiAnaW5zZXJ0QWZ0ZXInXShlbGVtKS5cblx0XHRcdFx0XHRjbGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICghcGx1Z2luLmlzRGlzYWJsZWQoZWxlbVswXSkpIHtcblx0XHRcdFx0XHRcdFx0cGx1Z2luW3BsdWdpbi5jdXJJbnN0ID09PSBpbnN0ID8gJ2hpZGUnIDogJ3Nob3cnXShlbGVtWzBdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSk7XG5cdFx0XHR0aGlzLl9hdXRvU2l6ZShlbGVtLCBpbnN0KTtcblx0XHRcdHZhciBkYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhpbnN0LCBlbGVtLnZhbCgpKTtcblx0XHRcdGlmIChkYXRlcykge1xuXHRcdFx0XHR0aGlzLnNldERhdGUoZWxlbVswXSwgZGF0ZXMsIG51bGwsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGRlZmF1bHREYXRlID0gaW5zdC5nZXQoJ2RlZmF1bHREYXRlJyk7XG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNlbGVjdERlZmF1bHREYXRlICYmIGRlZmF1bHREYXRlICYmIGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dGhpcy5zZXREYXRlKGVsZW1bMF0sIChkZWZhdWx0RGF0ZSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEFwcGx5IHRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIGRhdGUgZm9ybWF0LlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBlbGVtIHtqUXVlcnl9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLiAqL1xuXHRcdF9hdXRvU2l6ZTogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5hdXRvU2l6ZSAmJiAhaW5zdC5pbmxpbmUpIHtcblx0XHRcdFx0dmFyIGNhbGVuZGFyID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyO1xuXHRcdFx0XHR2YXIgZGF0ZSA9IGNhbGVuZGFyLm5ld0RhdGUoMjAwOSwgMTAsIDIwKTsgLy8gRW5zdXJlIGRvdWJsZSBkaWdpdHNcblx0XHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xuXHRcdFx0XHRpZiAoZGF0ZUZvcm1hdC5tYXRjaCgvW0RNXS8pKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmRNYXggPSBmdW5jdGlvbihuYW1lcykge1xuXHRcdFx0XHRcdFx0dmFyIG1heCA9IDA7XG5cdFx0XHRcdFx0XHR2YXIgbWF4SSA9IDA7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChuYW1lc1tpXS5sZW5ndGggPiBtYXgpIHtcblx0XHRcdFx0XHRcdFx0XHRtYXggPSBuYW1lc1tpXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0bWF4SSA9IGk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBtYXhJO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZGF0ZS5tb250aChmaW5kTWF4KGNhbGVuZGFyLmxvY2FsW2RhdGVGb3JtYXQubWF0Y2goL01NLykgPyAvLyBMb25nZXN0IG1vbnRoXG5cdFx0XHRcdFx0XHQnbW9udGhOYW1lcycgOiAnbW9udGhOYW1lc1Nob3J0J10pICsgMSk7XG5cdFx0XHRcdFx0ZGF0ZS5kYXkoZmluZE1heChjYWxlbmRhci5sb2NhbFtkYXRlRm9ybWF0Lm1hdGNoKC9ERC8pID8gLy8gTG9uZ2VzdCBkYXlcblx0XHRcdFx0XHRcdCdkYXlOYW1lcycgOiAnZGF5TmFtZXNTaG9ydCddKSArIDIwIC0gZGF0ZS5kYXlPZldlZWsoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC5lbGVtLmF0dHIoJ3NpemUnLCBkYXRlLmZvcm1hdERhdGUoZGF0ZUZvcm1hdCkubGVuZ3RoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3ByZURlc3Ryb3k6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcblx0XHRcdGlmIChpbnN0LnRyaWdnZXIpIHtcblx0XHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbS5lbXB0eSgpLm9mZignLicgKyBpbnN0Lm5hbWUpO1xuXHRcdFx0aWYgKGluc3QuaW5saW5lICYmICQuZm4ubW91c2V3aGVlbCkge1xuXHRcdFx0XHRlbGVtLnVubW91c2V3aGVlbCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpbnN0LmlubGluZSAmJiBpbnN0Lm9wdGlvbnMuYXV0b1NpemUpIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyKCdzaXplJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBBcHBseSBtdWx0aXBsZSBldmVudCBmdW5jdGlvbnMuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZm5zIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9ucyB0byBhcHBseS5cblx0XHRcdEBleGFtcGxlIG9uU2hvdzogbXVsdGlwbGVFdmVudHMoZm4xLCBmbjIsIC4uLikgKi9cblx0XHRtdWx0aXBsZUV2ZW50czogZnVuY3Rpb24oZm5zKSB7XG5cdFx0XHR2YXIgZnVuY3MgPSBhcmd1bWVudHM7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oYXJncykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZnVuY3NbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqIEVuYWJsZSB0aGUgY29udHJvbC5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnZW5hYmxlJykgKi9cblx0XHRlbmFibGU6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdGVsZW0gPSAkKGVsZW0pO1xuXHRcdFx0aWYgKCFlbGVtLmhhc0NsYXNzKHRoaXMuX2dldE1hcmtlcigpKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcblx0XHRcdFx0ZWxlbS5jaGlsZHJlbignLicgKyB0aGlzLl9kaXNhYmxlQ2xhc3MpLnJlbW92ZSgpLmVuZCgpLlxuXHRcdFx0XHRcdGZpbmQoJ2J1dHRvbixzZWxlY3QnKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKS5lbmQoKS5cblx0XHRcdFx0XHRmaW5kKCdhJykuYXR0cignaHJlZicsICdqYXZhc2NyaXB0OnZvaWQoMCknKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlbGVtLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuXHRcdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKCdidXR0b24uJyArIHRoaXMuX3RyaWdnZXJDbGFzcykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSkuZW5kKCkuXG5cdFx0XHRcdFx0ZmlsdGVyKCdpbWcuJyArIHRoaXMuX3RyaWdnZXJDbGFzcykuY3NzKHtvcGFjaXR5OiAnMS4wJywgY3Vyc29yOiAnJ30pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGlzYWJsZWQgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZCxcblx0XHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PT0gZWxlbVswXSA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBEZWxldGUgZW50cnlcblx0XHR9LFxuXG5cdFx0LyoqIERpc2FibGUgdGhlIGNvbnRyb2wuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2Rpc2FibGUnKSAqL1xuXHRcdGRpc2FibGU6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdGVsZW0gPSAkKGVsZW0pO1xuXHRcdFx0aWYgKCFlbGVtLmhhc0NsYXNzKHRoaXMuX2dldE1hcmtlcigpKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUpIHtcblx0XHRcdFx0dmFyIGlubGluZSA9IGVsZW0uY2hpbGRyZW4oJzpsYXN0Jyk7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBpbmxpbmUub2Zmc2V0KCk7XG5cdFx0XHRcdHZhciByZWxPZmZzZXQgPSB7bGVmdDogMCwgdG9wOiAwfTtcblx0XHRcdFx0aW5saW5lLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICgkKHRoaXMpLmNzcygncG9zaXRpb24nKSA9PT0gJ3JlbGF0aXZlJykge1xuXHRcdFx0XHRcdFx0cmVsT2Zmc2V0ID0gJCh0aGlzKS5vZmZzZXQoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR2YXIgekluZGV4ID0gZWxlbS5jc3MoJ3pJbmRleCcpO1xuXHRcdFx0XHR6SW5kZXggPSAoekluZGV4ID09PSAnYXV0bycgPyAwIDogcGFyc2VJbnQoekluZGV4LCAxMCkpICsgMTtcblx0XHRcdFx0ZWxlbS5wcmVwZW5kKCc8ZGl2IGNsYXNzPVwiJyArIHRoaXMuX2Rpc2FibGVDbGFzcyArICdcIiBzdHlsZT1cIicgK1xuXHRcdFx0XHRcdCd3aWR0aDogJyArIGlubGluZS5vdXRlcldpZHRoKCkgKyAncHg7IGhlaWdodDogJyArIGlubGluZS5vdXRlckhlaWdodCgpICtcblx0XHRcdFx0XHQncHg7IGxlZnQ6ICcgKyAob2Zmc2V0LmxlZnQgLSByZWxPZmZzZXQubGVmdCkgKyAncHg7IHRvcDogJyArXG5cdFx0XHRcdFx0KG9mZnNldC50b3AgLSByZWxPZmZzZXQudG9wKSArICdweDsgei1pbmRleDogJyArIHpJbmRleCArICdcIj48L2Rpdj4nKS5cblx0XHRcdFx0XHRmaW5kKCdidXR0b24sc2VsZWN0JykucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS5lbmQoKS5cblx0XHRcdFx0XHRmaW5kKCdhJykucmVtb3ZlQXR0cignaHJlZicpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGVsZW0ucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcblx0XHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcignYnV0dG9uLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSkuZW5kKCkuXG5cdFx0XHRcdFx0ZmlsdGVyKCdpbWcuJyArIHRoaXMuX3RyaWdnZXJDbGFzcykuY3NzKHtvcGFjaXR5OiAnMC41JywgY3Vyc29yOiAnZGVmYXVsdCd9KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2Rpc2FibGVkID0gJC5tYXAodGhpcy5fZGlzYWJsZWQsXG5cdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IGVsZW1bMF0gPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gRGVsZXRlIGVudHJ5XG5cdFx0XHR0aGlzLl9kaXNhYmxlZC5wdXNoKGVsZW1bMF0pO1xuXHRcdH0sXG5cblx0XHQvKiogSXMgdGhlIGZpcnN0IGZpZWxkIGluIGEgalF1ZXJ5IGNvbGxlY3Rpb24gZGlzYWJsZWQgYXMgYSBkYXRlcGlja2VyP1xuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBkaXNhYmxlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIGVuYWJsZWQuXG5cdFx0XHRAZXhhbXBsZSBpZiAoJChzZWxlY3RvcikuZGF0ZXBpY2soJ2lzRGlzYWJsZWQnKSkgey4uLn0gKi9cblx0XHRpc0Rpc2FibGVkOiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRyZXR1cm4gKGVsZW0gJiYgJC5pbkFycmF5KGVsZW0sIHRoaXMuX2Rpc2FibGVkKSA+IC0xKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNob3cgYSBwb3B1cCBkYXRlcGlja2VyLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge0V2ZW50fEVsZW1lbnR9IGEgZm9jdXMgZXZlbnQgb3IgdGhlIGNvbnRyb2wgdG8gdXNlLlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ3Nob3cnKSAqL1xuXHRcdHNob3c6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdGVsZW0gPSAkKGVsZW0udGFyZ2V0IHx8IGVsZW0pO1xuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAocGx1Z2luLmN1ckluc3QgPT09IGluc3QpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBsdWdpbi5jdXJJbnN0KSB7XG5cdFx0XHRcdHBsdWdpbi5oaWRlKHBsdWdpbi5jdXJJbnN0LCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdC8vIFJldHJpZXZlIGV4aXN0aW5nIGRhdGUocylcblx0XHRcdFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gcGx1Z2luLl9leHRyYWN0RGF0ZXMoaW5zdCwgZWxlbS52YWwoKSk7XG5cdFx0XHRcdGluc3QucGlja2luZ1JhbmdlID0gZmFsc2U7XG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgPSBwbHVnaW4uX2NoZWNrTWluTWF4KChpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHxcblx0XHRcdFx0XHRpbnN0LmdldCgnZGVmYXVsdERhdGUnKSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSkubmV3RGF0ZSgpLCBpbnN0KTtcblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpO1xuXHRcdFx0XHRwbHVnaW4uY3VySW5zdCA9IGluc3Q7XG5cdFx0XHRcdC8vIEdlbmVyYXRlIGNvbnRlbnRcblx0XHRcdFx0cGx1Z2luLl91cGRhdGUoZWxlbVswXSwgdHJ1ZSk7XG5cdFx0XHRcdC8vIEFkanVzdCBwb3NpdGlvbiBiZWZvcmUgc2hvd2luZ1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gcGx1Z2luLl9jaGVja09mZnNldChpbnN0KTtcblx0XHRcdFx0aW5zdC5kaXYuY3NzKHtsZWZ0OiBvZmZzZXQubGVmdCwgdG9wOiBvZmZzZXQudG9wfSk7XG5cdFx0XHRcdC8vIEFuZCBkaXNwbGF5XG5cdFx0XHRcdHZhciBzaG93QW5pbSA9IGluc3Qub3B0aW9ucy5zaG93QW5pbTtcblx0XHRcdFx0dmFyIHNob3dTcGVlZCA9IGluc3Qub3B0aW9ucy5zaG93U3BlZWQ7XG5cdFx0XHRcdHNob3dTcGVlZCA9IChzaG93U3BlZWQgPT09ICdub3JtYWwnICYmICQudWkgJiZcblx0XHRcdFx0XHRwYXJzZUludCgkLnVpLnZlcnNpb24uc3Vic3RyaW5nKDIpKSA+PSA4ID8gJ19kZWZhdWx0JyA6IHNob3dTcGVlZCk7XG5cdFx0XHRcdGlmICgkLmVmZmVjdHMgJiYgKCQuZWZmZWN0c1tzaG93QW5pbV0gfHwgKCQuZWZmZWN0cy5lZmZlY3QgJiYgJC5lZmZlY3RzLmVmZmVjdFtzaG93QW5pbV0pKSkge1xuXHRcdFx0XHRcdHZhciBkYXRhID0gaW5zdC5kaXYuZGF0YSgpOyAvLyBVcGRhdGUgb2xkIGVmZmVjdHMgZGF0YVxuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZiAoa2V5Lm1hdGNoKC9eZWNcXC5zdG9yYWdlXFwuLykpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YVtrZXldID0gaW5zdC5fbWFpbkRpdi5jc3Moa2V5LnJlcGxhY2UoL2VjXFwuc3RvcmFnZVxcLi8sICcnKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc3QuZGl2LmRhdGEoZGF0YSkuc2hvdyhzaG93QW5pbSwgaW5zdC5vcHRpb25zLnNob3dPcHRpb25zLCBzaG93U3BlZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGluc3QuZGl2W3Nob3dBbmltIHx8ICdzaG93J10oc2hvd0FuaW0gPyBzaG93U3BlZWQgOiAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogRXh0cmFjdCBwb3NzaWJsZSBkYXRlcyBmcm9tIGEgc3RyaW5nLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIHRleHQge3N0cmluZ30gVGhlIHRleHQgdG8gZXh0cmFjdCBmcm9tLlxuXHRcdFx0QHJldHVybiB7Q0RhdGVbXX0gVGhlIGV4dHJhY3RlZCBkYXRlcy4gKi9cblx0XHRfZXh0cmFjdERhdGVzOiBmdW5jdGlvbihpbnN0LCBkYXRlc1RleHQpIHtcblx0XHRcdGlmIChkYXRlc1RleHQgPT09IGluc3QubGFzdFZhbCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpbnN0Lmxhc3RWYWwgPSBkYXRlc1RleHQ7XG5cdFx0XHRkYXRlc1RleHQgPSBkYXRlc1RleHQuc3BsaXQoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0ID8gaW5zdC5vcHRpb25zLm11bHRpU2VwYXJhdG9yIDpcblx0XHRcdFx0KGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IGluc3Qub3B0aW9ucy5yYW5nZVNlcGFyYXRvciA6ICdcXHgwMCcpKTtcblx0XHRcdHZhciBkYXRlcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlc1RleHQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgZGF0ZSA9IGluc3Qub3B0aW9ucy5jYWxlbmRhci5wYXJzZURhdGUoaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKSwgZGF0ZXNUZXh0W2ldKTtcblx0XHRcdFx0XHRpZiAoZGF0ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChkYXRlc1tqXS5jb21wYXJlVG8oZGF0ZSkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghZm91bmQpIHtcblx0XHRcdFx0XHRcdFx0ZGF0ZXMucHVzaChkYXRlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBJZ25vcmVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGF0ZXMuc3BsaWNlKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCB8fCAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gMiA6IDEpLCBkYXRlcy5sZW5ndGgpO1xuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCAmJiBkYXRlcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0ZGF0ZXNbMV0gPSBkYXRlc1swXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlcztcblx0XHR9LFxuXG5cdFx0LyoqIFVwZGF0ZSB0aGUgZGF0ZXBpY2tlciBkaXNwbGF5LlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBlbGVtIHtFdmVudHxFbGVtZW50fSBhIGZvY3VzIGV2ZW50IG9yIHRoZSBjb250cm9sIHRvIHVzZS5cblx0XHRcdEBwYXJhbSBoaWRkZW4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGluaXRpYWxseSBoaWRlIHRoZSBkYXRlcGlja2VyLiAqL1xuXHRcdF91cGRhdGU6IGZ1bmN0aW9uKGVsZW0sIGhpZGRlbikge1xuXHRcdFx0ZWxlbSA9ICQoZWxlbS50YXJnZXQgfHwgZWxlbSk7XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdGlmIChpbnN0LmlubGluZSB8fCBwbHVnaW4uY3VySW5zdCA9PT0gaW5zdCkge1xuXHRcdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uQ2hhbmdlTW9udGhZZWFyKSAmJiAoIWluc3QucHJldkRhdGUgfHxcblx0XHRcdFx0XHRcdFx0aW5zdC5wcmV2RGF0ZS55ZWFyKCkgIT09IGluc3QuZHJhd0RhdGUueWVhcigpIHx8XG5cdFx0XHRcdFx0XHRcdGluc3QucHJldkRhdGUubW9udGgoKSAhPT0gaW5zdC5kcmF3RGF0ZS5tb250aCgpKSkge1xuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLm9uQ2hhbmdlTW9udGhZZWFyLmFwcGx5KGVsZW1bMF0sXG5cdFx0XHRcdFx0XHRcdFtpbnN0LmRyYXdEYXRlLnllYXIoKSwgaW5zdC5kcmF3RGF0ZS5tb250aCgpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpbnN0LmlubGluZSkge1xuXHRcdFx0XHRcdHZhciBpbmRleCA9ICQoJ2EsIDppbnB1dCcsIGVsZW0pLmluZGV4KCQoJzpmb2N1cycsIGVsZW0pKTtcblx0XHRcdFx0XHRlbGVtLmh0bWwodGhpcy5fZ2VuZXJhdGVDb250ZW50KGVsZW1bMF0sIGluc3QpKTtcblx0XHRcdFx0XHR2YXIgZm9jdXMgPSBlbGVtLmZpbmQoJ2EsIDppbnB1dCcpO1xuXHRcdFx0XHRcdGZvY3VzLmVxKE1hdGgubWF4KE1hdGgubWluKGluZGV4LCBmb2N1cy5sZW5ndGggLSAxKSwgMCkpLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocGx1Z2luLmN1ckluc3QgPT09IGluc3QpIHtcblx0XHRcdFx0XHRpZiAoIWluc3QuZGl2KSB7XG5cdFx0XHRcdFx0XHRpbnN0LmRpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3ModGhpcy5fcG9wdXBDbGFzcykuXG5cdFx0XHRcdFx0XHRcdGNzcyh7ZGlzcGxheTogKGhpZGRlbiA/ICdub25lJyA6ICdzdGF0aWMnKSwgcG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0XHRcdFx0bGVmdDogZWxlbS5vZmZzZXQoKS5sZWZ0LCB0b3A6IGVsZW0ub2Zmc2V0KCkudG9wICsgZWxlbS5vdXRlckhlaWdodCgpfSkuXG5cdFx0XHRcdFx0XHRcdGFwcGVuZFRvKCQoaW5zdC5vcHRpb25zLnBvcHVwQ29udGFpbmVyIHx8ICdib2R5JykpO1xuXHRcdFx0XHRcdFx0aWYgKCQuZm4ubW91c2V3aGVlbCkge1xuXHRcdFx0XHRcdFx0XHRpbnN0LmRpdi5tb3VzZXdoZWVsKHRoaXMuX2RvTW91c2VXaGVlbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc3QuZGl2Lmh0bWwodGhpcy5fZ2VuZXJhdGVDb250ZW50KGVsZW1bMF0sIGluc3QpKTtcblx0XHRcdFx0XHRlbGVtLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgYW5kIGFueSBhbHRlcm5hdGUgZmllbGQgd2l0aCB0aGUgY3VycmVudCBkYXRlcy5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gdXNlLlxuXHRcdFx0QHBhcmFtIGtleVVwIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21pbmcgZnJvbSA8Y29kZT5rZXlVcDwvY29kZT4gcHJvY2Vzc2luZyAoaW50ZXJuYWwpLiAqL1xuXHRcdF91cGRhdGVJbnB1dDogZnVuY3Rpb24oZWxlbSwga2V5VXApIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICcnO1xuXHRcdFx0XHR2YXIgYWx0VmFsdWUgPSAnJztcblx0XHRcdFx0dmFyIHNlcCA9IChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgPyBpbnN0Lm9wdGlvbnMubXVsdGlTZXBhcmF0b3IgOlxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5yYW5nZVNlcGFyYXRvcik7XG5cdFx0XHRcdHZhciBjYWxlbmRhciA9IGluc3Qub3B0aW9ucy5jYWxlbmRhcjtcblx0XHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xuXHRcdFx0XHR2YXIgYWx0Rm9ybWF0ID0gaW5zdC5vcHRpb25zLmFsdEZvcm1hdCB8fCBkYXRlRm9ybWF0O1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhbHVlICs9IChrZXlVcCA/ICcnIDogKGkgPiAwID8gc2VwIDogJycpICtcblx0XHRcdFx0XHRcdGNhbGVuZGFyLmZvcm1hdERhdGUoZGF0ZUZvcm1hdCwgaW5zdC5zZWxlY3RlZERhdGVzW2ldKSk7XG5cdFx0XHRcdFx0YWx0VmFsdWUgKz0gKGkgPiAwID8gc2VwIDogJycpICtcblx0XHRcdFx0XHRcdGNhbGVuZGFyLmZvcm1hdERhdGUoYWx0Rm9ybWF0LCBpbnN0LnNlbGVjdGVkRGF0ZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaW5zdC5pbmxpbmUgJiYgIWtleVVwKSB7XG5cdFx0XHRcdFx0JChlbGVtKS52YWwodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoaW5zdC5vcHRpb25zLmFsdEZpZWxkKS52YWwoYWx0VmFsdWUpO1xuXHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vblNlbGVjdCkgJiYgIWtleVVwICYmICFpbnN0LmluU2VsZWN0KSB7XG5cdFx0XHRcdFx0aW5zdC5pblNlbGVjdCA9IHRydWU7IC8vIFByZXZlbnQgZW5kbGVzcyBsb29wc1xuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5vblNlbGVjdC5hcHBseShlbGVtLCBbaW5zdC5zZWxlY3RlZERhdGVzXSk7XG5cdFx0XHRcdFx0aW5zdC5pblNlbGVjdCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgc2l6ZSBvZiBsZWZ0IGFuZCB0b3AgYm9yZGVycyBmb3IgYW4gZWxlbWVudC5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZWxlbSB7alF1ZXJ5fSBUaGUgZWxlbWVudCBvZiBpbnRlcmVzdC5cblx0XHRcdEByZXR1cm4ge251bWJlcltdfSBUaGUgbGVmdCBhbmQgdG9wIGJvcmRlcnMuICovXG5cdFx0X2dldEJvcmRlcnM6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdHZhciBjb252ZXJ0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHt0aGluOiAxLCBtZWRpdW06IDMsIHRoaWNrOiA1fVt2YWx1ZV0gfHwgdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIFtwYXJzZUZsb2F0KGNvbnZlcnQoZWxlbS5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykpKSxcblx0XHRcdFx0cGFyc2VGbG9hdChjb252ZXJ0KGVsZW0uY3NzKCdib3JkZXItdG9wLXdpZHRoJykpKV07XG5cdFx0fSxcblxuXHRcdC8qKiBDaGVjayBwb3NpdGlvbmluZyB0byByZW1haW4gb24gdGhlIHNjcmVlbi5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEByZXR1cm4ge29iamVjdH0gVGhlIHVwZGF0ZWQgb2Zmc2V0IGZvciB0aGUgZGF0ZXBpY2tlci4gKi9cblx0XHRfY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdHZhciBiYXNlID0gKGluc3QuZWxlbS5pcygnOmhpZGRlbicpICYmIGluc3QudHJpZ2dlciA/IGluc3QudHJpZ2dlciA6IGluc3QuZWxlbSk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gYmFzZS5vZmZzZXQoKTtcblx0XHRcdHZhciBicm93c2VyV2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcblx0XHRcdHZhciBicm93c2VySGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuXHRcdFx0aWYgKGJyb3dzZXJXaWR0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGlzRml4ZWQgPSBmYWxzZTtcblx0XHRcdCQoaW5zdC5lbGVtKS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aXNGaXhlZCB8PSAkKHRoaXMpLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJztcblx0XHRcdFx0cmV0dXJuICFpc0ZpeGVkO1xuXHRcdFx0fSk7XG5cdFx0XHR2YXIgc2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdHZhciBzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcblx0XHRcdHZhciBhYm92ZSA9IG9mZnNldC50b3AgLSAoaXNGaXhlZCA/IHNjcm9sbFkgOiAwKSAtIGluc3QuZGl2Lm91dGVySGVpZ2h0KCk7XG5cdFx0XHR2YXIgYmVsb3cgPSBvZmZzZXQudG9wIC0gKGlzRml4ZWQgPyBzY3JvbGxZIDogMCkgKyBiYXNlLm91dGVySGVpZ2h0KCk7XG5cdFx0XHR2YXIgYWxpZ25MID0gb2Zmc2V0LmxlZnQgLSAoaXNGaXhlZCA/IHNjcm9sbFggOiAwKTtcblx0XHRcdHZhciBhbGlnblIgPSBvZmZzZXQubGVmdCAtIChpc0ZpeGVkID8gc2Nyb2xsWCA6IDApICsgYmFzZS5vdXRlcldpZHRoKCkgLSBpbnN0LmRpdi5vdXRlcldpZHRoKCk7XG5cdFx0XHR2YXIgdG9vV2lkZSA9IChvZmZzZXQubGVmdCAtIHNjcm9sbFggKyBpbnN0LmRpdi5vdXRlcldpZHRoKCkpID4gYnJvd3NlcldpZHRoO1xuXHRcdFx0dmFyIHRvb0hpZ2ggPSAob2Zmc2V0LnRvcCAtIHNjcm9sbFkgKyBpbnN0LmVsZW0ub3V0ZXJIZWlnaHQoKSArXG5cdFx0XHRcdGluc3QuZGl2Lm91dGVySGVpZ2h0KCkpID4gYnJvd3NlckhlaWdodDtcblx0XHRcdGluc3QuZGl2LmNzcygncG9zaXRpb24nLCBpc0ZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScpO1xuXHRcdFx0dmFyIGFsaWdubWVudCA9IGluc3Qub3B0aW9ucy5hbGlnbm1lbnQ7XG5cdFx0XHRpZiAoYWxpZ25tZW50ID09PSAndG9wTGVmdCcpIHtcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduTCwgdG9wOiBhYm92ZX07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICd0b3BSaWdodCcpIHtcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduUiwgdG9wOiBhYm92ZX07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChhbGlnbm1lbnQgPT09ICdib3R0b21MZWZ0Jykge1xuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogYWxpZ25MLCB0b3A6IGJlbG93fTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGFsaWdubWVudCA9PT0gJ2JvdHRvbVJpZ2h0Jykge1xuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogYWxpZ25SLCB0b3A6IGJlbG93fTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGFsaWdubWVudCA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IChpbnN0Lm9wdGlvbnMuaXNSVEwgfHwgdG9vV2lkZSA/IGFsaWduUiA6IGFsaWduTCksIHRvcDogYWJvdmV9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIGJvdHRvbVxuXHRcdFx0XHRvZmZzZXQgPSB7bGVmdDogKGluc3Qub3B0aW9ucy5pc1JUTCB8fCB0b29XaWRlID8gYWxpZ25SIDogYWxpZ25MKSxcblx0XHRcdFx0XHR0b3A6ICh0b29IaWdoID8gYWJvdmUgOiBiZWxvdyl9O1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0LmxlZnQgPSBNYXRoLm1heCgoaXNGaXhlZCA/IDAgOiBzY3JvbGxYKSwgb2Zmc2V0LmxlZnQpO1xuXHRcdFx0b2Zmc2V0LnRvcCA9IE1hdGgubWF4KChpc0ZpeGVkID8gMCA6IHNjcm9sbFkpLCBvZmZzZXQudG9wKTtcblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fSxcblxuXHRcdC8qKiBDbG9zZSBkYXRlIHBpY2tlciBpZiBjbGlja2VkIGVsc2V3aGVyZS5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZXZlbnQge01vdXNlRXZlbnR9IFRoZSBtb3VzZSBjbGljayB0byBjaGVjay4gKi9cblx0XHRfY2hlY2tFeHRlcm5hbENsaWNrOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKCFwbHVnaW4uY3VySW5zdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZWxlbSA9ICQoZXZlbnQudGFyZ2V0KTtcblx0XHRcdGlmIChlbGVtLmNsb3Nlc3QoJy4nICsgcGx1Z2luLl9wb3B1cENsYXNzICsgJywuJyArIHBsdWdpbi5fdHJpZ2dlckNsYXNzKS5sZW5ndGggPT09IDAgJiZcblx0XHRcdFx0XHQhZWxlbS5oYXNDbGFzcyhwbHVnaW4uX2dldE1hcmtlcigpKSkge1xuXHRcdFx0XHRwbHVnaW4uaGlkZShwbHVnaW4uY3VySW5zdCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBIaWRlIGEgcG9wdXAgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fG9iamVjdH0gVGhlIGNvbnRyb2wgdG8gdXNlIG9yIHRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIGltbWVkaWF0ZSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY2xvc2UgaW1tZWRpYXRlbHkgd2l0aG91dCBhbmltYXRpb24gKGludGVybmFsKS5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdoaWRlJykgKi9cblx0XHRoaWRlOiBmdW5jdGlvbihlbGVtLCBpbW1lZGlhdGUpIHtcblx0XHRcdGlmICghZWxlbSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdGluc3QgPSBlbGVtO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluc3QgJiYgaW5zdCA9PT0gcGx1Z2luLmN1ckluc3QpIHtcblx0XHRcdFx0dmFyIHNob3dBbmltID0gKGltbWVkaWF0ZSA/ICcnIDogaW5zdC5vcHRpb25zLnNob3dBbmltKTtcblx0XHRcdFx0dmFyIHNob3dTcGVlZCA9IGluc3Qub3B0aW9ucy5zaG93U3BlZWQ7XG5cdFx0XHRcdHNob3dTcGVlZCA9IChzaG93U3BlZWQgPT09ICdub3JtYWwnICYmICQudWkgJiZcblx0XHRcdFx0XHRwYXJzZUludCgkLnVpLnZlcnNpb24uc3Vic3RyaW5nKDIpKSA+PSA4ID8gJ19kZWZhdWx0JyA6IHNob3dTcGVlZCk7XG5cdFx0XHRcdHZhciBwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICghaW5zdC5kaXYpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zdC5kaXYucmVtb3ZlKCk7XG5cdFx0XHRcdFx0aW5zdC5kaXYgPSBudWxsO1xuXHRcdFx0XHRcdHBsdWdpbi5jdXJJbnN0ID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vbkNsb3NlKSkge1xuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLm9uQ2xvc2UuYXBwbHkoZWxlbSwgW2luc3Quc2VsZWN0ZWREYXRlc10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0aW5zdC5kaXYuc3RvcCgpO1xuXHRcdFx0XHRpZiAoJC5lZmZlY3RzICYmICgkLmVmZmVjdHNbc2hvd0FuaW1dIHx8ICgkLmVmZmVjdHMuZWZmZWN0ICYmICQuZWZmZWN0cy5lZmZlY3Rbc2hvd0FuaW1dKSkpIHtcblx0XHRcdFx0XHRpbnN0LmRpdi5oaWRlKHNob3dBbmltLCBpbnN0Lm9wdGlvbnMuc2hvd09wdGlvbnMsIHNob3dTcGVlZCwgcG9zdFByb2Nlc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBoaWRlQW5pbSA9IChzaG93QW5pbSA9PT0gJ3NsaWRlRG93bicgPyAnc2xpZGVVcCcgOlxuXHRcdFx0XHRcdFx0KHNob3dBbmltID09PSAnZmFkZUluJyA/ICdmYWRlT3V0JyA6ICdoaWRlJykpO1xuXHRcdFx0XHRcdGluc3QuZGl2W2hpZGVBbmltXSgoc2hvd0FuaW0gPyBzaG93U3BlZWQgOiAnJyksIHBvc3RQcm9jZXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXNob3dBbmltKSB7XG5cdFx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogSGFuZGxlIGtleXN0cm9rZXMgaW4gdGhlIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtLZXlFdmVudH0gVGhlIGtleXN0cm9rZS5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIG5vdCBoYW5kbGVkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgaGFuZGxlZC4gKi9cblx0XHRfa2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBlbGVtID0gKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lbGVtKSB8fCBldmVudC50YXJnZXQ7XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdHZhciBoYW5kbGVkID0gZmFsc2U7XG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUgfHwgaW5zdC5kaXYpIHtcblx0XHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IDkpIHsgLy8gVGFiIC0gY2xvc2Vcblx0XHRcdFx0XHRwbHVnaW4uaGlkZShlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAxMykgeyAvLyBFbnRlciAtIHNlbGVjdFxuXHRcdFx0XHRcdHBsdWdpbi5zZWxlY3REYXRlKGVsZW0sXG5cdFx0XHRcdFx0XHQkKCdhLicgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuaGlnaGxpZ2h0ZWRDbGFzcywgaW5zdC5kaXYpWzBdKTtcblx0XHRcdFx0XHRoYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgLy8gQ29tbWFuZCBrZXlzdHJva2VzXG5cdFx0XHRcdFx0dmFyIGNvbW1hbmRzID0gaW5zdC5vcHRpb25zLmNvbW1hbmRzO1xuXHRcdFx0XHRcdGZvciAodmFyIG5hbWUgaW4gY29tbWFuZHMpIHtcblx0XHRcdFx0XHRcdHZhciBjb21tYW5kID0gY29tbWFuZHNbbmFtZV07XG5cdFx0XHRcdFx0XHRpZiAoY29tbWFuZC5rZXlzdHJva2Uua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSAmJlxuXHRcdFx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2UuY3RybEtleSA9PT0gISEoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJlxuXHRcdFx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2UuYWx0S2V5ID09PSBldmVudC5hbHRLZXkgJiZcblx0XHRcdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLnNoaWZ0S2V5ID09PSBldmVudC5zaGlmdEtleSkge1xuXHRcdFx0XHRcdFx0XHRwbHVnaW4ucGVyZm9ybUFjdGlvbihlbGVtLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0aGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIFNob3cgb24gJ2N1cnJlbnQnIGtleXN0cm9rZVxuXHRcdFx0XHR2YXIgY29tbWFuZCA9IGluc3Qub3B0aW9ucy5jb21tYW5kcy5jdXJyZW50O1xuXHRcdFx0XHRpZiAoY29tbWFuZC5rZXlzdHJva2Uua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSAmJlxuXHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5jdHJsS2V5ID09PSAhIShldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmXG5cdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLmFsdEtleSA9PT0gZXZlbnQuYWx0S2V5ICYmXG5cdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLnNoaWZ0S2V5ID09PSBldmVudC5zaGlmdEtleSkge1xuXHRcdFx0XHRcdHBsdWdpbi5zaG93KGVsZW0pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpbnN0LmN0cmxLZXkgPSAoKGV2ZW50LmtleUNvZGUgPCA0OCAmJiBldmVudC5rZXlDb2RlICE9PSAzMikgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KTtcblx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICFoYW5kbGVkO1xuXHRcdH0sXG5cblx0XHQvKiogRmlsdGVyIGtleXN0cm9rZXMgaW4gdGhlIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtLZXlFdmVudH0gVGhlIGtleXN0cm9rZS5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGFsbG93ZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QgYWxsb3dlZC4gKi9cblx0XHRfa2V5UHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdCgoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmVsZW0pIHx8IGV2ZW50LnRhcmdldCk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiBpbnN0Lm9wdGlvbnMuY29uc3RyYWluSW5wdXQpIHtcblx0XHRcdFx0dmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5rZXlDb2RlIHx8IGV2ZW50LmNoYXJDb2RlKTtcblx0XHRcdFx0dmFyIGFsbG93ZWRDaGFycyA9IHBsdWdpbi5fYWxsb3dlZENoYXJzKGluc3QpO1xuXHRcdFx0XHRyZXR1cm4gKGV2ZW50Lm1ldGFLZXkgfHwgaW5zdC5jdHJsS2V5IHx8IGNoIDwgJyAnIHx8XG5cdFx0XHRcdFx0IWFsbG93ZWRDaGFycyB8fCBhbGxvd2VkQ2hhcnMuaW5kZXhPZihjaCkgPiAtMSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqIERldGVybWluZSB0aGUgc2V0IG9mIGNoYXJhY3RlcnMgYWxsb3dlZCBieSB0aGUgZGF0ZSBmb3JtYXQuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBzZXQgb2YgYWxsb3dlZCBjaGFyYWN0ZXJzLCBvciA8Y29kZT5udWxsPC9jb2RlPiBpZiBhbnl0aGluZyBhbGxvd2VkLiAqL1xuXHRcdF9hbGxvd2VkQ2hhcnM6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdHZhciBhbGxvd2VkQ2hhcnMgPSAoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0ID8gaW5zdC5vcHRpb25zLm11bHRpU2VwYXJhdG9yIDpcblx0XHRcdFx0KGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IGluc3Qub3B0aW9ucy5yYW5nZVNlcGFyYXRvciA6ICcnKSk7XG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0dmFyIGhhc051bSA9IGZhbHNlO1xuXHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlRm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaCA9IGRhdGVGb3JtYXQuY2hhckF0KGkpO1xuXHRcdFx0XHRpZiAobGl0ZXJhbCkge1xuXHRcdFx0XHRcdGlmIChjaCA9PT0gXCInXCIgJiYgZGF0ZUZvcm1hdC5jaGFyQXQoaSArIDEpICE9PSBcIidcIikge1xuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSBjaDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c3dpdGNoIChjaCkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnZCc6IGNhc2UgJ20nOiBjYXNlICdvJzogY2FzZSAndyc6XG5cdFx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSAoaGFzTnVtID8gJycgOiAnMDEyMzQ1Njc4OScpOyBoYXNOdW0gPSB0cnVlOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3knOiBjYXNlICdAJzogY2FzZSAnISc6XG5cdFx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSAoaGFzTnVtID8gJycgOiAnMDEyMzQ1Njc4OScpICsgJy0nOyBoYXNOdW0gPSB0cnVlOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0onOlxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gKGhhc051bSA/ICcnIDogJzAxMjM0NTY3ODknKSArICctLic7IGhhc051bSA9IHRydWU7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnRCc6IGNhc2UgJ00nOiBjYXNlICdZJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdFx0aWYgKGRhdGVGb3JtYXQuY2hhckF0KGkgKyAxKSA9PT0gXCInXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRhbGxvd2VkQ2hhcnMgKz0gY2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWxsb3dlZENoYXJzO1xuXHRcdH0sXG5cblx0XHQvKiogU3luY2hyb25pc2UgZGF0ZXBpY2tlciB3aXRoIHRoZSBmaWVsZC5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZXZlbnQge0tleUV2ZW50fSBUaGUga2V5c3Ryb2tlLlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYWxsb3dlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdCBhbGxvd2VkLiAqL1xuXHRcdF9rZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBlbGVtID0gKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lbGVtKSB8fCBldmVudC50YXJnZXQ7XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmICFpbnN0LmN0cmxLZXkgJiYgaW5zdC5sYXN0VmFsICE9PSBpbnN0LmVsZW0udmFsKCkpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgZGF0ZXMgPSBwbHVnaW4uX2V4dHJhY3REYXRlcyhpbnN0LCBpbnN0LmVsZW0udmFsKCkpO1xuXHRcdFx0XHRcdGlmIChkYXRlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRwbHVnaW4uc2V0RGF0ZShlbGVtLCBkYXRlcywgbnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChldmVudCkge1xuXHRcdFx0XHRcdC8vIElnbm9yZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqIEluY3JlbWVudC9kZWNyZW1lbnQgbW9udGgveWVhciBvbiBtb3VzZSB3aGVlbCBhY3Rpdml0eS5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZXZlbnQge2V2ZW50fSBUaGUgbW91c2Ugd2hlZWwgZXZlbnQuXG5cdFx0XHRAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIGFtb3VudCBvZiBjaGFuZ2UuICovXG5cdFx0X2RvTW91c2VXaGVlbDogZnVuY3Rpb24oZXZlbnQsIGRlbHRhKSB7XG5cdFx0XHR2YXIgZWxlbSA9IChwbHVnaW4uY3VySW5zdCAmJiBwbHVnaW4uY3VySW5zdC5lbGVtWzBdKSB8fFxuXHRcdFx0XHQkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLicgKyBwbHVnaW4uX2dldE1hcmtlcigpKVswXTtcblx0XHRcdGlmIChwbHVnaW4uaXNEaXNhYmxlZChlbGVtKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMudXNlTW91c2VXaGVlbCkge1xuXHRcdFx0XHRkZWx0YSA9IChkZWx0YSA8IDAgPyAtMSA6ICsxKTtcblx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKGVsZW0sIC1pbnN0Lm9wdGlvbnNbZXZlbnQuY3RybEtleSA/ICdtb250aHNUb0p1bXAnIDogJ21vbnRoc1RvU3RlcCddICogZGVsdGEpO1xuXHRcdFx0fVxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9LFxuXG5cdFx0LyoqIENsZWFyIGFuIGlucHV0IGFuZCBjbG9zZSBhIHBvcHVwIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gdXNlLlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2NsZWFyJykgKi9cblx0XHRjbGVhcjogZnVuY3Rpb24oZWxlbSkge1xuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW107XG5cdFx0XHRcdHRoaXMuaGlkZShlbGVtKTtcblx0XHRcdFx0dmFyIGRlZmF1bHREYXRlID0gaW5zdC5nZXQoJ2RlZmF1bHREYXRlJyk7XG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuc2VsZWN0RGVmYXVsdERhdGUgJiYgZGVmYXVsdERhdGUpIHtcblx0XHRcdFx0XHR0aGlzLnNldERhdGUoZWxlbSwgKGRlZmF1bHREYXRlIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUlucHV0KGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgc2VsZWN0ZWQgZGF0ZShzKSBmb3IgYSBkYXRlcGlja2VyLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZVtdfSBUaGUgc2VsZWN0ZWQgZGF0ZShzKS5cblx0XHRcdEBleGFtcGxlIHZhciBkYXRlcyA9ICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdnZXREYXRlJykgKi9cblx0XHRnZXREYXRlOiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRyZXR1cm4gKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgPyBpbnN0LnNlbGVjdGVkRGF0ZXMgOiBbXSk7XG5cdFx0fSxcblxuXHRcdC8qKiBTZXQgdGhlIHNlbGVjdGVkIGRhdGUocykgZm9yIGEgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSB0aGUgY29udHJvbCB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIGRhdGVzIHtDRGF0ZXxudW1iZXJ8c3RyaW5nfGFycmF5fSB0aGUgc2VsZWN0ZWQgZGF0ZShzKS5cblx0XHRcdEBwYXJhbSBbZW5kRGF0ZV0ge0NEYXRlfG51bWJlcnxzdHJpbmd9IHRoZSBlbmRpbmcgZGF0ZSBmb3IgYSByYW5nZS5cblx0XHRcdEBwYXJhbSBba2V5VXBdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21pbmcgZnJvbSA8Y29kZT5rZXlVcDwvY29kZT4gcHJvY2Vzc2luZyAoaW50ZXJuYWwpLlxuXHRcdFx0QHBhcmFtIFtzZXRPcHRdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21pbmcgZnJvbSBvcHRpb24gcHJvY2Vzc2luZyAoaW50ZXJuYWwpLlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ3NldERhdGUnLCBuZXcgRGF0ZSgyMDE0LCAxMi0xLCAyNSkpXG4gJChzZWxlY3RvcikuZGF0ZXBpY2soJ3NldERhdGUnLCAnMTIvMjUvMjAxNCcsICcwMS8wMS8yMDE1JylcbiAkKHNlbGVjdG9yKS5kYXRlcGljaygnc2V0RGF0ZScsIFtkYXRlMSwgZGF0ZTIsIGRhdGUzXSkgKi9cblx0XHRzZXREYXRlOiBmdW5jdGlvbihlbGVtLCBkYXRlcywgZW5kRGF0ZSwga2V5VXAsIHNldE9wdCkge1xuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcblx0XHRcdFx0aWYgKCEkLmlzQXJyYXkoZGF0ZXMpKSB7XG5cdFx0XHRcdFx0ZGF0ZXMgPSBbZGF0ZXNdO1xuXHRcdFx0XHRcdGlmIChlbmREYXRlKSB7XG5cdFx0XHRcdFx0XHRkYXRlcy5wdXNoKGVuZERhdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuZ2V0KCdtaW5EYXRlJyk7XG5cdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcblx0XHRcdFx0dmFyIGN1ckRhdGUgPSBpbnN0LnNlbGVjdGVkRGF0ZXNbMF07XG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGRhdGUgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGV0ZXJtaW5lRGF0ZShcblx0XHRcdFx0XHRcdGRhdGVzW2ldLCBudWxsLCBjdXJEYXRlLCBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpLCBpbnN0LmdldENvbmZpZygpKTtcblx0XHRcdFx0XHRpZiAoZGF0ZSkge1xuXHRcdFx0XHRcdFx0aWYgKCghbWluRGF0ZSB8fCBkYXRlLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXG5cdFx0XHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGRhdGUuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluc3Quc2VsZWN0ZWREYXRlc1tqXS5jb21wYXJlVG8oZGF0ZSkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzLnB1c2goZGF0ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzLnNwbGljZShpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgfHxcblx0XHRcdFx0XHQoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gMiA6IDEpLCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoKTtcblx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCkge1xuXHRcdFx0XHRcdHN3aXRjaCAoaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y2FzZSAxOiBpbnN0LnNlbGVjdGVkRGF0ZXNbMV0gPSBpbnN0LnNlbGVjdGVkRGF0ZXNbMF07IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAyOiBpbnN0LnNlbGVjdGVkRGF0ZXNbMV0gPVxuXHRcdFx0XHRcdFx0XHQoaW5zdC5zZWxlY3RlZERhdGVzWzBdLmNvbXBhcmVUbyhpbnN0LnNlbGVjdGVkRGF0ZXNbMV0pID09PSArMSA/XG5cdFx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlc1swXSA6IGluc3Quc2VsZWN0ZWREYXRlc1sxXSk7IGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSAoaW5zdC5kcmF3RGF0ZSA/IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpIDogbnVsbCk7XG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgPSB0aGlzLl9jaGVja01pbk1heCgoaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8XG5cdFx0XHRcdFx0aW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSwgaW5zdCk7XG5cdFx0XHRcdGlmICghc2V0T3B0KSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW0pO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUlucHV0KGVsZW0sIGtleVVwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgYSBkYXRlIGlzIHNlbGVjdGFibGUgZm9yIHRoaXMgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gY2hlY2suXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV8c3RyaW5nfG51bWJlcn0gVGhlIGRhdGUgdG8gY2hlY2suXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBzZWxlY3RhYmxlLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxuXHRcdFx0QGV4YW1wbGUgdmFyIHNlbGVjdGFibGUgPSAkKHNlbGVjdG9yKS5kYXRlcGljaygnaXNTZWxlY3RhYmxlJywgZGF0ZSkgKi9cblx0XHRpc1NlbGVjdGFibGU6IGZ1bmN0aW9uKGVsZW0sIGRhdGUpIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICgkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZGF0ZSA9IGluc3Qub3B0aW9ucy5jYWxlbmRhci5kZXRlcm1pbmVEYXRlKGRhdGUsXG5cdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKSwgbnVsbCxcblx0XHRcdFx0aW5zdC5vcHRpb25zLmRhdGVGb3JtYXQsIGluc3QuZ2V0Q29uZmlnKCkpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2lzU2VsZWN0YWJsZShlbGVtLCBkYXRlLCBpbnN0Lm9wdGlvbnMub25EYXRlLFxuXHRcdFx0XHRpbnN0LmdldCgnbWluRGF0ZScpLCBpbnN0LmdldCgnbWF4RGF0ZScpKTtcblx0XHR9LFxuXG5cdFx0LyoqIEludGVybmFsbHkgZGV0ZXJtaW5lIHdoZXRoZXIgYSBkYXRlIGlzIHNlbGVjdGFibGUgZm9yIHRoaXMgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gdGhlIGNvbnRyb2wgdG8gY2hlY2suXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBkYXRlIHRvIGNoZWNrLlxuXHRcdFx0QHBhcmFtIG9uRGF0ZSB7ZnVuY3Rpb258Ym9vbGVhbn0gQW55IDxjb2RlPm9uRGF0ZTwvY29kZT4gY2FsbGJhY2sgb3IgPGNvZGU+Y2FsbGJhY2suc2VsZWN0YWJsZTwvY29kZT4uXG5cdFx0XHRAcGFyYW0gbWluRGF0ZSB7Q0RhdGV9IFRoZSBtaW5pbXVtIGFsbG93ZWQgZGF0ZS5cblx0XHRcdEBwYXJhbSBtYXhEYXRlIHtDRGF0ZX0gVGhlIG1heGltdW0gYWxsb3dlZCBkYXRlLlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgc2VsZWN0YWJsZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cblx0XHRfaXNTZWxlY3RhYmxlOiBmdW5jdGlvbihlbGVtLCBkYXRlLCBvbkRhdGUsIG1pbkRhdGUsIG1heERhdGUpIHtcblx0XHRcdHZhciBkYXRlSW5mbyA9ICh0eXBlb2Ygb25EYXRlID09PSAnYm9vbGVhbicgPyB7c2VsZWN0YWJsZTogb25EYXRlfSA6XG5cdFx0XHRcdCghJC5pc0Z1bmN0aW9uKG9uRGF0ZSkgPyB7fSA6IG9uRGF0ZS5hcHBseShlbGVtLCBbZGF0ZSwgdHJ1ZV0pKSk7XG5cdFx0XHRyZXR1cm4gKGRhdGVJbmZvLnNlbGVjdGFibGUgIT09IGZhbHNlKSAmJlxuXHRcdFx0XHQoIW1pbkRhdGUgfHwgZGF0ZS50b0pEKCkgPj0gbWluRGF0ZS50b0pEKCkpICYmICghbWF4RGF0ZSB8fCBkYXRlLnRvSkQoKSA8PSBtYXhEYXRlLnRvSkQoKSk7XG5cdFx0fSxcblxuXHRcdC8qKiBQZXJmb3JtIGEgbmFtZWQgYWN0aW9uIGZvciBhIGRhdGVwaWNrZXIuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcGFyYW0gZWxlbSB7ZWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxuXHRcdFx0QHBhcmFtIGFjdGlvbiB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgYWN0aW9uLiAqL1xuXHRcdHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKGVsZW0sIGFjdGlvbikge1xuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgIXRoaXMuaXNEaXNhYmxlZChlbGVtKSkge1xuXHRcdFx0XHR2YXIgY29tbWFuZHMgPSBpbnN0Lm9wdGlvbnMuY29tbWFuZHM7XG5cdFx0XHRcdGlmIChjb21tYW5kc1thY3Rpb25dICYmIGNvbW1hbmRzW2FjdGlvbl0uZW5hYmxlZC5hcHBseShlbGVtLCBbaW5zdF0pKSB7XG5cdFx0XHRcdFx0Y29tbWFuZHNbYWN0aW9uXS5hY3Rpb24uYXBwbHkoZWxlbSwgW2luc3RdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogU2V0IHRoZSBjdXJyZW50bHkgc2hvd24gbW9udGgsIGRlZmF1bHRpbmcgdG8gdG9kYXkncy5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAcGFyYW0gW3llYXJdIHtudW1iZXJ9IFRoZSB5ZWFyIHRvIHNob3cuXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gc2hvdyAoMS0xMikuXG5cdFx0XHRAcGFyYW0gW2RheV0ge251bWJlcn0gVGhlIGRheSB0byBzaG93LlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ3Nob3dNb250aCcsIDIwMTQsIDEyLCAyNSkgKi9cblx0XHRzaG93TW9udGg6IGZ1bmN0aW9uKGVsZW0sIHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmIChkYXkgIT0gbnVsbCB8fFxuXHRcdFx0XHRcdChpbnN0LmRyYXdEYXRlLnllYXIoKSAhPT0geWVhciB8fCBpbnN0LmRyYXdEYXRlLm1vbnRoKCkgIT09IG1vbnRoKSkpIHtcblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpO1xuXHRcdFx0XHR2YXIgY2FsZW5kYXIgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXI7XG5cdFx0XHRcdHZhciBzaG93ID0gdGhpcy5fY2hlY2tNaW5NYXgoKHllYXIgIT0gbnVsbCA/XG5cdFx0XHRcdFx0Y2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgMSkgOiBjYWxlbmRhci50b2RheSgpKSwgaW5zdCk7XG5cdFx0XHRcdGluc3QuZHJhd0RhdGUuZGF0ZShzaG93LnllYXIoKSwgc2hvdy5tb250aCgpLCBcblx0XHRcdFx0XHQoZGF5ICE9IG51bGwgPyBkYXkgOiBNYXRoLm1pbihpbnN0LmRyYXdEYXRlLmRheSgpLFxuXHRcdFx0XHRcdGNhbGVuZGFyLmRheXNJbk1vbnRoKHNob3cueWVhcigpLCBzaG93Lm1vbnRoKCkpKSkpO1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBBZGp1c3QgdGhlIGN1cnJlbnRseSBzaG93biBtb250aC5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbW9udGhzIHRvIGNoYW5nZSBieS5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdjaGFuZ2VNb250aCcsIDIpKi9cblx0XHRjaGFuZ2VNb250aDogZnVuY3Rpb24oZWxlbSwgb2Zmc2V0KSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xuXHRcdFx0XHR2YXIgZGF0ZSA9IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZChvZmZzZXQsICdtJyk7XG5cdFx0XHRcdHRoaXMuc2hvd01vbnRoKGVsZW0sIGRhdGUueWVhcigpLCBkYXRlLm1vbnRoKCkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogQWRqdXN0IHRoZSBjdXJyZW50bHkgc2hvd24gZGF5LlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIG51bWJlciBvZiBkYXlzIHRvIGNoYW5nZSBieS5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdjaGFuZ2VEYXknLCA3KSovXG5cdFx0Y2hhbmdlRGF5OiBmdW5jdGlvbihlbGVtLCBvZmZzZXQpIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XG5cdFx0XHRcdHZhciBkYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKG9mZnNldCwgJ2QnKTtcblx0XHRcdFx0dGhpcy5zaG93TW9udGgoZWxlbSwgZGF0ZS55ZWFyKCksIGRhdGUubW9udGgoKSwgZGF0ZS5kYXkoKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBSZXN0cmljdCBhIGRhdGUgdG8gdGhlIG1pbmltdW0vbWF4aW11bSBzcGVjaWZpZWQuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgZGF0ZSB0byBjaGVjay5cblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLiAqL1xuXHRcdF9jaGVja01pbk1heDogZnVuY3Rpb24oZGF0ZSwgaW5zdCkge1xuXHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmdldCgnbWluRGF0ZScpO1xuXHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xuXHRcdFx0ZGF0ZSA9IChtaW5EYXRlICYmIGRhdGUuY29tcGFyZVRvKG1pbkRhdGUpID09PSAtMSA/IG1pbkRhdGUubmV3RGF0ZSgpIDogZGF0ZSk7XG5cdFx0XHRkYXRlID0gKG1heERhdGUgJiYgZGF0ZS5jb21wYXJlVG8obWF4RGF0ZSkgPT09ICsxID8gbWF4RGF0ZS5uZXdEYXRlKCkgOiBkYXRlKTtcblx0XHRcdHJldHVybiBkYXRlO1xuXHRcdH0sXG5cblx0XHQvKiogUmV0cmlldmUgdGhlIGRhdGUgYXNzb2NpYXRlZCB3aXRoIGFuIGVudHJ5IGluIHRoZSBkYXRlcGlja2VyLlxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGV4YW1pbmUuXG5cdFx0XHRAcGFyYW0gdGFyZ2V0IHtFbGVtZW50fSBUaGUgc2VsZWN0ZWQgZGF0ZXBpY2tlciBlbGVtZW50LlxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IFRoZSBjb3JyZXNwb25kaW5nIGRhdGUsIG9yIDxjb2RlPm51bGw8L2NvZGU+Llx0XHRcdFxuXHRcdFx0QGV4YW1wbGUgdmFyIGRhdGUgPSAkKHNlbGVjdG9yKS5kYXRlcGljaygncmV0cmlldmVEYXRlJywgJCgnZGl2LmRhdGVwaWNrLXBvcHVwIGE6Y29udGFpbnMoMTApJylbMF0pICovXG5cdFx0cmV0cmlldmVEYXRlOiBmdW5jdGlvbihlbGVtLCB0YXJnZXQpIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdHJldHVybiAoJC5pc0VtcHR5T2JqZWN0KGluc3QpID8gbnVsbCA6IGluc3Qub3B0aW9ucy5jYWxlbmRhci5mcm9tSkQoXG5cdFx0XHRcdHBhcnNlRmxvYXQodGFyZ2V0LmNsYXNzTmFtZS5yZXBsYWNlKC9eLipqZChcXGQrXFwuNSkuKiQvLCAnJDEnKSkpKTtcblx0XHR9LFxuXG5cdFx0LyoqIFNlbGVjdCBhIGRhdGUgZm9yIHRoaXMgZGF0ZXBpY2tlci5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxuXHRcdFx0QHBhcmFtIHRhcmdldCB7RWxlbWVudH0gVGhlIHNlbGVjdGVkIGRhdGVwaWNrZXIgZWxlbWVudC5cblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzZWxlY3REYXRlJywgJCgnZGl2LmRhdGVwaWNrLXBvcHVwIGE6Y29udGFpbnMoMTApJylbMF0pICovXG5cdFx0c2VsZWN0RGF0ZTogZnVuY3Rpb24oZWxlbSwgdGFyZ2V0KSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiAhdGhpcy5pc0Rpc2FibGVkKGVsZW0pKSB7XG5cdFx0XHRcdHZhciBkYXRlID0gdGhpcy5yZXRyaWV2ZURhdGUoZWxlbSwgdGFyZ2V0KTtcblx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCkge1xuXHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGF0ZS5jb21wYXJlVG8oaW5zdC5zZWxlY3RlZERhdGVzW2ldKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIWZvdW5kICYmIGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGggPCBpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QpIHtcblx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcy5wdXNoKGRhdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QpIHtcblx0XHRcdFx0XHRpZiAoaW5zdC5waWNraW5nUmFuZ2UpIHtcblx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlc1sxXSA9IGRhdGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW2RhdGUsIGRhdGVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9ICFpbnN0LnBpY2tpbmdSYW5nZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbZGF0ZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC5wcmV2RGF0ZSA9IGluc3QuZHJhd0RhdGUgPSBkYXRlLm5ld0RhdGUoKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlSW5wdXQoZWxlbSk7XG5cdFx0XHRcdGlmIChpbnN0LmlubGluZSB8fCBpbnN0LnBpY2tpbmdSYW5nZSB8fCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDxcblx0XHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgfHwgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IDIgOiAxKSkpIHtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlKGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBHZW5lcmF0ZSB0aGUgZGF0ZXBpY2tlciBjb250ZW50IGZvciB0aGlzIGNvbnRyb2wuXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHJldHVybiB7alF1ZXJ5fSBUaGUgZGF0ZXBpY2tlciBjb250ZW50ICovXG5cdFx0X2dlbmVyYXRlQ29udGVudDogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xuXHRcdFx0dmFyIG1vbnRoc1RvU2hvdyA9IGluc3Qub3B0aW9ucy5tb250aHNUb1Nob3c7XG5cdFx0XHRtb250aHNUb1Nob3cgPSAoJC5pc0FycmF5KG1vbnRoc1RvU2hvdykgPyBtb250aHNUb1Nob3cgOiBbMSwgbW9udGhzVG9TaG93XSk7XG5cdFx0XHRpbnN0LmRyYXdEYXRlID0gdGhpcy5fY2hlY2tNaW5NYXgoXG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgfHwgaW5zdC5nZXQoJ2RlZmF1bHREYXRlJykgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCksIGluc3QpO1xuXHRcdFx0dmFyIGRyYXdEYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKC1pbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpO1xuXHRcdFx0Ly8gR2VuZXJhdGUgbW9udGhzXG5cdFx0XHR2YXIgbW9udGhSb3dzID0gJyc7XG5cdFx0XHRmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb250aHNUb1Nob3dbMF07IHJvdysrKSB7XG5cdFx0XHRcdHZhciBtb250aHMgPSAnJztcblx0XHRcdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9udGhzVG9TaG93WzFdOyBjb2wrKykge1xuXHRcdFx0XHRcdG1vbnRocyArPSB0aGlzLl9nZW5lcmF0ZU1vbnRoKGVsZW0sIGluc3QsIGRyYXdEYXRlLnllYXIoKSxcblx0XHRcdFx0XHRcdGRyYXdEYXRlLm1vbnRoKCksIGluc3Qub3B0aW9ucy5jYWxlbmRhciwgaW5zdC5vcHRpb25zLnJlbmRlcmVyLCAocm93ID09PSAwICYmIGNvbCA9PT0gMCkpO1xuXHRcdFx0XHRcdGRyYXdEYXRlLmFkZCgxLCAnbScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1vbnRoUm93cyArPSB0aGlzLl9wcmVwYXJlKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tb250aFJvdywgaW5zdCkucmVwbGFjZSgvXFx7bW9udGhzXFx9LywgbW9udGhzKTtcblx0XHRcdH1cblx0XHRcdHZhciBwaWNrZXIgPSB0aGlzLl9wcmVwYXJlKGluc3Qub3B0aW9ucy5yZW5kZXJlci5waWNrZXIsIGluc3QpLnJlcGxhY2UoL1xce21vbnRoc1xcfS8sIG1vbnRoUm93cykuXG5cdFx0XHRcdHJlcGxhY2UoL1xce3dlZWtIZWFkZXJcXH0vZywgdGhpcy5fZ2VuZXJhdGVEYXlIZWFkZXJzKGluc3QsIGluc3Qub3B0aW9ucy5jYWxlbmRhciwgaW5zdC5vcHRpb25zLnJlbmRlcmVyKSk7XG5cdFx0XHQvLyBBZGQgY29tbWFuZHNcblx0XHRcdHZhciBhZGRDb21tYW5kID0gZnVuY3Rpb24odHlwZSwgb3BlbiwgY2xvc2UsIG5hbWUsIGNsYXNzZXMpIHtcblx0XHRcdFx0aWYgKHBpY2tlci5pbmRleE9mKCd7JyArIHR5cGUgKyAnOicgKyBuYW1lICsgJ30nKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNvbW1hbmQgPSBpbnN0Lm9wdGlvbnMuY29tbWFuZHNbbmFtZV07XG5cdFx0XHRcdHZhciBkYXRlID0gKGluc3Qub3B0aW9ucy5jb21tYW5kc0FzRGF0ZUZvcm1hdCA/IGNvbW1hbmQuZGF0ZS5hcHBseShlbGVtLCBbaW5zdF0pIDogbnVsbCk7XG5cdFx0XHRcdHBpY2tlciA9IHBpY2tlci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFx7JyArIHR5cGUgKyAnOicgKyBuYW1lICsgJ1xcXFx9JywgJ2cnKSxcblx0XHRcdFx0XHQnPCcgKyBvcGVuICsgKGNvbW1hbmQuc3RhdHVzID8gJyB0aXRsZT1cIicgKyBpbnN0Lm9wdGlvbnNbY29tbWFuZC5zdGF0dXNdICsgJ1wiJyA6ICcnKSArXG5cdFx0XHRcdFx0JyBjbGFzcz1cIicgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZENsYXNzICsgJyAnICtcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZENsYXNzICsgJy0nICsgbmFtZSArICcgJyArIGNsYXNzZXMgK1xuXHRcdFx0XHRcdChjb21tYW5kLmVuYWJsZWQoaW5zdCkgPyAnJyA6ICcgJyArIGluc3Qub3B0aW9ucy5yZW5kZXJlci5kaXNhYmxlZENsYXNzKSArICdcIj4nICtcblx0XHRcdFx0XHQoZGF0ZSA/IGRhdGUuZm9ybWF0RGF0ZShpbnN0Lm9wdGlvbnNbY29tbWFuZC50ZXh0XSkgOlxuXHRcdFx0XHRcdGluc3Qub3B0aW9uc1tjb21tYW5kLnRleHRdKSArICc8LycgKyBjbG9zZSArICc+Jyk7XG5cdFx0XHR9O1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBpbnN0Lm9wdGlvbnMuY29tbWFuZHMpIHtcblx0XHRcdFx0YWRkQ29tbWFuZCgnYnV0dG9uJywgJ2J1dHRvbiB0eXBlPVwiYnV0dG9uXCInLCAnYnV0dG9uJywgbmFtZSxcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZEJ1dHRvbkNsYXNzKTtcblx0XHRcdFx0YWRkQ29tbWFuZCgnbGluaycsICdhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIicsICdhJywgbmFtZSxcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZExpbmtDbGFzcyk7XG5cdFx0XHR9XG5cdFx0XHRwaWNrZXIgPSAkKHBpY2tlcik7XG5cdFx0XHRpZiAobW9udGhzVG9TaG93WzFdID4gMSkge1xuXHRcdFx0XHR2YXIgY291bnQgPSAwO1xuXHRcdFx0XHQkKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tb250aFNlbGVjdG9yLCBwaWNrZXIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIG50aCA9ICsrY291bnQgJSBtb250aHNUb1Nob3dbMV07XG5cdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhudGggPT09IDEgPyAnZmlyc3QnIDogKG50aCA9PT0gMCA/ICdsYXN0JyA6ICcnKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIGRhdGVwaWNrZXIgYmVoYXZpb3VyXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRmdW5jdGlvbiByZW1vdmVIaWdobGlnaHQoKSB7XG5cdFx0XHRcdChpbnN0LmlubGluZSA/ICQodGhpcykuY2xvc2VzdCgnLicgKyBzZWxmLl9nZXRNYXJrZXIoKSkgOiBpbnN0LmRpdikuXG5cdFx0XHRcdFx0ZmluZChpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGF5U2VsZWN0b3IgKyAnIGEnKS5cblx0XHRcdFx0XHRyZW1vdmVDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIuaGlnaGxpZ2h0ZWRDbGFzcyk7XG5cdFx0XHR9XG5cdFx0XHRwaWNrZXIuZmluZChpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGF5U2VsZWN0b3IgKyAnIGEnKS5ob3Zlcihcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUhpZ2hsaWdodC5hcHBseSh0aGlzKTtcblx0XHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVtb3ZlSGlnaGxpZ2h0KS5cblx0XHRcdFx0Y2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5zZWxlY3REYXRlKGVsZW0sIHRoaXMpO1xuXHRcdFx0XHR9KS5lbmQoKS5cblx0XHRcdFx0ZmluZCgnc2VsZWN0LicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArICc6bm90KC4nICsgdGhpcy5fYW55WWVhckNsYXNzICsgJyknKS5cblx0XHRcdFx0Y2hhbmdlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBtb250aFllYXIgPSAkKHRoaXMpLnZhbCgpLnNwbGl0KCcvJyk7XG5cdFx0XHRcdFx0c2VsZi5zaG93TW9udGgoZWxlbSwgcGFyc2VJbnQobW9udGhZZWFyWzFdLCAxMCksIHBhcnNlSW50KG1vbnRoWWVhclswXSwgMTApKTtcblx0XHRcdFx0fSkuZW5kKCkuXG5cdFx0XHRcdGZpbmQoJ3NlbGVjdC4nICsgdGhpcy5fYW55WWVhckNsYXNzKS5jbGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5cblx0XHRcdFx0XHRcdG5leHQoJ2lucHV0JykuY3NzKHtsZWZ0OiB0aGlzLm9mZnNldExlZnQsIHRvcDogdGhpcy5vZmZzZXRUb3AsXG5cdFx0XHRcdFx0XHR3aWR0aDogdGhpcy5vZmZzZXRXaWR0aCwgaGVpZ2h0OiB0aGlzLm9mZnNldEhlaWdodH0pLnNob3coKS5mb2N1cygpO1xuXHRcdFx0XHR9KS5lbmQoKS5cblx0XHRcdFx0ZmluZCgnaW5wdXQuJyArIHNlbGYuX21vbnRoWWVhckNsYXNzKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhciB5ZWFyID0gcGFyc2VJbnQoJCh0aGlzKS52YWwoKSwgMTApO1xuXHRcdFx0XHRcdFx0eWVhciA9IChpc05hTih5ZWFyKSA/IGluc3QuZHJhd0RhdGUueWVhcigpIDogeWVhcik7XG5cdFx0XHRcdFx0XHRzZWxmLnNob3dNb250aChlbGVtLCB5ZWFyLCBpbnN0LmRyYXdEYXRlLm1vbnRoKCksIGluc3QuZHJhd0RhdGUuZGF5KCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0YWxlcnQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KS5rZXlkb3duKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7IC8vIEVudGVyXG5cdFx0XHRcdFx0XHQkKGV2ZW50LmVsZW0pLmNoYW5nZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAyNykgeyAvLyBFc2NhcGVcblx0XHRcdFx0XHRcdCQoZXZlbnQuZWxlbSkuaGlkZSgpLnByZXYoJ3NlbGVjdCcpLmNzcygndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG5cdFx0XHRcdFx0XHRpbnN0LmVsZW0uZm9jdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0Ly8gQWRkIGtleWJvYXJkIGhhbmRsaW5nXG5cdFx0XHR2YXIgZGF0YSA9IHtlbGVtOiBpbnN0LmVsZW1bMF19O1xuXHRcdFx0cGlja2VyLmtleWRvd24oZGF0YSwgdGhpcy5fa2V5RG93bikua2V5cHJlc3MoZGF0YSwgdGhpcy5fa2V5UHJlc3MpLmtleXVwKGRhdGEsIHRoaXMuX2tleVVwKTtcblx0XHRcdC8vIEFkZCBjb21tYW5kIGJlaGF2aW91clxuXHRcdFx0cGlja2VyLmZpbmQoJy4nICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcykuY2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCEkKHRoaXMpLmhhc0NsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5kaXNhYmxlZENsYXNzKSkge1xuXHRcdFx0XHRcdFx0dmFyIGFjdGlvbiA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdG5ldyBSZWdFeHAoJ14uKicgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZENsYXNzICsgJy0oW14gXSspLiokJyksICckMScpO1xuXHRcdFx0XHRcdFx0cGx1Z2luLnBlcmZvcm1BY3Rpb24oZWxlbSwgYWN0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0Ly8gQWRkIGNsYXNzZXNcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuaXNSVEwpIHtcblx0XHRcdFx0cGlja2VyLmFkZENsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5ydGxDbGFzcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9udGhzVG9TaG93WzBdICogbW9udGhzVG9TaG93WzFdID4gMSkge1xuXHRcdFx0XHRwaWNrZXIuYWRkQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLm11bHRpQ2xhc3MpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5waWNrZXJDbGFzcykge1xuXHRcdFx0XHRwaWNrZXIuYWRkQ2xhc3MoaW5zdC5vcHRpb25zLnBpY2tlckNsYXNzKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlc2l6ZVxuXHRcdFx0JCgnYm9keScpLmFwcGVuZChwaWNrZXIpO1xuXHRcdFx0dmFyIHdpZHRoID0gMDtcblx0XHRcdHBpY2tlci5maW5kKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tb250aFNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR3aWR0aCArPSAkKHRoaXMpLm91dGVyV2lkdGgoKTtcblx0XHRcdH0pO1xuXHRcdFx0cGlja2VyLndpZHRoKHdpZHRoIC8gbW9udGhzVG9TaG93WzBdKTtcblx0XHRcdC8vIFByZS1zaG93IGN1c3RvbWlzYXRpb25cblx0XHRcdGlmICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uU2hvdykpIHtcblx0XHRcdFx0aW5zdC5vcHRpb25zLm9uU2hvdy5hcHBseShlbGVtLCBbcGlja2VyLCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIsIGluc3RdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaWNrZXI7XG5cdFx0fSxcblxuXHRcdC8qKiBHZW5lcmF0ZSB0aGUgY29udGVudCBmb3IgYSBzaW5nbGUgbW9udGguXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIHllYXIgdG8gZ2VuZXJhdGUuXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG1vbnRoIHRvIGdlbmVyYXRlLlxuXHRcdFx0QHBhcmFtIGNhbGVuZGFyIHtCYXNlQ2FsZW5kYXJ9IFRoZSBjdXJyZW50IGNhbGVuZGFyLlxuXHRcdFx0QHBhcmFtIHJlbmRlcmVyIHtvYmplY3R9IFRoZSByZW5kZXJpbmcgdGVtcGxhdGVzLlxuXHRcdFx0QHBhcmFtIGZpcnN0IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBmaXJzdCBvZiBtdWx0aXBsZSBtb250aHMuXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBtb250aCBjb250ZW50LiAqL1xuXHRcdF9nZW5lcmF0ZU1vbnRoOiBmdW5jdGlvbihlbGVtLCBpbnN0LCB5ZWFyLCBtb250aCwgY2FsZW5kYXIsIHJlbmRlcmVyLCBmaXJzdCkge1xuXHRcdFx0dmFyIGRheXNJbk1vbnRoID0gY2FsZW5kYXIuZGF5c0luTW9udGgoeWVhciwgbW9udGgpO1xuXHRcdFx0dmFyIG1vbnRoc1RvU2hvdyA9IGluc3Qub3B0aW9ucy5tb250aHNUb1Nob3c7XG5cdFx0XHRtb250aHNUb1Nob3cgPSAoJC5pc0FycmF5KG1vbnRoc1RvU2hvdykgPyBtb250aHNUb1Nob3cgOiBbMSwgbW9udGhzVG9TaG93XSk7XG5cdFx0XHR2YXIgZml4ZWRXZWVrcyA9IGluc3Qub3B0aW9ucy5maXhlZFdlZWtzIHx8IChtb250aHNUb1Nob3dbMF0gKiBtb250aHNUb1Nob3dbMV0gPiAxKTtcblx0XHRcdHZhciBmaXJzdERheSA9IGluc3Qub3B0aW9ucy5maXJzdERheTtcblx0XHRcdGZpcnN0RGF5ID0gKGZpcnN0RGF5ID09IG51bGwgPyBjYWxlbmRhci5sb2NhbC5maXJzdERheSA6IGZpcnN0RGF5KTtcblx0XHRcdHZhciBsZWFkRGF5cyA9IChjYWxlbmRhci5kYXlPZldlZWsoeWVhciwgbW9udGgsIGNhbGVuZGFyLm1pbkRheSkgLVxuXHRcdFx0XHRmaXJzdERheSArIGNhbGVuZGFyLmRheXNJbldlZWsoKSkgJSBjYWxlbmRhci5kYXlzSW5XZWVrKCk7XG5cdFx0XHR2YXIgbnVtV2Vla3MgPSAoZml4ZWRXZWVrcyA/IDYgOiBNYXRoLmNlaWwoKGxlYWREYXlzICsgZGF5c0luTW9udGgpIC8gY2FsZW5kYXIuZGF5c0luV2VlaygpKSk7XG5cdFx0XHR2YXIgc2VsZWN0T3RoZXJNb250aHMgPSBpbnN0Lm9wdGlvbnMuc2VsZWN0T3RoZXJNb250aHMgJiYgaW5zdC5vcHRpb25zLnNob3dPdGhlck1vbnRocztcblx0XHRcdHZhciBtaW5EYXRlID0gKGluc3QucGlja2luZ1JhbmdlID8gaW5zdC5zZWxlY3RlZERhdGVzWzBdIDogaW5zdC5nZXQoJ21pbkRhdGUnKSk7XG5cdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XG5cdFx0XHR2YXIgc2hvd1dlZWtzID0gcmVuZGVyZXIud2Vlay5pbmRleE9mKCd7d2Vla09mWWVhcn0nKSA+IC0xO1xuXHRcdFx0dmFyIHRvZGF5ID0gY2FsZW5kYXIudG9kYXkoKTtcblx0XHRcdHZhciBkcmF3RGF0ZSA9IGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIGNhbGVuZGFyLm1pbkRheSk7XG5cdFx0XHRkcmF3RGF0ZS5hZGQoLWxlYWREYXlzIC0gKGZpeGVkV2Vla3MgJiZcblx0XHRcdFx0KGRyYXdEYXRlLmRheU9mV2VlaygpID09PSBmaXJzdERheSB8fCBkcmF3RGF0ZS5kYXlzSW5Nb250aCgpIDwgY2FsZW5kYXIuZGF5c0luV2VlaygpKT9cblx0XHRcdFx0Y2FsZW5kYXIuZGF5c0luV2VlaygpIDogMCksICdkJyk7XG5cdFx0XHR2YXIgamQgPSBkcmF3RGF0ZS50b0pEKCk7XG5cdFx0XHQvLyBHZW5lcmF0ZSB3ZWVrc1xuXHRcdFx0dmFyIHdlZWtzID0gJyc7XG5cdFx0XHRmb3IgKHZhciB3ZWVrID0gMDsgd2VlayA8IG51bVdlZWtzOyB3ZWVrKyspIHtcblx0XHRcdFx0dmFyIHdlZWtPZlllYXIgPSAoIXNob3dXZWVrcyA/ICcnIDogJzxzcGFuIGNsYXNzPVwiamQnICsgamQgKyAnXCI+JyArXG5cdFx0XHRcdFx0KCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMuY2FsY3VsYXRlV2VlaykgP1xuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5jYWxjdWxhdGVXZWVrKGRyYXdEYXRlKSA6IGRyYXdEYXRlLndlZWtPZlllYXIoKSkgKyAnPC9zcGFuPicpO1xuXHRcdFx0XHR2YXIgZGF5cyA9ICcnO1xuXHRcdFx0XHRmb3IgKHZhciBkYXkgPSAwOyBkYXkgPCBjYWxlbmRhci5kYXlzSW5XZWVrKCk7IGRheSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCAmJiBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWQgPSAoZHJhd0RhdGUuY29tcGFyZVRvKGluc3Quc2VsZWN0ZWREYXRlc1swXSkgIT09IC0xICYmXG5cdFx0XHRcdFx0XHRcdGRyYXdEYXRlLmNvbXBhcmVUbyhpbnN0LnNlbGVjdGVkRGF0ZXNbMV0pICE9PSArMSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5zdC5zZWxlY3RlZERhdGVzW2ldLmNvbXBhcmVUbyhkcmF3RGF0ZSkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGRhdGVJbmZvID0gKCEkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uRGF0ZSkgPyB7fSA6XG5cdFx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMub25EYXRlLmFwcGx5KGVsZW0sIFtkcmF3RGF0ZSwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGhdKSk7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGFibGUgPSAoc2VsZWN0T3RoZXJNb250aHMgfHwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGgpICYmXG5cdFx0XHRcdFx0XHR0aGlzLl9pc1NlbGVjdGFibGUoZWxlbSwgZHJhd0RhdGUsIGRhdGVJbmZvLnNlbGVjdGFibGUsIG1pbkRhdGUsIG1heERhdGUpO1xuXHRcdFx0XHRcdGRheXMgKz0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5kYXksIGluc3QpLnJlcGxhY2UoL1xce2RheVxcfS9nLFxuXHRcdFx0XHRcdFx0KHNlbGVjdGFibGUgPyAnPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiJyA6ICc8c3BhbicpICtcblx0XHRcdFx0XHRcdCcgY2xhc3M9XCJqZCcgKyBqZCArICcgJyArIChkYXRlSW5mby5kYXRlQ2xhc3MgfHwgJycpICtcblx0XHRcdFx0XHRcdChzZWxlY3RlZCAmJiAoc2VsZWN0T3RoZXJNb250aHMgfHwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGgpID9cblx0XHRcdFx0XHRcdCcgJyArIHJlbmRlcmVyLnNlbGVjdGVkQ2xhc3MgOiAnJykgK1xuXHRcdFx0XHRcdFx0KHNlbGVjdGFibGUgPyAnICcgKyByZW5kZXJlci5kZWZhdWx0Q2xhc3MgOiAnJykgK1xuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLndlZWtEYXkoKSA/ICcnIDogJyAnICsgcmVuZGVyZXIud2Vla2VuZENsYXNzKSArXG5cdFx0XHRcdFx0XHQoZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGggPyAnJyA6ICcgJyArIHJlbmRlcmVyLm90aGVyTW9udGhDbGFzcykgK1xuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLmNvbXBhcmVUbyh0b2RheSkgPT09IDAgJiYgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGggP1xuXHRcdFx0XHRcdFx0JyAnICsgcmVuZGVyZXIudG9kYXlDbGFzcyA6ICcnKSArXG5cdFx0XHRcdFx0XHQoZHJhd0RhdGUuY29tcGFyZVRvKGluc3QuZHJhd0RhdGUpID09PSAwICYmIGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID9cblx0XHRcdFx0XHRcdCcgJyArIHJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MgOiAnJykgKyAnXCInICtcblx0XHRcdFx0XHRcdChkYXRlSW5mby50aXRsZSB8fCAoaW5zdC5vcHRpb25zLmRheVN0YXR1cyAmJiBzZWxlY3RhYmxlKSA/ICcgdGl0bGU9XCInICtcblx0XHRcdFx0XHRcdChkYXRlSW5mby50aXRsZSB8fCBkcmF3RGF0ZS5mb3JtYXREYXRlKGluc3Qub3B0aW9ucy5kYXlTdGF0dXMpKSArICdcIicgOiAnJykgKyAnPicgK1xuXHRcdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5zaG93T3RoZXJNb250aHMgfHwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGggP1xuXHRcdFx0XHRcdFx0ZGF0ZUluZm8uY29udGVudCB8fCBkcmF3RGF0ZS5kYXkoKSA6ICcmIzE2MDsnKSArXG5cdFx0XHRcdFx0XHQoc2VsZWN0YWJsZSA/ICc8L2E+JyA6ICc8L3NwYW4+JykpO1xuXHRcdFx0XHRcdGRyYXdEYXRlLmFkZCgxLCAnZCcpO1xuXHRcdFx0XHRcdGpkKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2Vla3MgKz0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci53ZWVrLCBpbnN0KS5yZXBsYWNlKC9cXHtkYXlzXFx9L2csIGRheXMpLlxuXHRcdFx0XHRcdHJlcGxhY2UoL1xce3dlZWtPZlllYXJcXH0vZywgd2Vla09mWWVhcik7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbW9udGhIZWFkZXIgPSB0aGlzLl9wcmVwYXJlKHJlbmRlcmVyLm1vbnRoLCBpbnN0KS5tYXRjaCgvXFx7bW9udGhIZWFkZXIoOlteXFx9XSspP1xcfS8pO1xuXHRcdFx0bW9udGhIZWFkZXIgPSAobW9udGhIZWFkZXJbMF0ubGVuZ3RoIDw9IDEzID8gJ01NIHl5eXknIDpcblx0XHRcdFx0bW9udGhIZWFkZXJbMF0uc3Vic3RyaW5nKDEzLCBtb250aEhlYWRlclswXS5sZW5ndGggLSAxKSk7XG5cdFx0XHRtb250aEhlYWRlciA9IChmaXJzdCA/IHRoaXMuX2dlbmVyYXRlTW9udGhTZWxlY3Rpb24oXG5cdFx0XHRcdGluc3QsIHllYXIsIG1vbnRoLCBtaW5EYXRlLCBtYXhEYXRlLCBtb250aEhlYWRlciwgY2FsZW5kYXIsIHJlbmRlcmVyKSA6XG5cdFx0XHRcdGNhbGVuZGFyLmZvcm1hdERhdGUobW9udGhIZWFkZXIsIGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgbW9udGgsIGNhbGVuZGFyLm1pbkRheSkpKTtcblx0XHRcdHZhciB3ZWVrSGVhZGVyID0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci53ZWVrSGVhZGVyLCBpbnN0KS5cblx0XHRcdFx0cmVwbGFjZSgvXFx7ZGF5c1xcfS9nLCB0aGlzLl9nZW5lcmF0ZURheUhlYWRlcnMoaW5zdCwgY2FsZW5kYXIsIHJlbmRlcmVyKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5tb250aCwgaW5zdCkucmVwbGFjZSgvXFx7bW9udGhIZWFkZXIoOlteXFx9XSspP1xcfS9nLCBtb250aEhlYWRlcikuXG5cdFx0XHRcdHJlcGxhY2UoL1xce3dlZWtIZWFkZXJcXH0vZywgd2Vla0hlYWRlcikucmVwbGFjZSgvXFx7d2Vla3NcXH0vZywgd2Vla3MpO1xuXHRcdH0sXG5cblx0XHQvKiogR2VuZXJhdGUgdGhlIEhUTUwgZm9yIHRoZSBkYXkgaGVhZGVycy5cblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY3VycmVudCBjYWxlbmRhci5cblx0XHRcdEBwYXJhbSByZW5kZXJlciB7b2JqZWN0fSBUaGUgcmVuZGVyaW5nIHRlbXBsYXRlcy5cblx0XHRcdEByZXR1cm4ge3N0cmluZ30gQSB3ZWVrJ3Mgd29ydGggb2YgZGF5IGhlYWRlcnMuICovXG5cdFx0X2dlbmVyYXRlRGF5SGVhZGVyczogZnVuY3Rpb24oaW5zdCwgY2FsZW5kYXIsIHJlbmRlcmVyKSB7XG5cdFx0XHR2YXIgZmlyc3REYXkgPSBpbnN0Lm9wdGlvbnMuZmlyc3REYXk7XG5cdFx0XHRmaXJzdERheSA9IChmaXJzdERheSA9PSBudWxsID8gY2FsZW5kYXIubG9jYWwuZmlyc3REYXkgOiBmaXJzdERheSk7XG5cdFx0XHR2YXIgaGVhZGVyID0gJyc7XG5cdFx0XHRmb3IgKHZhciBkYXkgPSAwOyBkYXkgPCBjYWxlbmRhci5kYXlzSW5XZWVrKCk7IGRheSsrKSB7XG5cdFx0XHRcdHZhciBkb3cgPSAoZGF5ICsgZmlyc3REYXkpICUgY2FsZW5kYXIuZGF5c0luV2VlaygpO1xuXHRcdFx0XHRoZWFkZXIgKz0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci5kYXlIZWFkZXIsIGluc3QpLnJlcGxhY2UoL1xce2RheVxcfS9nLFxuXHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cIicgKyB0aGlzLl9jdXJEb1dDbGFzcyArIGRvdyArICdcIiB0aXRsZT1cIicgK1xuXHRcdFx0XHRcdGNhbGVuZGFyLmxvY2FsLmRheU5hbWVzW2Rvd10gKyAnXCI+JyArIGNhbGVuZGFyLmxvY2FsLmRheU5hbWVzTWluW2Rvd10gKyAnPC9zcGFuPicpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhlYWRlcjtcblx0XHR9LFxuXG5cdFx0LyoqIEdlbmVyYXRlIHNlbGVjdGlvbiBjb250cm9scyBmb3IgbW9udGguXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcGFyYW0geWVhciB7bnVtYmVyfSBUaGUgeWVhciB0byBnZW5lcmF0ZS5cblx0XHRcdEBwYXJhbSBtb250aCB7bnVtYmVyfSBUaGUgbW9udGggdG8gZ2VuZXJhdGUuXG5cdFx0XHRAcGFyYW0gbWluRGF0ZSB7Q0RhdGV9IFRoZSBtaW5pbXVtIGRhdGUgYWxsb3dlZC5cblx0XHRcdEBwYXJhbSBtYXhEYXRlIHtDRGF0ZX0gVGhlIG1heGltdW0gZGF0ZSBhbGxvd2VkLlxuXHRcdFx0QHBhcmFtIG1vbnRoSGVhZGVyIHtzdHJpbmd9IFRoZSBtb250aC95ZWFyIGZvcm1hdC5cblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY3VycmVudCBjYWxlbmRhci5cblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIG1vbnRoIHNlbGVjdGlvbiBjb250ZW50LiAqL1xuXHRcdF9nZW5lcmF0ZU1vbnRoU2VsZWN0aW9uOiBmdW5jdGlvbihpbnN0LCB5ZWFyLCBtb250aCwgbWluRGF0ZSwgbWF4RGF0ZSwgbW9udGhIZWFkZXIsIGNhbGVuZGFyKSB7XG5cdFx0XHRpZiAoIWluc3Qub3B0aW9ucy5jaGFuZ2VNb250aCkge1xuXHRcdFx0XHRyZXR1cm4gY2FsZW5kYXIuZm9ybWF0RGF0ZShtb250aEhlYWRlciwgY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgMSkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTW9udGhzXG5cdFx0XHR2YXIgbW9udGhOYW1lcyA9IGNhbGVuZGFyLmxvY2FsW1xuXHRcdFx0XHQnbW9udGhOYW1lcycgKyAobW9udGhIZWFkZXIubWF0Y2goL21tL2kpID8gJycgOiAnU2hvcnQnKV07XG5cdFx0XHR2YXIgaHRtbCA9IG1vbnRoSGVhZGVyLnJlcGxhY2UoL20rL2ksICdcXFxceDJFJykucmVwbGFjZSgveSsvaSwgJ1xcXFx4MkYnKTtcblx0XHRcdHZhciBzZWxlY3RvciA9ICc8c2VsZWN0IGNsYXNzPVwiJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICtcblx0XHRcdFx0J1wiIHRpdGxlPVwiJyArIGluc3Qub3B0aW9ucy5tb250aFN0YXR1cyArICdcIj4nO1xuXHRcdFx0dmFyIG1heE1vbnRoID0gY2FsZW5kYXIubW9udGhzSW5ZZWFyKHllYXIpICsgY2FsZW5kYXIubWluTW9udGg7XG5cdFx0XHRmb3IgKHZhciBtID0gY2FsZW5kYXIubWluTW9udGg7IG0gPCBtYXhNb250aDsgbSsrKSB7XG5cdFx0XHRcdGlmICgoIW1pbkRhdGUgfHwgY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtLFxuXHRcdFx0XHRcdFx0Y2FsZW5kYXIuZGF5c0luTW9udGgoeWVhciwgbSkgLSAxICsgY2FsZW5kYXIubWluRGF5KS5cblx0XHRcdFx0XHRcdGNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXG5cdFx0XHRcdFx0XHQoIW1heERhdGUgfHwgY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtLCBjYWxlbmRhci5taW5EYXkpLlxuXHRcdFx0XHRcdFx0Y29tcGFyZVRvKG1heERhdGUpICE9PSArMSkpIHtcblx0XHRcdFx0XHRzZWxlY3RvciArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBtICsgJy8nICsgeWVhciArICdcIicgK1xuXHRcdFx0XHRcdFx0KG1vbnRoID09PSBtID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICsgJz4nICtcblx0XHRcdFx0XHRcdG1vbnRoTmFtZXNbbSAtIGNhbGVuZGFyLm1pbk1vbnRoXSArICc8L29wdGlvbj4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzZWxlY3RvciArPSAnPC9zZWxlY3Q+Jztcblx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcXFx4MkUvLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBZZWFyc1xuXHRcdFx0dmFyIHllYXJSYW5nZSA9IGluc3Qub3B0aW9ucy55ZWFyUmFuZ2U7XG5cdFx0XHRpZiAoeWVhclJhbmdlID09PSAnYW55Jykge1xuXHRcdFx0XHRzZWxlY3RvciA9ICc8c2VsZWN0IGNsYXNzPVwiJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICsgJyAnICsgdGhpcy5fYW55WWVhckNsYXNzICtcblx0XHRcdFx0XHQnXCIgdGl0bGU9XCInICsgaW5zdC5vcHRpb25zLnllYXJTdGF0dXMgKyAnXCI+JyArXG5cdFx0XHRcdFx0JzxvcHRpb24+JyArIHllYXIgKyAnPC9vcHRpb24+PC9zZWxlY3Q+JyArXG5cdFx0XHRcdFx0JzxpbnB1dCBjbGFzcz1cIicgKyB0aGlzLl9tb250aFllYXJDbGFzcyArICcgJyArIHRoaXMuX2N1ck1vbnRoQ2xhc3MgK1xuXHRcdFx0XHRcdG1vbnRoICsgJ1wiIHZhbHVlPVwiJyArIHllYXIgKyAnXCI+Jztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR5ZWFyUmFuZ2UgPSB5ZWFyUmFuZ2Uuc3BsaXQoJzonKTtcblx0XHRcdFx0dmFyIHRvZGF5WWVhciA9IGNhbGVuZGFyLnRvZGF5KCkueWVhcigpO1xuXHRcdFx0XHR2YXIgc3RhcnQgPSAoeWVhclJhbmdlWzBdLm1hdGNoKCdjWystXS4qJykgPyB5ZWFyICsgcGFyc2VJbnQoeWVhclJhbmdlWzBdLnN1YnN0cmluZygxKSwgMTApIDpcblx0XHRcdFx0XHQoKHllYXJSYW5nZVswXS5tYXRjaCgnWystXS4qJykgPyB0b2RheVllYXIgOiAwKSArIHBhcnNlSW50KHllYXJSYW5nZVswXSwgMTApKSk7XG5cdFx0XHRcdHZhciBlbmQgPSAoeWVhclJhbmdlWzFdLm1hdGNoKCdjWystXS4qJykgPyB5ZWFyICsgcGFyc2VJbnQoeWVhclJhbmdlWzFdLnN1YnN0cmluZygxKSwgMTApIDpcblx0XHRcdFx0XHQoKHllYXJSYW5nZVsxXS5tYXRjaCgnWystXS4qJykgPyB0b2RheVllYXIgOiAwKSArIHBhcnNlSW50KHllYXJSYW5nZVsxXSwgMTApKSk7XG5cdFx0XHRcdHNlbGVjdG9yID0gJzxzZWxlY3QgY2xhc3M9XCInICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgK1xuXHRcdFx0XHRcdCdcIiB0aXRsZT1cIicgKyBpbnN0Lm9wdGlvbnMueWVhclN0YXR1cyArICdcIj4nO1xuXHRcdFx0XHRzdGFydCA9IGNhbGVuZGFyLm5ld0RhdGUoc3RhcnQgKyAxLCBjYWxlbmRhci5maXJzdE1vbnRoLCBjYWxlbmRhci5taW5EYXkpLmFkZCgtMSwgJ2QnKTtcblx0XHRcdFx0ZW5kID0gY2FsZW5kYXIubmV3RGF0ZShlbmQsIGNhbGVuZGFyLmZpcnN0TW9udGgsIGNhbGVuZGFyLm1pbkRheSk7XG5cdFx0XHRcdHZhciBhZGRZZWFyID0gZnVuY3Rpb24oeSwgeURpc3BsYXkpIHtcblx0XHRcdFx0XHRpZiAoeSAhPT0gMCB8fCBjYWxlbmRhci5oYXNZZWFyWmVybykge1xuXHRcdFx0XHRcdFx0c2VsZWN0b3IgKz0gJzxvcHRpb24gdmFsdWU9XCInICtcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4obW9udGgsIGNhbGVuZGFyLm1vbnRoc0luWWVhcih5KSAtIDEgKyBjYWxlbmRhci5taW5Nb250aCkgK1xuXHRcdFx0XHRcdFx0XHQnLycgKyB5ICsgJ1wiJyArICh5ZWFyID09PSB5ID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICsgJz4nICtcblx0XHRcdFx0XHRcdFx0KHlEaXNwbGF5IHx8IHkpICsgJzwvb3B0aW9uPic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoc3RhcnQudG9KRCgpIDwgZW5kLnRvSkQoKSkge1xuXHRcdFx0XHRcdHN0YXJ0ID0gKG1pbkRhdGUgJiYgbWluRGF0ZS5jb21wYXJlVG8oc3RhcnQpID09PSArMSA/IG1pbkRhdGUgOiBzdGFydCkueWVhcigpO1xuXHRcdFx0XHRcdGVuZCA9IChtYXhEYXRlICYmIG1heERhdGUuY29tcGFyZVRvKGVuZCkgPT09IC0xID8gbWF4RGF0ZSA6IGVuZCkueWVhcigpO1xuXHRcdFx0XHRcdHZhciBlYXJsaWVyTGF0ZXIgPSBNYXRoLmZsb29yKChlbmQgLSBzdGFydCkgLyAyKTtcblx0XHRcdFx0XHRpZiAoIW1pbkRhdGUgfHwgbWluRGF0ZS55ZWFyKCkgPCBzdGFydCkge1xuXHRcdFx0XHRcdFx0YWRkWWVhcihzdGFydCAtIGVhcmxpZXJMYXRlciwgaW5zdC5vcHRpb25zLmVhcmxpZXJUZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9yICh2YXIgeSA9IHN0YXJ0OyB5IDw9IGVuZDsgeSsrKSB7XG5cdFx0XHRcdFx0XHRhZGRZZWFyKHkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIW1heERhdGUgfHwgbWF4RGF0ZS55ZWFyKCkgPiBlbmQpIHtcblx0XHRcdFx0XHRcdGFkZFllYXIoZW5kICsgZWFybGllckxhdGVyLCBpbnN0Lm9wdGlvbnMubGF0ZXJUZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c3RhcnQgPSAobWF4RGF0ZSAmJiBtYXhEYXRlLmNvbXBhcmVUbyhzdGFydCkgPT09IC0xID8gbWF4RGF0ZSA6IHN0YXJ0KS55ZWFyKCk7XG5cdFx0XHRcdFx0ZW5kID0gKG1pbkRhdGUgJiYgbWluRGF0ZS5jb21wYXJlVG8oZW5kKSA9PT0gKzEgPyBtaW5EYXRlIDogZW5kKS55ZWFyKCk7XG5cdFx0XHRcdFx0dmFyIGVhcmxpZXJMYXRlciA9IE1hdGguZmxvb3IoKHN0YXJ0IC0gZW5kKSAvIDIpO1xuXHRcdFx0XHRcdGlmICghbWF4RGF0ZSB8fCBtYXhEYXRlLnllYXIoKSA+IHN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRhZGRZZWFyKHN0YXJ0ICsgZWFybGllckxhdGVyLCBpbnN0Lm9wdGlvbnMuZWFybGllclRleHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKHZhciB5ID0gc3RhcnQ7IHkgPj0gZW5kOyB5LS0pIHtcblx0XHRcdFx0XHRcdGFkZFllYXIoeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghbWluRGF0ZSB8fCBtaW5EYXRlLnllYXIoKSA8IGVuZCkge1xuXHRcdFx0XHRcdFx0YWRkWWVhcihlbmQgLSBlYXJsaWVyTGF0ZXIsIGluc3Qub3B0aW9ucy5sYXRlclRleHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxlY3RvciArPSAnPC9zZWxlY3Q+Jztcblx0XHRcdH1cblx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcXFx4MkYvLCBzZWxlY3Rvcik7XG5cdFx0XHRyZXR1cm4gaHRtbDtcblx0XHR9LFxuXG5cdFx0LyoqIFByZXBhcmUgYSByZW5kZXIgdGVtcGxhdGUgZm9yIHVzZS5cblx0XHRcdEV4Y2x1ZGUgcG9wdXAvaW5saW5lIHNlY3Rpb25zIHRoYXQgYXJlIG5vdCBhcHBsaWNhYmxlLlxuXHRcdFx0TG9jYWxpc2UgdGV4dCBvZiB0aGUgZm9ybToge2wxMG46bmFtZX0uXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIHRleHQge3N0cmluZ30gVGhlIHRleHQgdG8gbG9jYWxpc2UuXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIGxvY2FsaXNlZCB0ZXh0LiAqL1xuXHRcdF9wcmVwYXJlOiBmdW5jdGlvbih0ZXh0LCBpbnN0KSB7XG5cdFx0XHR2YXIgcmVwbGFjZVNlY3Rpb24gPSBmdW5jdGlvbih0eXBlLCByZXRhaW4pIHtcblx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSB0ZXh0LmluZGV4T2YoJ3snICsgdHlwZSArICc6c3RhcnR9Jyk7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgZW5kID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQpLmluZGV4T2YoJ3snICsgdHlwZSArICc6ZW5kfScpO1xuXHRcdFx0XHRcdGlmIChlbmQgPiAtMSkge1xuXHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0KSArXG5cdFx0XHRcdFx0XHRcdChyZXRhaW4gPyB0ZXh0LnN1YnN0cihzdGFydCArIHR5cGUubGVuZ3RoICsgOCwgZW5kIC0gdHlwZS5sZW5ndGggLSA4KSA6ICcnKSArXG5cdFx0XHRcdFx0XHRcdHRleHQuc3Vic3RyaW5nKHN0YXJ0ICsgZW5kICsgdHlwZS5sZW5ndGggKyA2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRyZXBsYWNlU2VjdGlvbignaW5saW5lJywgaW5zdC5pbmxpbmUpO1xuXHRcdFx0cmVwbGFjZVNlY3Rpb24oJ3BvcHVwJywgIWluc3QuaW5saW5lKTtcblx0XHRcdHZhciBwYXR0ZXJuID0gL1xce2wxMG46KFteXFx9XSspXFx9Lztcblx0XHRcdHZhciBtYXRjaGVzID0gbnVsbDtcblx0XHRcdHdoaWxlIChtYXRjaGVzID0gcGF0dGVybi5leGVjKHRleHQpKSB7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UobWF0Y2hlc1swXSwgaW5zdC5vcHRpb25zW21hdGNoZXNbMV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fSk7XG5cblx0dmFyIHBsdWdpbiA9ICQuY2FsZW5kYXJzUGlja2VyOyAvLyBTaW5nbGV0b24gaW5zdGFuY2VcblxuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdCQoZG9jdW1lbnQpLm9uKCdtb3VzZWRvd24uJyArIHBsdWdpbk5hbWUsIHBsdWdpbi5fY2hlY2tFeHRlcm5hbENsaWNrKS5cblx0XHRcdG9uKCdyZXNpemUuJyArIHBsdWdpbk5hbWUsIGZ1bmN0aW9uKCkgeyBwbHVnaW4uaGlkZShwbHVnaW4uY3VySW5zdCk7IH0pO1xuXHR9KTtcblxufSkoalF1ZXJ5KTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
