/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/*
 jQuery UI Sortable plugin wrapper

 @param [ui-sortable] {object} Options to pass to $.fn.sortable() merged onto ui.config
 */
angular.module('ui.sortable', [])
  .value('uiSortableConfig',{})
  .directive('uiSortable', [
    'uiSortableConfig', '$timeout', '$log',
    function(uiSortableConfig, $timeout, $log) {
      return {
        require: '?ngModel',
        link: function(scope, element, attrs, ngModel) {
          var savedNodes;

          function combineCallbacks(first,second){
            if(second && (typeof second === 'function')) {
              return function(e, ui) {
                first(e, ui);
                second(e, ui);
              };
            }
            return first;
          }

          function hasSortingHelper (element, ui) {
            var helperOption = element.sortable('option','helper');
            return helperOption === 'clone' || (typeof helperOption === 'function' && ui.item.sortable.isCustomHelperUsed());
          }

          // thanks jquery-ui
          function isFloating (item) {
            return (/left|right/).test(item.css('float')) || (/inline|table-cell/).test(item.css('display'));
          }

          function afterStop(e, ui) {
            ui.item.sortable._destroy();
          }

          var opts = {};

          // directive specific options
          var directiveOpts = {
            'ui-floating': undefined
          };

          var callbacks = {
            receive: null,
            remove:null,
            start:null,
            stop:null,
            update:null
          };

          var wrappers = {
            helper: null
          };

          angular.extend(opts, directiveOpts, uiSortableConfig, scope.$eval(attrs.uiSortable));

          if (!angular.element.fn || !angular.element.fn.jquery) {
            $log.error('ui.sortable: jQuery should be included before AngularJS!');
            return;
          }

          if (ngModel) {

            // When we add or remove elements, we need the sortable to 'refresh'
            // so it can find the new/removed elements.
            scope.$watch(attrs.ngModel+'.length', function() {
              // Timeout to let ng-repeat modify the DOM
              $timeout(function() {
                // ensure that the jquery-ui-sortable widget instance
                // is still bound to the directive's element
                if (!!element.data('ui-sortable')) {
                  element.sortable('refresh');
                }
              }, 0, false);
            });

            callbacks.start = function(e, ui) {
              if (opts['ui-floating'] === 'auto') {
                // since the drag has started, the element will be
                // absolutely positioned, so we check its siblings
                var siblings = ui.item.siblings();
                angular.element(e.target).data('ui-sortable').floating = isFloating(siblings);
              }

              // Save the starting position of dragged item
              ui.item.sortable = {
                model: ngModel.$modelValue[ui.item.index()],
                index: ui.item.index(),
                source: ui.item.parent(),
                sourceModel: ngModel.$modelValue,
                cancel: function () {
                  ui.item.sortable._isCanceled = true;
                },
                isCanceled: function () {
                  return ui.item.sortable._isCanceled;
                },
                isCustomHelperUsed: function () {
                  return !!ui.item.sortable._isCustomHelperUsed;
                },
                _isCanceled: false,
                _isCustomHelperUsed: ui.item.sortable._isCustomHelperUsed,
                _destroy: function () {
                  angular.forEach(ui.item.sortable, function(value, key) {
                    ui.item.sortable[key] = undefined;
                  });
                }
              };
            };

            callbacks.activate = function(/*e, ui*/) {
              // We need to make a copy of the current element's contents so
              // we can restore it after sortable has messed it up.
              // This is inside activate (instead of start) in order to save
              // both lists when dragging between connected lists.
              savedNodes = element.contents();

              // If this list has a placeholder (the connected lists won't),
              // don't inlcude it in saved nodes.
              var placeholder = element.sortable('option','placeholder');

              // placeholder.element will be a function if the placeholder, has
              // been created (placeholder will be an object).  If it hasn't
              // been created, either placeholder will be false if no
              // placeholder class was given or placeholder.element will be
              // undefined if a class was given (placeholder will be a string)
              if (placeholder && placeholder.element && typeof placeholder.element === 'function') {
                var phElement = placeholder.element();
                // workaround for jquery ui 1.9.x,
                // not returning jquery collection
                phElement = angular.element(phElement);

                // exact match with the placeholder's class attribute to handle
                // the case that multiple connected sortables exist and
                // the placehoilder option equals the class of sortable items
                var excludes = element.find('[class="' + phElement.attr('class') + '"]');

                savedNodes = savedNodes.not(excludes);
              }
            };

            callbacks.update = function(e, ui) {
              // Save current drop position but only if this is not a second
              // update that happens when moving between lists because then
              // the value will be overwritten with the old value
              if(!ui.item.sortable.received) {
                ui.item.sortable.dropindex = ui.item.index();
                var droptarget = ui.item.parent();
                ui.item.sortable.droptarget = droptarget;
                var attr = droptarget.attr('ng-model') || droptarget.attr('data-ng-model');
                ui.item.sortable.droptargetModel = droptarget.scope().$eval(attr);

                // Cancel the sort (let ng-repeat do the sort for us)
                // Don't cancel if this is the received list because it has
                // already been canceled in the other list, and trying to cancel
                // here will mess up the DOM.
                element.sortable('cancel');
              }

              // Put the nodes back exactly the way they started (this is very
              // important because ng-repeat uses comment elements to delineate
              // the start and stop of repeat sections and sortable doesn't
              // respect their order (even if we cancel, the order of the
              // comments are still messed up).
              if (hasSortingHelper(element, ui) && !ui.item.sortable.received &&
                  element.sortable( 'option', 'appendTo' ) === 'parent') {
                // restore all the savedNodes except .ui-sortable-helper element
                // (which is placed last). That way it will be garbage collected.
                savedNodes = savedNodes.not(savedNodes.last());
              }
              savedNodes.appendTo(element);

              // If this is the target connected list then
              // it's safe to clear the restored nodes since:
              // update is currently running and
              // stop is not called for the target list.
              if(ui.item.sortable.received) {
                savedNodes = null;
              }

              // If received is true (an item was dropped in from another list)
              // then we add the new item to this list otherwise wait until the
              // stop event where we will know if it was a sort or item was
              // moved here from another list
              if(ui.item.sortable.received && !ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ngModel.$modelValue.splice(ui.item.sortable.dropindex, 0,
                                             ui.item.sortable.moved);
                });
              }
            };

            callbacks.stop = function(e, ui) {
              // If the received flag hasn't be set on the item, this is a
              // normal sort, if dropindex is set, the item was moved, so move
              // the items in the list.
              if(!ui.item.sortable.received &&
                 ('dropindex' in ui.item.sortable) &&
                 !ui.item.sortable.isCanceled()) {

                scope.$apply(function () {
                  ngModel.$modelValue.splice(
                    ui.item.sortable.dropindex, 0,
                    ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0]);
                });
              } else {
                // if the item was not moved, then restore the elements
                // so that the ngRepeat's comment are correct.
                if ((!('dropindex' in ui.item.sortable) || ui.item.sortable.isCanceled()) &&
                    !hasSortingHelper(element, ui)) {
                  savedNodes.appendTo(element);
                }
              }

              // It's now safe to clear the savedNodes
              // since stop is the last callback.
              savedNodes = null;
            };

            callbacks.receive = function(e, ui) {
              // An item was dropped here from another list, set a flag on the
              // item.
              ui.item.sortable.received = true;
            };

            callbacks.remove = function(e, ui) {
              // Workaround for a problem observed in nested connected lists.
              // There should be an 'update' event before 'remove' when moving
              // elements. If the event did not fire, cancel sorting.
              if (!('dropindex' in ui.item.sortable)) {
                element.sortable('cancel');
                ui.item.sortable.cancel();
              }

              // Remove the item from this list's model and copy data into item,
              // so the next list can retrive it
              if (!ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ui.item.sortable.moved = ngModel.$modelValue.splice(
                    ui.item.sortable.index, 1)[0];
                });
              }
            };

            wrappers.helper = function (inner) {
              if (inner && typeof inner === 'function') {
                return function (e, item) {
                  var innerResult = inner(e, item);
                  item.sortable._isCustomHelperUsed = item !== innerResult;
                  return innerResult;
                };
              }
              return inner;
            };

            scope.$watch(attrs.uiSortable, function(newVal /*, oldVal*/) {
              // ensure that the jquery-ui-sortable widget instance
              // is still bound to the directive's element
              if (!!element.data('ui-sortable')) {
                angular.forEach(newVal, function(value, key) {
                  // if it's a custom option of the directive,
                  // handle it approprietly
                  if (key in directiveOpts) {
                    if (key === 'ui-floating' && (value === false || value === true)) {
                      element.data('ui-sortable').floating = value;
                    }

                    opts[key] = value;
                    return;
                  }

                  if (callbacks[key]) {
                    if( key === 'stop' ){
                      // call apply after stop
                      value = combineCallbacks(
                        value, function() { scope.$apply(); });

                      value = combineCallbacks(value, afterStop);
                    }
                    // wrap the callback
                    value = combineCallbacks(callbacks[key], value);
                  } else if (wrappers[key]) {
                    value = wrappers[key](value);
                  }

                  opts[key] = value;
                  element.sortable('option', key, value);
                });
              }
            }, true);

            angular.forEach(callbacks, function(value, key) {
              opts[key] = combineCallbacks(value, opts[key]);
              if( key === 'stop' ){
                opts[key] = combineCallbacks(opts[key], afterStop);
              }
            });

          } else {
            $log.info('ui.sortable: ngModel not provided!', element);
          }

          // Create sortable
          element.sortable(opts);
        }
      };
    }
  ]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFuZ3VsYXItc29ydGFibGUuanMiLCJzb3J0YWJsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYW5ndWxhci1zb3J0YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiLypcbiBqUXVlcnkgVUkgU29ydGFibGUgcGx1Z2luIHdyYXBwZXJcblxuIEBwYXJhbSBbdWktc29ydGFibGVdIHtvYmplY3R9IE9wdGlvbnMgdG8gcGFzcyB0byAkLmZuLnNvcnRhYmxlKCkgbWVyZ2VkIG9udG8gdWkuY29uZmlnXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5zb3J0YWJsZScsIFtdKVxuICAudmFsdWUoJ3VpU29ydGFibGVDb25maWcnLHt9KVxuICAuZGlyZWN0aXZlKCd1aVNvcnRhYmxlJywgW1xuICAgICd1aVNvcnRhYmxlQ29uZmlnJywgJyR0aW1lb3V0JywgJyRsb2cnLFxuICAgIGZ1bmN0aW9uKHVpU29ydGFibGVDb25maWcsICR0aW1lb3V0LCAkbG9nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXF1aXJlOiAnP25nTW9kZWwnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcbiAgICAgICAgICB2YXIgc2F2ZWROb2RlcztcblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbWJpbmVDYWxsYmFja3MoZmlyc3Qsc2Vjb25kKXtcbiAgICAgICAgICAgIGlmKHNlY29uZCAmJiAodHlwZW9mIHNlY29uZCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUsIHVpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QoZSwgdWkpO1xuICAgICAgICAgICAgICAgIHNlY29uZChlLCB1aSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzU29ydGluZ0hlbHBlciAoZWxlbWVudCwgdWkpIHtcbiAgICAgICAgICAgIHZhciBoZWxwZXJPcHRpb24gPSBlbGVtZW50LnNvcnRhYmxlKCdvcHRpb24nLCdoZWxwZXInKTtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJPcHRpb24gPT09ICdjbG9uZScgfHwgKHR5cGVvZiBoZWxwZXJPcHRpb24gPT09ICdmdW5jdGlvbicgJiYgdWkuaXRlbS5zb3J0YWJsZS5pc0N1c3RvbUhlbHBlclVzZWQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGhhbmtzIGpxdWVyeS11aVxuICAgICAgICAgIGZ1bmN0aW9uIGlzRmxvYXRpbmcgKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAoL2xlZnR8cmlnaHQvKS50ZXN0KGl0ZW0uY3NzKCdmbG9hdCcpKSB8fCAoL2lubGluZXx0YWJsZS1jZWxsLykudGVzdChpdGVtLmNzcygnZGlzcGxheScpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhZnRlclN0b3AoZSwgdWkpIHtcbiAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUuX2Rlc3Ryb3koKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuXG4gICAgICAgICAgLy8gZGlyZWN0aXZlIHNwZWNpZmljIG9wdGlvbnNcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlT3B0cyA9IHtcbiAgICAgICAgICAgICd1aS1mbG9hdGluZyc6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgcmVjZWl2ZTogbnVsbCxcbiAgICAgICAgICAgIHJlbW92ZTpudWxsLFxuICAgICAgICAgICAgc3RhcnQ6bnVsbCxcbiAgICAgICAgICAgIHN0b3A6bnVsbCxcbiAgICAgICAgICAgIHVwZGF0ZTpudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciB3cmFwcGVycyA9IHtcbiAgICAgICAgICAgIGhlbHBlcjogbnVsbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBhbmd1bGFyLmV4dGVuZChvcHRzLCBkaXJlY3RpdmVPcHRzLCB1aVNvcnRhYmxlQ29uZmlnLCBzY29wZS4kZXZhbChhdHRycy51aVNvcnRhYmxlKSk7XG5cbiAgICAgICAgICBpZiAoIWFuZ3VsYXIuZWxlbWVudC5mbiB8fCAhYW5ndWxhci5lbGVtZW50LmZuLmpxdWVyeSkge1xuICAgICAgICAgICAgJGxvZy5lcnJvcigndWkuc29ydGFibGU6IGpRdWVyeSBzaG91bGQgYmUgaW5jbHVkZWQgYmVmb3JlIEFuZ3VsYXJKUyEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmdNb2RlbCkge1xuXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFkZCBvciByZW1vdmUgZWxlbWVudHMsIHdlIG5lZWQgdGhlIHNvcnRhYmxlIHRvICdyZWZyZXNoJ1xuICAgICAgICAgICAgLy8gc28gaXQgY2FuIGZpbmQgdGhlIG5ldy9yZW1vdmVkIGVsZW1lbnRzLlxuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLm5nTW9kZWwrJy5sZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gVGltZW91dCB0byBsZXQgbmctcmVwZWF0IG1vZGlmeSB0aGUgRE9NXG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBqcXVlcnktdWktc29ydGFibGUgd2lkZ2V0IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgLy8gaXMgc3RpbGwgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZSdzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoISFlbGVtZW50LmRhdGEoJ3VpLXNvcnRhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc29ydGFibGUoJ3JlZnJlc2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYWxsYmFja3Muc3RhcnQgPSBmdW5jdGlvbihlLCB1aSkge1xuICAgICAgICAgICAgICBpZiAob3B0c1sndWktZmxvYXRpbmcnXSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGRyYWcgaGFzIHN0YXJ0ZWQsIHRoZSBlbGVtZW50IHdpbGwgYmVcbiAgICAgICAgICAgICAgICAvLyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQsIHNvIHdlIGNoZWNrIGl0cyBzaWJsaW5nc1xuICAgICAgICAgICAgICAgIHZhciBzaWJsaW5ncyA9IHVpLml0ZW0uc2libGluZ3MoKTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZS50YXJnZXQpLmRhdGEoJ3VpLXNvcnRhYmxlJykuZmxvYXRpbmcgPSBpc0Zsb2F0aW5nKHNpYmxpbmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIGRyYWdnZWQgaXRlbVxuICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBuZ01vZGVsLiRtb2RlbFZhbHVlW3VpLml0ZW0uaW5kZXgoKV0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IHVpLml0ZW0uaW5kZXgoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHVpLml0ZW0ucGFyZW50KCksXG4gICAgICAgICAgICAgICAgc291cmNlTW9kZWw6IG5nTW9kZWwuJG1vZGVsVmFsdWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlLl9pc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzQ2FuY2VsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1aS5pdGVtLnNvcnRhYmxlLl9pc0NhbmNlbGVkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNDdXN0b21IZWxwZXJVc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gISF1aS5pdGVtLnNvcnRhYmxlLl9pc0N1c3RvbUhlbHBlclVzZWQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfaXNDYW5jZWxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgX2lzQ3VzdG9tSGVscGVyVXNlZDogdWkuaXRlbS5zb3J0YWJsZS5faXNDdXN0b21IZWxwZXJVc2VkLFxuICAgICAgICAgICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godWkuaXRlbS5zb3J0YWJsZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYWxsYmFja3MuYWN0aXZhdGUgPSBmdW5jdGlvbigvKmUsIHVpKi8pIHtcbiAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYWtlIGEgY29weSBvZiB0aGUgY3VycmVudCBlbGVtZW50J3MgY29udGVudHMgc29cbiAgICAgICAgICAgICAgLy8gd2UgY2FuIHJlc3RvcmUgaXQgYWZ0ZXIgc29ydGFibGUgaGFzIG1lc3NlZCBpdCB1cC5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbnNpZGUgYWN0aXZhdGUgKGluc3RlYWQgb2Ygc3RhcnQpIGluIG9yZGVyIHRvIHNhdmVcbiAgICAgICAgICAgICAgLy8gYm90aCBsaXN0cyB3aGVuIGRyYWdnaW5nIGJldHdlZW4gY29ubmVjdGVkIGxpc3RzLlxuICAgICAgICAgICAgICBzYXZlZE5vZGVzID0gZWxlbWVudC5jb250ZW50cygpO1xuXG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgbGlzdCBoYXMgYSBwbGFjZWhvbGRlciAodGhlIGNvbm5lY3RlZCBsaXN0cyB3b24ndCksXG4gICAgICAgICAgICAgIC8vIGRvbid0IGlubGN1ZGUgaXQgaW4gc2F2ZWQgbm9kZXMuXG4gICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGVsZW1lbnQuc29ydGFibGUoJ29wdGlvbicsJ3BsYWNlaG9sZGVyJyk7XG5cbiAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIuZWxlbWVudCB3aWxsIGJlIGEgZnVuY3Rpb24gaWYgdGhlIHBsYWNlaG9sZGVyLCBoYXNcbiAgICAgICAgICAgICAgLy8gYmVlbiBjcmVhdGVkIChwbGFjZWhvbGRlciB3aWxsIGJlIGFuIG9iamVjdCkuICBJZiBpdCBoYXNuJ3RcbiAgICAgICAgICAgICAgLy8gYmVlbiBjcmVhdGVkLCBlaXRoZXIgcGxhY2Vob2xkZXIgd2lsbCBiZSBmYWxzZSBpZiBub1xuICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBjbGFzcyB3YXMgZ2l2ZW4gb3IgcGxhY2Vob2xkZXIuZWxlbWVudCB3aWxsIGJlXG4gICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBpZiBhIGNsYXNzIHdhcyBnaXZlbiAocGxhY2Vob2xkZXIgd2lsbCBiZSBhIHN0cmluZylcbiAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyICYmIHBsYWNlaG9sZGVyLmVsZW1lbnQgJiYgdHlwZW9mIHBsYWNlaG9sZGVyLmVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGhFbGVtZW50ID0gcGxhY2Vob2xkZXIuZWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGpxdWVyeSB1aSAxLjkueCxcbiAgICAgICAgICAgICAgICAvLyBub3QgcmV0dXJuaW5nIGpxdWVyeSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgcGhFbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KHBoRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBleGFjdCBtYXRjaCB3aXRoIHRoZSBwbGFjZWhvbGRlcidzIGNsYXNzIGF0dHJpYnV0ZSB0byBoYW5kbGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FzZSB0aGF0IG11bHRpcGxlIGNvbm5lY3RlZCBzb3J0YWJsZXMgZXhpc3QgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBsYWNlaG9pbGRlciBvcHRpb24gZXF1YWxzIHRoZSBjbGFzcyBvZiBzb3J0YWJsZSBpdGVtc1xuICAgICAgICAgICAgICAgIHZhciBleGNsdWRlcyA9IGVsZW1lbnQuZmluZCgnW2NsYXNzPVwiJyArIHBoRWxlbWVudC5hdHRyKCdjbGFzcycpICsgJ1wiXScpO1xuXG4gICAgICAgICAgICAgICAgc2F2ZWROb2RlcyA9IHNhdmVkTm9kZXMubm90KGV4Y2x1ZGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzLnVwZGF0ZSA9IGZ1bmN0aW9uKGUsIHVpKSB7XG4gICAgICAgICAgICAgIC8vIFNhdmUgY3VycmVudCBkcm9wIHBvc2l0aW9uIGJ1dCBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc2Vjb25kXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGF0IGhhcHBlbnMgd2hlbiBtb3ZpbmcgYmV0d2VlbiBsaXN0cyBiZWNhdXNlIHRoZW5cbiAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgb2xkIHZhbHVlXG4gICAgICAgICAgICAgIGlmKCF1aS5pdGVtLnNvcnRhYmxlLnJlY2VpdmVkKSB7XG4gICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZS5kcm9waW5kZXggPSB1aS5pdGVtLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3B0YXJnZXQgPSB1aS5pdGVtLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUuZHJvcHRhcmdldCA9IGRyb3B0YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBkcm9wdGFyZ2V0LmF0dHIoJ25nLW1vZGVsJykgfHwgZHJvcHRhcmdldC5hdHRyKCdkYXRhLW5nLW1vZGVsJyk7XG4gICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZS5kcm9wdGFyZ2V0TW9kZWwgPSBkcm9wdGFyZ2V0LnNjb3BlKCkuJGV2YWwoYXR0cik7XG5cbiAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHNvcnQgKGxldCBuZy1yZXBlYXQgZG8gdGhlIHNvcnQgZm9yIHVzKVxuICAgICAgICAgICAgICAgIC8vIERvbid0IGNhbmNlbCBpZiB0aGlzIGlzIHRoZSByZWNlaXZlZCBsaXN0IGJlY2F1c2UgaXQgaGFzXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBiZWVuIGNhbmNlbGVkIGluIHRoZSBvdGhlciBsaXN0LCBhbmQgdHJ5aW5nIHRvIGNhbmNlbFxuICAgICAgICAgICAgICAgIC8vIGhlcmUgd2lsbCBtZXNzIHVwIHRoZSBET00uXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zb3J0YWJsZSgnY2FuY2VsJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQdXQgdGhlIG5vZGVzIGJhY2sgZXhhY3RseSB0aGUgd2F5IHRoZXkgc3RhcnRlZCAodGhpcyBpcyB2ZXJ5XG4gICAgICAgICAgICAgIC8vIGltcG9ydGFudCBiZWNhdXNlIG5nLXJlcGVhdCB1c2VzIGNvbW1lbnQgZWxlbWVudHMgdG8gZGVsaW5lYXRlXG4gICAgICAgICAgICAgIC8vIHRoZSBzdGFydCBhbmQgc3RvcCBvZiByZXBlYXQgc2VjdGlvbnMgYW5kIHNvcnRhYmxlIGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gcmVzcGVjdCB0aGVpciBvcmRlciAoZXZlbiBpZiB3ZSBjYW5jZWwsIHRoZSBvcmRlciBvZiB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWVudHMgYXJlIHN0aWxsIG1lc3NlZCB1cCkuXG4gICAgICAgICAgICAgIGlmIChoYXNTb3J0aW5nSGVscGVyKGVsZW1lbnQsIHVpKSAmJiAhdWkuaXRlbS5zb3J0YWJsZS5yZWNlaXZlZCAmJlxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5zb3J0YWJsZSggJ29wdGlvbicsICdhcHBlbmRUbycgKSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGFsbCB0aGUgc2F2ZWROb2RlcyBleGNlcHQgLnVpLXNvcnRhYmxlLWhlbHBlciBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gKHdoaWNoIGlzIHBsYWNlZCBsYXN0KS4gVGhhdCB3YXkgaXQgd2lsbCBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgICAgICAgICBzYXZlZE5vZGVzID0gc2F2ZWROb2Rlcy5ub3Qoc2F2ZWROb2Rlcy5sYXN0KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNhdmVkTm9kZXMuYXBwZW5kVG8oZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgdGFyZ2V0IGNvbm5lY3RlZCBsaXN0IHRoZW5cbiAgICAgICAgICAgICAgLy8gaXQncyBzYWZlIHRvIGNsZWFyIHRoZSByZXN0b3JlZCBub2RlcyBzaW5jZTpcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGlzIGN1cnJlbnRseSBydW5uaW5nIGFuZFxuICAgICAgICAgICAgICAvLyBzdG9wIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSB0YXJnZXQgbGlzdC5cbiAgICAgICAgICAgICAgaWYodWkuaXRlbS5zb3J0YWJsZS5yZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgIHNhdmVkTm9kZXMgPSBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSWYgcmVjZWl2ZWQgaXMgdHJ1ZSAoYW4gaXRlbSB3YXMgZHJvcHBlZCBpbiBmcm9tIGFub3RoZXIgbGlzdClcbiAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBhZGQgdGhlIG5ldyBpdGVtIHRvIHRoaXMgbGlzdCBvdGhlcndpc2Ugd2FpdCB1bnRpbCB0aGVcbiAgICAgICAgICAgICAgLy8gc3RvcCBldmVudCB3aGVyZSB3ZSB3aWxsIGtub3cgaWYgaXQgd2FzIGEgc29ydCBvciBpdGVtIHdhc1xuICAgICAgICAgICAgICAvLyBtb3ZlZCBoZXJlIGZyb20gYW5vdGhlciBsaXN0XG4gICAgICAgICAgICAgIGlmKHVpLml0ZW0uc29ydGFibGUucmVjZWl2ZWQgJiYgIXVpLml0ZW0uc29ydGFibGUuaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIG5nTW9kZWwuJG1vZGVsVmFsdWUuc3BsaWNlKHVpLml0ZW0uc29ydGFibGUuZHJvcGluZGV4LCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZS5tb3ZlZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNhbGxiYWNrcy5zdG9wID0gZnVuY3Rpb24oZSwgdWkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlY2VpdmVkIGZsYWcgaGFzbid0IGJlIHNldCBvbiB0aGUgaXRlbSwgdGhpcyBpcyBhXG4gICAgICAgICAgICAgIC8vIG5vcm1hbCBzb3J0LCBpZiBkcm9waW5kZXggaXMgc2V0LCB0aGUgaXRlbSB3YXMgbW92ZWQsIHNvIG1vdmVcbiAgICAgICAgICAgICAgLy8gdGhlIGl0ZW1zIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgICBpZighdWkuaXRlbS5zb3J0YWJsZS5yZWNlaXZlZCAmJlxuICAgICAgICAgICAgICAgICAoJ2Ryb3BpbmRleCcgaW4gdWkuaXRlbS5zb3J0YWJsZSkgJiZcbiAgICAgICAgICAgICAgICAgIXVpLml0ZW0uc29ydGFibGUuaXNDYW5jZWxlZCgpKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgbmdNb2RlbC4kbW9kZWxWYWx1ZS5zcGxpY2UoXG4gICAgICAgICAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUuZHJvcGluZGV4LCAwLFxuICAgICAgICAgICAgICAgICAgICBuZ01vZGVsLiRtb2RlbFZhbHVlLnNwbGljZSh1aS5pdGVtLnNvcnRhYmxlLmluZGV4LCAxKVswXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gd2FzIG5vdCBtb3ZlZCwgdGhlbiByZXN0b3JlIHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIG5nUmVwZWF0J3MgY29tbWVudCBhcmUgY29ycmVjdC5cbiAgICAgICAgICAgICAgICBpZiAoKCEoJ2Ryb3BpbmRleCcgaW4gdWkuaXRlbS5zb3J0YWJsZSkgfHwgdWkuaXRlbS5zb3J0YWJsZS5pc0NhbmNlbGVkKCkpICYmXG4gICAgICAgICAgICAgICAgICAgICFoYXNTb3J0aW5nSGVscGVyKGVsZW1lbnQsIHVpKSkge1xuICAgICAgICAgICAgICAgICAgc2F2ZWROb2Rlcy5hcHBlbmRUbyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBJdCdzIG5vdyBzYWZlIHRvIGNsZWFyIHRoZSBzYXZlZE5vZGVzXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHN0b3AgaXMgdGhlIGxhc3QgY2FsbGJhY2suXG4gICAgICAgICAgICAgIHNhdmVkTm9kZXMgPSBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzLnJlY2VpdmUgPSBmdW5jdGlvbihlLCB1aSkge1xuICAgICAgICAgICAgICAvLyBBbiBpdGVtIHdhcyBkcm9wcGVkIGhlcmUgZnJvbSBhbm90aGVyIGxpc3QsIHNldCBhIGZsYWcgb24gdGhlXG4gICAgICAgICAgICAgIC8vIGl0ZW0uXG4gICAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUucmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzLnJlbW92ZSA9IGZ1bmN0aW9uKGUsIHVpKSB7XG4gICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGEgcHJvYmxlbSBvYnNlcnZlZCBpbiBuZXN0ZWQgY29ubmVjdGVkIGxpc3RzLlxuICAgICAgICAgICAgICAvLyBUaGVyZSBzaG91bGQgYmUgYW4gJ3VwZGF0ZScgZXZlbnQgYmVmb3JlICdyZW1vdmUnIHdoZW4gbW92aW5nXG4gICAgICAgICAgICAgIC8vIGVsZW1lbnRzLiBJZiB0aGUgZXZlbnQgZGlkIG5vdCBmaXJlLCBjYW5jZWwgc29ydGluZy5cbiAgICAgICAgICAgICAgaWYgKCEoJ2Ryb3BpbmRleCcgaW4gdWkuaXRlbS5zb3J0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNvcnRhYmxlKCdjYW5jZWwnKTtcbiAgICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhpcyBsaXN0J3MgbW9kZWwgYW5kIGNvcHkgZGF0YSBpbnRvIGl0ZW0sXG4gICAgICAgICAgICAgIC8vIHNvIHRoZSBuZXh0IGxpc3QgY2FuIHJldHJpdmUgaXRcbiAgICAgICAgICAgICAgaWYgKCF1aS5pdGVtLnNvcnRhYmxlLmlzQ2FuY2VsZWQoKSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlLm1vdmVkID0gbmdNb2RlbC4kbW9kZWxWYWx1ZS5zcGxpY2UoXG4gICAgICAgICAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUuaW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3cmFwcGVycy5oZWxwZXIgPSBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGlubmVyICYmIHR5cGVvZiBpbm5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGlubmVyUmVzdWx0ID0gaW5uZXIoZSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICBpdGVtLnNvcnRhYmxlLl9pc0N1c3RvbUhlbHBlclVzZWQgPSBpdGVtICE9PSBpbm5lclJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lclJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRycy51aVNvcnRhYmxlLCBmdW5jdGlvbihuZXdWYWwgLyosIG9sZFZhbCovKSB7XG4gICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBqcXVlcnktdWktc29ydGFibGUgd2lkZ2V0IGluc3RhbmNlXG4gICAgICAgICAgICAgIC8vIGlzIHN0aWxsIGJvdW5kIHRvIHRoZSBkaXJlY3RpdmUncyBlbGVtZW50XG4gICAgICAgICAgICAgIGlmICghIWVsZW1lbnQuZGF0YSgndWktc29ydGFibGUnKSkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChuZXdWYWwsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBjdXN0b20gb3B0aW9uIG9mIHRoZSBkaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgaXQgYXBwcm9wcmlldGx5XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGRpcmVjdGl2ZU9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3VpLWZsb2F0aW5nJyAmJiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YSgndWktc29ydGFibGUnKS5mbG9hdGluZyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0c1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBrZXkgPT09ICdzdG9wJyApe1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgYXBwbHkgYWZ0ZXIgc3RvcFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29tYmluZUNhbGxiYWNrcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLCBmdW5jdGlvbigpIHsgc2NvcGUuJGFwcGx5KCk7IH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb21iaW5lQ2FsbGJhY2tzKHZhbHVlLCBhZnRlclN0b3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29tYmluZUNhbGxiYWNrcyhjYWxsYmFja3Nba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3cmFwcGVyc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcHBlcnNba2V5XSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG9wdHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5zb3J0YWJsZSgnb3B0aW9uJywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY2FsbGJhY2tzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgIG9wdHNba2V5XSA9IGNvbWJpbmVDYWxsYmFja3ModmFsdWUsIG9wdHNba2V5XSk7XG4gICAgICAgICAgICAgIGlmKCBrZXkgPT09ICdzdG9wJyApe1xuICAgICAgICAgICAgICAgIG9wdHNba2V5XSA9IGNvbWJpbmVDYWxsYmFja3Mob3B0c1trZXldLCBhZnRlclN0b3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbG9nLmluZm8oJ3VpLnNvcnRhYmxlOiBuZ01vZGVsIG5vdCBwcm92aWRlZCEnLCBlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgc29ydGFibGVcbiAgICAgICAgICBlbGVtZW50LnNvcnRhYmxlKG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgXSk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
