/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/*
 jQuery UI Sortable plugin wrapper

 @param [ui-sortable] {object} Options to pass to $.fn.sortable() merged onto ui.config
 */
angular.module('ui.sortable', [])
  .value('uiSortableConfig',{})
  .directive('uiSortable', [
    'uiSortableConfig', '$timeout', '$log',
    function(uiSortableConfig, $timeout, $log) {
      return {
        require: '?ngModel',
        link: function(scope, element, attrs, ngModel) {
          var savedNodes;

          function combineCallbacks(first,second){
            if(second && (typeof second === 'function')) {
              return function(e, ui) {
                first(e, ui);
                second(e, ui);
              };
            }
            return first;
          }

          function hasSortingHelper (element, ui) {
            var helperOption = element.sortable('option','helper');
            return helperOption === 'clone' || (typeof helperOption === 'function' && ui.item.sortable.isCustomHelperUsed());
          }

          // thanks jquery-ui
          function isFloating (item) {
            return (/left|right/).test(item.css('float')) || (/inline|table-cell/).test(item.css('display'));
          }

          function afterStop(e, ui) {
            ui.item.sortable._destroy();
          }

          var opts = {};

          // directive specific options
          var directiveOpts = {
            'ui-floating': undefined
          };

          var callbacks = {
            receive: null,
            remove:null,
            start:null,
            stop:null,
            update:null
          };

          var wrappers = {
            helper: null
          };

          angular.extend(opts, directiveOpts, uiSortableConfig, scope.$eval(attrs.uiSortable));

          if (!angular.element.fn || !angular.element.fn.jquery) {
            $log.error('ui.sortable: jQuery should be included before AngularJS!');
            return;
          }

          if (ngModel) {

            // When we add or remove elements, we need the sortable to 'refresh'
            // so it can find the new/removed elements.
            scope.$watch(attrs.ngModel+'.length', function() {
              // Timeout to let ng-repeat modify the DOM
              $timeout(function() {
                // ensure that the jquery-ui-sortable widget instance
                // is still bound to the directive's element
                if (!!element.data('ui-sortable')) {
                  element.sortable('refresh');
                }
              }, 0, false);
            });

            callbacks.start = function(e, ui) {
              if (opts['ui-floating'] === 'auto') {
                // since the drag has started, the element will be
                // absolutely positioned, so we check its siblings
                var siblings = ui.item.siblings();
                angular.element(e.target).data('ui-sortable').floating = isFloating(siblings);
              }

              // Save the starting position of dragged item
              ui.item.sortable = {
                model: ngModel.$modelValue[ui.item.index()],
                index: ui.item.index(),
                source: ui.item.parent(),
                sourceModel: ngModel.$modelValue,
                cancel: function () {
                  ui.item.sortable._isCanceled = true;
                },
                isCanceled: function () {
                  return ui.item.sortable._isCanceled;
                },
                isCustomHelperUsed: function () {
                  return !!ui.item.sortable._isCustomHelperUsed;
                },
                _isCanceled: false,
                _isCustomHelperUsed: ui.item.sortable._isCustomHelperUsed,
                _destroy: function () {
                  angular.forEach(ui.item.sortable, function(value, key) {
                    ui.item.sortable[key] = undefined;
                  });
                }
              };
            };

            callbacks.activate = function(/*e, ui*/) {
              // We need to make a copy of the current element's contents so
              // we can restore it after sortable has messed it up.
              // This is inside activate (instead of start) in order to save
              // both lists when dragging between connected lists.
              savedNodes = element.contents();

              // If this list has a placeholder (the connected lists won't),
              // don't inlcude it in saved nodes.
              var placeholder = element.sortable('option','placeholder');

              // placeholder.element will be a function if the placeholder, has
              // been created (placeholder will be an object).  If it hasn't
              // been created, either placeholder will be false if no
              // placeholder class was given or placeholder.element will be
              // undefined if a class was given (placeholder will be a string)
              if (placeholder && placeholder.element && typeof placeholder.element === 'function') {
                var phElement = placeholder.element();
                // workaround for jquery ui 1.9.x,
                // not returning jquery collection
                phElement = angular.element(phElement);

                // exact match with the placeholder's class attribute to handle
                // the case that multiple connected sortables exist and
                // the placehoilder option equals the class of sortable items
                var excludes = element.find('[class="' + phElement.attr('class') + '"]');

                savedNodes = savedNodes.not(excludes);
              }
            };

            callbacks.update = function(e, ui) {
              // Save current drop position but only if this is not a second
              // update that happens when moving between lists because then
              // the value will be overwritten with the old value
              if(!ui.item.sortable.received) {
                ui.item.sortable.dropindex = ui.item.index();
                var droptarget = ui.item.parent();
                ui.item.sortable.droptarget = droptarget;
                var attr = droptarget.attr('ng-model') || droptarget.attr('data-ng-model');
                ui.item.sortable.droptargetModel = droptarget.scope().$eval(attr);

                // Cancel the sort (let ng-repeat do the sort for us)
                // Don't cancel if this is the received list because it has
                // already been canceled in the other list, and trying to cancel
                // here will mess up the DOM.
                element.sortable('cancel');
              }

              // Put the nodes back exactly the way they started (this is very
              // important because ng-repeat uses comment elements to delineate
              // the start and stop of repeat sections and sortable doesn't
              // respect their order (even if we cancel, the order of the
              // comments are still messed up).
              if (hasSortingHelper(element, ui) && !ui.item.sortable.received &&
                  element.sortable( 'option', 'appendTo' ) === 'parent') {
                // restore all the savedNodes except .ui-sortable-helper element
                // (which is placed last). That way it will be garbage collected.
                savedNodes = savedNodes.not(savedNodes.last());
              }
              savedNodes.appendTo(element);

              // If this is the target connected list then
              // it's safe to clear the restored nodes since:
              // update is currently running and
              // stop is not called for the target list.
              if(ui.item.sortable.received) {
                savedNodes = null;
              }

              // If received is true (an item was dropped in from another list)
              // then we add the new item to this list otherwise wait until the
              // stop event where we will know if it was a sort or item was
              // moved here from another list
              if(ui.item.sortable.received && !ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ngModel.$modelValue.splice(ui.item.sortable.dropindex, 0,
                                             ui.item.sortable.moved);
                });
              }
            };

            callbacks.stop = function(e, ui) {
              // If the received flag hasn't be set on the item, this is a
              // normal sort, if dropindex is set, the item was moved, so move
              // the items in the list.
              if(!ui.item.sortable.received &&
                 ('dropindex' in ui.item.sortable) &&
                 !ui.item.sortable.isCanceled()) {

                scope.$apply(function () {
                  ngModel.$modelValue.splice(
                    ui.item.sortable.dropindex, 0,
                    ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0]);
                });
              } else {
                // if the item was not moved, then restore the elements
                // so that the ngRepeat's comment are correct.
                if ((!('dropindex' in ui.item.sortable) || ui.item.sortable.isCanceled()) &&
                    !hasSortingHelper(element, ui)) {
                  savedNodes.appendTo(element);
                }
              }

              // It's now safe to clear the savedNodes
              // since stop is the last callback.
              savedNodes = null;
            };

            callbacks.receive = function(e, ui) {
              // An item was dropped here from another list, set a flag on the
              // item.
              ui.item.sortable.received = true;
            };

            callbacks.remove = function(e, ui) {
              // Workaround for a problem observed in nested connected lists.
              // There should be an 'update' event before 'remove' when moving
              // elements. If the event did not fire, cancel sorting.
              if (!('dropindex' in ui.item.sortable)) {
                element.sortable('cancel');
                ui.item.sortable.cancel();
              }

              // Remove the item from this list's model and copy data into item,
              // so the next list can retrive it
              if (!ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ui.item.sortable.moved = ngModel.$modelValue.splice(
                    ui.item.sortable.index, 1)[0];
                });
              }
            };

            wrappers.helper = function (inner) {
              if (inner && typeof inner === 'function') {
                return function (e, item) {
                  var innerResult = inner(e, item);
                  item.sortable._isCustomHelperUsed = item !== innerResult;
                  return innerResult;
                };
              }
              return inner;
            };

            scope.$watch(attrs.uiSortable, function(newVal /*, oldVal*/) {
              // ensure that the jquery-ui-sortable widget instance
              // is still bound to the directive's element
              if (!!element.data('ui-sortable')) {
                angular.forEach(newVal, function(value, key) {
                  // if it's a custom option of the directive,
                  // handle it approprietly
                  if (key in directiveOpts) {
                    if (key === 'ui-floating' && (value === false || value === true)) {
                      element.data('ui-sortable').floating = value;
                    }

                    opts[key] = value;
                    return;
                  }

                  if (callbacks[key]) {
                    if( key === 'stop' ){
                      // call apply after stop
                      value = combineCallbacks(
                        value, function() { scope.$apply(); });

                      value = combineCallbacks(value, afterStop);
                    }
                    // wrap the callback
                    value = combineCallbacks(callbacks[key], value);
                  } else if (wrappers[key]) {
                    value = wrappers[key](value);
                  }

                  opts[key] = value;
                  element.sortable('option', key, value);
                });
              }
            }, true);

            angular.forEach(callbacks, function(value, key) {
              opts[key] = combineCallbacks(value, opts[key]);
              if( key === 'stop' ){
                opts[key] = combineCallbacks(opts[key], afterStop);
              }
            });

          } else {
            $log.info('ui.sortable: ngModel not provided!', element);
          }

          // Create sortable
          element.sortable(opts);
        }
      };
    }
  ]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFuZ3VsYXItc29ydGFibGUuanMiLCJzb3J0YWJsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYW5ndWxhci1zb3J0YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiLypcclxuIGpRdWVyeSBVSSBTb3J0YWJsZSBwbHVnaW4gd3JhcHBlclxyXG5cclxuIEBwYXJhbSBbdWktc29ydGFibGVdIHtvYmplY3R9IE9wdGlvbnMgdG8gcGFzcyB0byAkLmZuLnNvcnRhYmxlKCkgbWVyZ2VkIG9udG8gdWkuY29uZmlnXHJcbiAqL1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuc29ydGFibGUnLCBbXSlcclxuICAudmFsdWUoJ3VpU29ydGFibGVDb25maWcnLHt9KVxyXG4gIC5kaXJlY3RpdmUoJ3VpU29ydGFibGUnLCBbXHJcbiAgICAndWlTb3J0YWJsZUNvbmZpZycsICckdGltZW91dCcsICckbG9nJyxcclxuICAgIGZ1bmN0aW9uKHVpU29ydGFibGVDb25maWcsICR0aW1lb3V0LCAkbG9nKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVxdWlyZTogJz9uZ01vZGVsJyxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgICAgIHZhciBzYXZlZE5vZGVzO1xyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIGNvbWJpbmVDYWxsYmFja3MoZmlyc3Qsc2Vjb25kKXtcclxuICAgICAgICAgICAgaWYoc2Vjb25kICYmICh0eXBlb2Ygc2Vjb25kID09PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlLCB1aSkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QoZSwgdWkpO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kKGUsIHVpKTtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBoYXNTb3J0aW5nSGVscGVyIChlbGVtZW50LCB1aSkge1xyXG4gICAgICAgICAgICB2YXIgaGVscGVyT3B0aW9uID0gZWxlbWVudC5zb3J0YWJsZSgnb3B0aW9uJywnaGVscGVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJPcHRpb24gPT09ICdjbG9uZScgfHwgKHR5cGVvZiBoZWxwZXJPcHRpb24gPT09ICdmdW5jdGlvbicgJiYgdWkuaXRlbS5zb3J0YWJsZS5pc0N1c3RvbUhlbHBlclVzZWQoKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gdGhhbmtzIGpxdWVyeS11aVxyXG4gICAgICAgICAgZnVuY3Rpb24gaXNGbG9hdGluZyAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKC9sZWZ0fHJpZ2h0LykudGVzdChpdGVtLmNzcygnZmxvYXQnKSkgfHwgKC9pbmxpbmV8dGFibGUtY2VsbC8pLnRlc3QoaXRlbS5jc3MoJ2Rpc3BsYXknKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gYWZ0ZXJTdG9wKGUsIHVpKSB7XHJcbiAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUuX2Rlc3Ryb3koKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xyXG5cclxuICAgICAgICAgIC8vIGRpcmVjdGl2ZSBzcGVjaWZpYyBvcHRpb25zXHJcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlT3B0cyA9IHtcclxuICAgICAgICAgICAgJ3VpLWZsb2F0aW5nJzogdW5kZWZpbmVkXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciBjYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICAgIHJlY2VpdmU6IG51bGwsXHJcbiAgICAgICAgICAgIHJlbW92ZTpudWxsLFxyXG4gICAgICAgICAgICBzdGFydDpudWxsLFxyXG4gICAgICAgICAgICBzdG9wOm51bGwsXHJcbiAgICAgICAgICAgIHVwZGF0ZTpudWxsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciB3cmFwcGVycyA9IHtcclxuICAgICAgICAgICAgaGVscGVyOiBudWxsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKG9wdHMsIGRpcmVjdGl2ZU9wdHMsIHVpU29ydGFibGVDb25maWcsIHNjb3BlLiRldmFsKGF0dHJzLnVpU29ydGFibGUpKTtcclxuXHJcbiAgICAgICAgICBpZiAoIWFuZ3VsYXIuZWxlbWVudC5mbiB8fCAhYW5ndWxhci5lbGVtZW50LmZuLmpxdWVyeSkge1xyXG4gICAgICAgICAgICAkbG9nLmVycm9yKCd1aS5zb3J0YWJsZTogalF1ZXJ5IHNob3VsZCBiZSBpbmNsdWRlZCBiZWZvcmUgQW5ndWxhckpTIScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKG5nTW9kZWwpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYWRkIG9yIHJlbW92ZSBlbGVtZW50cywgd2UgbmVlZCB0aGUgc29ydGFibGUgdG8gJ3JlZnJlc2gnXHJcbiAgICAgICAgICAgIC8vIHNvIGl0IGNhbiBmaW5kIHRoZSBuZXcvcmVtb3ZlZCBlbGVtZW50cy5cclxuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLm5nTW9kZWwrJy5sZW5ndGgnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAvLyBUaW1lb3V0IHRvIGxldCBuZy1yZXBlYXQgbW9kaWZ5IHRoZSBET01cclxuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBqcXVlcnktdWktc29ydGFibGUgd2lkZ2V0IGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAvLyBpcyBzdGlsbCBib3VuZCB0byB0aGUgZGlyZWN0aXZlJ3MgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCEhZWxlbWVudC5kYXRhKCd1aS1zb3J0YWJsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc29ydGFibGUoJ3JlZnJlc2gnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9LCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2tzLnN0YXJ0ID0gZnVuY3Rpb24oZSwgdWkpIHtcclxuICAgICAgICAgICAgICBpZiAob3B0c1sndWktZmxvYXRpbmcnXSA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgZHJhZyBoYXMgc3RhcnRlZCwgdGhlIGVsZW1lbnQgd2lsbCBiZVxyXG4gICAgICAgICAgICAgICAgLy8gYWJzb2x1dGVseSBwb3NpdGlvbmVkLCBzbyB3ZSBjaGVjayBpdHMgc2libGluZ3NcclxuICAgICAgICAgICAgICAgIHZhciBzaWJsaW5ncyA9IHVpLml0ZW0uc2libGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudChlLnRhcmdldCkuZGF0YSgndWktc29ydGFibGUnKS5mbG9hdGluZyA9IGlzRmxvYXRpbmcoc2libGluZ3MpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgZHJhZ2dlZCBpdGVtXHJcbiAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZSA9IHtcclxuICAgICAgICAgICAgICAgIG1vZGVsOiBuZ01vZGVsLiRtb2RlbFZhbHVlW3VpLml0ZW0uaW5kZXgoKV0sXHJcbiAgICAgICAgICAgICAgICBpbmRleDogdWkuaXRlbS5pbmRleCgpLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiB1aS5pdGVtLnBhcmVudCgpLFxyXG4gICAgICAgICAgICAgICAgc291cmNlTW9kZWw6IG5nTW9kZWwuJG1vZGVsVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZS5faXNDYW5jZWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaXNDYW5jZWxlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdWkuaXRlbS5zb3J0YWJsZS5faXNDYW5jZWxlZDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBpc0N1c3RvbUhlbHBlclVzZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdWkuaXRlbS5zb3J0YWJsZS5faXNDdXN0b21IZWxwZXJVc2VkO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9pc0NhbmNlbGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIF9pc0N1c3RvbUhlbHBlclVzZWQ6IHVpLml0ZW0uc29ydGFibGUuX2lzQ3VzdG9tSGVscGVyVXNlZCxcclxuICAgICAgICAgICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCh1aS5pdGVtLnNvcnRhYmxlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZVtrZXldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2tzLmFjdGl2YXRlID0gZnVuY3Rpb24oLyplLCB1aSovKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYWtlIGEgY29weSBvZiB0aGUgY3VycmVudCBlbGVtZW50J3MgY29udGVudHMgc29cclxuICAgICAgICAgICAgICAvLyB3ZSBjYW4gcmVzdG9yZSBpdCBhZnRlciBzb3J0YWJsZSBoYXMgbWVzc2VkIGl0IHVwLlxyXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgaW5zaWRlIGFjdGl2YXRlIChpbnN0ZWFkIG9mIHN0YXJ0KSBpbiBvcmRlciB0byBzYXZlXHJcbiAgICAgICAgICAgICAgLy8gYm90aCBsaXN0cyB3aGVuIGRyYWdnaW5nIGJldHdlZW4gY29ubmVjdGVkIGxpc3RzLlxyXG4gICAgICAgICAgICAgIHNhdmVkTm9kZXMgPSBlbGVtZW50LmNvbnRlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgbGlzdCBoYXMgYSBwbGFjZWhvbGRlciAodGhlIGNvbm5lY3RlZCBsaXN0cyB3b24ndCksXHJcbiAgICAgICAgICAgICAgLy8gZG9uJ3QgaW5sY3VkZSBpdCBpbiBzYXZlZCBub2Rlcy5cclxuICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBlbGVtZW50LnNvcnRhYmxlKCdvcHRpb24nLCdwbGFjZWhvbGRlcicpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlci5lbGVtZW50IHdpbGwgYmUgYSBmdW5jdGlvbiBpZiB0aGUgcGxhY2Vob2xkZXIsIGhhc1xyXG4gICAgICAgICAgICAgIC8vIGJlZW4gY3JlYXRlZCAocGxhY2Vob2xkZXIgd2lsbCBiZSBhbiBvYmplY3QpLiAgSWYgaXQgaGFzbid0XHJcbiAgICAgICAgICAgICAgLy8gYmVlbiBjcmVhdGVkLCBlaXRoZXIgcGxhY2Vob2xkZXIgd2lsbCBiZSBmYWxzZSBpZiBub1xyXG4gICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIGNsYXNzIHdhcyBnaXZlbiBvciBwbGFjZWhvbGRlci5lbGVtZW50IHdpbGwgYmVcclxuICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgaWYgYSBjbGFzcyB3YXMgZ2l2ZW4gKHBsYWNlaG9sZGVyIHdpbGwgYmUgYSBzdHJpbmcpXHJcbiAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyICYmIHBsYWNlaG9sZGVyLmVsZW1lbnQgJiYgdHlwZW9mIHBsYWNlaG9sZGVyLmVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwaEVsZW1lbnQgPSBwbGFjZWhvbGRlci5lbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBqcXVlcnkgdWkgMS45LngsXHJcbiAgICAgICAgICAgICAgICAvLyBub3QgcmV0dXJuaW5nIGpxdWVyeSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBwaEVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQocGhFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBleGFjdCBtYXRjaCB3aXRoIHRoZSBwbGFjZWhvbGRlcidzIGNsYXNzIGF0dHJpYnV0ZSB0byBoYW5kbGVcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBjYXNlIHRoYXQgbXVsdGlwbGUgY29ubmVjdGVkIHNvcnRhYmxlcyBleGlzdCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBwbGFjZWhvaWxkZXIgb3B0aW9uIGVxdWFscyB0aGUgY2xhc3Mgb2Ygc29ydGFibGUgaXRlbXNcclxuICAgICAgICAgICAgICAgIHZhciBleGNsdWRlcyA9IGVsZW1lbnQuZmluZCgnW2NsYXNzPVwiJyArIHBoRWxlbWVudC5hdHRyKCdjbGFzcycpICsgJ1wiXScpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNhdmVkTm9kZXMgPSBzYXZlZE5vZGVzLm5vdChleGNsdWRlcyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2tzLnVwZGF0ZSA9IGZ1bmN0aW9uKGUsIHVpKSB7XHJcbiAgICAgICAgICAgICAgLy8gU2F2ZSBjdXJyZW50IGRyb3AgcG9zaXRpb24gYnV0IG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzZWNvbmRcclxuICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhhdCBoYXBwZW5zIHdoZW4gbW92aW5nIGJldHdlZW4gbGlzdHMgYmVjYXVzZSB0aGVuXHJcbiAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgb2xkIHZhbHVlXHJcbiAgICAgICAgICAgICAgaWYoIXVpLml0ZW0uc29ydGFibGUucmVjZWl2ZWQpIHtcclxuICAgICAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUuZHJvcGluZGV4ID0gdWkuaXRlbS5pbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyb3B0YXJnZXQgPSB1aS5pdGVtLnBhcmVudCgpO1xyXG4gICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZS5kcm9wdGFyZ2V0ID0gZHJvcHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gZHJvcHRhcmdldC5hdHRyKCduZy1tb2RlbCcpIHx8IGRyb3B0YXJnZXQuYXR0cignZGF0YS1uZy1tb2RlbCcpO1xyXG4gICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZS5kcm9wdGFyZ2V0TW9kZWwgPSBkcm9wdGFyZ2V0LnNjb3BlKCkuJGV2YWwoYXR0cik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSBzb3J0IChsZXQgbmctcmVwZWF0IGRvIHRoZSBzb3J0IGZvciB1cylcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGNhbmNlbCBpZiB0aGlzIGlzIHRoZSByZWNlaXZlZCBsaXN0IGJlY2F1c2UgaXQgaGFzXHJcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGJlZW4gY2FuY2VsZWQgaW4gdGhlIG90aGVyIGxpc3QsIGFuZCB0cnlpbmcgdG8gY2FuY2VsXHJcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdpbGwgbWVzcyB1cCB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zb3J0YWJsZSgnY2FuY2VsJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBQdXQgdGhlIG5vZGVzIGJhY2sgZXhhY3RseSB0aGUgd2F5IHRoZXkgc3RhcnRlZCAodGhpcyBpcyB2ZXJ5XHJcbiAgICAgICAgICAgICAgLy8gaW1wb3J0YW50IGJlY2F1c2UgbmctcmVwZWF0IHVzZXMgY29tbWVudCBlbGVtZW50cyB0byBkZWxpbmVhdGVcclxuICAgICAgICAgICAgICAvLyB0aGUgc3RhcnQgYW5kIHN0b3Agb2YgcmVwZWF0IHNlY3Rpb25zIGFuZCBzb3J0YWJsZSBkb2Vzbid0XHJcbiAgICAgICAgICAgICAgLy8gcmVzcGVjdCB0aGVpciBvcmRlciAoZXZlbiBpZiB3ZSBjYW5jZWwsIHRoZSBvcmRlciBvZiB0aGVcclxuICAgICAgICAgICAgICAvLyBjb21tZW50cyBhcmUgc3RpbGwgbWVzc2VkIHVwKS5cclxuICAgICAgICAgICAgICBpZiAoaGFzU29ydGluZ0hlbHBlcihlbGVtZW50LCB1aSkgJiYgIXVpLml0ZW0uc29ydGFibGUucmVjZWl2ZWQgJiZcclxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5zb3J0YWJsZSggJ29wdGlvbicsICdhcHBlbmRUbycgKSA9PT0gJ3BhcmVudCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgYWxsIHRoZSBzYXZlZE5vZGVzIGV4Y2VwdCAudWktc29ydGFibGUtaGVscGVyIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIC8vICh3aGljaCBpcyBwbGFjZWQgbGFzdCkuIFRoYXQgd2F5IGl0IHdpbGwgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICBzYXZlZE5vZGVzID0gc2F2ZWROb2Rlcy5ub3Qoc2F2ZWROb2Rlcy5sYXN0KCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBzYXZlZE5vZGVzLmFwcGVuZFRvKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSB0YXJnZXQgY29ubmVjdGVkIGxpc3QgdGhlblxyXG4gICAgICAgICAgICAgIC8vIGl0J3Mgc2FmZSB0byBjbGVhciB0aGUgcmVzdG9yZWQgbm9kZXMgc2luY2U6XHJcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGlzIGN1cnJlbnRseSBydW5uaW5nIGFuZFxyXG4gICAgICAgICAgICAgIC8vIHN0b3AgaXMgbm90IGNhbGxlZCBmb3IgdGhlIHRhcmdldCBsaXN0LlxyXG4gICAgICAgICAgICAgIGlmKHVpLml0ZW0uc29ydGFibGUucmVjZWl2ZWQpIHtcclxuICAgICAgICAgICAgICAgIHNhdmVkTm9kZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcmVjZWl2ZWQgaXMgdHJ1ZSAoYW4gaXRlbSB3YXMgZHJvcHBlZCBpbiBmcm9tIGFub3RoZXIgbGlzdClcclxuICAgICAgICAgICAgICAvLyB0aGVuIHdlIGFkZCB0aGUgbmV3IGl0ZW0gdG8gdGhpcyBsaXN0IG90aGVyd2lzZSB3YWl0IHVudGlsIHRoZVxyXG4gICAgICAgICAgICAgIC8vIHN0b3AgZXZlbnQgd2hlcmUgd2Ugd2lsbCBrbm93IGlmIGl0IHdhcyBhIHNvcnQgb3IgaXRlbSB3YXNcclxuICAgICAgICAgICAgICAvLyBtb3ZlZCBoZXJlIGZyb20gYW5vdGhlciBsaXN0XHJcbiAgICAgICAgICAgICAgaWYodWkuaXRlbS5zb3J0YWJsZS5yZWNlaXZlZCAmJiAhdWkuaXRlbS5zb3J0YWJsZS5pc0NhbmNlbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5nTW9kZWwuJG1vZGVsVmFsdWUuc3BsaWNlKHVpLml0ZW0uc29ydGFibGUuZHJvcGluZGV4LCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlLm1vdmVkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zdG9wID0gZnVuY3Rpb24oZSwgdWkpIHtcclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVjZWl2ZWQgZmxhZyBoYXNuJ3QgYmUgc2V0IG9uIHRoZSBpdGVtLCB0aGlzIGlzIGFcclxuICAgICAgICAgICAgICAvLyBub3JtYWwgc29ydCwgaWYgZHJvcGluZGV4IGlzIHNldCwgdGhlIGl0ZW0gd2FzIG1vdmVkLCBzbyBtb3ZlXHJcbiAgICAgICAgICAgICAgLy8gdGhlIGl0ZW1zIGluIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgIGlmKCF1aS5pdGVtLnNvcnRhYmxlLnJlY2VpdmVkICYmXHJcbiAgICAgICAgICAgICAgICAgKCdkcm9waW5kZXgnIGluIHVpLml0ZW0uc29ydGFibGUpICYmXHJcbiAgICAgICAgICAgICAgICAgIXVpLml0ZW0uc29ydGFibGUuaXNDYW5jZWxlZCgpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgbmdNb2RlbC4kbW9kZWxWYWx1ZS5zcGxpY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgdWkuaXRlbS5zb3J0YWJsZS5kcm9waW5kZXgsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbmdNb2RlbC4kbW9kZWxWYWx1ZS5zcGxpY2UodWkuaXRlbS5zb3J0YWJsZS5pbmRleCwgMSlbMF0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpdGVtIHdhcyBub3QgbW92ZWQsIHRoZW4gcmVzdG9yZSB0aGUgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIG5nUmVwZWF0J3MgY29tbWVudCBhcmUgY29ycmVjdC5cclxuICAgICAgICAgICAgICAgIGlmICgoISgnZHJvcGluZGV4JyBpbiB1aS5pdGVtLnNvcnRhYmxlKSB8fCB1aS5pdGVtLnNvcnRhYmxlLmlzQ2FuY2VsZWQoKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaGFzU29ydGluZ0hlbHBlcihlbGVtZW50LCB1aSkpIHtcclxuICAgICAgICAgICAgICAgICAgc2F2ZWROb2Rlcy5hcHBlbmRUbyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIEl0J3Mgbm93IHNhZmUgdG8gY2xlYXIgdGhlIHNhdmVkTm9kZXNcclxuICAgICAgICAgICAgICAvLyBzaW5jZSBzdG9wIGlzIHRoZSBsYXN0IGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAgIHNhdmVkTm9kZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2tzLnJlY2VpdmUgPSBmdW5jdGlvbihlLCB1aSkge1xyXG4gICAgICAgICAgICAgIC8vIEFuIGl0ZW0gd2FzIGRyb3BwZWQgaGVyZSBmcm9tIGFub3RoZXIgbGlzdCwgc2V0IGEgZmxhZyBvbiB0aGVcclxuICAgICAgICAgICAgICAvLyBpdGVtLlxyXG4gICAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUucmVjZWl2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2tzLnJlbW92ZSA9IGZ1bmN0aW9uKGUsIHVpKSB7XHJcbiAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgYSBwcm9ibGVtIG9ic2VydmVkIGluIG5lc3RlZCBjb25uZWN0ZWQgbGlzdHMuXHJcbiAgICAgICAgICAgICAgLy8gVGhlcmUgc2hvdWxkIGJlIGFuICd1cGRhdGUnIGV2ZW50IGJlZm9yZSAncmVtb3ZlJyB3aGVuIG1vdmluZ1xyXG4gICAgICAgICAgICAgIC8vIGVsZW1lbnRzLiBJZiB0aGUgZXZlbnQgZGlkIG5vdCBmaXJlLCBjYW5jZWwgc29ydGluZy5cclxuICAgICAgICAgICAgICBpZiAoISgnZHJvcGluZGV4JyBpbiB1aS5pdGVtLnNvcnRhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zb3J0YWJsZSgnY2FuY2VsJyk7XHJcbiAgICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhpcyBsaXN0J3MgbW9kZWwgYW5kIGNvcHkgZGF0YSBpbnRvIGl0ZW0sXHJcbiAgICAgICAgICAgICAgLy8gc28gdGhlIG5leHQgbGlzdCBjYW4gcmV0cml2ZSBpdFxyXG4gICAgICAgICAgICAgIGlmICghdWkuaXRlbS5zb3J0YWJsZS5pc0NhbmNlbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHVpLml0ZW0uc29ydGFibGUubW92ZWQgPSBuZ01vZGVsLiRtb2RlbFZhbHVlLnNwbGljZShcclxuICAgICAgICAgICAgICAgICAgICB1aS5pdGVtLnNvcnRhYmxlLmluZGV4LCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHdyYXBwZXJzLmhlbHBlciA9IGZ1bmN0aW9uIChpbm5lcikge1xyXG4gICAgICAgICAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgaW5uZXJSZXN1bHQgPSBpbm5lcihlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgaXRlbS5zb3J0YWJsZS5faXNDdXN0b21IZWxwZXJVc2VkID0gaXRlbSAhPT0gaW5uZXJSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lclJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRycy51aVNvcnRhYmxlLCBmdW5jdGlvbihuZXdWYWwgLyosIG9sZFZhbCovKSB7XHJcbiAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGpxdWVyeS11aS1zb3J0YWJsZSB3aWRnZXQgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAvLyBpcyBzdGlsbCBib3VuZCB0byB0aGUgZGlyZWN0aXZlJ3MgZWxlbWVudFxyXG4gICAgICAgICAgICAgIGlmICghIWVsZW1lbnQuZGF0YSgndWktc29ydGFibGUnKSkge1xyXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG5ld1ZhbCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGEgY3VzdG9tIG9wdGlvbiBvZiB0aGUgZGlyZWN0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgaXQgYXBwcm9wcmlldGx5XHJcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gZGlyZWN0aXZlT3B0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd1aS1mbG9hdGluZycgJiYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YSgndWktc29ydGFibGUnKS5mbG9hdGluZyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0c1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZigga2V5ID09PSAnc3RvcCcgKXtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgYXBwbHkgYWZ0ZXIgc3RvcFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb21iaW5lQ2FsbGJhY2tzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgZnVuY3Rpb24oKSB7IHNjb3BlLiRhcHBseSgpOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbWJpbmVDYWxsYmFja3ModmFsdWUsIGFmdGVyU3RvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb21iaW5lQ2FsbGJhY2tzKGNhbGxiYWNrc1trZXldLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod3JhcHBlcnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcHBlcnNba2V5XSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIG9wdHNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LnNvcnRhYmxlKCdvcHRpb24nLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY2FsbGJhY2tzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgb3B0c1trZXldID0gY29tYmluZUNhbGxiYWNrcyh2YWx1ZSwgb3B0c1trZXldKTtcclxuICAgICAgICAgICAgICBpZigga2V5ID09PSAnc3RvcCcgKXtcclxuICAgICAgICAgICAgICAgIG9wdHNba2V5XSA9IGNvbWJpbmVDYWxsYmFja3Mob3B0c1trZXldLCBhZnRlclN0b3ApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJGxvZy5pbmZvKCd1aS5zb3J0YWJsZTogbmdNb2RlbCBub3QgcHJvdmlkZWQhJywgZWxlbWVudCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIHNvcnRhYmxlXHJcbiAgICAgICAgICBlbGVtZW50LnNvcnRhYmxlKG9wdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICBdKTtcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
