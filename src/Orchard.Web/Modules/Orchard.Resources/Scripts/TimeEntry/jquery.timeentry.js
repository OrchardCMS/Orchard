/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/timeEntry.html
   Time entry for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) June 2007.
   Available under the MIT (https://github.com/jquery/jquery/blob/master/MIT-LICENSE.txt) license.
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'timeEntry';

	/** Create the time entry plugin.
		<p>Sets an input field to add a spinner for time entry.</p>
		<p>The time can be entered via directly typing the value,
		via the arrow keys, or via spinner buttons.
		It is configurable to show 12 or 24-hour time, to show or hide seconds,
		to enforce a minimum and/or maximum time, to change the spinner image,
		and to constrain the time to steps, e.g. only on the quarter hours.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;input type="text"></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;input type="text" data-timeEntry="name: 'value'"></pre>
	 	@module TimeEntry
		@augments JQPlugin
		@example $(selector).timeEntry()
 $(selector).timeEntry({showSeconds: true, minTime: new Date(0, 0, 0, 12, 0, 0)}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin. */
		name: pluginName,
			
		/** Time entry before show callback.
			Triggered when the input field is focussed.
			@callback beforeShowCallback
			@param input {Element} The current input field.
			@return {object} Any changes to the instance settings.
			@example beforeShow: function(input) {
	// Cross-populate minimum/maximum times for a range
 	return {minTime: (input.id === 'timeTo' ?
 		$('#timeFrom').timeEntry('getTime') : null), 
 		maxTime: (input.id === 'timeFrom' ?
 		$('#timeTo').timeEntry('getTime') : null)};
 } */
			
		/** Time entry before set time callback.
			Triggered when the input field value is to be changed.
			@callback beforeSetTimeCallback
			@param current {string} The current time value entered.
			@param newTime {string} The new time value to use.
			@param minTime {Date} The minimum time value allowed.
			@param maxTime {Date} The maximum time value allowed.
			@return {Date} The actual time value to set.
			@example beforeSetTime: function(oldTime, newTime, minTime, maxTime) {
 	var increment = (newTime - (oldTime || newTime)) > 0;
 	if (newTime.getMinutes() > 30) { // First half of hour only
 		newTime.setMinutes(increment ? 0 : 30);
 		newTime.setHours(newTime.getHours() + (increment ? 1 : 0));
 	}
 	return newTime;
 } */
			
		/** Default settings for the plugin.
			@property [appendText=''] {string} Display text following the input box, e.g. showing the format.
			@property [showSeconds=false] {boolean} <code>true</code> to show seconds as well,
						<code>false</code> for hours/minutes only.
			@property [unlimitedHours=false] {boolean} <code>true</code> to allow entry of more than 24 hours,
						<code>false</code> to restrict to one day.
			@property [timeSteps=[1,1,1]] {number[]} Steps for each of hours/minutes/seconds when incrementing/decrementing.
			@property [initialField=null] {number} The field to highlight initially (0 = hours, 1 = minutes, ...),
						or <code>null</code> for none.
			@property [noSeparatorEntry=false] {boolean} <code>true</code> to move to next sub-field after two digits entry.
			@property [tabToExit=false] {boolean} <code>true</code> for tab key to go to next element,
						<code>false</code> for tab key to step through internal fields.
			@property [useMouseWheel=true] {boolean} <code>true</code> to use mouse wheel for increment/decrement if possible,
						<code>false</code> to never use it.
			@property [defaultTime=null] {Date|number|string} The time to use if none has been set,
						or <code>null</code> for now. Specify as a <code>Date</code> object, as a number of seconds
						offset from now, or as a string of offsets from now, using 'H' for hours,
						'M' for minutes, 'S' for seconds.
			@property [minTime=null] {Date|number|string|number[]} The earliest selectable time,
						or <code>null</code> for no limit. See <code>defaultTime</code> for possible formats,
						use array of hours, minutes, seconds for <code>unlimitedHours</code>.
			@property [maxTime=null] {Date|number|string|number[]} The latest selectable time,
						or <code>null</code> for no limit. See <code>defaultTime</code> for possible formats,
						use array of hours, minutes, seconds for <code>unlimitedHours</code>.
			@property [spinnerImage='spinnerDefault.png'] {string} The URL of the images to use for the time spinner -
						seven images packed horizontally for normal, each button pressed
						(centre, previous, next, increment, decrement), and disabled.
			@property [spinnerSize=[20,20,8]] {number[]} The width and height of the spinner image,
						and size of centre button for current time.
			@property [spinnerBigImage=''] {string} The URL of the images to use for the expanded time spinner -
						seven images packed horizontally for normal, each button pressed
						(centre, previous, next, increment, decrement), and disabled.
			@property [spinnerBigSize=[40,40,16]] {number[]} The width and height of the expanded spinner image,
						and size of centre button for current time.
			@property [spinnerIncDecOnly=false] {boolean} <code>true</code> for increment/decrement buttons only, <code>false</code> for all.
			@property [spinnerRepeat=[500,250]] {number[]} Initial and subsequent waits in milliseconds
						for repeats on the spinner buttons.
			@property [beforeShow=null] {beforeShowCallback} Function that takes an input field and
						returns a set of custom settings for the time entry.
			@property [beforeSetTime=null] {beforeSetTimeCallback} Function that runs before updating the time,
						takes the old and new times, and minimum and maximum times as parameters,
						and returns an adjusted time if necessary.
			@example {defaultTime: new Date(0, 0, 0, 8, 30, 0), minTime: -300, maxTime: '+2H +30M'} */
		defaultOptions: {
			appendText: '',
			showSeconds: false,
			unlimitedHours: false,
			timeSteps: [1, 1, 1],
			initialField: null,
			noSeparatorEntry: false,
			tabToExit: false,
			useMouseWheel: true,
			defaultTime: null,
			minTime: null,
			maxTime: null,
			spinnerImage: 'spinnerDefault.png',
			spinnerSize: [20, 20, 8],
			spinnerBigImage: '',
			spinnerBigSize: [40, 40, 16],
			spinnerIncDecOnly: false,
			spinnerRepeat: [500, 250],
			beforeShow: null,
			beforeSetTime: null
		},

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@property [show24Hours=false] {boolean} <code>true</code> to use 24 hour time, <code>false</code> for 12 hour (AM/PM).
			@property [separator=':'] {string} The separator between time fields.
			@property [ampmPrefix=''] {string} The separator before the AM/PM text.
			@property [ampmNames=['AM','PM']] {string[]} Names of morning/evening markers.
			@property [spinnerTexts=['Now','Previous&nbsp;field','Next&nbsp;field','Increment','Decrement']] {string[]}
						The popup texts for the spinner image areas. */
		regionalOptions: { // Available regional settings, indexed by language/country code
			'': { // Default regional settings - English/US
				show24Hours: false,
				separator: ':',
				ampmPrefix: '',
				ampmNames: ['AM', 'PM'],
				spinnerTexts: ['Now', 'Previous field', 'Next field', 'Increment', 'Decrement']
			}
		},
		
		_getters: ['getOffset', 'getTime', 'isDisabled'],

		_appendClass: pluginName + '-append', // Class name for the appended content
		_controlClass: pluginName + '-control', // Class name for the date entry control
		_expandClass: pluginName + '-expand', // Class name for the expanded spinner

		_disabledInputs: [], // List of time inputs that have been disabled

		_instSettings: function(elem, options) {
			return {_field: 0, _selectedHour: 0, _selectedMinute: 0, _selectedSecond: 0};
		},
		
		_postAttach: function(elem, inst) {
			elem.on('focus.' + inst.name, this._doFocus).
				on('blur.' + inst.name, this._doBlur).
				on('click.' + inst.name, this._doClick).
				on('keydown.' + inst.name, this._doKeyDown).
				on('keypress.' + inst.name, this._doKeyPress).
				on('paste.' + inst.name, function(event) { // Check pastes
					setTimeout(function() { plugin._parseTime(inst); }, 1);
				});
		},

		_optionsChanged: function(elem, inst, options) {
			var currentTime = this._extractTime(inst);
			$.extend(inst.options, options);
			inst.options.show24Hours = inst.options.show24Hours || inst.options.unlimitedHours;
			inst._field = 0;
			if (currentTime) {
				this._setTime(inst, new Date(0, 0, 0, currentTime[0], currentTime[1], currentTime[2]));
			}
			// Remove stuff dependent on old settings
			elem.next('span.' + this._appendClass).remove();
			elem.parent().find('span.' + this._controlClass).remove();
			if ($.fn.mousewheel) {
				elem.unmousewheel();
			}
			// And re-add if requested
			var spinner = (!inst.options.spinnerImage ? null :
				$('<span class="' + this._controlClass + '" style="display: inline-block; ' +
				'background: url(\'' + inst.options.spinnerImage + '\') 0 0 no-repeat; width: ' + 
				inst.options.spinnerSize[0] + 'px; height: ' + inst.options.spinnerSize[1] + 'px;"></span>'));
			elem.after(inst.options.appendText ? '<span class="' + this._appendClass + '">' +
				inst.options.appendText + '</span>' : '').after(spinner || '');
			// Allow mouse wheel usage
			if (inst.options.useMouseWheel && $.fn.mousewheel) {
				elem.mousewheel(this._doMouseWheel);
			}
			if (spinner) {
				spinner.mousedown(this._handleSpinner).mouseup(this._endSpinner).
					mouseover(this._expandSpinner).mouseout(this._endSpinner).
					mousemove(this._describeSpinner);
			}
		},

		/** Enable a time entry input and any associated spinner.
			@param elem {Element} The single input field.
			@example $(selector).timeEntry('enable') */
		enable: function(elem) {
			this._enableDisable(elem, false);
		},

		/** Disable a time entry input and any associated spinner.
			@param elem {Element} The single input field.
			@example $(selector).timeEntry('disable') */
		disable: function(elem) {
			this._enableDisable(elem, true);
		},

		/** Enable or disable a time entry input and any associated spinner.
			@private
			@param elem {Element} The single input field.
			@param disable {boolean} <code>true</code> to disable, <code>false</code> to enable. */
		_enableDisable: function(elem, disable) {
			var inst = this._getInst(elem);
			if (!inst) {
				return;
			}
			elem.disabled = disable;
			if (elem.nextSibling && elem.nextSibling.nodeName.toLowerCase() === 'span') {
				this._changeSpinner(inst, elem.nextSibling, (disable ? 5 : -1));
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === elem ? null : value); }); // Delete entry
			if (disable) {
				this._disabledInputs.push(elem);
			}
		},

		/** Check whether an input field has been disabled.
			@param elem {Element} The input field to check.
			@return {boolean} <code>true</code> if this field has been disabled, <code>false</code> if it is enabled.
			@example if ($(selector).dateEntry('isDisabled')) {...} */
		isDisabled: function(elem) {
			return $.inArray(elem, this._disabledInputs) > -1;
		},

		_preDestroy: function(elem, inst) {
			elem = $(elem).off('.' + pluginName);
			if ($.fn.mousewheel) {
				elem.unmousewheel();
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
			elem.siblings('.' + this._appendClass + ',.' + this._controlClass).remove();
		},

		/** Initialise the current time for a time entry input field.
			@param elem {Element} The input field to update.
			@param time {Date|number|string} The new time or offset or <code>null</code> to clear.
					An actual time or offset in seconds from now or units and periods of offsets from now.
			@example $(selector).timeEntry('setTime', new Date(0, 0, 0, 11, 22, 33))
 $(selector).timeEntry('setTime', +300)
 $(selector).timeEntry('setTime', '+1H +30M')
 $(selector).timeEntry('setTime', null) */
		setTime: function(elem, time) {
			var inst = this._getInst(elem);
			if (inst) {
				if (time === null || time === '') {
					$(elem).val('');
				}
				else {
					this._setTime(inst, time ? ($.isArray(time) ? time :
						(typeof time === 'object' ? new Date(time.getTime()) : time)) : null);
				}
			}
		},

		/** Retrieve the current time for a time entry input field.
			@param elem {Element} The input field to update.
			@return {Date} The current time or <code>null</code> if none.
			@example var time = $(selector).timeEntry('getTime') */
		getTime: function(elem) {
			var inst = this._getInst(elem);
			var currentTime = (inst ? this._extractTime(inst) : null);
			return (!currentTime ? null :
				new Date(0, 0, 0, currentTime[0], currentTime[1], currentTime[2]));
		},

		/** Retrieve the millisecond offset for the current time.
			@param elem {Element} The input field to examine.
			@return {number} The time as milliseconds offset or zero if none.
			@example var offset = $(selector).timeEntry('getOffset') */
		getOffset: function(elem) {
			var inst = this._getInst(elem);
			var currentTime = (inst ? this._extractTime(inst) : null);
			return (!currentTime ? 0 :
				(currentTime[0] * 3600 + currentTime[1] * 60 + currentTime[2]) * 1000);
		},

		/** Initialise date entry.
			@private
			@param elem {Element|Event} The input field or the focus event. */
		_doFocus: function(elem) {
			var input = (elem.nodeName && elem.nodeName.toLowerCase() === 'input' ? elem : this);
			if (plugin._lastInput === input || plugin.isDisabled(input)) {
				plugin._focussed = false;
				return;
			}
			var inst = plugin._getInst(input);
			plugin._focussed = true;
			plugin._lastInput = input;
			plugin._blurredInput = null;
			$.extend(inst.options, ($.isFunction(inst.options.beforeShow) ?
				inst.options.beforeShow.apply(input, [input]) : {}));
				plugin._parseTime(inst, elem.nodeName ? null : elem);
			setTimeout(function() { plugin._showField(inst); }, 10);
		},

		/** Note that the field has been exited.
			@private
			@param event {Event} The blur event. */
		_doBlur: function(event) {
			plugin._blurredInput = plugin._lastInput;
			plugin._lastInput = null;
		},

		/** Select appropriate field portion on click, if already in the field.
			@private
			@param event {Event} The click event. */
		_doClick: function(event) {
			var input = event.target;
			var inst = plugin._getInst(input);
			var prevField = inst._field;
			if (!plugin._focussed) {
				inst._field = plugin._getSelection(inst, input, event);
			}
			if (prevField !== inst._field) {
				inst._lastChr = '';
			}
			plugin._showField(inst);
			plugin._focussed = false;
		},

		/** Find the selected subfield within the control.
			@private
			@param inst {object} The current instance settings.
			@param input {Element} The input control.
			@param event {Event} The triggering event.
			@return {number} The selected subfield. */
		_getSelection: function(inst, input, event) {
			var select = 0;
			var fieldSizes = [inst.elem.val().split(inst.options.separator)[0].length, 2, 2];
			if (input.selectionStart !== null) { // Use input select range
				var end = 0;
				for (var field = 0; field <= Math.max(1, inst._secondField, inst._ampmField); field++) {
					end += (field !== inst._ampmField ? fieldSizes[field] + inst.options.separator.length :
						inst.options.ampmPrefix.length + inst.options.ampmNames[0].length);
					select = field;
					if (input.selectionStart < end) {
						break;
					}
				}
			}
			else if (input.createTextRange && event != null) { // Check against bounding boxes
				var src = $(event.srcElement);
				var range = input.createTextRange();
				var convert = function(value) {
					return {thin: 2, medium: 4, thick: 6}[value] || value;
				};
				var offsetX = event.clientX + document.documentElement.scrollLeft -
					(src.offset().left + parseInt(convert(src.css('border-left-width')), 10)) -
					range.offsetLeft; // Position - left edge - alignment
				for (var field = 0; field <= Math.max(1, inst._secondField, inst._ampmField); field++) {
					var end = (field !== inst._ampmField ? (field * fieldSize) + 2 :
						(inst._ampmField * fieldSize) + inst.options.ampmPrefix.length +
						inst.options.ampmNames[0].length);
					range.collapse();
					range.moveEnd('character', end);
					select = field;
					if (offsetX < range.boundingWidth) { // And compare
						break;
					}
				}
			}
			return select;
		},

		/** Handle keystrokes in the field.
			@private
			@param event {Event} The keydown event.
			@return {boolean} <code>true</code> to continue, <code>false</code> to stop processing. */
		_doKeyDown: function(event) {
			if (event.keyCode >= 48) { // >= '0'
				return true;
			}
			var inst = plugin._getInst(event.target);
			switch (event.keyCode) {
				case 9: return (inst.options.tabToExit ? true : (event.shiftKey ?
							// Move to previous time field, or out if at the beginning
							plugin._changeField(inst, -1, true) :
							// Move to next time field, or out if at the end
							plugin._changeField(inst, +1, true)));
				case 35: if (event.ctrlKey) { // Clear time on ctrl+end
							plugin._setValue(inst, '');
						}
						else { // Last field on end
							inst._field = Math.max(1, inst._secondField, inst._ampmField);
							plugin._adjustField(inst, 0);
						}
						break;
				case 36: if (event.ctrlKey) { // Current time on ctrl+home
							plugin._setTime(inst);
						}
						else { // First field on home
							inst._field = 0;
							plugin._adjustField(inst, 0);
						}
						break;
				case 37: plugin._changeField(inst, -1, false); break; // Previous field on left
				case 38: plugin._adjustField(inst, +1); break; // Increment time field on up
				case 39: plugin._changeField(inst, +1, false); break; // Next field on right
				case 40: plugin._adjustField(inst, -1); break; // Decrement time field on down
				case 46: plugin._setValue(inst, ''); break; // Clear time on delete
				case 8: inst._lastChr = ''; // Fall through
				default: return true;
			}
			return false;
		},

		/** Disallow unwanted characters.
			@private
			@param event {Event} The keypress event.
			@return {boolean} <code>true</code> to continue, <code>false</code> to stop processing. */
		_doKeyPress: function(event) {
			var chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
			if (chr < ' ') {
				return true;
			}
			var inst = plugin._getInst(event.target);
			plugin._handleKeyPress(inst, chr);
			return false;
		},

		/** Update date based on keystroke entered.
			@private
			@param inst {object} The instance settings.
			@param chr {string} The new character. */
		_handleKeyPress: function(inst, chr) {
			if (chr === inst.options.separator) {
				this._changeField(inst, +1, false);
			}
			else if (chr >= '0' && chr <= '9') { // Allow direct entry of date
				var key = parseInt(chr, 10);
				var value = parseInt(inst._lastChr + chr, 10);
				var hour = (inst._field !== 0 ? inst._selectedHour :
					(inst.options.unlimitedHours ? value :
					(inst.options.show24Hours ? (value < 24 ? value : key) :
					(value >= 1 && value <= 12 ? value :
					(key > 0 ? key : inst._selectedHour)) % 12 +
					(inst._selectedHour >= 12 ? 12 : 0))));
				var minute = (inst._field !== 1 ? inst._selectedMinute :
					(value < 60 ? value : key));
				var second = (inst._field !== inst._secondField ? inst._selectedSecond :
					(value < 60 ? value : key));
				var fields = this._constrainTime(inst, [hour, minute, second]);
				this._setTime(inst, (inst.options.unlimitedHours ? fields :
					new Date(0, 0, 0, fields[0], fields[1], fields[2])));
				if (inst.options.noSeparatorEntry && inst._lastChr) {
					this._changeField(inst, +1, false);
				}
				else {
					inst._lastChr = (inst.options.unlimitedHours && inst._field === 0 ? inst._lastChr + chr : chr);
				}
			}
			else if (!inst.options.show24Hours) { // Set am/pm based on first char of names
				chr = chr.toLowerCase();
				if ((chr === inst.options.ampmNames[0].substring(0, 1).toLowerCase() &&
						inst._selectedHour >= 12) ||
						(chr === inst.options.ampmNames[1].substring(0, 1).toLowerCase() &&
						inst._selectedHour < 12)) {
					var saveField = inst._field;
					inst._field = inst._ampmField;
					this._adjustField(inst, +1);
					inst._field = saveField;
					this._showField(inst);
				}
			}
		},

		/** Increment/decrement on mouse wheel activity.
			@private
			@param event {Event} The mouse wheel event.
			@param delta {number} The amount of change. */
		_doMouseWheel: function(event, delta) {
			if (plugin.isDisabled(event.target)) {
				return;
			}
			var inst = plugin._getInst(event.target);
			inst.elem.focus();
			if (!inst.elem.val()) {
				plugin._parseTime(inst);
			}
			plugin._adjustField(inst, delta);
			event.preventDefault();
		},

		/** Expand the spinner, if possible, to make it easier to use.
			@private
			@param event {Event} The mouse over event. */
		_expandSpinner: function(event) {
			var spinner = plugin._getSpinnerTarget(event);
			var inst = plugin._getInst(plugin._getInput(spinner));
			if (plugin.isDisabled(inst.elem[0])) {
				return;
			}
			if (inst.options.spinnerBigImage) {
				inst._expanded = true;
				var offset = $(spinner).offset();
				var relative = null;
				$(spinner).parents().each(function() {
					var parent = $(this);
					if (parent.css('position') === 'relative' || parent.css('position') === 'absolute') {
						relative = parent.offset();
					}
					return !relative;
				});
				$('<div class="' + plugin._expandClass + '" style="position: absolute; left: ' +
					(offset.left - (inst.options.spinnerBigSize[0] - inst.options.spinnerSize[0]) / 2 -
					(relative ? relative.left : 0)) + 'px; top: ' +
					(offset.top - (inst.options.spinnerBigSize[1] - inst.options.spinnerSize[1]) / 2 -
					(relative ? relative.top : 0)) + 'px; width: ' +
					inst.options.spinnerBigSize[0] + 'px; height: ' +
					inst.options.spinnerBigSize[1] + 'px; background: transparent url(' +
					inst.options.spinnerBigImage + ') no-repeat 0px 0px; z-index: 10;"></div>').
					mousedown(plugin._handleSpinner).mouseup(plugin._endSpinner).
					mouseout(plugin._endExpand).mousemove(plugin._describeSpinner).
					insertAfter(spinner);
			}
		},

		/** Locate the actual input field from the spinner.
			@private
			@param spinner {Element} The current spinner.
			@return {Element} The corresponding input. */
		_getInput: function(spinner) {
			return $(spinner).siblings('.' + this._getMarker())[0];
		},

		/** Change the title based on position within the spinner.
			@private
			@param event {Event} The mouse move event. */
		_describeSpinner: function(event) {
			var spinner = plugin._getSpinnerTarget(event);
			var inst = plugin._getInst(plugin._getInput(spinner));
			spinner.title = inst.options.spinnerTexts[plugin._getSpinnerRegion(inst, event)];
		},

		/** Handle a click on the spinner.
			@private
			@param event {Event} The mouse click event. */
		_handleSpinner: function(event) {
			var spinner = plugin._getSpinnerTarget(event);
			var input = plugin._getInput(spinner);
			if (plugin.isDisabled(input)) {
				return;
			}
			if (input === plugin._blurredInput) {
				plugin._lastInput = input;
				plugin._blurredInput = null;
			}
			var inst = plugin._getInst(input);
			plugin._doFocus(input);
			var region = plugin._getSpinnerRegion(inst, event);
			plugin._changeSpinner(inst, spinner, region);
			plugin._actionSpinner(inst, region);
			plugin._timer = null;
			plugin._handlingSpinner = true;
			if (region >= 3 && inst.options.spinnerRepeat[0]) { // Repeat increment/decrement
				plugin._timer = setTimeout(
					function() { plugin._repeatSpinner(inst, region); },
					inst.options.spinnerRepeat[0]);
				$(spinner).one('mouseout', plugin._releaseSpinner).
					one('mouseup', plugin._releaseSpinner);
			}
		},

		/** Action a click on the spinner.
			@private
			@param inst {object} The instance settings.
			@param region {number} The spinner "button". */
		_actionSpinner: function(inst, region) {
			if (!inst.elem.val()) {
				plugin._parseTime(inst);
			}
			switch (region) {
				case 0: this._setTime(inst); break;
				case 1: this._changeField(inst, -1, false); break;
				case 2: this._changeField(inst, +1, false); break;
				case 3: this._adjustField(inst, +1); break;
				case 4: this._adjustField(inst, -1); break;
			}
		},

		/** Repeat a click on the spinner.
			@private
			@param inst {object} The instance settings.
			@param region {number} The spinner "button". */
		_repeatSpinner: function(inst, region) {
			if (!plugin._timer) {
				return;
			}
			plugin._lastInput = plugin._blurredInput;
			this._actionSpinner(inst, region);
			this._timer = setTimeout(
				function() { plugin._repeatSpinner(inst, region); },
				inst.options.spinnerRepeat[1]);
		},

		/** Stop a spinner repeat.
			@private
			@param event {Event} The mouse event. */
		_releaseSpinner: function(event) {
			clearTimeout(plugin._timer);
			plugin._timer = null;
		},

		/** Tidy up after an expanded spinner.
			@private
			@param event {Event} The mouse event. */
		_endExpand: function(event) {
			plugin._timer = null;
			var spinner = plugin._getSpinnerTarget(event);
			var input = plugin._getInput(spinner);
			var inst = plugin._getInst(input);
			$(spinner).remove();
			inst._expanded = false;
		},

		/** Tidy up after a spinner click.
			@private
			@param event {Event} The mouse event. */
		_endSpinner: function(event) {
			plugin._timer = null;
			var spinner = plugin._getSpinnerTarget(event);
			var input = plugin._getInput(spinner);
			var inst = plugin._getInst(input);
			if (!plugin.isDisabled(input)) {
				plugin._changeSpinner(inst, spinner, -1);
			}
			if (plugin._handlingSpinner) {
				plugin._lastInput = plugin._blurredInput;
			}
			if (plugin._lastInput && plugin._handlingSpinner) {
				plugin._showField(inst);
			}
			plugin._handlingSpinner = false;
		},

		/** Retrieve the spinner from the event.
			@private
			@param event {Event} The mouse click event.
			@return {Element} The target field. */
		_getSpinnerTarget: function(event) {
			return event.target || event.srcElement;
		},

		/** Determine which "button" within the spinner was clicked.
			@private
			@param inst {object} The instance settings.
			@param event {Event} The mouse event.
			@return {number} The spinner "button" number. */
		_getSpinnerRegion: function(inst, event) {
			var spinner = this._getSpinnerTarget(event);
			var pos = $(spinner).offset();
			var scrolled = [document.documentElement.scrollLeft || document.body.scrollLeft,
				document.documentElement.scrollTop || document.body.scrollTop];
			var left = (inst.options.spinnerIncDecOnly ? 99 : event.clientX + scrolled[0] - pos.left);
			var top = event.clientY + scrolled[1] - pos.top;
			var spinnerSize = inst.options[inst._expanded ? 'spinnerBigSize' : 'spinnerSize'];
			var right = (inst.options.spinnerIncDecOnly ? 99 : spinnerSize[0] - 1 - left);
			var bottom = spinnerSize[1] - 1 - top;
			if (spinnerSize[2] > 0 && Math.abs(left - right) <= spinnerSize[2] &&
					Math.abs(top - bottom) <= spinnerSize[2]) {
				return 0; // Centre button
			}
			var min = Math.min(left, top, right, bottom);
			return (min === left ? 1 : (min === right ? 2 : (min === top ? 3 : 4))); // Nearest edge
		},

		/** Change the spinner image depending on the button clicked.
			@private
			@param inst {object} The instance settings.
			@param spinner {Element} The spinner control.
			@param region {number} The spinner "button". */
		_changeSpinner: function(inst, spinner, region) {
			$(spinner).css('background-position', '-' + ((region + 1) *
				inst.options[inst._expanded ? 'spinnerBigSize' : 'spinnerSize'][0]) + 'px 0px');
		},

		/** Extract the time value from the input field, or default to now.
			@private
			@param inst {object} The instance settings.
			@param event {Event} The triggering event or <code>null</code>. */
		_parseTime: function(inst, event) {
			var currentTime = this._extractTime(inst);
			if (currentTime) {
				inst._selectedHour = currentTime[0];
				inst._selectedMinute = currentTime[1];
				inst._selectedSecond = currentTime[2];
			}
			else {
				var now = this._constrainTime(inst);
				inst._selectedHour = now[0];
				inst._selectedMinute = now[1];
				inst._selectedSecond = (inst.options.showSeconds ? now[2] : 0);
			}
			inst._secondField = (inst.options.showSeconds ? 2 : -1);
			inst._ampmField = (inst.options.show24Hours ? -1 : (inst.options.showSeconds ? 3 : 2));
			inst._lastChr = '';
			var postProcess = function() {
				if (inst.elem.val() !== '') {
					plugin._showTime(inst);
				}
			};
			if (typeof inst.options.initialField === 'number') {
				inst._field = Math.max(0, Math.min(
					Math.max(1, inst._secondField, inst._ampmField), inst.options.initialField));
				postProcess();
			}
			else {
				setTimeout(function() {
					inst._field = plugin._getSelection(inst, inst.elem[0], event);
					postProcess();
				}, 0);
			}
		},

		/** Extract the time value from a string as an array of values, or default to <code>null</code>.
			@private
			@param value {string} The date text.
			@param inst {object} The instance settings.
			@return {number[]} The retrieved time components (hours, minutes, seconds) or
					<code>null</code> if no value. */
		_extractTime: function(inst, value) {
			value = value || inst.elem.val();
			var currentTime = value.split(inst.options.separator);
			if (inst.options.separator === '' && value !== '') {
				currentTime[0] = value.substring(0, 2);
				currentTime[1] = value.substring(2, 4);
				currentTime[2] = value.substring(4, 6);
			}
			if (currentTime.length >= 2) {
				var isAM = !inst.options.show24Hours && (value.indexOf(inst.options.ampmNames[0]) > -1);
				var isPM = !inst.options.show24Hours && (value.indexOf(inst.options.ampmNames[1]) > -1);
				var hour = parseInt(currentTime[0], 10);
				hour = (isNaN(hour) ? 0 : hour);
				hour = ((isAM || isPM) && hour === 12 ? 0 : hour) + (isPM ? 12 : 0);
				var minute = parseInt(currentTime[1], 10);
				minute = (isNaN(minute) ? 0 : minute);
				var second = (currentTime.length >= 3 ? parseInt(currentTime[2], 10) : 0);
				second = (isNaN(second) || !inst.options.showSeconds ? 0 : second);
				return this._constrainTime(inst, [hour, minute, second]);
			} 
			return null;
		},

		/** Constrain the given/current time to the time steps.
			@private
			@param inst {object} The instance settings.
			@param fields {number[]} The current time components (hours, minutes, seconds).
			@return {number[]} The constrained time components (hours, minutes, seconds). */
		_constrainTime: function(inst, fields) {
			var specified = (fields !== null && fields !== undefined);
			if (!specified) {
				var now = this._determineTime(inst.options.defaultTime, inst) || new Date();
				fields = [now.getHours(), now.getMinutes(), now.getSeconds()];
			}
			var reset = false;
			for (var i = 0; i < inst.options.timeSteps.length; i++) {
				if (reset) {
					fields[i] = 0;
				}
				else if (inst.options.timeSteps[i] > 1) {
					fields[i] = Math.round(fields[i] / inst.options.timeSteps[i]) *
						inst.options.timeSteps[i];
					reset = true;
				}
			}
			return fields;
		},

		/** Set the selected time into the input field.
			@private
			@param inst {object} The instance settings. */
		_showTime: function(inst) {
			var currentTime = (inst.options.unlimitedHours ? inst._selectedHour :
				this._formatNumber(inst.options.show24Hours ? inst._selectedHour :
				((inst._selectedHour + 11) % 12) + 1)) + inst.options.separator +
				this._formatNumber(inst._selectedMinute) +
				(inst.options.showSeconds ? inst.options.separator +
				this._formatNumber(inst._selectedSecond) : '') +
				(inst.options.show24Hours ?  '' : inst.options.ampmPrefix +
				inst.options.ampmNames[(inst._selectedHour < 12 ? 0 : 1)]);
			this._setValue(inst, currentTime);
			this._showField(inst);
		},

		/** Highlight the current date field.
			@private
			@param inst {object} The instance settings. */
		_showField: function(inst) {
			var input = inst.elem[0];
			if (inst.elem.is(':hidden') || plugin._lastInput !== input) {
				return;
			}
			var fieldSizes = [inst.elem.val().split(inst.options.separator)[0].length, 2, 2];
			var start = 0;
			var field = 0;
			while (field < inst._field) {
				start += fieldSizes[field] +
					(field === Math.max(1, inst._secondField) ? 0 : inst.options.separator.length);
				field++;
			}
			var end = start + (inst._field !== inst._ampmField ? fieldSizes[field] :
				inst.options.ampmPrefix.length + inst.options.ampmNames[0].length);
			if (input.setSelectionRange) { // Mozilla
				input.setSelectionRange(start, end);
			}
			else if (input.createTextRange) { // IE
				var range = input.createTextRange();
				range.moveStart('character', start);
				range.moveEnd('character', end - inst.elem.val().length);
				range.select();
			}
			if (!input.disabled) {
				input.focus();
			}
		},

		/** Ensure displayed single number has a leading zero.
			@private
			@param value {number} The current value.
			@return {string} Number with at least two digits. */
		_formatNumber: function(value) {
			return (value < 10 ? '0' : '') + value;
		},

		/** Update the input field and notify listeners.
			@private
			@param inst {object} The instance settings.
			@param value {string} The new value. */
		_setValue: function(inst, value) {
			if (value !== inst.elem.val()) {
				inst.elem.val(value).trigger('change');
			}
		},

		/** Move to previous/next field, or out of field altogether if appropriate.
			@private
			@param inst {object} The instance settings.
			@param offset {number} The direction of change (-1, +1).
			@param moveOut {boolean} <code>true</code> if can move out of the field.
			@return {boolean} <code>true</code> if exiting the field, <code>false</code> if not. */
		_changeField: function(inst, offset, moveOut) {
			var atFirstLast = (inst.elem.val() === '' ||
				inst._field === (offset === -1 ? 0 : Math.max(1, inst._secondField, inst._ampmField)));
			if (!atFirstLast) {
				inst._field += offset;
			}
			this._showField(inst);
			inst._lastChr = '';
			return (atFirstLast && moveOut);
		},

		/** Update the current field in the direction indicated.
			@private
			@param inst {object} The instance settings.
			@param offset {number} The amount to change by. */
		_adjustField: function(inst, offset) {
			if (inst.elem.val() === '') {
				offset = 0;
			}
			if (inst.options.unlimitedHours) {
				this._setTime(inst, [inst._selectedHour + (inst._field === 0 ? offset * inst.options.timeSteps[0] : 0),
					inst._selectedMinute + (inst._field === 1 ? offset * inst.options.timeSteps[1] : 0),
					inst._selectedSecond + (inst._field === inst._secondField ? offset * inst.options.timeSteps[2] : 0)]);
			}
			else {
			this._setTime(inst, new Date(0, 0, 0,
				inst._selectedHour + (inst._field === 0 ? offset * inst.options.timeSteps[0] : 0) +
				(inst._field === inst._ampmField ? offset * 12 : 0),
				inst._selectedMinute + (inst._field === 1 ? offset * inst.options.timeSteps[1] : 0),
					inst._selectedSecond + (inst._field === inst._secondField ? offset * inst.options.timeSteps[2] : 0)));
			}
		},

		/** Check against minimum/maximum and display time.
			@private
			@param inst {object} The instance settings.
			@param time {Date|number|string|number[]} The actual time or offset in seconds from now or
					units and periods of offsets from now or numeric period values. */
		_setTime: function(inst, time) {
			if (inst.options.unlimitedHours && $.isArray(time)) {
				var fields = time;
			}
			else {
			time = this._determineTime(time, inst);
				var fields = (time ? [time.getHours(), time.getMinutes(), time.getSeconds()] : null);
			}
			fields = this._constrainTime(inst, fields);
			time = new Date(0, 0, 0, fields[0], fields[1], fields[2]);
			// Normalise to base date
			var time = this._normaliseTime(time);
			var minTime = this._normaliseTime(this._determineTime(inst.options.minTime, inst));
			var maxTime = this._normaliseTime(this._determineTime(inst.options.maxTime, inst));
			// Ensure it is within the bounds set
			if (inst.options.unlimitedHours) {
				while (fields[2] < 0) {
					fields[2] += 60;
					fields[1]--;
				}
				while (fields[2] > 59) {
					fields[2] -= 60;
					fields[1]++;
				}
				while (fields[1] < 0) {
					fields[1] += 60;
					fields[0]--;
				}
				while (fields[1] > 59) {
					fields[1] -= 60;
					fields[0]++;
				}
				minTime = (inst.options.minTime != null && $.isArray(inst.options.minTime)) ?
					inst.options.minTime : [0, 0, 0];
				if (fields[0] < minTime[0]) {
					fields = minTime.slice(0, 3);
				}
				else if (fields[0] === minTime[0]) {
					if (fields[1] < minTime[1]) {
						fields[1] = minTime[1];
						fields[2] = minTime[2];
					}
					else if (fields[1] === minTime[1]) {
						if (fields[2] < minTime[2]) {
							fields[2] = minTime[2];
						}
					}
				}
				if (inst.options.maxTime != null && $.isArray(inst.options.maxTime)) {
					if (fields[0] > inst.options.maxTime[0]) {
						fields = inst.options.maxTime.slice(0, 3);
					}
					else if (fields[0] === inst.options.maxTime[0]) {
						if (fields[1] > inst.options.maxTime[1]) {
							fields[1] = inst.options.maxTime[1];
							fields[2] = inst.options.maxTime[2];
						}
						else if (fields[1] === inst.options.maxTime[1]) {
							if (fields[2] > inst.options.maxTime[2]) {
								fields[2] = inst.options.maxTime[2];
							}
						}
					}
				}
			}
			else {
			if (minTime && maxTime && minTime > maxTime) {
				if (time < minTime && time > maxTime) {
					time = (Math.abs(time - minTime) < Math.abs(time - maxTime) ? minTime : maxTime);
				}
			}
			else {
				time = (minTime && time < minTime ? minTime :
					(maxTime && time > maxTime ? maxTime : time));
			}
				fields[0] = time.getHours();
				fields[1] = time.getMinutes();
				fields[2] = time.getSeconds();
			}
			// Perform further restrictions if required
			if ($.isFunction(inst.options.beforeSetTime)) {
				time = inst.options.beforeSetTime.apply(inst.elem[0],
					[this.getTime(inst.elem[0]), time, minTime, maxTime]);
				fields[0] = time.getHours();
				fields[1] = time.getMinutes();
				fields[2] = time.getSeconds();
			}
			inst._selectedHour = fields[0];
			inst._selectedMinute = fields[1];
			inst._selectedSecond = fields[2];
			this._showTime(inst);
		},

		/** A time may be specified as an exact value or a relative one.
			@private
			@param setting {Date|number|string|number[]} The actual time or offset in seconds from now or
					units and periods of offsets from now or numeric period values.
			@param inst {object} The instance settings.
			@return {Date} The calculated time. */
		_determineTime: function(setting, inst) {
			var offsetNumeric = function(offset) { // E.g. +300, -2
				var time = new Date();
				time.setTime(time.getTime() + offset * 1000);
				return time;
			};
			var offsetString = function(offset) { // E.g. '+2m', '-4h', '+3h +30m' or '12:34:56PM'
				var fields = plugin._extractTime(inst, offset); // Actual time?
				var time = new Date();
				var hour = (fields ? fields[0] : time.getHours());
				var minute = (fields ? fields[1] : time.getMinutes());
				var second = (fields ? fields[2] : time.getSeconds());
				if (!fields) {
					var pattern = /([+-]?[0-9]+)\s*(s|S|m|M|h|H)?/g;
					var matches = pattern.exec(offset);
					while (matches) {
						switch (matches[2] || 's') {
							case 's' : case 'S' :
								second += parseInt(matches[1], 10); break;
							case 'm' : case 'M' :
								minute += parseInt(matches[1], 10); break;
							case 'h' : case 'H' :
								hour += parseInt(matches[1], 10); break;
						}
						matches = pattern.exec(offset);
					}
				}
				time = new Date(0, 0, 10, hour, minute, second, 0);
				if (/^!/.test(offset)) { // No wrapping
					if (time.getDate() > 10) {
						time = new Date(0, 0, 10, 23, 59, 59);
					}
					else if (time.getDate() < 10) {
						time = new Date(0, 0, 10, 0, 0, 0);
					}
				}
				return time;
			};
			var offsetArray = function(setting) {
				return new Date(0, 0, 0, setting[0], setting[1] || 0, setting[2] || 0, 0);
			};
			return (setting ? (typeof setting === 'string' ? offsetString(setting) :
				(typeof setting === 'number' ? offsetNumeric(setting) :
				($.isArray(setting) ? offsetArray(setting) : setting))) : null);
		},

		/** Normalise time object to a common date.
			@private
			@param time {Date} The original time.
			@return {Date} The normalised time. */
		_normaliseTime: function(time) {
			if (!time) {
				return null;
			}
			time.setFullYear(1900);
			time.setMonth(0);
			time.setDate(0);
			return time;
		}
	});
	
	var plugin = $.timeEntry;

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS50aW1lZW50cnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LnRpbWVlbnRyeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvdGltZUVudHJ5Lmh0bWxcclxuICAgVGltZSBlbnRyeSBmb3IgalF1ZXJ5IHYyLjAuMS5cclxuICAgV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSBKdW5lIDIwMDcuXHJcbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9NSVQtTElDRU5TRS50eHQpIGxpY2Vuc2UuXHJcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xyXG5cclxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxyXG5cclxuXHR2YXIgcGx1Z2luTmFtZSA9ICd0aW1lRW50cnknO1xyXG5cclxuXHQvKiogQ3JlYXRlIHRoZSB0aW1lIGVudHJ5IHBsdWdpbi5cclxuXHRcdDxwPlNldHMgYW4gaW5wdXQgZmllbGQgdG8gYWRkIGEgc3Bpbm5lciBmb3IgdGltZSBlbnRyeS48L3A+XHJcblx0XHQ8cD5UaGUgdGltZSBjYW4gYmUgZW50ZXJlZCB2aWEgZGlyZWN0bHkgdHlwaW5nIHRoZSB2YWx1ZSxcclxuXHRcdHZpYSB0aGUgYXJyb3cga2V5cywgb3IgdmlhIHNwaW5uZXIgYnV0dG9ucy5cclxuXHRcdEl0IGlzIGNvbmZpZ3VyYWJsZSB0byBzaG93IDEyIG9yIDI0LWhvdXIgdGltZSwgdG8gc2hvdyBvciBoaWRlIHNlY29uZHMsXHJcblx0XHR0byBlbmZvcmNlIGEgbWluaW11bSBhbmQvb3IgbWF4aW11bSB0aW1lLCB0byBjaGFuZ2UgdGhlIHNwaW5uZXIgaW1hZ2UsXHJcblx0XHRhbmQgdG8gY29uc3RyYWluIHRoZSB0aW1lIHRvIHN0ZXBzLCBlLmcuIG9ubHkgb24gdGhlIHF1YXJ0ZXIgaG91cnMuPC9wPlxyXG5cdFx0PHA+RXhwZWN0cyBIVE1MIGxpa2U6PC9wPlxyXG5cdFx0PHByZT4mbHQ7aW5wdXQgdHlwZT1cInRleHRcIj48L3ByZT5cclxuXHRcdDxwPlByb3ZpZGUgaW5saW5lIGNvbmZpZ3VyYXRpb24gbGlrZTo8L3A+XHJcblx0XHQ8cHJlPiZsdDtpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtdGltZUVudHJ5PVwibmFtZTogJ3ZhbHVlJ1wiPjwvcHJlPlxyXG5cdCBcdEBtb2R1bGUgVGltZUVudHJ5XHJcblx0XHRAYXVnbWVudHMgSlFQbHVnaW5cclxuXHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLnRpbWVFbnRyeSgpXHJcbiAkKHNlbGVjdG9yKS50aW1lRW50cnkoe3Nob3dTZWNvbmRzOiB0cnVlLCBtaW5UaW1lOiBuZXcgRGF0ZSgwLCAwLCAwLCAxMiwgMCwgMCl9KSAqL1xyXG5cdCQuSlFQbHVnaW4uY3JlYXRlUGx1Z2luKHtcclxuXHRcclxuXHRcdC8qKiBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLiAqL1xyXG5cdFx0bmFtZTogcGx1Z2luTmFtZSxcclxuXHRcdFx0XHJcblx0XHQvKiogVGltZSBlbnRyeSBiZWZvcmUgc2hvdyBjYWxsYmFjay5cclxuXHRcdFx0VHJpZ2dlcmVkIHdoZW4gdGhlIGlucHV0IGZpZWxkIGlzIGZvY3Vzc2VkLlxyXG5cdFx0XHRAY2FsbGJhY2sgYmVmb3JlU2hvd0NhbGxiYWNrXHJcblx0XHRcdEBwYXJhbSBpbnB1dCB7RWxlbWVudH0gVGhlIGN1cnJlbnQgaW5wdXQgZmllbGQuXHJcblx0XHRcdEByZXR1cm4ge29iamVjdH0gQW55IGNoYW5nZXMgdG8gdGhlIGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAZXhhbXBsZSBiZWZvcmVTaG93OiBmdW5jdGlvbihpbnB1dCkge1xyXG5cdC8vIENyb3NzLXBvcHVsYXRlIG1pbmltdW0vbWF4aW11bSB0aW1lcyBmb3IgYSByYW5nZVxyXG4gXHRyZXR1cm4ge21pblRpbWU6IChpbnB1dC5pZCA9PT0gJ3RpbWVUbycgP1xyXG4gXHRcdCQoJyN0aW1lRnJvbScpLnRpbWVFbnRyeSgnZ2V0VGltZScpIDogbnVsbCksIFxyXG4gXHRcdG1heFRpbWU6IChpbnB1dC5pZCA9PT0gJ3RpbWVGcm9tJyA/XHJcbiBcdFx0JCgnI3RpbWVUbycpLnRpbWVFbnRyeSgnZ2V0VGltZScpIDogbnVsbCl9O1xyXG4gfSAqL1xyXG5cdFx0XHRcclxuXHRcdC8qKiBUaW1lIGVudHJ5IGJlZm9yZSBzZXQgdGltZSBjYWxsYmFjay5cclxuXHRcdFx0VHJpZ2dlcmVkIHdoZW4gdGhlIGlucHV0IGZpZWxkIHZhbHVlIGlzIHRvIGJlIGNoYW5nZWQuXHJcblx0XHRcdEBjYWxsYmFjayBiZWZvcmVTZXRUaW1lQ2FsbGJhY2tcclxuXHRcdFx0QHBhcmFtIGN1cnJlbnQge3N0cmluZ30gVGhlIGN1cnJlbnQgdGltZSB2YWx1ZSBlbnRlcmVkLlxyXG5cdFx0XHRAcGFyYW0gbmV3VGltZSB7c3RyaW5nfSBUaGUgbmV3IHRpbWUgdmFsdWUgdG8gdXNlLlxyXG5cdFx0XHRAcGFyYW0gbWluVGltZSB7RGF0ZX0gVGhlIG1pbmltdW0gdGltZSB2YWx1ZSBhbGxvd2VkLlxyXG5cdFx0XHRAcGFyYW0gbWF4VGltZSB7RGF0ZX0gVGhlIG1heGltdW0gdGltZSB2YWx1ZSBhbGxvd2VkLlxyXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgYWN0dWFsIHRpbWUgdmFsdWUgdG8gc2V0LlxyXG5cdFx0XHRAZXhhbXBsZSBiZWZvcmVTZXRUaW1lOiBmdW5jdGlvbihvbGRUaW1lLCBuZXdUaW1lLCBtaW5UaW1lLCBtYXhUaW1lKSB7XHJcbiBcdHZhciBpbmNyZW1lbnQgPSAobmV3VGltZSAtIChvbGRUaW1lIHx8IG5ld1RpbWUpKSA+IDA7XHJcbiBcdGlmIChuZXdUaW1lLmdldE1pbnV0ZXMoKSA+IDMwKSB7IC8vIEZpcnN0IGhhbGYgb2YgaG91ciBvbmx5XHJcbiBcdFx0bmV3VGltZS5zZXRNaW51dGVzKGluY3JlbWVudCA/IDAgOiAzMCk7XHJcbiBcdFx0bmV3VGltZS5zZXRIb3VycyhuZXdUaW1lLmdldEhvdXJzKCkgKyAoaW5jcmVtZW50ID8gMSA6IDApKTtcclxuIFx0fVxyXG4gXHRyZXR1cm4gbmV3VGltZTtcclxuIH0gKi9cclxuXHRcdFx0XHJcblx0XHQvKiogRGVmYXVsdCBzZXR0aW5ncyBmb3IgdGhlIHBsdWdpbi5cclxuXHRcdFx0QHByb3BlcnR5IFthcHBlbmRUZXh0PScnXSB7c3RyaW5nfSBEaXNwbGF5IHRleHQgZm9sbG93aW5nIHRoZSBpbnB1dCBib3gsIGUuZy4gc2hvd2luZyB0aGUgZm9ybWF0LlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dTZWNvbmRzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gc2hvdyBzZWNvbmRzIGFzIHdlbGwsXHJcblx0XHRcdFx0XHRcdDxjb2RlPmZhbHNlPC9jb2RlPiBmb3IgaG91cnMvbWludXRlcyBvbmx5LlxyXG5cdFx0XHRAcHJvcGVydHkgW3VubGltaXRlZEhvdXJzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gYWxsb3cgZW50cnkgb2YgbW9yZSB0aGFuIDI0IGhvdXJzLFxyXG5cdFx0XHRcdFx0XHQ8Y29kZT5mYWxzZTwvY29kZT4gdG8gcmVzdHJpY3QgdG8gb25lIGRheS5cclxuXHRcdFx0QHByb3BlcnR5IFt0aW1lU3RlcHM9WzEsMSwxXV0ge251bWJlcltdfSBTdGVwcyBmb3IgZWFjaCBvZiBob3Vycy9taW51dGVzL3NlY29uZHMgd2hlbiBpbmNyZW1lbnRpbmcvZGVjcmVtZW50aW5nLlxyXG5cdFx0XHRAcHJvcGVydHkgW2luaXRpYWxGaWVsZD1udWxsXSB7bnVtYmVyfSBUaGUgZmllbGQgdG8gaGlnaGxpZ2h0IGluaXRpYWxseSAoMCA9IGhvdXJzLCAxID0gbWludXRlcywgLi4uKSxcclxuXHRcdFx0XHRcdFx0b3IgPGNvZGU+bnVsbDwvY29kZT4gZm9yIG5vbmUuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbm9TZXBhcmF0b3JFbnRyeT1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIG1vdmUgdG8gbmV4dCBzdWItZmllbGQgYWZ0ZXIgdHdvIGRpZ2l0cyBlbnRyeS5cclxuXHRcdFx0QHByb3BlcnR5IFt0YWJUb0V4aXQ9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBmb3IgdGFiIGtleSB0byBnbyB0byBuZXh0IGVsZW1lbnQsXHJcblx0XHRcdFx0XHRcdDxjb2RlPmZhbHNlPC9jb2RlPiBmb3IgdGFiIGtleSB0byBzdGVwIHRocm91Z2ggaW50ZXJuYWwgZmllbGRzLlxyXG5cdFx0XHRAcHJvcGVydHkgW3VzZU1vdXNlV2hlZWw9dHJ1ZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHVzZSBtb3VzZSB3aGVlbCBmb3IgaW5jcmVtZW50L2RlY3JlbWVudCBpZiBwb3NzaWJsZSxcclxuXHRcdFx0XHRcdFx0PGNvZGU+ZmFsc2U8L2NvZGU+IHRvIG5ldmVyIHVzZSBpdC5cclxuXHRcdFx0QHByb3BlcnR5IFtkZWZhdWx0VGltZT1udWxsXSB7RGF0ZXxudW1iZXJ8c3RyaW5nfSBUaGUgdGltZSB0byB1c2UgaWYgbm9uZSBoYXMgYmVlbiBzZXQsXHJcblx0XHRcdFx0XHRcdG9yIDxjb2RlPm51bGw8L2NvZGU+IGZvciBub3cuIFNwZWNpZnkgYXMgYSA8Y29kZT5EYXRlPC9jb2RlPiBvYmplY3QsIGFzIGEgbnVtYmVyIG9mIHNlY29uZHNcclxuXHRcdFx0XHRcdFx0b2Zmc2V0IGZyb20gbm93LCBvciBhcyBhIHN0cmluZyBvZiBvZmZzZXRzIGZyb20gbm93LCB1c2luZyAnSCcgZm9yIGhvdXJzLFxyXG5cdFx0XHRcdFx0XHQnTScgZm9yIG1pbnV0ZXMsICdTJyBmb3Igc2Vjb25kcy5cclxuXHRcdFx0QHByb3BlcnR5IFttaW5UaW1lPW51bGxdIHtEYXRlfG51bWJlcnxzdHJpbmd8bnVtYmVyW119IFRoZSBlYXJsaWVzdCBzZWxlY3RhYmxlIHRpbWUsXHJcblx0XHRcdFx0XHRcdG9yIDxjb2RlPm51bGw8L2NvZGU+IGZvciBubyBsaW1pdC4gU2VlIDxjb2RlPmRlZmF1bHRUaW1lPC9jb2RlPiBmb3IgcG9zc2libGUgZm9ybWF0cyxcclxuXHRcdFx0XHRcdFx0dXNlIGFycmF5IG9mIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzIGZvciA8Y29kZT51bmxpbWl0ZWRIb3VyczwvY29kZT4uXHJcblx0XHRcdEBwcm9wZXJ0eSBbbWF4VGltZT1udWxsXSB7RGF0ZXxudW1iZXJ8c3RyaW5nfG51bWJlcltdfSBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgdGltZSxcclxuXHRcdFx0XHRcdFx0b3IgPGNvZGU+bnVsbDwvY29kZT4gZm9yIG5vIGxpbWl0LiBTZWUgPGNvZGU+ZGVmYXVsdFRpbWU8L2NvZGU+IGZvciBwb3NzaWJsZSBmb3JtYXRzLFxyXG5cdFx0XHRcdFx0XHR1c2UgYXJyYXkgb2YgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgZm9yIDxjb2RlPnVubGltaXRlZEhvdXJzPC9jb2RlPi5cclxuXHRcdFx0QHByb3BlcnR5IFtzcGlubmVySW1hZ2U9J3NwaW5uZXJEZWZhdWx0LnBuZyddIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIGltYWdlcyB0byB1c2UgZm9yIHRoZSB0aW1lIHNwaW5uZXIgLVxyXG5cdFx0XHRcdFx0XHRzZXZlbiBpbWFnZXMgcGFja2VkIGhvcml6b250YWxseSBmb3Igbm9ybWFsLCBlYWNoIGJ1dHRvbiBwcmVzc2VkXHJcblx0XHRcdFx0XHRcdChjZW50cmUsIHByZXZpb3VzLCBuZXh0LCBpbmNyZW1lbnQsIGRlY3JlbWVudCksIGFuZCBkaXNhYmxlZC5cclxuXHRcdFx0QHByb3BlcnR5IFtzcGlubmVyU2l6ZT1bMjAsMjAsOF1dIHtudW1iZXJbXX0gVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNwaW5uZXIgaW1hZ2UsXHJcblx0XHRcdFx0XHRcdGFuZCBzaXplIG9mIGNlbnRyZSBidXR0b24gZm9yIGN1cnJlbnQgdGltZS5cclxuXHRcdFx0QHByb3BlcnR5IFtzcGlubmVyQmlnSW1hZ2U9JyddIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIGltYWdlcyB0byB1c2UgZm9yIHRoZSBleHBhbmRlZCB0aW1lIHNwaW5uZXIgLVxyXG5cdFx0XHRcdFx0XHRzZXZlbiBpbWFnZXMgcGFja2VkIGhvcml6b250YWxseSBmb3Igbm9ybWFsLCBlYWNoIGJ1dHRvbiBwcmVzc2VkXHJcblx0XHRcdFx0XHRcdChjZW50cmUsIHByZXZpb3VzLCBuZXh0LCBpbmNyZW1lbnQsIGRlY3JlbWVudCksIGFuZCBkaXNhYmxlZC5cclxuXHRcdFx0QHByb3BlcnR5IFtzcGlubmVyQmlnU2l6ZT1bNDAsNDAsMTZdXSB7bnVtYmVyW119IFRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBleHBhbmRlZCBzcGlubmVyIGltYWdlLFxyXG5cdFx0XHRcdFx0XHRhbmQgc2l6ZSBvZiBjZW50cmUgYnV0dG9uIGZvciBjdXJyZW50IHRpbWUuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc3Bpbm5lckluY0RlY09ubHk9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBmb3IgaW5jcmVtZW50L2RlY3JlbWVudCBidXR0b25zIG9ubHksIDxjb2RlPmZhbHNlPC9jb2RlPiBmb3IgYWxsLlxyXG5cdFx0XHRAcHJvcGVydHkgW3NwaW5uZXJSZXBlYXQ9WzUwMCwyNTBdXSB7bnVtYmVyW119IEluaXRpYWwgYW5kIHN1YnNlcXVlbnQgd2FpdHMgaW4gbWlsbGlzZWNvbmRzXHJcblx0XHRcdFx0XHRcdGZvciByZXBlYXRzIG9uIHRoZSBzcGlubmVyIGJ1dHRvbnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbYmVmb3JlU2hvdz1udWxsXSB7YmVmb3JlU2hvd0NhbGxiYWNrfSBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGlucHV0IGZpZWxkIGFuZFxyXG5cdFx0XHRcdFx0XHRyZXR1cm5zIGEgc2V0IG9mIGN1c3RvbSBzZXR0aW5ncyBmb3IgdGhlIHRpbWUgZW50cnkuXHJcblx0XHRcdEBwcm9wZXJ0eSBbYmVmb3JlU2V0VGltZT1udWxsXSB7YmVmb3JlU2V0VGltZUNhbGxiYWNrfSBGdW5jdGlvbiB0aGF0IHJ1bnMgYmVmb3JlIHVwZGF0aW5nIHRoZSB0aW1lLFxyXG5cdFx0XHRcdFx0XHR0YWtlcyB0aGUgb2xkIGFuZCBuZXcgdGltZXMsIGFuZCBtaW5pbXVtIGFuZCBtYXhpbXVtIHRpbWVzIGFzIHBhcmFtZXRlcnMsXHJcblx0XHRcdFx0XHRcdGFuZCByZXR1cm5zIGFuIGFkanVzdGVkIHRpbWUgaWYgbmVjZXNzYXJ5LlxyXG5cdFx0XHRAZXhhbXBsZSB7ZGVmYXVsdFRpbWU6IG5ldyBEYXRlKDAsIDAsIDAsIDgsIDMwLCAwKSwgbWluVGltZTogLTMwMCwgbWF4VGltZTogJysySCArMzBNJ30gKi9cclxuXHRcdGRlZmF1bHRPcHRpb25zOiB7XHJcblx0XHRcdGFwcGVuZFRleHQ6ICcnLFxyXG5cdFx0XHRzaG93U2Vjb25kczogZmFsc2UsXHJcblx0XHRcdHVubGltaXRlZEhvdXJzOiBmYWxzZSxcclxuXHRcdFx0dGltZVN0ZXBzOiBbMSwgMSwgMV0sXHJcblx0XHRcdGluaXRpYWxGaWVsZDogbnVsbCxcclxuXHRcdFx0bm9TZXBhcmF0b3JFbnRyeTogZmFsc2UsXHJcblx0XHRcdHRhYlRvRXhpdDogZmFsc2UsXHJcblx0XHRcdHVzZU1vdXNlV2hlZWw6IHRydWUsXHJcblx0XHRcdGRlZmF1bHRUaW1lOiBudWxsLFxyXG5cdFx0XHRtaW5UaW1lOiBudWxsLFxyXG5cdFx0XHRtYXhUaW1lOiBudWxsLFxyXG5cdFx0XHRzcGlubmVySW1hZ2U6ICdzcGlubmVyRGVmYXVsdC5wbmcnLFxyXG5cdFx0XHRzcGlubmVyU2l6ZTogWzIwLCAyMCwgOF0sXHJcblx0XHRcdHNwaW5uZXJCaWdJbWFnZTogJycsXHJcblx0XHRcdHNwaW5uZXJCaWdTaXplOiBbNDAsIDQwLCAxNl0sXHJcblx0XHRcdHNwaW5uZXJJbmNEZWNPbmx5OiBmYWxzZSxcclxuXHRcdFx0c3Bpbm5lclJlcGVhdDogWzUwMCwgMjUwXSxcclxuXHRcdFx0YmVmb3JlU2hvdzogbnVsbCxcclxuXHRcdFx0YmVmb3JlU2V0VGltZTogbnVsbFxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogTG9jYWxpc2F0aW9ucyBmb3IgdGhlIHBsdWdpbi5cclxuXHRcdFx0RW50cmllcyBhcmUgb2JqZWN0cyBpbmRleGVkIGJ5IHRoZSBsYW5ndWFnZSBjb2RlICgnJyBiZWluZyB0aGUgZGVmYXVsdCBVUy9FbmdsaXNoKS5cclxuXHRcdFx0RWFjaCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcy5cclxuXHRcdFx0QHByb3BlcnR5IFtzaG93MjRIb3Vycz1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHVzZSAyNCBob3VyIHRpbWUsIDxjb2RlPmZhbHNlPC9jb2RlPiBmb3IgMTIgaG91ciAoQU0vUE0pLlxyXG5cdFx0XHRAcHJvcGVydHkgW3NlcGFyYXRvcj0nOiddIHtzdHJpbmd9IFRoZSBzZXBhcmF0b3IgYmV0d2VlbiB0aW1lIGZpZWxkcy5cclxuXHRcdFx0QHByb3BlcnR5IFthbXBtUHJlZml4PScnXSB7c3RyaW5nfSBUaGUgc2VwYXJhdG9yIGJlZm9yZSB0aGUgQU0vUE0gdGV4dC5cclxuXHRcdFx0QHByb3BlcnR5IFthbXBtTmFtZXM9WydBTScsJ1BNJ11dIHtzdHJpbmdbXX0gTmFtZXMgb2YgbW9ybmluZy9ldmVuaW5nIG1hcmtlcnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc3Bpbm5lclRleHRzPVsnTm93JywnUHJldmlvdXMmbmJzcDtmaWVsZCcsJ05leHQmbmJzcDtmaWVsZCcsJ0luY3JlbWVudCcsJ0RlY3JlbWVudCddXSB7c3RyaW5nW119XHJcblx0XHRcdFx0XHRcdFRoZSBwb3B1cCB0ZXh0cyBmb3IgdGhlIHNwaW5uZXIgaW1hZ2UgYXJlYXMuICovXHJcblx0XHRyZWdpb25hbE9wdGlvbnM6IHsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlL2NvdW50cnkgY29kZVxyXG5cdFx0XHQnJzogeyAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzIC0gRW5nbGlzaC9VU1xyXG5cdFx0XHRcdHNob3cyNEhvdXJzOiBmYWxzZSxcclxuXHRcdFx0XHRzZXBhcmF0b3I6ICc6JyxcclxuXHRcdFx0XHRhbXBtUHJlZml4OiAnJyxcclxuXHRcdFx0XHRhbXBtTmFtZXM6IFsnQU0nLCAnUE0nXSxcclxuXHRcdFx0XHRzcGlubmVyVGV4dHM6IFsnTm93JywgJ1ByZXZpb3VzIGZpZWxkJywgJ05leHQgZmllbGQnLCAnSW5jcmVtZW50JywgJ0RlY3JlbWVudCddXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdF9nZXR0ZXJzOiBbJ2dldE9mZnNldCcsICdnZXRUaW1lJywgJ2lzRGlzYWJsZWQnXSxcclxuXHJcblx0XHRfYXBwZW5kQ2xhc3M6IHBsdWdpbk5hbWUgKyAnLWFwcGVuZCcsIC8vIENsYXNzIG5hbWUgZm9yIHRoZSBhcHBlbmRlZCBjb250ZW50XHJcblx0XHRfY29udHJvbENsYXNzOiBwbHVnaW5OYW1lICsgJy1jb250cm9sJywgLy8gQ2xhc3MgbmFtZSBmb3IgdGhlIGRhdGUgZW50cnkgY29udHJvbFxyXG5cdFx0X2V4cGFuZENsYXNzOiBwbHVnaW5OYW1lICsgJy1leHBhbmQnLCAvLyBDbGFzcyBuYW1lIGZvciB0aGUgZXhwYW5kZWQgc3Bpbm5lclxyXG5cclxuXHRcdF9kaXNhYmxlZElucHV0czogW10sIC8vIExpc3Qgb2YgdGltZSBpbnB1dHMgdGhhdCBoYXZlIGJlZW4gZGlzYWJsZWRcclxuXHJcblx0XHRfaW5zdFNldHRpbmdzOiBmdW5jdGlvbihlbGVtLCBvcHRpb25zKSB7XHJcblx0XHRcdHJldHVybiB7X2ZpZWxkOiAwLCBfc2VsZWN0ZWRIb3VyOiAwLCBfc2VsZWN0ZWRNaW51dGU6IDAsIF9zZWxlY3RlZFNlY29uZDogMH07XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRfcG9zdEF0dGFjaDogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xyXG5cdFx0XHRlbGVtLm9uKCdmb2N1cy4nICsgaW5zdC5uYW1lLCB0aGlzLl9kb0ZvY3VzKS5cclxuXHRcdFx0XHRvbignYmx1ci4nICsgaW5zdC5uYW1lLCB0aGlzLl9kb0JsdXIpLlxyXG5cdFx0XHRcdG9uKCdjbGljay4nICsgaW5zdC5uYW1lLCB0aGlzLl9kb0NsaWNrKS5cclxuXHRcdFx0XHRvbigna2V5ZG93bi4nICsgaW5zdC5uYW1lLCB0aGlzLl9kb0tleURvd24pLlxyXG5cdFx0XHRcdG9uKCdrZXlwcmVzcy4nICsgaW5zdC5uYW1lLCB0aGlzLl9kb0tleVByZXNzKS5cclxuXHRcdFx0XHRvbigncGFzdGUuJyArIGluc3QubmFtZSwgZnVuY3Rpb24oZXZlbnQpIHsgLy8gQ2hlY2sgcGFzdGVzXHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBwbHVnaW4uX3BhcnNlVGltZShpbnN0KTsgfSwgMSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9vcHRpb25zQ2hhbmdlZDogZnVuY3Rpb24oZWxlbSwgaW5zdCwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSB0aGlzLl9leHRyYWN0VGltZShpbnN0KTtcclxuXHRcdFx0JC5leHRlbmQoaW5zdC5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRcdFx0aW5zdC5vcHRpb25zLnNob3cyNEhvdXJzID0gaW5zdC5vcHRpb25zLnNob3cyNEhvdXJzIHx8IGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3VycztcclxuXHRcdFx0aW5zdC5fZmllbGQgPSAwO1xyXG5cdFx0XHRpZiAoY3VycmVudFRpbWUpIHtcclxuXHRcdFx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIG5ldyBEYXRlKDAsIDAsIDAsIGN1cnJlbnRUaW1lWzBdLCBjdXJyZW50VGltZVsxXSwgY3VycmVudFRpbWVbMl0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBSZW1vdmUgc3R1ZmYgZGVwZW5kZW50IG9uIG9sZCBzZXR0aW5nc1xyXG5cdFx0XHRlbGVtLm5leHQoJ3NwYW4uJyArIHRoaXMuX2FwcGVuZENsYXNzKS5yZW1vdmUoKTtcclxuXHRcdFx0ZWxlbS5wYXJlbnQoKS5maW5kKCdzcGFuLicgKyB0aGlzLl9jb250cm9sQ2xhc3MpLnJlbW92ZSgpO1xyXG5cdFx0XHRpZiAoJC5mbi5tb3VzZXdoZWVsKSB7XHJcblx0XHRcdFx0ZWxlbS51bm1vdXNld2hlZWwoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBBbmQgcmUtYWRkIGlmIHJlcXVlc3RlZFxyXG5cdFx0XHR2YXIgc3Bpbm5lciA9ICghaW5zdC5vcHRpb25zLnNwaW5uZXJJbWFnZSA/IG51bGwgOlxyXG5cdFx0XHRcdCQoJzxzcGFuIGNsYXNzPVwiJyArIHRoaXMuX2NvbnRyb2xDbGFzcyArICdcIiBzdHlsZT1cImRpc3BsYXk6IGlubGluZS1ibG9jazsgJyArXHJcblx0XHRcdFx0J2JhY2tncm91bmQ6IHVybChcXCcnICsgaW5zdC5vcHRpb25zLnNwaW5uZXJJbWFnZSArICdcXCcpIDAgMCBuby1yZXBlYXQ7IHdpZHRoOiAnICsgXHJcblx0XHRcdFx0aW5zdC5vcHRpb25zLnNwaW5uZXJTaXplWzBdICsgJ3B4OyBoZWlnaHQ6ICcgKyBpbnN0Lm9wdGlvbnMuc3Bpbm5lclNpemVbMV0gKyAncHg7XCI+PC9zcGFuPicpKTtcclxuXHRcdFx0ZWxlbS5hZnRlcihpbnN0Lm9wdGlvbnMuYXBwZW5kVGV4dCA/ICc8c3BhbiBjbGFzcz1cIicgKyB0aGlzLl9hcHBlbmRDbGFzcyArICdcIj4nICtcclxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuYXBwZW5kVGV4dCArICc8L3NwYW4+JyA6ICcnKS5hZnRlcihzcGlubmVyIHx8ICcnKTtcclxuXHRcdFx0Ly8gQWxsb3cgbW91c2Ugd2hlZWwgdXNhZ2VcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy51c2VNb3VzZVdoZWVsICYmICQuZm4ubW91c2V3aGVlbCkge1xyXG5cdFx0XHRcdGVsZW0ubW91c2V3aGVlbCh0aGlzLl9kb01vdXNlV2hlZWwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcGlubmVyKSB7XHJcblx0XHRcdFx0c3Bpbm5lci5tb3VzZWRvd24odGhpcy5faGFuZGxlU3Bpbm5lcikubW91c2V1cCh0aGlzLl9lbmRTcGlubmVyKS5cclxuXHRcdFx0XHRcdG1vdXNlb3Zlcih0aGlzLl9leHBhbmRTcGlubmVyKS5tb3VzZW91dCh0aGlzLl9lbmRTcGlubmVyKS5cclxuXHRcdFx0XHRcdG1vdXNlbW92ZSh0aGlzLl9kZXNjcmliZVNwaW5uZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBFbmFibGUgYSB0aW1lIGVudHJ5IGlucHV0IGFuZCBhbnkgYXNzb2NpYXRlZCBzcGlubmVyLlxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIHNpbmdsZSBpbnB1dCBmaWVsZC5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikudGltZUVudHJ5KCdlbmFibGUnKSAqL1xyXG5cdFx0ZW5hYmxlOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdHRoaXMuX2VuYWJsZURpc2FibGUoZWxlbSwgZmFsc2UpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGlzYWJsZSBhIHRpbWUgZW50cnkgaW5wdXQgYW5kIGFueSBhc3NvY2lhdGVkIHNwaW5uZXIuXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgc2luZ2xlIGlucHV0IGZpZWxkLlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS50aW1lRW50cnkoJ2Rpc2FibGUnKSAqL1xyXG5cdFx0ZGlzYWJsZTogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHR0aGlzLl9lbmFibGVEaXNhYmxlKGVsZW0sIHRydWUpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRW5hYmxlIG9yIGRpc2FibGUgYSB0aW1lIGVudHJ5IGlucHV0IGFuZCBhbnkgYXNzb2NpYXRlZCBzcGlubmVyLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIHNpbmdsZSBpbnB1dCBmaWVsZC5cclxuXHRcdFx0QHBhcmFtIGRpc2FibGUge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGRpc2FibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBlbmFibGUuICovXHJcblx0XHRfZW5hYmxlRGlzYWJsZTogZnVuY3Rpb24oZWxlbSwgZGlzYWJsZSkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghaW5zdCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbGVtLmRpc2FibGVkID0gZGlzYWJsZTtcclxuXHRcdFx0aWYgKGVsZW0ubmV4dFNpYmxpbmcgJiYgZWxlbS5uZXh0U2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3BhbicpIHtcclxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VTcGlubmVyKGluc3QsIGVsZW0ubmV4dFNpYmxpbmcsIChkaXNhYmxlID8gNSA6IC0xKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcclxuXHRcdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSBlbGVtID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIERlbGV0ZSBlbnRyeVxyXG5cdFx0XHRpZiAoZGlzYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzLnB1c2goZWxlbSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENoZWNrIHdoZXRoZXIgYW4gaW5wdXQgZmllbGQgaGFzIGJlZW4gZGlzYWJsZWQuXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgaW5wdXQgZmllbGQgdG8gY2hlY2suXHJcblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgZmllbGQgaGFzIGJlZW4gZGlzYWJsZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBpdCBpcyBlbmFibGVkLlxyXG5cdFx0XHRAZXhhbXBsZSBpZiAoJChzZWxlY3RvcikuZGF0ZUVudHJ5KCdpc0Rpc2FibGVkJykpIHsuLi59ICovXHJcblx0XHRpc0Rpc2FibGVkOiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdHJldHVybiAkLmluQXJyYXkoZWxlbSwgdGhpcy5fZGlzYWJsZWRJbnB1dHMpID4gLTE7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9wcmVEZXN0cm95OiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XHJcblx0XHRcdGVsZW0gPSAkKGVsZW0pLm9mZignLicgKyBwbHVnaW5OYW1lKTtcclxuXHRcdFx0aWYgKCQuZm4ubW91c2V3aGVlbCkge1xyXG5cdFx0XHRcdGVsZW0udW5tb3VzZXdoZWVsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcclxuXHRcdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSBlbGVtWzBdID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIERlbGV0ZSBlbnRyeVxyXG5cdFx0XHRlbGVtLnNpYmxpbmdzKCcuJyArIHRoaXMuX2FwcGVuZENsYXNzICsgJywuJyArIHRoaXMuX2NvbnRyb2xDbGFzcykucmVtb3ZlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBJbml0aWFsaXNlIHRoZSBjdXJyZW50IHRpbWUgZm9yIGEgdGltZSBlbnRyeSBpbnB1dCBmaWVsZC5cclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBpbnB1dCBmaWVsZCB0byB1cGRhdGUuXHJcblx0XHRcdEBwYXJhbSB0aW1lIHtEYXRlfG51bWJlcnxzdHJpbmd9IFRoZSBuZXcgdGltZSBvciBvZmZzZXQgb3IgPGNvZGU+bnVsbDwvY29kZT4gdG8gY2xlYXIuXHJcblx0XHRcdFx0XHRBbiBhY3R1YWwgdGltZSBvciBvZmZzZXQgaW4gc2Vjb25kcyBmcm9tIG5vdyBvciB1bml0cyBhbmQgcGVyaW9kcyBvZiBvZmZzZXRzIGZyb20gbm93LlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS50aW1lRW50cnkoJ3NldFRpbWUnLCBuZXcgRGF0ZSgwLCAwLCAwLCAxMSwgMjIsIDMzKSlcclxuICQoc2VsZWN0b3IpLnRpbWVFbnRyeSgnc2V0VGltZScsICszMDApXHJcbiAkKHNlbGVjdG9yKS50aW1lRW50cnkoJ3NldFRpbWUnLCAnKzFIICszME0nKVxyXG4gJChzZWxlY3RvcikudGltZUVudHJ5KCdzZXRUaW1lJywgbnVsbCkgKi9cclxuXHRcdHNldFRpbWU6IGZ1bmN0aW9uKGVsZW0sIHRpbWUpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoaW5zdCkge1xyXG5cdFx0XHRcdGlmICh0aW1lID09PSBudWxsIHx8IHRpbWUgPT09ICcnKSB7XHJcblx0XHRcdFx0XHQkKGVsZW0pLnZhbCgnJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fc2V0VGltZShpbnN0LCB0aW1lID8gKCQuaXNBcnJheSh0aW1lKSA/IHRpbWUgOlxyXG5cdFx0XHRcdFx0XHQodHlwZW9mIHRpbWUgPT09ICdvYmplY3QnID8gbmV3IERhdGUodGltZS5nZXRUaW1lKCkpIDogdGltZSkpIDogbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgY3VycmVudCB0aW1lIGZvciBhIHRpbWUgZW50cnkgaW5wdXQgZmllbGQuXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgaW5wdXQgZmllbGQgdG8gdXBkYXRlLlxyXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgY3VycmVudCB0aW1lIG9yIDxjb2RlPm51bGw8L2NvZGU+IGlmIG5vbmUuXHJcblx0XHRcdEBleGFtcGxlIHZhciB0aW1lID0gJChzZWxlY3RvcikudGltZUVudHJ5KCdnZXRUaW1lJykgKi9cclxuXHRcdGdldFRpbWU6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSAoaW5zdCA/IHRoaXMuX2V4dHJhY3RUaW1lKGluc3QpIDogbnVsbCk7XHJcblx0XHRcdHJldHVybiAoIWN1cnJlbnRUaW1lID8gbnVsbCA6XHJcblx0XHRcdFx0bmV3IERhdGUoMCwgMCwgMCwgY3VycmVudFRpbWVbMF0sIGN1cnJlbnRUaW1lWzFdLCBjdXJyZW50VGltZVsyXSkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIG1pbGxpc2Vjb25kIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgdGltZS5cclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBpbnB1dCBmaWVsZCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSB0aW1lIGFzIG1pbGxpc2Vjb25kcyBvZmZzZXQgb3IgemVybyBpZiBub25lLlxyXG5cdFx0XHRAZXhhbXBsZSB2YXIgb2Zmc2V0ID0gJChzZWxlY3RvcikudGltZUVudHJ5KCdnZXRPZmZzZXQnKSAqL1xyXG5cdFx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihlbGVtKSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gKGluc3QgPyB0aGlzLl9leHRyYWN0VGltZShpbnN0KSA6IG51bGwpO1xyXG5cdFx0XHRyZXR1cm4gKCFjdXJyZW50VGltZSA/IDAgOlxyXG5cdFx0XHRcdChjdXJyZW50VGltZVswXSAqIDM2MDAgKyBjdXJyZW50VGltZVsxXSAqIDYwICsgY3VycmVudFRpbWVbMl0pICogMTAwMCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBJbml0aWFsaXNlIGRhdGUgZW50cnkuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fEV2ZW50fSBUaGUgaW5wdXQgZmllbGQgb3IgdGhlIGZvY3VzIGV2ZW50LiAqL1xyXG5cdFx0X2RvRm9jdXM6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0dmFyIGlucHV0ID0gKGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnID8gZWxlbSA6IHRoaXMpO1xyXG5cdFx0XHRpZiAocGx1Z2luLl9sYXN0SW5wdXQgPT09IGlucHV0IHx8IHBsdWdpbi5pc0Rpc2FibGVkKGlucHV0KSkge1xyXG5cdFx0XHRcdHBsdWdpbi5fZm9jdXNzZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoaW5wdXQpO1xyXG5cdFx0XHRwbHVnaW4uX2ZvY3Vzc2VkID0gdHJ1ZTtcclxuXHRcdFx0cGx1Z2luLl9sYXN0SW5wdXQgPSBpbnB1dDtcclxuXHRcdFx0cGx1Z2luLl9ibHVycmVkSW5wdXQgPSBudWxsO1xyXG5cdFx0XHQkLmV4dGVuZChpbnN0Lm9wdGlvbnMsICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLmJlZm9yZVNob3cpID9cclxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuYmVmb3JlU2hvdy5hcHBseShpbnB1dCwgW2lucHV0XSkgOiB7fSkpO1xyXG5cdFx0XHRcdHBsdWdpbi5fcGFyc2VUaW1lKGluc3QsIGVsZW0ubm9kZU5hbWUgPyBudWxsIDogZWxlbSk7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHBsdWdpbi5fc2hvd0ZpZWxkKGluc3QpOyB9LCAxMCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBOb3RlIHRoYXQgdGhlIGZpZWxkIGhhcyBiZWVuIGV4aXRlZC5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIGJsdXIgZXZlbnQuICovXHJcblx0XHRfZG9CbHVyOiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHRwbHVnaW4uX2JsdXJyZWRJbnB1dCA9IHBsdWdpbi5fbGFzdElucHV0O1xyXG5cdFx0XHRwbHVnaW4uX2xhc3RJbnB1dCA9IG51bGw7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTZWxlY3QgYXBwcm9wcmlhdGUgZmllbGQgcG9ydGlvbiBvbiBjbGljaywgaWYgYWxyZWFkeSBpbiB0aGUgZmllbGQuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBjbGljayBldmVudC4gKi9cclxuXHRcdF9kb0NsaWNrOiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHR2YXIgaW5wdXQgPSBldmVudC50YXJnZXQ7XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGlucHV0KTtcclxuXHRcdFx0dmFyIHByZXZGaWVsZCA9IGluc3QuX2ZpZWxkO1xyXG5cdFx0XHRpZiAoIXBsdWdpbi5fZm9jdXNzZWQpIHtcclxuXHRcdFx0XHRpbnN0Ll9maWVsZCA9IHBsdWdpbi5fZ2V0U2VsZWN0aW9uKGluc3QsIGlucHV0LCBldmVudCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHByZXZGaWVsZCAhPT0gaW5zdC5fZmllbGQpIHtcclxuXHRcdFx0XHRpbnN0Ll9sYXN0Q2hyID0gJyc7XHJcblx0XHRcdH1cclxuXHRcdFx0cGx1Z2luLl9zaG93RmllbGQoaW5zdCk7XHJcblx0XHRcdHBsdWdpbi5fZm9jdXNzZWQgPSBmYWxzZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEZpbmQgdGhlIHNlbGVjdGVkIHN1YmZpZWxkIHdpdGhpbiB0aGUgY29udHJvbC5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSBpbnB1dCB7RWxlbWVudH0gVGhlIGlucHV0IGNvbnRyb2wuXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSB0cmlnZ2VyaW5nIGV2ZW50LlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBzZWxlY3RlZCBzdWJmaWVsZC4gKi9cclxuXHRcdF9nZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGluc3QsIGlucHV0LCBldmVudCkge1xyXG5cdFx0XHR2YXIgc2VsZWN0ID0gMDtcclxuXHRcdFx0dmFyIGZpZWxkU2l6ZXMgPSBbaW5zdC5lbGVtLnZhbCgpLnNwbGl0KGluc3Qub3B0aW9ucy5zZXBhcmF0b3IpWzBdLmxlbmd0aCwgMiwgMl07XHJcblx0XHRcdGlmIChpbnB1dC5zZWxlY3Rpb25TdGFydCAhPT0gbnVsbCkgeyAvLyBVc2UgaW5wdXQgc2VsZWN0IHJhbmdlXHJcblx0XHRcdFx0dmFyIGVuZCA9IDA7XHJcblx0XHRcdFx0Zm9yICh2YXIgZmllbGQgPSAwOyBmaWVsZCA8PSBNYXRoLm1heCgxLCBpbnN0Ll9zZWNvbmRGaWVsZCwgaW5zdC5fYW1wbUZpZWxkKTsgZmllbGQrKykge1xyXG5cdFx0XHRcdFx0ZW5kICs9IChmaWVsZCAhPT0gaW5zdC5fYW1wbUZpZWxkID8gZmllbGRTaXplc1tmaWVsZF0gKyBpbnN0Lm9wdGlvbnMuc2VwYXJhdG9yLmxlbmd0aCA6XHJcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5hbXBtUHJlZml4Lmxlbmd0aCArIGluc3Qub3B0aW9ucy5hbXBtTmFtZXNbMF0ubGVuZ3RoKTtcclxuXHRcdFx0XHRcdHNlbGVjdCA9IGZpZWxkO1xyXG5cdFx0XHRcdFx0aWYgKGlucHV0LnNlbGVjdGlvblN0YXJ0IDwgZW5kKSB7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChpbnB1dC5jcmVhdGVUZXh0UmFuZ2UgJiYgZXZlbnQgIT0gbnVsbCkgeyAvLyBDaGVjayBhZ2FpbnN0IGJvdW5kaW5nIGJveGVzXHJcblx0XHRcdFx0dmFyIHNyYyA9ICQoZXZlbnQuc3JjRWxlbWVudCk7XHJcblx0XHRcdFx0dmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XHJcblx0XHRcdFx0dmFyIGNvbnZlcnQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHt0aGluOiAyLCBtZWRpdW06IDQsIHRoaWNrOiA2fVt2YWx1ZV0gfHwgdmFsdWU7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHR2YXIgb2Zmc2V0WCA9IGV2ZW50LmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCAtXHJcblx0XHRcdFx0XHQoc3JjLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludChjb252ZXJ0KHNyYy5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykpLCAxMCkpIC1cclxuXHRcdFx0XHRcdHJhbmdlLm9mZnNldExlZnQ7IC8vIFBvc2l0aW9uIC0gbGVmdCBlZGdlIC0gYWxpZ25tZW50XHJcblx0XHRcdFx0Zm9yICh2YXIgZmllbGQgPSAwOyBmaWVsZCA8PSBNYXRoLm1heCgxLCBpbnN0Ll9zZWNvbmRGaWVsZCwgaW5zdC5fYW1wbUZpZWxkKTsgZmllbGQrKykge1xyXG5cdFx0XHRcdFx0dmFyIGVuZCA9IChmaWVsZCAhPT0gaW5zdC5fYW1wbUZpZWxkID8gKGZpZWxkICogZmllbGRTaXplKSArIDIgOlxyXG5cdFx0XHRcdFx0XHQoaW5zdC5fYW1wbUZpZWxkICogZmllbGRTaXplKSArIGluc3Qub3B0aW9ucy5hbXBtUHJlZml4Lmxlbmd0aCArXHJcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5hbXBtTmFtZXNbMF0ubGVuZ3RoKTtcclxuXHRcdFx0XHRcdHJhbmdlLmNvbGxhcHNlKCk7XHJcblx0XHRcdFx0XHRyYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xyXG5cdFx0XHRcdFx0c2VsZWN0ID0gZmllbGQ7XHJcblx0XHRcdFx0XHRpZiAob2Zmc2V0WCA8IHJhbmdlLmJvdW5kaW5nV2lkdGgpIHsgLy8gQW5kIGNvbXBhcmVcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzZWxlY3Q7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBIYW5kbGUga2V5c3Ryb2tlcyBpbiB0aGUgZmllbGQuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBrZXlkb3duIGV2ZW50LlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBjb250aW51ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IHRvIHN0b3AgcHJvY2Vzc2luZy4gKi9cclxuXHRcdF9kb0tleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdGlmIChldmVudC5rZXlDb2RlID49IDQ4KSB7IC8vID49ICcwJ1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGV2ZW50LnRhcmdldCk7XHJcblx0XHRcdHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xyXG5cdFx0XHRcdGNhc2UgOTogcmV0dXJuIChpbnN0Lm9wdGlvbnMudGFiVG9FeGl0ID8gdHJ1ZSA6IChldmVudC5zaGlmdEtleSA/XHJcblx0XHRcdFx0XHRcdFx0Ly8gTW92ZSB0byBwcmV2aW91cyB0aW1lIGZpZWxkLCBvciBvdXQgaWYgYXQgdGhlIGJlZ2lubmluZ1xyXG5cdFx0XHRcdFx0XHRcdHBsdWdpbi5fY2hhbmdlRmllbGQoaW5zdCwgLTEsIHRydWUpIDpcclxuXHRcdFx0XHRcdFx0XHQvLyBNb3ZlIHRvIG5leHQgdGltZSBmaWVsZCwgb3Igb3V0IGlmIGF0IHRoZSBlbmRcclxuXHRcdFx0XHRcdFx0XHRwbHVnaW4uX2NoYW5nZUZpZWxkKGluc3QsICsxLCB0cnVlKSkpO1xyXG5cdFx0XHRcdGNhc2UgMzU6IGlmIChldmVudC5jdHJsS2V5KSB7IC8vIENsZWFyIHRpbWUgb24gY3RybCtlbmRcclxuXHRcdFx0XHRcdFx0XHRwbHVnaW4uX3NldFZhbHVlKGluc3QsICcnKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHsgLy8gTGFzdCBmaWVsZCBvbiBlbmRcclxuXHRcdFx0XHRcdFx0XHRpbnN0Ll9maWVsZCA9IE1hdGgubWF4KDEsIGluc3QuX3NlY29uZEZpZWxkLCBpbnN0Ll9hbXBtRmllbGQpO1xyXG5cdFx0XHRcdFx0XHRcdHBsdWdpbi5fYWRqdXN0RmllbGQoaW5zdCwgMCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAzNjogaWYgKGV2ZW50LmN0cmxLZXkpIHsgLy8gQ3VycmVudCB0aW1lIG9uIGN0cmwraG9tZVxyXG5cdFx0XHRcdFx0XHRcdHBsdWdpbi5fc2V0VGltZShpbnN0KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHsgLy8gRmlyc3QgZmllbGQgb24gaG9tZVxyXG5cdFx0XHRcdFx0XHRcdGluc3QuX2ZpZWxkID0gMDtcclxuXHRcdFx0XHRcdFx0XHRwbHVnaW4uX2FkanVzdEZpZWxkKGluc3QsIDApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMzc6IHBsdWdpbi5fY2hhbmdlRmllbGQoaW5zdCwgLTEsIGZhbHNlKTsgYnJlYWs7IC8vIFByZXZpb3VzIGZpZWxkIG9uIGxlZnRcclxuXHRcdFx0XHRjYXNlIDM4OiBwbHVnaW4uX2FkanVzdEZpZWxkKGluc3QsICsxKTsgYnJlYWs7IC8vIEluY3JlbWVudCB0aW1lIGZpZWxkIG9uIHVwXHJcblx0XHRcdFx0Y2FzZSAzOTogcGx1Z2luLl9jaGFuZ2VGaWVsZChpbnN0LCArMSwgZmFsc2UpOyBicmVhazsgLy8gTmV4dCBmaWVsZCBvbiByaWdodFxyXG5cdFx0XHRcdGNhc2UgNDA6IHBsdWdpbi5fYWRqdXN0RmllbGQoaW5zdCwgLTEpOyBicmVhazsgLy8gRGVjcmVtZW50IHRpbWUgZmllbGQgb24gZG93blxyXG5cdFx0XHRcdGNhc2UgNDY6IHBsdWdpbi5fc2V0VmFsdWUoaW5zdCwgJycpOyBicmVhazsgLy8gQ2xlYXIgdGltZSBvbiBkZWxldGVcclxuXHRcdFx0XHRjYXNlIDg6IGluc3QuX2xhc3RDaHIgPSAnJzsgLy8gRmFsbCB0aHJvdWdoXHJcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGlzYWxsb3cgdW53YW50ZWQgY2hhcmFjdGVycy5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIGtleXByZXNzIGV2ZW50LlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBjb250aW51ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IHRvIHN0b3AgcHJvY2Vzc2luZy4gKi9cclxuXHRcdF9kb0tleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHR2YXIgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PT0gdW5kZWZpbmVkID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcclxuXHRcdFx0aWYgKGNociA8ICcgJykge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGV2ZW50LnRhcmdldCk7XHJcblx0XHRcdHBsdWdpbi5faGFuZGxlS2V5UHJlc3MoaW5zdCwgY2hyKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogVXBkYXRlIGRhdGUgYmFzZWQgb24ga2V5c3Ryb2tlIGVudGVyZWQuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIGNociB7c3RyaW5nfSBUaGUgbmV3IGNoYXJhY3Rlci4gKi9cclxuXHRcdF9oYW5kbGVLZXlQcmVzczogZnVuY3Rpb24oaW5zdCwgY2hyKSB7XHJcblx0XHRcdGlmIChjaHIgPT09IGluc3Qub3B0aW9ucy5zZXBhcmF0b3IpIHtcclxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VGaWVsZChpbnN0LCArMSwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGNociA+PSAnMCcgJiYgY2hyIDw9ICc5JykgeyAvLyBBbGxvdyBkaXJlY3QgZW50cnkgb2YgZGF0ZVxyXG5cdFx0XHRcdHZhciBrZXkgPSBwYXJzZUludChjaHIsIDEwKTtcclxuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUludChpbnN0Ll9sYXN0Q2hyICsgY2hyLCAxMCk7XHJcblx0XHRcdFx0dmFyIGhvdXIgPSAoaW5zdC5fZmllbGQgIT09IDAgPyBpbnN0Ll9zZWxlY3RlZEhvdXIgOlxyXG5cdFx0XHRcdFx0KGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3VycyA/IHZhbHVlIDpcclxuXHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMuc2hvdzI0SG91cnMgPyAodmFsdWUgPCAyNCA/IHZhbHVlIDoga2V5KSA6XHJcblx0XHRcdFx0XHQodmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSAxMiA/IHZhbHVlIDpcclxuXHRcdFx0XHRcdChrZXkgPiAwID8ga2V5IDogaW5zdC5fc2VsZWN0ZWRIb3VyKSkgJSAxMiArXHJcblx0XHRcdFx0XHQoaW5zdC5fc2VsZWN0ZWRIb3VyID49IDEyID8gMTIgOiAwKSkpKTtcclxuXHRcdFx0XHR2YXIgbWludXRlID0gKGluc3QuX2ZpZWxkICE9PSAxID8gaW5zdC5fc2VsZWN0ZWRNaW51dGUgOlxyXG5cdFx0XHRcdFx0KHZhbHVlIDwgNjAgPyB2YWx1ZSA6IGtleSkpO1xyXG5cdFx0XHRcdHZhciBzZWNvbmQgPSAoaW5zdC5fZmllbGQgIT09IGluc3QuX3NlY29uZEZpZWxkID8gaW5zdC5fc2VsZWN0ZWRTZWNvbmQgOlxyXG5cdFx0XHRcdFx0KHZhbHVlIDwgNjAgPyB2YWx1ZSA6IGtleSkpO1xyXG5cdFx0XHRcdHZhciBmaWVsZHMgPSB0aGlzLl9jb25zdHJhaW5UaW1lKGluc3QsIFtob3VyLCBtaW51dGUsIHNlY29uZF0pO1xyXG5cdFx0XHRcdHRoaXMuX3NldFRpbWUoaW5zdCwgKGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3VycyA/IGZpZWxkcyA6XHJcblx0XHRcdFx0XHRuZXcgRGF0ZSgwLCAwLCAwLCBmaWVsZHNbMF0sIGZpZWxkc1sxXSwgZmllbGRzWzJdKSkpO1xyXG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMubm9TZXBhcmF0b3JFbnRyeSAmJiBpbnN0Ll9sYXN0Q2hyKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VGaWVsZChpbnN0LCArMSwgZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGluc3QuX2xhc3RDaHIgPSAoaW5zdC5vcHRpb25zLnVubGltaXRlZEhvdXJzICYmIGluc3QuX2ZpZWxkID09PSAwID8gaW5zdC5fbGFzdENociArIGNociA6IGNocik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKCFpbnN0Lm9wdGlvbnMuc2hvdzI0SG91cnMpIHsgLy8gU2V0IGFtL3BtIGJhc2VkIG9uIGZpcnN0IGNoYXIgb2YgbmFtZXNcclxuXHRcdFx0XHRjaHIgPSBjaHIudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRpZiAoKGNociA9PT0gaW5zdC5vcHRpb25zLmFtcG1OYW1lc1swXS5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSAmJlxyXG5cdFx0XHRcdFx0XHRpbnN0Ll9zZWxlY3RlZEhvdXIgPj0gMTIpIHx8XHJcblx0XHRcdFx0XHRcdChjaHIgPT09IGluc3Qub3B0aW9ucy5hbXBtTmFtZXNbMV0uc3Vic3RyaW5nKDAsIDEpLnRvTG93ZXJDYXNlKCkgJiZcclxuXHRcdFx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRIb3VyIDwgMTIpKSB7XHJcblx0XHRcdFx0XHR2YXIgc2F2ZUZpZWxkID0gaW5zdC5fZmllbGQ7XHJcblx0XHRcdFx0XHRpbnN0Ll9maWVsZCA9IGluc3QuX2FtcG1GaWVsZDtcclxuXHRcdFx0XHRcdHRoaXMuX2FkanVzdEZpZWxkKGluc3QsICsxKTtcclxuXHRcdFx0XHRcdGluc3QuX2ZpZWxkID0gc2F2ZUZpZWxkO1xyXG5cdFx0XHRcdFx0dGhpcy5fc2hvd0ZpZWxkKGluc3QpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogSW5jcmVtZW50L2RlY3JlbWVudCBvbiBtb3VzZSB3aGVlbCBhY3Rpdml0eS5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIG1vdXNlIHdoZWVsIGV2ZW50LlxyXG5cdFx0XHRAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIGFtb3VudCBvZiBjaGFuZ2UuICovXHJcblx0XHRfZG9Nb3VzZVdoZWVsOiBmdW5jdGlvbihldmVudCwgZGVsdGEpIHtcclxuXHRcdFx0aWYgKHBsdWdpbi5pc0Rpc2FibGVkKGV2ZW50LnRhcmdldCkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcclxuXHRcdFx0aW5zdC5lbGVtLmZvY3VzKCk7XHJcblx0XHRcdGlmICghaW5zdC5lbGVtLnZhbCgpKSB7XHJcblx0XHRcdFx0cGx1Z2luLl9wYXJzZVRpbWUoaW5zdCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGx1Z2luLl9hZGp1c3RGaWVsZChpbnN0LCBkZWx0YSk7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBFeHBhbmQgdGhlIHNwaW5uZXIsIGlmIHBvc3NpYmxlLCB0byBtYWtlIGl0IGVhc2llciB0byB1c2UuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBtb3VzZSBvdmVyIGV2ZW50LiAqL1xyXG5cdFx0X2V4cGFuZFNwaW5uZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHZhciBzcGlubmVyID0gcGx1Z2luLl9nZXRTcGlubmVyVGFyZ2V0KGV2ZW50KTtcclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QocGx1Z2luLl9nZXRJbnB1dChzcGlubmVyKSk7XHJcblx0XHRcdGlmIChwbHVnaW4uaXNEaXNhYmxlZChpbnN0LmVsZW1bMF0pKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuc3Bpbm5lckJpZ0ltYWdlKSB7XHJcblx0XHRcdFx0aW5zdC5fZXhwYW5kZWQgPSB0cnVlO1xyXG5cdFx0XHRcdHZhciBvZmZzZXQgPSAkKHNwaW5uZXIpLm9mZnNldCgpO1xyXG5cdFx0XHRcdHZhciByZWxhdGl2ZSA9IG51bGw7XHJcblx0XHRcdFx0JChzcGlubmVyKS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBwYXJlbnQgPSAkKHRoaXMpO1xyXG5cdFx0XHRcdFx0aWYgKHBhcmVudC5jc3MoJ3Bvc2l0aW9uJykgPT09ICdyZWxhdGl2ZScgfHwgcGFyZW50LmNzcygncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJykge1xyXG5cdFx0XHRcdFx0XHRyZWxhdGl2ZSA9IHBhcmVudC5vZmZzZXQoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiAhcmVsYXRpdmU7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0JCgnPGRpdiBjbGFzcz1cIicgKyBwbHVnaW4uX2V4cGFuZENsYXNzICsgJ1wiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAnICtcclxuXHRcdFx0XHRcdChvZmZzZXQubGVmdCAtIChpbnN0Lm9wdGlvbnMuc3Bpbm5lckJpZ1NpemVbMF0gLSBpbnN0Lm9wdGlvbnMuc3Bpbm5lclNpemVbMF0pIC8gMiAtXHJcblx0XHRcdFx0XHQocmVsYXRpdmUgPyByZWxhdGl2ZS5sZWZ0IDogMCkpICsgJ3B4OyB0b3A6ICcgK1xyXG5cdFx0XHRcdFx0KG9mZnNldC50b3AgLSAoaW5zdC5vcHRpb25zLnNwaW5uZXJCaWdTaXplWzFdIC0gaW5zdC5vcHRpb25zLnNwaW5uZXJTaXplWzFdKSAvIDIgLVxyXG5cdFx0XHRcdFx0KHJlbGF0aXZlID8gcmVsYXRpdmUudG9wIDogMCkpICsgJ3B4OyB3aWR0aDogJyArXHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMuc3Bpbm5lckJpZ1NpemVbMF0gKyAncHg7IGhlaWdodDogJyArXHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMuc3Bpbm5lckJpZ1NpemVbMV0gKyAncHg7IGJhY2tncm91bmQ6IHRyYW5zcGFyZW50IHVybCgnICtcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5zcGlubmVyQmlnSW1hZ2UgKyAnKSBuby1yZXBlYXQgMHB4IDBweDsgei1pbmRleDogMTA7XCI+PC9kaXY+JykuXHJcblx0XHRcdFx0XHRtb3VzZWRvd24ocGx1Z2luLl9oYW5kbGVTcGlubmVyKS5tb3VzZXVwKHBsdWdpbi5fZW5kU3Bpbm5lcikuXHJcblx0XHRcdFx0XHRtb3VzZW91dChwbHVnaW4uX2VuZEV4cGFuZCkubW91c2Vtb3ZlKHBsdWdpbi5fZGVzY3JpYmVTcGlubmVyKS5cclxuXHRcdFx0XHRcdGluc2VydEFmdGVyKHNwaW5uZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBMb2NhdGUgdGhlIGFjdHVhbCBpbnB1dCBmaWVsZCBmcm9tIHRoZSBzcGlubmVyLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gc3Bpbm5lciB7RWxlbWVudH0gVGhlIGN1cnJlbnQgc3Bpbm5lci5cclxuXHRcdFx0QHJldHVybiB7RWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgaW5wdXQuICovXHJcblx0XHRfZ2V0SW5wdXQ6IGZ1bmN0aW9uKHNwaW5uZXIpIHtcclxuXHRcdFx0cmV0dXJuICQoc3Bpbm5lcikuc2libGluZ3MoJy4nICsgdGhpcy5fZ2V0TWFya2VyKCkpWzBdO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ2hhbmdlIHRoZSB0aXRsZSBiYXNlZCBvbiBwb3NpdGlvbiB3aXRoaW4gdGhlIHNwaW5uZXIuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBtb3VzZSBtb3ZlIGV2ZW50LiAqL1xyXG5cdFx0X2Rlc2NyaWJlU3Bpbm5lcjogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0dmFyIHNwaW5uZXIgPSBwbHVnaW4uX2dldFNwaW5uZXJUYXJnZXQoZXZlbnQpO1xyXG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChwbHVnaW4uX2dldElucHV0KHNwaW5uZXIpKTtcclxuXHRcdFx0c3Bpbm5lci50aXRsZSA9IGluc3Qub3B0aW9ucy5zcGlubmVyVGV4dHNbcGx1Z2luLl9nZXRTcGlubmVyUmVnaW9uKGluc3QsIGV2ZW50KV07XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgc3Bpbm5lci5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIG1vdXNlIGNsaWNrIGV2ZW50LiAqL1xyXG5cdFx0X2hhbmRsZVNwaW5uZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHZhciBzcGlubmVyID0gcGx1Z2luLl9nZXRTcGlubmVyVGFyZ2V0KGV2ZW50KTtcclxuXHRcdFx0dmFyIGlucHV0ID0gcGx1Z2luLl9nZXRJbnB1dChzcGlubmVyKTtcclxuXHRcdFx0aWYgKHBsdWdpbi5pc0Rpc2FibGVkKGlucHV0KSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaW5wdXQgPT09IHBsdWdpbi5fYmx1cnJlZElucHV0KSB7XHJcblx0XHRcdFx0cGx1Z2luLl9sYXN0SW5wdXQgPSBpbnB1dDtcclxuXHRcdFx0XHRwbHVnaW4uX2JsdXJyZWRJbnB1dCA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoaW5wdXQpO1xyXG5cdFx0XHRwbHVnaW4uX2RvRm9jdXMoaW5wdXQpO1xyXG5cdFx0XHR2YXIgcmVnaW9uID0gcGx1Z2luLl9nZXRTcGlubmVyUmVnaW9uKGluc3QsIGV2ZW50KTtcclxuXHRcdFx0cGx1Z2luLl9jaGFuZ2VTcGlubmVyKGluc3QsIHNwaW5uZXIsIHJlZ2lvbik7XHJcblx0XHRcdHBsdWdpbi5fYWN0aW9uU3Bpbm5lcihpbnN0LCByZWdpb24pO1xyXG5cdFx0XHRwbHVnaW4uX3RpbWVyID0gbnVsbDtcclxuXHRcdFx0cGx1Z2luLl9oYW5kbGluZ1NwaW5uZXIgPSB0cnVlO1xyXG5cdFx0XHRpZiAocmVnaW9uID49IDMgJiYgaW5zdC5vcHRpb25zLnNwaW5uZXJSZXBlYXRbMF0pIHsgLy8gUmVwZWF0IGluY3JlbWVudC9kZWNyZW1lbnRcclxuXHRcdFx0XHRwbHVnaW4uX3RpbWVyID0gc2V0VGltZW91dChcclxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkgeyBwbHVnaW4uX3JlcGVhdFNwaW5uZXIoaW5zdCwgcmVnaW9uKTsgfSxcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5zcGlubmVyUmVwZWF0WzBdKTtcclxuXHRcdFx0XHQkKHNwaW5uZXIpLm9uZSgnbW91c2VvdXQnLCBwbHVnaW4uX3JlbGVhc2VTcGlubmVyKS5cclxuXHRcdFx0XHRcdG9uZSgnbW91c2V1cCcsIHBsdWdpbi5fcmVsZWFzZVNwaW5uZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBBY3Rpb24gYSBjbGljayBvbiB0aGUgc3Bpbm5lci5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcGFyYW0gcmVnaW9uIHtudW1iZXJ9IFRoZSBzcGlubmVyIFwiYnV0dG9uXCIuICovXHJcblx0XHRfYWN0aW9uU3Bpbm5lcjogZnVuY3Rpb24oaW5zdCwgcmVnaW9uKSB7XHJcblx0XHRcdGlmICghaW5zdC5lbGVtLnZhbCgpKSB7XHJcblx0XHRcdFx0cGx1Z2luLl9wYXJzZVRpbWUoaW5zdCk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3dpdGNoIChyZWdpb24pIHtcclxuXHRcdFx0XHRjYXNlIDA6IHRoaXMuX3NldFRpbWUoaW5zdCk7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMTogdGhpcy5fY2hhbmdlRmllbGQoaW5zdCwgLTEsIGZhbHNlKTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAyOiB0aGlzLl9jaGFuZ2VGaWVsZChpbnN0LCArMSwgZmFsc2UpOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIDM6IHRoaXMuX2FkanVzdEZpZWxkKGluc3QsICsxKTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA0OiB0aGlzLl9hZGp1c3RGaWVsZChpbnN0LCAtMSk7IGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXBlYXQgYSBjbGljayBvbiB0aGUgc3Bpbm5lci5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcGFyYW0gcmVnaW9uIHtudW1iZXJ9IFRoZSBzcGlubmVyIFwiYnV0dG9uXCIuICovXHJcblx0XHRfcmVwZWF0U3Bpbm5lcjogZnVuY3Rpb24oaW5zdCwgcmVnaW9uKSB7XHJcblx0XHRcdGlmICghcGx1Z2luLl90aW1lcikge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRwbHVnaW4uX2xhc3RJbnB1dCA9IHBsdWdpbi5fYmx1cnJlZElucHV0O1xyXG5cdFx0XHR0aGlzLl9hY3Rpb25TcGlubmVyKGluc3QsIHJlZ2lvbik7XHJcblx0XHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChcclxuXHRcdFx0XHRmdW5jdGlvbigpIHsgcGx1Z2luLl9yZXBlYXRTcGlubmVyKGluc3QsIHJlZ2lvbik7IH0sXHJcblx0XHRcdFx0aW5zdC5vcHRpb25zLnNwaW5uZXJSZXBlYXRbMV0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU3RvcCBhIHNwaW5uZXIgcmVwZWF0LlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgbW91c2UgZXZlbnQuICovXHJcblx0XHRfcmVsZWFzZVNwaW5uZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdGNsZWFyVGltZW91dChwbHVnaW4uX3RpbWVyKTtcclxuXHRcdFx0cGx1Z2luLl90aW1lciA9IG51bGw7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBUaWR5IHVwIGFmdGVyIGFuIGV4cGFuZGVkIHNwaW5uZXIuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBtb3VzZSBldmVudC4gKi9cclxuXHRcdF9lbmRFeHBhbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHBsdWdpbi5fdGltZXIgPSBudWxsO1xyXG5cdFx0XHR2YXIgc3Bpbm5lciA9IHBsdWdpbi5fZ2V0U3Bpbm5lclRhcmdldChldmVudCk7XHJcblx0XHRcdHZhciBpbnB1dCA9IHBsdWdpbi5fZ2V0SW5wdXQoc3Bpbm5lcik7XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGlucHV0KTtcclxuXHRcdFx0JChzcGlubmVyKS5yZW1vdmUoKTtcclxuXHRcdFx0aW5zdC5fZXhwYW5kZWQgPSBmYWxzZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFRpZHkgdXAgYWZ0ZXIgYSBzcGlubmVyIGNsaWNrLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgbW91c2UgZXZlbnQuICovXHJcblx0XHRfZW5kU3Bpbm5lcjogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0cGx1Z2luLl90aW1lciA9IG51bGw7XHJcblx0XHRcdHZhciBzcGlubmVyID0gcGx1Z2luLl9nZXRTcGlubmVyVGFyZ2V0KGV2ZW50KTtcclxuXHRcdFx0dmFyIGlucHV0ID0gcGx1Z2luLl9nZXRJbnB1dChzcGlubmVyKTtcclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoaW5wdXQpO1xyXG5cdFx0XHRpZiAoIXBsdWdpbi5pc0Rpc2FibGVkKGlucHV0KSkge1xyXG5cdFx0XHRcdHBsdWdpbi5fY2hhbmdlU3Bpbm5lcihpbnN0LCBzcGlubmVyLCAtMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHBsdWdpbi5faGFuZGxpbmdTcGlubmVyKSB7XHJcblx0XHRcdFx0cGx1Z2luLl9sYXN0SW5wdXQgPSBwbHVnaW4uX2JsdXJyZWRJbnB1dDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocGx1Z2luLl9sYXN0SW5wdXQgJiYgcGx1Z2luLl9oYW5kbGluZ1NwaW5uZXIpIHtcclxuXHRcdFx0XHRwbHVnaW4uX3Nob3dGaWVsZChpbnN0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwbHVnaW4uX2hhbmRsaW5nU3Bpbm5lciA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIHNwaW5uZXIgZnJvbSB0aGUgZXZlbnQuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBtb3VzZSBjbGljayBldmVudC5cclxuXHRcdFx0QHJldHVybiB7RWxlbWVudH0gVGhlIHRhcmdldCBmaWVsZC4gKi9cclxuXHRcdF9nZXRTcGlubmVyVGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHRyZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBEZXRlcm1pbmUgd2hpY2ggXCJidXR0b25cIiB3aXRoaW4gdGhlIHNwaW5uZXIgd2FzIGNsaWNrZWQuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIG1vdXNlIGV2ZW50LlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGlubmVyIFwiYnV0dG9uXCIgbnVtYmVyLiAqL1xyXG5cdFx0X2dldFNwaW5uZXJSZWdpb246IGZ1bmN0aW9uKGluc3QsIGV2ZW50KSB7XHJcblx0XHRcdHZhciBzcGlubmVyID0gdGhpcy5fZ2V0U3Bpbm5lclRhcmdldChldmVudCk7XHJcblx0XHRcdHZhciBwb3MgPSAkKHNwaW5uZXIpLm9mZnNldCgpO1xyXG5cdFx0XHR2YXIgc2Nyb2xsZWQgPSBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxyXG5cdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BdO1xyXG5cdFx0XHR2YXIgbGVmdCA9IChpbnN0Lm9wdGlvbnMuc3Bpbm5lckluY0RlY09ubHkgPyA5OSA6IGV2ZW50LmNsaWVudFggKyBzY3JvbGxlZFswXSAtIHBvcy5sZWZ0KTtcclxuXHRcdFx0dmFyIHRvcCA9IGV2ZW50LmNsaWVudFkgKyBzY3JvbGxlZFsxXSAtIHBvcy50b3A7XHJcblx0XHRcdHZhciBzcGlubmVyU2l6ZSA9IGluc3Qub3B0aW9uc1tpbnN0Ll9leHBhbmRlZCA/ICdzcGlubmVyQmlnU2l6ZScgOiAnc3Bpbm5lclNpemUnXTtcclxuXHRcdFx0dmFyIHJpZ2h0ID0gKGluc3Qub3B0aW9ucy5zcGlubmVySW5jRGVjT25seSA/IDk5IDogc3Bpbm5lclNpemVbMF0gLSAxIC0gbGVmdCk7XHJcblx0XHRcdHZhciBib3R0b20gPSBzcGlubmVyU2l6ZVsxXSAtIDEgLSB0b3A7XHJcblx0XHRcdGlmIChzcGlubmVyU2l6ZVsyXSA+IDAgJiYgTWF0aC5hYnMobGVmdCAtIHJpZ2h0KSA8PSBzcGlubmVyU2l6ZVsyXSAmJlxyXG5cdFx0XHRcdFx0TWF0aC5hYnModG9wIC0gYm90dG9tKSA8PSBzcGlubmVyU2l6ZVsyXSkge1xyXG5cdFx0XHRcdHJldHVybiAwOyAvLyBDZW50cmUgYnV0dG9uXHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIG1pbiA9IE1hdGgubWluKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XHJcblx0XHRcdHJldHVybiAobWluID09PSBsZWZ0ID8gMSA6IChtaW4gPT09IHJpZ2h0ID8gMiA6IChtaW4gPT09IHRvcCA/IDMgOiA0KSkpOyAvLyBOZWFyZXN0IGVkZ2VcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENoYW5nZSB0aGUgc3Bpbm5lciBpbWFnZSBkZXBlbmRpbmcgb24gdGhlIGJ1dHRvbiBjbGlja2VkLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSBzcGlubmVyIHtFbGVtZW50fSBUaGUgc3Bpbm5lciBjb250cm9sLlxyXG5cdFx0XHRAcGFyYW0gcmVnaW9uIHtudW1iZXJ9IFRoZSBzcGlubmVyIFwiYnV0dG9uXCIuICovXHJcblx0XHRfY2hhbmdlU3Bpbm5lcjogZnVuY3Rpb24oaW5zdCwgc3Bpbm5lciwgcmVnaW9uKSB7XHJcblx0XHRcdCQoc3Bpbm5lcikuY3NzKCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgJy0nICsgKChyZWdpb24gKyAxKSAqXHJcblx0XHRcdFx0aW5zdC5vcHRpb25zW2luc3QuX2V4cGFuZGVkID8gJ3NwaW5uZXJCaWdTaXplJyA6ICdzcGlubmVyU2l6ZSddWzBdKSArICdweCAwcHgnKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEV4dHJhY3QgdGhlIHRpbWUgdmFsdWUgZnJvbSB0aGUgaW5wdXQgZmllbGQsIG9yIGRlZmF1bHQgdG8gbm93LlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSB0cmlnZ2VyaW5nIGV2ZW50IG9yIDxjb2RlPm51bGw8L2NvZGU+LiAqL1xyXG5cdFx0X3BhcnNlVGltZTogZnVuY3Rpb24oaW5zdCwgZXZlbnQpIHtcclxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gdGhpcy5fZXh0cmFjdFRpbWUoaW5zdCk7XHJcblx0XHRcdGlmIChjdXJyZW50VGltZSkge1xyXG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkSG91ciA9IGN1cnJlbnRUaW1lWzBdO1xyXG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkTWludXRlID0gY3VycmVudFRpbWVbMV07XHJcblx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRTZWNvbmQgPSBjdXJyZW50VGltZVsyXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR2YXIgbm93ID0gdGhpcy5fY29uc3RyYWluVGltZShpbnN0KTtcclxuXHRcdFx0XHRpbnN0Ll9zZWxlY3RlZEhvdXIgPSBub3dbMF07XHJcblx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRNaW51dGUgPSBub3dbMV07XHJcblx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRTZWNvbmQgPSAoaW5zdC5vcHRpb25zLnNob3dTZWNvbmRzID8gbm93WzJdIDogMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aW5zdC5fc2Vjb25kRmllbGQgPSAoaW5zdC5vcHRpb25zLnNob3dTZWNvbmRzID8gMiA6IC0xKTtcclxuXHRcdFx0aW5zdC5fYW1wbUZpZWxkID0gKGluc3Qub3B0aW9ucy5zaG93MjRIb3VycyA/IC0xIDogKGluc3Qub3B0aW9ucy5zaG93U2Vjb25kcyA/IDMgOiAyKSk7XHJcblx0XHRcdGluc3QuX2xhc3RDaHIgPSAnJztcclxuXHRcdFx0dmFyIHBvc3RQcm9jZXNzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKGluc3QuZWxlbS52YWwoKSAhPT0gJycpIHtcclxuXHRcdFx0XHRcdHBsdWdpbi5fc2hvd1RpbWUoaW5zdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRpZiAodHlwZW9mIGluc3Qub3B0aW9ucy5pbml0aWFsRmllbGQgPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0aW5zdC5fZmllbGQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihcclxuXHRcdFx0XHRcdE1hdGgubWF4KDEsIGluc3QuX3NlY29uZEZpZWxkLCBpbnN0Ll9hbXBtRmllbGQpLCBpbnN0Lm9wdGlvbnMuaW5pdGlhbEZpZWxkKSk7XHJcblx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aW5zdC5fZmllbGQgPSBwbHVnaW4uX2dldFNlbGVjdGlvbihpbnN0LCBpbnN0LmVsZW1bMF0sIGV2ZW50KTtcclxuXHRcdFx0XHRcdHBvc3RQcm9jZXNzKCk7XHJcblx0XHRcdFx0fSwgMCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEV4dHJhY3QgdGhlIHRpbWUgdmFsdWUgZnJvbSBhIHN0cmluZyBhcyBhbiBhcnJheSBvZiB2YWx1ZXMsIG9yIGRlZmF1bHQgdG8gPGNvZGU+bnVsbDwvY29kZT4uXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSB2YWx1ZSB7c3RyaW5nfSBUaGUgZGF0ZSB0ZXh0LlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEByZXR1cm4ge251bWJlcltdfSBUaGUgcmV0cmlldmVkIHRpbWUgY29tcG9uZW50cyAoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIG9yXHJcblx0XHRcdFx0XHQ8Y29kZT5udWxsPC9jb2RlPiBpZiBubyB2YWx1ZS4gKi9cclxuXHRcdF9leHRyYWN0VGltZTogZnVuY3Rpb24oaW5zdCwgdmFsdWUpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBpbnN0LmVsZW0udmFsKCk7XHJcblx0XHRcdHZhciBjdXJyZW50VGltZSA9IHZhbHVlLnNwbGl0KGluc3Qub3B0aW9ucy5zZXBhcmF0b3IpO1xyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNlcGFyYXRvciA9PT0gJycgJiYgdmFsdWUgIT09ICcnKSB7XHJcblx0XHRcdFx0Y3VycmVudFRpbWVbMF0gPSB2YWx1ZS5zdWJzdHJpbmcoMCwgMik7XHJcblx0XHRcdFx0Y3VycmVudFRpbWVbMV0gPSB2YWx1ZS5zdWJzdHJpbmcoMiwgNCk7XHJcblx0XHRcdFx0Y3VycmVudFRpbWVbMl0gPSB2YWx1ZS5zdWJzdHJpbmcoNCwgNik7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGN1cnJlbnRUaW1lLmxlbmd0aCA+PSAyKSB7XHJcblx0XHRcdFx0dmFyIGlzQU0gPSAhaW5zdC5vcHRpb25zLnNob3cyNEhvdXJzICYmICh2YWx1ZS5pbmRleE9mKGluc3Qub3B0aW9ucy5hbXBtTmFtZXNbMF0pID4gLTEpO1xyXG5cdFx0XHRcdHZhciBpc1BNID0gIWluc3Qub3B0aW9ucy5zaG93MjRIb3VycyAmJiAodmFsdWUuaW5kZXhPZihpbnN0Lm9wdGlvbnMuYW1wbU5hbWVzWzFdKSA+IC0xKTtcclxuXHRcdFx0XHR2YXIgaG91ciA9IHBhcnNlSW50KGN1cnJlbnRUaW1lWzBdLCAxMCk7XHJcblx0XHRcdFx0aG91ciA9IChpc05hTihob3VyKSA/IDAgOiBob3VyKTtcclxuXHRcdFx0XHRob3VyID0gKChpc0FNIHx8IGlzUE0pICYmIGhvdXIgPT09IDEyID8gMCA6IGhvdXIpICsgKGlzUE0gPyAxMiA6IDApO1xyXG5cdFx0XHRcdHZhciBtaW51dGUgPSBwYXJzZUludChjdXJyZW50VGltZVsxXSwgMTApO1xyXG5cdFx0XHRcdG1pbnV0ZSA9IChpc05hTihtaW51dGUpID8gMCA6IG1pbnV0ZSk7XHJcblx0XHRcdFx0dmFyIHNlY29uZCA9IChjdXJyZW50VGltZS5sZW5ndGggPj0gMyA/IHBhcnNlSW50KGN1cnJlbnRUaW1lWzJdLCAxMCkgOiAwKTtcclxuXHRcdFx0XHRzZWNvbmQgPSAoaXNOYU4oc2Vjb25kKSB8fCAhaW5zdC5vcHRpb25zLnNob3dTZWNvbmRzID8gMCA6IHNlY29uZCk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnN0cmFpblRpbWUoaW5zdCwgW2hvdXIsIG1pbnV0ZSwgc2Vjb25kXSk7XHJcblx0XHRcdH0gXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ29uc3RyYWluIHRoZSBnaXZlbi9jdXJyZW50IHRpbWUgdG8gdGhlIHRpbWUgc3RlcHMuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIGZpZWxkcyB7bnVtYmVyW119IFRoZSBjdXJyZW50IHRpbWUgY29tcG9uZW50cyAoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJbXX0gVGhlIGNvbnN0cmFpbmVkIHRpbWUgY29tcG9uZW50cyAoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpLiAqL1xyXG5cdFx0X2NvbnN0cmFpblRpbWU6IGZ1bmN0aW9uKGluc3QsIGZpZWxkcykge1xyXG5cdFx0XHR2YXIgc3BlY2lmaWVkID0gKGZpZWxkcyAhPT0gbnVsbCAmJiBmaWVsZHMgIT09IHVuZGVmaW5lZCk7XHJcblx0XHRcdGlmICghc3BlY2lmaWVkKSB7XHJcblx0XHRcdFx0dmFyIG5vdyA9IHRoaXMuX2RldGVybWluZVRpbWUoaW5zdC5vcHRpb25zLmRlZmF1bHRUaW1lLCBpbnN0KSB8fCBuZXcgRGF0ZSgpO1xyXG5cdFx0XHRcdGZpZWxkcyA9IFtub3cuZ2V0SG91cnMoKSwgbm93LmdldE1pbnV0ZXMoKSwgbm93LmdldFNlY29uZHMoKV07XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHJlc2V0ID0gZmFsc2U7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdC5vcHRpb25zLnRpbWVTdGVwcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChyZXNldCkge1xyXG5cdFx0XHRcdFx0ZmllbGRzW2ldID0gMDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoaW5zdC5vcHRpb25zLnRpbWVTdGVwc1tpXSA+IDEpIHtcclxuXHRcdFx0XHRcdGZpZWxkc1tpXSA9IE1hdGgucm91bmQoZmllbGRzW2ldIC8gaW5zdC5vcHRpb25zLnRpbWVTdGVwc1tpXSkgKlxyXG5cdFx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMudGltZVN0ZXBzW2ldO1xyXG5cdFx0XHRcdFx0cmVzZXQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmllbGRzO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2V0IHRoZSBzZWxlY3RlZCB0aW1lIGludG8gdGhlIGlucHV0IGZpZWxkLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuICovXHJcblx0XHRfc2hvd1RpbWU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gKGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3VycyA/IGluc3QuX3NlbGVjdGVkSG91ciA6XHJcblx0XHRcdFx0dGhpcy5fZm9ybWF0TnVtYmVyKGluc3Qub3B0aW9ucy5zaG93MjRIb3VycyA/IGluc3QuX3NlbGVjdGVkSG91ciA6XHJcblx0XHRcdFx0KChpbnN0Ll9zZWxlY3RlZEhvdXIgKyAxMSkgJSAxMikgKyAxKSkgKyBpbnN0Lm9wdGlvbnMuc2VwYXJhdG9yICtcclxuXHRcdFx0XHR0aGlzLl9mb3JtYXROdW1iZXIoaW5zdC5fc2VsZWN0ZWRNaW51dGUpICtcclxuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnNob3dTZWNvbmRzID8gaW5zdC5vcHRpb25zLnNlcGFyYXRvciArXHJcblx0XHRcdFx0dGhpcy5fZm9ybWF0TnVtYmVyKGluc3QuX3NlbGVjdGVkU2Vjb25kKSA6ICcnKSArXHJcblx0XHRcdFx0KGluc3Qub3B0aW9ucy5zaG93MjRIb3VycyA/ICAnJyA6IGluc3Qub3B0aW9ucy5hbXBtUHJlZml4ICtcclxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuYW1wbU5hbWVzWyhpbnN0Ll9zZWxlY3RlZEhvdXIgPCAxMiA/IDAgOiAxKV0pO1xyXG5cdFx0XHR0aGlzLl9zZXRWYWx1ZShpbnN0LCBjdXJyZW50VGltZSk7XHJcblx0XHRcdHRoaXMuX3Nob3dGaWVsZChpbnN0KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEhpZ2hsaWdodCB0aGUgY3VycmVudCBkYXRlIGZpZWxkLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuICovXHJcblx0XHRfc2hvd0ZpZWxkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdHZhciBpbnB1dCA9IGluc3QuZWxlbVswXTtcclxuXHRcdFx0aWYgKGluc3QuZWxlbS5pcygnOmhpZGRlbicpIHx8IHBsdWdpbi5fbGFzdElucHV0ICE9PSBpbnB1dCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZmllbGRTaXplcyA9IFtpbnN0LmVsZW0udmFsKCkuc3BsaXQoaW5zdC5vcHRpb25zLnNlcGFyYXRvcilbMF0ubGVuZ3RoLCAyLCAyXTtcclxuXHRcdFx0dmFyIHN0YXJ0ID0gMDtcclxuXHRcdFx0dmFyIGZpZWxkID0gMDtcclxuXHRcdFx0d2hpbGUgKGZpZWxkIDwgaW5zdC5fZmllbGQpIHtcclxuXHRcdFx0XHRzdGFydCArPSBmaWVsZFNpemVzW2ZpZWxkXSArXHJcblx0XHRcdFx0XHQoZmllbGQgPT09IE1hdGgubWF4KDEsIGluc3QuX3NlY29uZEZpZWxkKSA/IDAgOiBpbnN0Lm9wdGlvbnMuc2VwYXJhdG9yLmxlbmd0aCk7XHJcblx0XHRcdFx0ZmllbGQrKztcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZW5kID0gc3RhcnQgKyAoaW5zdC5fZmllbGQgIT09IGluc3QuX2FtcG1GaWVsZCA/IGZpZWxkU2l6ZXNbZmllbGRdIDpcclxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuYW1wbVByZWZpeC5sZW5ndGggKyBpbnN0Lm9wdGlvbnMuYW1wbU5hbWVzWzBdLmxlbmd0aCk7XHJcblx0XHRcdGlmIChpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSkgeyAvLyBNb3ppbGxhXHJcblx0XHRcdFx0aW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoaW5wdXQuY3JlYXRlVGV4dFJhbmdlKSB7IC8vIElFXHJcblx0XHRcdFx0dmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XHJcblx0XHRcdFx0cmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XHJcblx0XHRcdFx0cmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gaW5zdC5lbGVtLnZhbCgpLmxlbmd0aCk7XHJcblx0XHRcdFx0cmFuZ2Uuc2VsZWN0KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFpbnB1dC5kaXNhYmxlZCkge1xyXG5cdFx0XHRcdGlucHV0LmZvY3VzKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEVuc3VyZSBkaXNwbGF5ZWQgc2luZ2xlIG51bWJlciBoYXMgYSBsZWFkaW5nIHplcm8uXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSB2YWx1ZSB7bnVtYmVyfSBUaGUgY3VycmVudCB2YWx1ZS5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBOdW1iZXIgd2l0aCBhdCBsZWFzdCB0d28gZGlnaXRzLiAqL1xyXG5cdFx0X2Zvcm1hdE51bWJlcjogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuICh2YWx1ZSA8IDEwID8gJzAnIDogJycpICsgdmFsdWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBVcGRhdGUgdGhlIGlucHV0IGZpZWxkIGFuZCBub3RpZnkgbGlzdGVuZXJzLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSB2YWx1ZSB7c3RyaW5nfSBUaGUgbmV3IHZhbHVlLiAqL1xyXG5cdFx0X3NldFZhbHVlOiBmdW5jdGlvbihpbnN0LCB2YWx1ZSkge1xyXG5cdFx0XHRpZiAodmFsdWUgIT09IGluc3QuZWxlbS52YWwoKSkge1xyXG5cdFx0XHRcdGluc3QuZWxlbS52YWwodmFsdWUpLnRyaWdnZXIoJ2NoYW5nZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBNb3ZlIHRvIHByZXZpb3VzL25leHQgZmllbGQsIG9yIG91dCBvZiBmaWVsZCBhbHRvZ2V0aGVyIGlmIGFwcHJvcHJpYXRlLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIGRpcmVjdGlvbiBvZiBjaGFuZ2UgKC0xLCArMSkuXHJcblx0XHRcdEBwYXJhbSBtb3ZlT3V0IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBjYW4gbW92ZSBvdXQgb2YgdGhlIGZpZWxkLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBleGl0aW5nIHRoZSBmaWVsZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdC4gKi9cclxuXHRcdF9jaGFuZ2VGaWVsZDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBtb3ZlT3V0KSB7XHJcblx0XHRcdHZhciBhdEZpcnN0TGFzdCA9IChpbnN0LmVsZW0udmFsKCkgPT09ICcnIHx8XHJcblx0XHRcdFx0aW5zdC5fZmllbGQgPT09IChvZmZzZXQgPT09IC0xID8gMCA6IE1hdGgubWF4KDEsIGluc3QuX3NlY29uZEZpZWxkLCBpbnN0Ll9hbXBtRmllbGQpKSk7XHJcblx0XHRcdGlmICghYXRGaXJzdExhc3QpIHtcclxuXHRcdFx0XHRpbnN0Ll9maWVsZCArPSBvZmZzZXQ7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fc2hvd0ZpZWxkKGluc3QpO1xyXG5cdFx0XHRpbnN0Ll9sYXN0Q2hyID0gJyc7XHJcblx0XHRcdHJldHVybiAoYXRGaXJzdExhc3QgJiYgbW92ZU91dCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBVcGRhdGUgdGhlIGN1cnJlbnQgZmllbGQgaW4gdGhlIGRpcmVjdGlvbiBpbmRpY2F0ZWQuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgYW1vdW50IHRvIGNoYW5nZSBieS4gKi9cclxuXHRcdF9hZGp1c3RGaWVsZDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0KSB7XHJcblx0XHRcdGlmIChpbnN0LmVsZW0udmFsKCkgPT09ICcnKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnVubGltaXRlZEhvdXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fc2V0VGltZShpbnN0LCBbaW5zdC5fc2VsZWN0ZWRIb3VyICsgKGluc3QuX2ZpZWxkID09PSAwID8gb2Zmc2V0ICogaW5zdC5vcHRpb25zLnRpbWVTdGVwc1swXSA6IDApLFxyXG5cdFx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRNaW51dGUgKyAoaW5zdC5fZmllbGQgPT09IDEgPyBvZmZzZXQgKiBpbnN0Lm9wdGlvbnMudGltZVN0ZXBzWzFdIDogMCksXHJcblx0XHRcdFx0XHRpbnN0Ll9zZWxlY3RlZFNlY29uZCArIChpbnN0Ll9maWVsZCA9PT0gaW5zdC5fc2Vjb25kRmllbGQgPyBvZmZzZXQgKiBpbnN0Lm9wdGlvbnMudGltZVN0ZXBzWzJdIDogMCldKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5fc2V0VGltZShpbnN0LCBuZXcgRGF0ZSgwLCAwLCAwLFxyXG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkSG91ciArIChpbnN0Ll9maWVsZCA9PT0gMCA/IG9mZnNldCAqIGluc3Qub3B0aW9ucy50aW1lU3RlcHNbMF0gOiAwKSArXHJcblx0XHRcdFx0KGluc3QuX2ZpZWxkID09PSBpbnN0Ll9hbXBtRmllbGQgPyBvZmZzZXQgKiAxMiA6IDApLFxyXG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkTWludXRlICsgKGluc3QuX2ZpZWxkID09PSAxID8gb2Zmc2V0ICogaW5zdC5vcHRpb25zLnRpbWVTdGVwc1sxXSA6IDApLFxyXG5cdFx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRTZWNvbmQgKyAoaW5zdC5fZmllbGQgPT09IGluc3QuX3NlY29uZEZpZWxkID8gb2Zmc2V0ICogaW5zdC5vcHRpb25zLnRpbWVTdGVwc1syXSA6IDApKSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENoZWNrIGFnYWluc3QgbWluaW11bS9tYXhpbXVtIGFuZCBkaXNwbGF5IHRpbWUuXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIHRpbWUge0RhdGV8bnVtYmVyfHN0cmluZ3xudW1iZXJbXX0gVGhlIGFjdHVhbCB0aW1lIG9yIG9mZnNldCBpbiBzZWNvbmRzIGZyb20gbm93IG9yXHJcblx0XHRcdFx0XHR1bml0cyBhbmQgcGVyaW9kcyBvZiBvZmZzZXRzIGZyb20gbm93IG9yIG51bWVyaWMgcGVyaW9kIHZhbHVlcy4gKi9cclxuXHRcdF9zZXRUaW1lOiBmdW5jdGlvbihpbnN0LCB0aW1lKSB7XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMudW5saW1pdGVkSG91cnMgJiYgJC5pc0FycmF5KHRpbWUpKSB7XHJcblx0XHRcdFx0dmFyIGZpZWxkcyA9IHRpbWU7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdHRpbWUgPSB0aGlzLl9kZXRlcm1pbmVUaW1lKHRpbWUsIGluc3QpO1xyXG5cdFx0XHRcdHZhciBmaWVsZHMgPSAodGltZSA/IFt0aW1lLmdldEhvdXJzKCksIHRpbWUuZ2V0TWludXRlcygpLCB0aW1lLmdldFNlY29uZHMoKV0gOiBudWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmaWVsZHMgPSB0aGlzLl9jb25zdHJhaW5UaW1lKGluc3QsIGZpZWxkcyk7XHJcblx0XHRcdHRpbWUgPSBuZXcgRGF0ZSgwLCAwLCAwLCBmaWVsZHNbMF0sIGZpZWxkc1sxXSwgZmllbGRzWzJdKTtcclxuXHRcdFx0Ly8gTm9ybWFsaXNlIHRvIGJhc2UgZGF0ZVxyXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX25vcm1hbGlzZVRpbWUodGltZSk7XHJcblx0XHRcdHZhciBtaW5UaW1lID0gdGhpcy5fbm9ybWFsaXNlVGltZSh0aGlzLl9kZXRlcm1pbmVUaW1lKGluc3Qub3B0aW9ucy5taW5UaW1lLCBpbnN0KSk7XHJcblx0XHRcdHZhciBtYXhUaW1lID0gdGhpcy5fbm9ybWFsaXNlVGltZSh0aGlzLl9kZXRlcm1pbmVUaW1lKGluc3Qub3B0aW9ucy5tYXhUaW1lLCBpbnN0KSk7XHJcblx0XHRcdC8vIEVuc3VyZSBpdCBpcyB3aXRoaW4gdGhlIGJvdW5kcyBzZXRcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3Vycykge1xyXG5cdFx0XHRcdHdoaWxlIChmaWVsZHNbMl0gPCAwKSB7XHJcblx0XHRcdFx0XHRmaWVsZHNbMl0gKz0gNjA7XHJcblx0XHRcdFx0XHRmaWVsZHNbMV0tLTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0d2hpbGUgKGZpZWxkc1syXSA+IDU5KSB7XHJcblx0XHRcdFx0XHRmaWVsZHNbMl0gLT0gNjA7XHJcblx0XHRcdFx0XHRmaWVsZHNbMV0rKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0d2hpbGUgKGZpZWxkc1sxXSA8IDApIHtcclxuXHRcdFx0XHRcdGZpZWxkc1sxXSArPSA2MDtcclxuXHRcdFx0XHRcdGZpZWxkc1swXS0tO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR3aGlsZSAoZmllbGRzWzFdID4gNTkpIHtcclxuXHRcdFx0XHRcdGZpZWxkc1sxXSAtPSA2MDtcclxuXHRcdFx0XHRcdGZpZWxkc1swXSsrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtaW5UaW1lID0gKGluc3Qub3B0aW9ucy5taW5UaW1lICE9IG51bGwgJiYgJC5pc0FycmF5KGluc3Qub3B0aW9ucy5taW5UaW1lKSkgP1xyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLm1pblRpbWUgOiBbMCwgMCwgMF07XHJcblx0XHRcdFx0aWYgKGZpZWxkc1swXSA8IG1pblRpbWVbMF0pIHtcclxuXHRcdFx0XHRcdGZpZWxkcyA9IG1pblRpbWUuc2xpY2UoMCwgMyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGZpZWxkc1swXSA9PT0gbWluVGltZVswXSkge1xyXG5cdFx0XHRcdFx0aWYgKGZpZWxkc1sxXSA8IG1pblRpbWVbMV0pIHtcclxuXHRcdFx0XHRcdFx0ZmllbGRzWzFdID0gbWluVGltZVsxXTtcclxuXHRcdFx0XHRcdFx0ZmllbGRzWzJdID0gbWluVGltZVsyXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKGZpZWxkc1sxXSA9PT0gbWluVGltZVsxXSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoZmllbGRzWzJdIDwgbWluVGltZVsyXSkge1xyXG5cdFx0XHRcdFx0XHRcdGZpZWxkc1syXSA9IG1pblRpbWVbMl07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5tYXhUaW1lICE9IG51bGwgJiYgJC5pc0FycmF5KGluc3Qub3B0aW9ucy5tYXhUaW1lKSkge1xyXG5cdFx0XHRcdFx0aWYgKGZpZWxkc1swXSA+IGluc3Qub3B0aW9ucy5tYXhUaW1lWzBdKSB7XHJcblx0XHRcdFx0XHRcdGZpZWxkcyA9IGluc3Qub3B0aW9ucy5tYXhUaW1lLnNsaWNlKDAsIDMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoZmllbGRzWzBdID09PSBpbnN0Lm9wdGlvbnMubWF4VGltZVswXSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoZmllbGRzWzFdID4gaW5zdC5vcHRpb25zLm1heFRpbWVbMV0pIHtcclxuXHRcdFx0XHRcdFx0XHRmaWVsZHNbMV0gPSBpbnN0Lm9wdGlvbnMubWF4VGltZVsxXTtcclxuXHRcdFx0XHRcdFx0XHRmaWVsZHNbMl0gPSBpbnN0Lm9wdGlvbnMubWF4VGltZVsyXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChmaWVsZHNbMV0gPT09IGluc3Qub3B0aW9ucy5tYXhUaW1lWzFdKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGZpZWxkc1syXSA+IGluc3Qub3B0aW9ucy5tYXhUaW1lWzJdKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHNbMl0gPSBpbnN0Lm9wdGlvbnMubWF4VGltZVsyXTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdGlmIChtaW5UaW1lICYmIG1heFRpbWUgJiYgbWluVGltZSA+IG1heFRpbWUpIHtcclxuXHRcdFx0XHRpZiAodGltZSA8IG1pblRpbWUgJiYgdGltZSA+IG1heFRpbWUpIHtcclxuXHRcdFx0XHRcdHRpbWUgPSAoTWF0aC5hYnModGltZSAtIG1pblRpbWUpIDwgTWF0aC5hYnModGltZSAtIG1heFRpbWUpID8gbWluVGltZSA6IG1heFRpbWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aW1lID0gKG1pblRpbWUgJiYgdGltZSA8IG1pblRpbWUgPyBtaW5UaW1lIDpcclxuXHRcdFx0XHRcdChtYXhUaW1lICYmIHRpbWUgPiBtYXhUaW1lID8gbWF4VGltZSA6IHRpbWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcdGZpZWxkc1swXSA9IHRpbWUuZ2V0SG91cnMoKTtcclxuXHRcdFx0XHRmaWVsZHNbMV0gPSB0aW1lLmdldE1pbnV0ZXMoKTtcclxuXHRcdFx0XHRmaWVsZHNbMl0gPSB0aW1lLmdldFNlY29uZHMoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBQZXJmb3JtIGZ1cnRoZXIgcmVzdHJpY3Rpb25zIGlmIHJlcXVpcmVkXHJcblx0XHRcdGlmICgkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLmJlZm9yZVNldFRpbWUpKSB7XHJcblx0XHRcdFx0dGltZSA9IGluc3Qub3B0aW9ucy5iZWZvcmVTZXRUaW1lLmFwcGx5KGluc3QuZWxlbVswXSxcclxuXHRcdFx0XHRcdFt0aGlzLmdldFRpbWUoaW5zdC5lbGVtWzBdKSwgdGltZSwgbWluVGltZSwgbWF4VGltZV0pO1xyXG5cdFx0XHRcdGZpZWxkc1swXSA9IHRpbWUuZ2V0SG91cnMoKTtcclxuXHRcdFx0XHRmaWVsZHNbMV0gPSB0aW1lLmdldE1pbnV0ZXMoKTtcclxuXHRcdFx0XHRmaWVsZHNbMl0gPSB0aW1lLmdldFNlY29uZHMoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpbnN0Ll9zZWxlY3RlZEhvdXIgPSBmaWVsZHNbMF07XHJcblx0XHRcdGluc3QuX3NlbGVjdGVkTWludXRlID0gZmllbGRzWzFdO1xyXG5cdFx0XHRpbnN0Ll9zZWxlY3RlZFNlY29uZCA9IGZpZWxkc1syXTtcclxuXHRcdFx0dGhpcy5fc2hvd1RpbWUoaW5zdCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBBIHRpbWUgbWF5IGJlIHNwZWNpZmllZCBhcyBhbiBleGFjdCB2YWx1ZSBvciBhIHJlbGF0aXZlIG9uZS5cclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIHNldHRpbmcge0RhdGV8bnVtYmVyfHN0cmluZ3xudW1iZXJbXX0gVGhlIGFjdHVhbCB0aW1lIG9yIG9mZnNldCBpbiBzZWNvbmRzIGZyb20gbm93IG9yXHJcblx0XHRcdFx0XHR1bml0cyBhbmQgcGVyaW9kcyBvZiBvZmZzZXRzIGZyb20gbm93IG9yIG51bWVyaWMgcGVyaW9kIHZhbHVlcy5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcmV0dXJuIHtEYXRlfSBUaGUgY2FsY3VsYXRlZCB0aW1lLiAqL1xyXG5cdFx0X2RldGVybWluZVRpbWU6IGZ1bmN0aW9uKHNldHRpbmcsIGluc3QpIHtcclxuXHRcdFx0dmFyIG9mZnNldE51bWVyaWMgPSBmdW5jdGlvbihvZmZzZXQpIHsgLy8gRS5nLiArMzAwLCAtMlxyXG5cdFx0XHRcdHZhciB0aW1lID0gbmV3IERhdGUoKTtcclxuXHRcdFx0XHR0aW1lLnNldFRpbWUodGltZS5nZXRUaW1lKCkgKyBvZmZzZXQgKiAxMDAwKTtcclxuXHRcdFx0XHRyZXR1cm4gdGltZTtcclxuXHRcdFx0fTtcclxuXHRcdFx0dmFyIG9mZnNldFN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkgeyAvLyBFLmcuICcrMm0nLCAnLTRoJywgJyszaCArMzBtJyBvciAnMTI6MzQ6NTZQTSdcclxuXHRcdFx0XHR2YXIgZmllbGRzID0gcGx1Z2luLl9leHRyYWN0VGltZShpbnN0LCBvZmZzZXQpOyAvLyBBY3R1YWwgdGltZT9cclxuXHRcdFx0XHR2YXIgdGltZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0dmFyIGhvdXIgPSAoZmllbGRzID8gZmllbGRzWzBdIDogdGltZS5nZXRIb3VycygpKTtcclxuXHRcdFx0XHR2YXIgbWludXRlID0gKGZpZWxkcyA/IGZpZWxkc1sxXSA6IHRpbWUuZ2V0TWludXRlcygpKTtcclxuXHRcdFx0XHR2YXIgc2Vjb25kID0gKGZpZWxkcyA/IGZpZWxkc1syXSA6IHRpbWUuZ2V0U2Vjb25kcygpKTtcclxuXHRcdFx0XHRpZiAoIWZpZWxkcykge1xyXG5cdFx0XHRcdFx0dmFyIHBhdHRlcm4gPSAvKFsrLV0/WzAtOV0rKVxccyooc3xTfG18TXxofEgpPy9nO1xyXG5cdFx0XHRcdFx0dmFyIG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcclxuXHRcdFx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XHJcblx0XHRcdFx0XHRcdHN3aXRjaCAobWF0Y2hlc1syXSB8fCAncycpIHtcclxuXHRcdFx0XHRcdFx0XHRjYXNlICdzJyA6IGNhc2UgJ1MnIDpcclxuXHRcdFx0XHRcdFx0XHRcdHNlY29uZCArPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ20nIDogY2FzZSAnTScgOlxyXG5cdFx0XHRcdFx0XHRcdFx0bWludXRlICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnaCcgOiBjYXNlICdIJyA6XHJcblx0XHRcdFx0XHRcdFx0XHRob3VyICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aW1lID0gbmV3IERhdGUoMCwgMCwgMTAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCAwKTtcclxuXHRcdFx0XHRpZiAoL14hLy50ZXN0KG9mZnNldCkpIHsgLy8gTm8gd3JhcHBpbmdcclxuXHRcdFx0XHRcdGlmICh0aW1lLmdldERhdGUoKSA+IDEwKSB7XHJcblx0XHRcdFx0XHRcdHRpbWUgPSBuZXcgRGF0ZSgwLCAwLCAxMCwgMjMsIDU5LCA1OSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0aW1lLmdldERhdGUoKSA8IDEwKSB7XHJcblx0XHRcdFx0XHRcdHRpbWUgPSBuZXcgRGF0ZSgwLCAwLCAxMCwgMCwgMCwgMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0aW1lO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHR2YXIgb2Zmc2V0QXJyYXkgPSBmdW5jdGlvbihzZXR0aW5nKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBEYXRlKDAsIDAsIDAsIHNldHRpbmdbMF0sIHNldHRpbmdbMV0gfHwgMCwgc2V0dGluZ1syXSB8fCAwLCAwKTtcclxuXHRcdFx0fTtcclxuXHRcdFx0cmV0dXJuIChzZXR0aW5nID8gKHR5cGVvZiBzZXR0aW5nID09PSAnc3RyaW5nJyA/IG9mZnNldFN0cmluZyhzZXR0aW5nKSA6XHJcblx0XHRcdFx0KHR5cGVvZiBzZXR0aW5nID09PSAnbnVtYmVyJyA/IG9mZnNldE51bWVyaWMoc2V0dGluZykgOlxyXG5cdFx0XHRcdCgkLmlzQXJyYXkoc2V0dGluZykgPyBvZmZzZXRBcnJheShzZXR0aW5nKSA6IHNldHRpbmcpKSkgOiBudWxsKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIE5vcm1hbGlzZSB0aW1lIG9iamVjdCB0byBhIGNvbW1vbiBkYXRlLlxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gdGltZSB7RGF0ZX0gVGhlIG9yaWdpbmFsIHRpbWUuXHJcblx0XHRcdEByZXR1cm4ge0RhdGV9IFRoZSBub3JtYWxpc2VkIHRpbWUuICovXHJcblx0XHRfbm9ybWFsaXNlVGltZTogZnVuY3Rpb24odGltZSkge1xyXG5cdFx0XHRpZiAoIXRpbWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aW1lLnNldEZ1bGxZZWFyKDE5MDApO1xyXG5cdFx0XHR0aW1lLnNldE1vbnRoKDApO1xyXG5cdFx0XHR0aW1lLnNldERhdGUoMCk7XHJcblx0XHRcdHJldHVybiB0aW1lO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdFxyXG5cdHZhciBwbHVnaW4gPSAkLnRpbWVFbnRyeTtcclxuXHJcbn0pKGpRdWVyeSk7XHJcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
