/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/timeEntry.html
   Time entry for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) June 2007.
   Available under the MIT (https://github.com/jquery/jquery/blob/master/MIT-LICENSE.txt) license.
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'timeEntry';

	/** Create the time entry plugin.
		<p>Sets an input field to add a spinner for time entry.</p>
		<p>The time can be entered via directly typing the value,
		via the arrow keys, or via spinner buttons.
		It is configurable to show 12 or 24-hour time, to show or hide seconds,
		to enforce a minimum and/or maximum time, to change the spinner image,
		and to constrain the time to steps, e.g. only on the quarter hours.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;input type="text"></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;input type="text" data-timeEntry="name: 'value'"></pre>
	 	@module TimeEntry
		@augments JQPlugin
		@example $(selector).timeEntry()
 $(selector).timeEntry({showSeconds: true, minTime: new Date(0, 0, 0, 12, 0, 0)}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin. */
		name: pluginName,
			
		/** Time entry before show callback.
			Triggered when the input field is focussed.
			@callback beforeShowCallback
			@param input {Element} The current input field.
			@return {object} Any changes to the instance settings.
			@example beforeShow: function(input) {
	// Cross-populate minimum/maximum times for a range
 	return {minTime: (input.id === 'timeTo' ?
 		$('#timeFrom').timeEntry('getTime') : null), 
 		maxTime: (input.id === 'timeFrom' ?
 		$('#timeTo').timeEntry('getTime') : null)};
 } */
			
		/** Time entry before set time callback.
			Triggered when the input field value is to be changed.
			@callback beforeSetTimeCallback
			@param current {string} The current time value entered.
			@param newTime {string} The new time value to use.
			@param minTime {Date} The minimum time value allowed.
			@param maxTime {Date} The maximum time value allowed.
			@return {Date} The actual time value to set.
			@example beforeSetTime: function(oldTime, newTime, minTime, maxTime) {
 	var increment = (newTime - (oldTime || newTime)) > 0;
 	if (newTime.getMinutes() > 30) { // First half of hour only
 		newTime.setMinutes(increment ? 0 : 30);
 		newTime.setHours(newTime.getHours() + (increment ? 1 : 0));
 	}
 	return newTime;
 } */
			
		/** Default settings for the plugin.
			@property [appendText=''] {string} Display text following the input box, e.g. showing the format.
			@property [showSeconds=false] {boolean} <code>true</code> to show seconds as well,
						<code>false</code> for hours/minutes only.
			@property [unlimitedHours=false] {boolean} <code>true</code> to allow entry of more than 24 hours,
						<code>false</code> to restrict to one day.
			@property [timeSteps=[1,1,1]] {number[]} Steps for each of hours/minutes/seconds when incrementing/decrementing.
			@property [initialField=null] {number} The field to highlight initially (0 = hours, 1 = minutes, ...),
						or <code>null</code> for none.
			@property [noSeparatorEntry=false] {boolean} <code>true</code> to move to next sub-field after two digits entry.
			@property [tabToExit=false] {boolean} <code>true</code> for tab key to go to next element,
						<code>false</code> for tab key to step through internal fields.
			@property [useMouseWheel=true] {boolean} <code>true</code> to use mouse wheel for increment/decrement if possible,
						<code>false</code> to never use it.
			@property [defaultTime=null] {Date|number|string} The time to use if none has been set,
						or <code>null</code> for now. Specify as a <code>Date</code> object, as a number of seconds
						offset from now, or as a string of offsets from now, using 'H' for hours,
						'M' for minutes, 'S' for seconds.
			@property [minTime=null] {Date|number|string|number[]} The earliest selectable time,
						or <code>null</code> for no limit. See <code>defaultTime</code> for possible formats,
						use array of hours, minutes, seconds for <code>unlimitedHours</code>.
			@property [maxTime=null] {Date|number|string|number[]} The latest selectable time,
						or <code>null</code> for no limit. See <code>defaultTime</code> for possible formats,
						use array of hours, minutes, seconds for <code>unlimitedHours</code>.
			@property [spinnerImage='spinnerDefault.png'] {string} The URL of the images to use for the time spinner -
						seven images packed horizontally for normal, each button pressed
						(centre, previous, next, increment, decrement), and disabled.
			@property [spinnerSize=[20,20,8]] {number[]} The width and height of the spinner image,
						and size of centre button for current time.
			@property [spinnerBigImage=''] {string} The URL of the images to use for the expanded time spinner -
						seven images packed horizontally for normal, each button pressed
						(centre, previous, next, increment, decrement), and disabled.
			@property [spinnerBigSize=[40,40,16]] {number[]} The width and height of the expanded spinner image,
						and size of centre button for current time.
			@property [spinnerIncDecOnly=false] {boolean} <code>true</code> for increment/decrement buttons only, <code>false</code> for all.
			@property [spinnerRepeat=[500,250]] {number[]} Initial and subsequent waits in milliseconds
						for repeats on the spinner buttons.
			@property [beforeShow=null] {beforeShowCallback} Function that takes an input field and
						returns a set of custom settings for the time entry.
			@property [beforeSetTime=null] {beforeSetTimeCallback} Function that runs before updating the time,
						takes the old and new times, and minimum and maximum times as parameters,
						and returns an adjusted time if necessary.
			@example {defaultTime: new Date(0, 0, 0, 8, 30, 0), minTime: -300, maxTime: '+2H +30M'} */
		defaultOptions: {
			appendText: '',
			showSeconds: false,
			unlimitedHours: false,
			timeSteps: [1, 1, 1],
			initialField: null,
			noSeparatorEntry: false,
			tabToExit: false,
			useMouseWheel: true,
			defaultTime: null,
			minTime: null,
			maxTime: null,
			spinnerImage: 'spinnerDefault.png',
			spinnerSize: [20, 20, 8],
			spinnerBigImage: '',
			spinnerBigSize: [40, 40, 16],
			spinnerIncDecOnly: false,
			spinnerRepeat: [500, 250],
			beforeShow: null,
			beforeSetTime: null
		},

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@property [show24Hours=false] {boolean} <code>true</code> to use 24 hour time, <code>false</code> for 12 hour (AM/PM).
			@property [separator=':'] {string} The separator between time fields.
			@property [ampmPrefix=''] {string} The separator before the AM/PM text.
			@property [ampmNames=['AM','PM']] {string[]} Names of morning/evening markers.
			@property [spinnerTexts=['Now','Previous&nbsp;field','Next&nbsp;field','Increment','Decrement']] {string[]}
						The popup texts for the spinner image areas. */
		regionalOptions: { // Available regional settings, indexed by language/country code
			'': { // Default regional settings - English/US
				show24Hours: false,
				separator: ':',
				ampmPrefix: '',
				ampmNames: ['AM', 'PM'],
				spinnerTexts: ['Now', 'Previous field', 'Next field', 'Increment', 'Decrement']
			}
		},
		
		_getters: ['getOffset', 'getTime', 'isDisabled'],

		_appendClass: pluginName + '-append', // Class name for the appended content
		_controlClass: pluginName + '-control', // Class name for the date entry control
		_expandClass: pluginName + '-expand', // Class name for the expanded spinner

		_disabledInputs: [], // List of time inputs that have been disabled

		_instSettings: function(elem, options) {
			return {_field: 0, _selectedHour: 0, _selectedMinute: 0, _selectedSecond: 0};
		},
		
		_postAttach: function(elem, inst) {
			elem.on('focus.' + inst.name, this._doFocus).
				on('blur.' + inst.name, this._doBlur).
				on('click.' + inst.name, this._doClick).
				on('keydown.' + inst.name, this._doKeyDown).
				on('keypress.' + inst.name, this._doKeyPress).
				on('paste.' + inst.name, function(event) { // Check pastes
					setTimeout(function() { plugin._parseTime(inst); }, 1);
				});
		},

		_optionsChanged: function(elem, inst, options) {
			var currentTime = this._extractTime(inst);
			$.extend(inst.options, options);
			inst.options.show24Hours = inst.options.show24Hours || inst.options.unlimitedHours;
			inst._field = 0;
			if (currentTime) {
				this._setTime(inst, new Date(0, 0, 0, currentTime[0], currentTime[1], currentTime[2]));
			}
			// Remove stuff dependent on old settings
			elem.next('span.' + this._appendClass).remove();
			elem.parent().find('span.' + this._controlClass).remove();
			if ($.fn.mousewheel) {
				elem.unmousewheel();
			}
			// And re-add if requested
			var spinner = (!inst.options.spinnerImage ? null :
				$('<span class="' + this._controlClass + '" style="display: inline-block; ' +
				'background: url(\'' + inst.options.spinnerImage + '\') 0 0 no-repeat; width: ' + 
				inst.options.spinnerSize[0] + 'px; height: ' + inst.options.spinnerSize[1] + 'px;"></span>'));
			elem.after(inst.options.appendText ? '<span class="' + this._appendClass + '">' +
				inst.options.appendText + '</span>' : '').after(spinner || '');
			// Allow mouse wheel usage
			if (inst.options.useMouseWheel && $.fn.mousewheel) {
				elem.mousewheel(this._doMouseWheel);
			}
			if (spinner) {
				spinner.mousedown(this._handleSpinner).mouseup(this._endSpinner).
					mouseover(this._expandSpinner).mouseout(this._endSpinner).
					mousemove(this._describeSpinner);
			}
		},

		/** Enable a time entry input and any associated spinner.
			@param elem {Element} The single input field.
			@example $(selector).timeEntry('enable') */
		enable: function(elem) {
			this._enableDisable(elem, false);
		},

		/** Disable a time entry input and any associated spinner.
			@param elem {Element} The single input field.
			@example $(selector).timeEntry('disable') */
		disable: function(elem) {
			this._enableDisable(elem, true);
		},

		/** Enable or disable a time entry input and any associated spinner.
			@private
			@param elem {Element} The single input field.
			@param disable {boolean} <code>true</code> to disable, <code>false</code> to enable. */
		_enableDisable: function(elem, disable) {
			var inst = this._getInst(elem);
			if (!inst) {
				return;
			}
			elem.disabled = disable;
			if (elem.nextSibling && elem.nextSibling.nodeName.toLowerCase() === 'span') {
				this._changeSpinner(inst, elem.nextSibling, (disable ? 5 : -1));
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === elem ? null : value); }); // Delete entry
			if (disable) {
				this._disabledInputs.push(elem);
			}
		},

		/** Check whether an input field has been disabled.
			@param elem {Element} The input field to check.
			@return {boolean} <code>true</code> if this field has been disabled, <code>false</code> if it is enabled.
			@example if ($(selector).dateEntry('isDisabled')) {...} */
		isDisabled: function(elem) {
			return $.inArray(elem, this._disabledInputs) > -1;
		},

		_preDestroy: function(elem, inst) {
			elem = $(elem).off('.' + pluginName);
			if ($.fn.mousewheel) {
				elem.unmousewheel();
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
			elem.siblings('.' + this._appendClass + ',.' + this._controlClass).remove();
		},

		/** Initialise the current time for a time entry input field.
			@param elem {Element} The input field to update.
			@param time {Date|number|string} The new time or offset or <code>null</code> to clear.
					An actual time or offset in seconds from now or units and periods of offsets from now.
			@example $(selector).timeEntry('setTime', new Date(0, 0, 0, 11, 22, 33))
 $(selector).timeEntry('setTime', +300)
 $(selector).timeEntry('setTime', '+1H +30M')
 $(selector).timeEntry('setTime', null) */
		setTime: function(elem, time) {
			var inst = this._getInst(elem);
			if (inst) {
				if (time === null || time === '') {
					$(elem).val('');
				}
				else {
					this._setTime(inst, time ? ($.isArray(time) ? time :
						(typeof time === 'object' ? new Date(time.getTime()) : time)) : null);
				}
			}
		},

		/** Retrieve the current time for a time entry input field.
			@param elem {Element} The input field to update.
			@return {Date} The current time or <code>null</code> if none.
			@example var time = $(selector).timeEntry('getTime') */
		getTime: function(elem) {
			var inst = this._getInst(elem);
			var currentTime = (inst ? this._extractTime(inst) : null);
			return (!currentTime ? null :
				new Date(0, 0, 0, currentTime[0], currentTime[1], currentTime[2]));
		},

		/** Retrieve the millisecond offset for the current time.
			@param elem {Element} The input field to examine.
			@return {number} The time as milliseconds offset or zero if none.
			@example var offset = $(selector).timeEntry('getOffset') */
		getOffset: function(elem) {
			var inst = this._getInst(elem);
			var currentTime = (inst ? this._extractTime(inst) : null);
			return (!currentTime ? 0 :
				(currentTime[0] * 3600 + currentTime[1] * 60 + currentTime[2]) * 1000);
		},

		/** Initialise date entry.
			@private
			@param elem {Element|Event} The input field or the focus event. */
		_doFocus: function(elem) {
			var input = (elem.nodeName && elem.nodeName.toLowerCase() === 'input' ? elem : this);
			if (plugin._lastInput === input || plugin.isDisabled(input)) {
				plugin._focussed = false;
				return;
			}
			var inst = plugin._getInst(input);
			plugin._focussed = true;
			plugin._lastInput = input;
			plugin._blurredInput = null;
			$.extend(inst.options, ($.isFunction(inst.options.beforeShow) ?
				inst.options.beforeShow.apply(input, [input]) : {}));
				plugin._parseTime(inst, elem.nodeName ? null : elem);
			setTimeout(function() { plugin._showField(inst); }, 10);
		},

		/** Note that the field has been exited.
			@private
			@param event {Event} The blur event. */
		_doBlur: function(event) {
			plugin._blurredInput = plugin._lastInput;
			plugin._lastInput = null;
		},

		/** Select appropriate field portion on click, if already in the field.
			@private
			@param event {Event} The click event. */
		_doClick: function(event) {
			var input = event.target;
			var inst = plugin._getInst(input);
			var prevField = inst._field;
			if (!plugin._focussed) {
				inst._field = plugin._getSelection(inst, input, event);
			}
			if (prevField !== inst._field) {
				inst._lastChr = '';
			}
			plugin._showField(inst);
			plugin._focussed = false;
		},

		/** Find the selected subfield within the control.
			@private
			@param inst {object} The current instance settings.
			@param input {Element} The input control.
			@param event {Event} The triggering event.
			@return {number} The selected subfield. */
		_getSelection: function(inst, input, event) {
			var select = 0;
			var fieldSizes = [inst.elem.val().split(inst.options.separator)[0].length, 2, 2];
			if (input.selectionStart !== null) { // Use input select range
				var end = 0;
				for (var field = 0; field <= Math.max(1, inst._secondField, inst._ampmField); field++) {
					end += (field !== inst._ampmField ? fieldSizes[field] + inst.options.separator.length :
						inst.options.ampmPrefix.length + inst.options.ampmNames[0].length);
					select = field;
					if (input.selectionStart < end) {
						break;
					}
				}
			}
			else if (input.createTextRange && event != null) { // Check against bounding boxes
				var src = $(event.srcElement);
				var range = input.createTextRange();
				var convert = function(value) {
					return {thin: 2, medium: 4, thick: 6}[value] || value;
				};
				var offsetX = event.clientX + document.documentElement.scrollLeft -
					(src.offset().left + parseInt(convert(src.css('border-left-width')), 10)) -
					range.offsetLeft; // Position - left edge - alignment
				for (var field = 0; field <= Math.max(1, inst._secondField, inst._ampmField); field++) {
					var end = (field !== inst._ampmField ? (field * fieldSize) + 2 :
						(inst._ampmField * fieldSize) + inst.options.ampmPrefix.length +
						inst.options.ampmNames[0].length);
					range.collapse();
					range.moveEnd('character', end);
					select = field;
					if (offsetX < range.boundingWidth) { // And compare
						break;
					}
				}
			}
			return select;
		},

		/** Handle keystrokes in the field.
			@private
			@param event {Event} The keydown event.
			@return {boolean} <code>true</code> to continue, <code>false</code> to stop processing. */
		_doKeyDown: function(event) {
			if (event.keyCode >= 48) { // >= '0'
				return true;
			}
			var inst = plugin._getInst(event.target);
			switch (event.keyCode) {
				case 9: return (inst.options.tabToExit ? true : (event.shiftKey ?
							// Move to previous time field, or out if at the beginning
							plugin._changeField(inst, -1, true) :
							// Move to next time field, or out if at the end
							plugin._changeField(inst, +1, true)));
				case 35: if (event.ctrlKey) { // Clear time on ctrl+end
							plugin._setValue(inst, '');
						}
						else { // Last field on end
							inst._field = Math.max(1, inst._secondField, inst._ampmField);
							plugin._adjustField(inst, 0);
						}
						break;
				case 36: if (event.ctrlKey) { // Current time on ctrl+home
							plugin._setTime(inst);
						}
						else { // First field on home
							inst._field = 0;
							plugin._adjustField(inst, 0);
						}
						break;
				case 37: plugin._changeField(inst, -1, false); break; // Previous field on left
				case 38: plugin._adjustField(inst, +1); break; // Increment time field on up
				case 39: plugin._changeField(inst, +1, false); break; // Next field on right
				case 40: plugin._adjustField(inst, -1); break; // Decrement time field on down
				case 46: plugin._setValue(inst, ''); break; // Clear time on delete
				case 8: inst._lastChr = ''; // Fall through
				default: return true;
			}
			return false;
		},

		/** Disallow unwanted characters.
			@private
			@param event {Event} The keypress event.
			@return {boolean} <code>true</code> to continue, <code>false</code> to stop processing. */
		_doKeyPress: function(event) {
			var chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
			if (chr < ' ') {
				return true;
			}
			var inst = plugin._getInst(event.target);
			plugin._handleKeyPress(inst, chr);
			return false;
		},

		/** Update date based on keystroke entered.
			@private
			@param inst {object} The instance settings.
			@param chr {string} The new character. */
		_handleKeyPress: function(inst, chr) {
			if (chr === inst.options.separator) {
				this._changeField(inst, +1, false);
			}
			else if (chr >= '0' && chr <= '9') { // Allow direct entry of date
				var key = parseInt(chr, 10);
				var value = parseInt(inst._lastChr + chr, 10);
				var hour = (inst._field !== 0 ? inst._selectedHour :
					(inst.options.unlimitedHours ? value :
					(inst.options.show24Hours ? (value < 24 ? value : key) :
					(value >= 1 && value <= 12 ? value :
					(key > 0 ? key : inst._selectedHour)) % 12 +
					(inst._selectedHour >= 12 ? 12 : 0))));
				var minute = (inst._field !== 1 ? inst._selectedMinute :
					(value < 60 ? value : key));
				var second = (inst._field !== inst._secondField ? inst._selectedSecond :
					(value < 60 ? value : key));
				var fields = this._constrainTime(inst, [hour, minute, second]);
				this._setTime(inst, (inst.options.unlimitedHours ? fields :
					new Date(0, 0, 0, fields[0], fields[1], fields[2])));
				if (inst.options.noSeparatorEntry && inst._lastChr) {
					this._changeField(inst, +1, false);
				}
				else {
					inst._lastChr = (inst.options.unlimitedHours && inst._field === 0 ? inst._lastChr + chr : chr);
				}
			}
			else if (!inst.options.show24Hours) { // Set am/pm based on first char of names
				chr = chr.toLowerCase();
				if ((chr === inst.options.ampmNames[0].substring(0, 1).toLowerCase() &&
						inst._selectedHour >= 12) ||
						(chr === inst.options.ampmNames[1].substring(0, 1).toLowerCase() &&
						inst._selectedHour < 12)) {
					var saveField = inst._field;
					inst._field = inst._ampmField;
					this._adjustField(inst, +1);
					inst._field = saveField;
					this._showField(inst);
				}
			}
		},

		/** Increment/decrement on mouse wheel activity.
			@private
			@param event {Event} The mouse wheel event.
			@param delta {number} The amount of change. */
		_doMouseWheel: function(event, delta) {
			if (plugin.isDisabled(event.target)) {
				return;
			}
			var inst = plugin._getInst(event.target);
			inst.elem.focus();
			if (!inst.elem.val()) {
				plugin._parseTime(inst);
			}
			plugin._adjustField(inst, delta);
			event.preventDefault();
		},

		/** Expand the spinner, if possible, to make it easier to use.
			@private
			@param event {Event} The mouse over event. */
		_expandSpinner: function(event) {
			var spinner = plugin._getSpinnerTarget(event);
			var inst = plugin._getInst(plugin._getInput(spinner));
			if (plugin.isDisabled(inst.elem[0])) {
				return;
			}
			if (inst.options.spinnerBigImage) {
				inst._expanded = true;
				var offset = $(spinner).offset();
				var relative = null;
				$(spinner).parents().each(function() {
					var parent = $(this);
					if (parent.css('position') === 'relative' || parent.css('position') === 'absolute') {
						relative = parent.offset();
					}
					return !relative;
				});
				$('<div class="' + plugin._expandClass + '" style="position: absolute; left: ' +
					(offset.left - (inst.options.spinnerBigSize[0] - inst.options.spinnerSize[0]) / 2 -
					(relative ? relative.left : 0)) + 'px; top: ' +
					(offset.top - (inst.options.spinnerBigSize[1] - inst.options.spinnerSize[1]) / 2 -
					(relative ? relative.top : 0)) + 'px; width: ' +
					inst.options.spinnerBigSize[0] + 'px; height: ' +
					inst.options.spinnerBigSize[1] + 'px; background: transparent url(' +
					inst.options.spinnerBigImage + ') no-repeat 0px 0px; z-index: 10;"></div>').
					mousedown(plugin._handleSpinner).mouseup(plugin._endSpinner).
					mouseout(plugin._endExpand).mousemove(plugin._describeSpinner).
					insertAfter(spinner);
			}
		},

		/** Locate the actual input field from the spinner.
			@private
			@param spinner {Element} The current spinner.
			@return {Element} The corresponding input. */
		_getInput: function(spinner) {
			return $(spinner).siblings('.' + this._getMarker())[0];
		},

		/** Change the title based on position within the spinner.
			@private
			@param event {Event} The mouse move event. */
		_describeSpinner: function(event) {
			var spinner = plugin._getSpinnerTarget(event);
			var inst = plugin._getInst(plugin._getInput(spinner));
			spinner.title = inst.options.spinnerTexts[plugin._getSpinnerRegion(inst, event)];
		},

		/** Handle a click on the spinner.
			@private
			@param event {Event} The mouse click event. */
		_handleSpinner: function(event) {
			var spinner = plugin._getSpinnerTarget(event);
			var input = plugin._getInput(spinner);
			if (plugin.isDisabled(input)) {
				return;
			}
			if (input === plugin._blurredInput) {
				plugin._lastInput = input;
				plugin._blurredInput = null;
			}
			var inst = plugin._getInst(input);
			plugin._doFocus(input);
			var region = plugin._getSpinnerRegion(inst, event);
			plugin._changeSpinner(inst, spinner, region);
			plugin._actionSpinner(inst, region);
			plugin._timer = null;
			plugin._handlingSpinner = true;
			if (region >= 3 && inst.options.spinnerRepeat[0]) { // Repeat increment/decrement
				plugin._timer = setTimeout(
					function() { plugin._repeatSpinner(inst, region); },
					inst.options.spinnerRepeat[0]);
				$(spinner).one('mouseout', plugin._releaseSpinner).
					one('mouseup', plugin._releaseSpinner);
			}
		},

		/** Action a click on the spinner.
			@private
			@param inst {object} The instance settings.
			@param region {number} The spinner "button". */
		_actionSpinner: function(inst, region) {
			if (!inst.elem.val()) {
				plugin._parseTime(inst);
			}
			switch (region) {
				case 0: this._setTime(inst); break;
				case 1: this._changeField(inst, -1, false); break;
				case 2: this._changeField(inst, +1, false); break;
				case 3: this._adjustField(inst, +1); break;
				case 4: this._adjustField(inst, -1); break;
			}
		},

		/** Repeat a click on the spinner.
			@private
			@param inst {object} The instance settings.
			@param region {number} The spinner "button". */
		_repeatSpinner: function(inst, region) {
			if (!plugin._timer) {
				return;
			}
			plugin._lastInput = plugin._blurredInput;
			this._actionSpinner(inst, region);
			this._timer = setTimeout(
				function() { plugin._repeatSpinner(inst, region); },
				inst.options.spinnerRepeat[1]);
		},

		/** Stop a spinner repeat.
			@private
			@param event {Event} The mouse event. */
		_releaseSpinner: function(event) {
			clearTimeout(plugin._timer);
			plugin._timer = null;
		},

		/** Tidy up after an expanded spinner.
			@private
			@param event {Event} The mouse event. */
		_endExpand: function(event) {
			plugin._timer = null;
			var spinner = plugin._getSpinnerTarget(event);
			var input = plugin._getInput(spinner);
			var inst = plugin._getInst(input);
			$(spinner).remove();
			inst._expanded = false;
		},

		/** Tidy up after a spinner click.
			@private
			@param event {Event} The mouse event. */
		_endSpinner: function(event) {
			plugin._timer = null;
			var spinner = plugin._getSpinnerTarget(event);
			var input = plugin._getInput(spinner);
			var inst = plugin._getInst(input);
			if (!plugin.isDisabled(input)) {
				plugin._changeSpinner(inst, spinner, -1);
			}
			if (plugin._handlingSpinner) {
				plugin._lastInput = plugin._blurredInput;
			}
			if (plugin._lastInput && plugin._handlingSpinner) {
				plugin._showField(inst);
			}
			plugin._handlingSpinner = false;
		},

		/** Retrieve the spinner from the event.
			@private
			@param event {Event} The mouse click event.
			@return {Element} The target field. */
		_getSpinnerTarget: function(event) {
			return event.target || event.srcElement;
		},

		/** Determine which "button" within the spinner was clicked.
			@private
			@param inst {object} The instance settings.
			@param event {Event} The mouse event.
			@return {number} The spinner "button" number. */
		_getSpinnerRegion: function(inst, event) {
			var spinner = this._getSpinnerTarget(event);
			var pos = $(spinner).offset();
			var scrolled = [document.documentElement.scrollLeft || document.body.scrollLeft,
				document.documentElement.scrollTop || document.body.scrollTop];
			var left = (inst.options.spinnerIncDecOnly ? 99 : event.clientX + scrolled[0] - pos.left);
			var top = event.clientY + scrolled[1] - pos.top;
			var spinnerSize = inst.options[inst._expanded ? 'spinnerBigSize' : 'spinnerSize'];
			var right = (inst.options.spinnerIncDecOnly ? 99 : spinnerSize[0] - 1 - left);
			var bottom = spinnerSize[1] - 1 - top;
			if (spinnerSize[2] > 0 && Math.abs(left - right) <= spinnerSize[2] &&
					Math.abs(top - bottom) <= spinnerSize[2]) {
				return 0; // Centre button
			}
			var min = Math.min(left, top, right, bottom);
			return (min === left ? 1 : (min === right ? 2 : (min === top ? 3 : 4))); // Nearest edge
		},

		/** Change the spinner image depending on the button clicked.
			@private
			@param inst {object} The instance settings.
			@param spinner {Element} The spinner control.
			@param region {number} The spinner "button". */
		_changeSpinner: function(inst, spinner, region) {
			$(spinner).css('background-position', '-' + ((region + 1) *
				inst.options[inst._expanded ? 'spinnerBigSize' : 'spinnerSize'][0]) + 'px 0px');
		},

		/** Extract the time value from the input field, or default to now.
			@private
			@param inst {object} The instance settings.
			@param event {Event} The triggering event or <code>null</code>. */
		_parseTime: function(inst, event) {
			var currentTime = this._extractTime(inst);
			if (currentTime) {
				inst._selectedHour = currentTime[0];
				inst._selectedMinute = currentTime[1];
				inst._selectedSecond = currentTime[2];
			}
			else {
				var now = this._constrainTime(inst);
				inst._selectedHour = now[0];
				inst._selectedMinute = now[1];
				inst._selectedSecond = (inst.options.showSeconds ? now[2] : 0);
			}
			inst._secondField = (inst.options.showSeconds ? 2 : -1);
			inst._ampmField = (inst.options.show24Hours ? -1 : (inst.options.showSeconds ? 3 : 2));
			inst._lastChr = '';
			var postProcess = function() {
				if (inst.elem.val() !== '') {
					plugin._showTime(inst);
				}
			};
			if (typeof inst.options.initialField === 'number') {
				inst._field = Math.max(0, Math.min(
					Math.max(1, inst._secondField, inst._ampmField), inst.options.initialField));
				postProcess();
			}
			else {
				setTimeout(function() {
					inst._field = plugin._getSelection(inst, inst.elem[0], event);
					postProcess();
				}, 0);
			}
		},

		/** Extract the time value from a string as an array of values, or default to <code>null</code>.
			@private
			@param value {string} The date text.
			@param inst {object} The instance settings.
			@return {number[]} The retrieved time components (hours, minutes, seconds) or
					<code>null</code> if no value. */
		_extractTime: function(inst, value) {
			value = value || inst.elem.val();
			var currentTime = value.split(inst.options.separator);
			if (inst.options.separator === '' && value !== '') {
				currentTime[0] = value.substring(0, 2);
				currentTime[1] = value.substring(2, 4);
				currentTime[2] = value.substring(4, 6);
			}
			if (currentTime.length >= 2) {
				var isAM = !inst.options.show24Hours && (value.indexOf(inst.options.ampmNames[0]) > -1);
				var isPM = !inst.options.show24Hours && (value.indexOf(inst.options.ampmNames[1]) > -1);
				var hour = parseInt(currentTime[0], 10);
				hour = (isNaN(hour) ? 0 : hour);
				hour = ((isAM || isPM) && hour === 12 ? 0 : hour) + (isPM ? 12 : 0);
				var minute = parseInt(currentTime[1], 10);
				minute = (isNaN(minute) ? 0 : minute);
				var second = (currentTime.length >= 3 ? parseInt(currentTime[2], 10) : 0);
				second = (isNaN(second) || !inst.options.showSeconds ? 0 : second);
				return this._constrainTime(inst, [hour, minute, second]);
			} 
			return null;
		},

		/** Constrain the given/current time to the time steps.
			@private
			@param inst {object} The instance settings.
			@param fields {number[]} The current time components (hours, minutes, seconds).
			@return {number[]} The constrained time components (hours, minutes, seconds). */
		_constrainTime: function(inst, fields) {
			var specified = (fields !== null && fields !== undefined);
			if (!specified) {
				var now = this._determineTime(inst.options.defaultTime, inst) || new Date();
				fields = [now.getHours(), now.getMinutes(), now.getSeconds()];
			}
			var reset = false;
			for (var i = 0; i < inst.options.timeSteps.length; i++) {
				if (reset) {
					fields[i] = 0;
				}
				else if (inst.options.timeSteps[i] > 1) {
					fields[i] = Math.round(fields[i] / inst.options.timeSteps[i]) *
						inst.options.timeSteps[i];
					reset = true;
				}
			}
			return fields;
		},

		/** Set the selected time into the input field.
			@private
			@param inst {object} The instance settings. */
		_showTime: function(inst) {
			var currentTime = (inst.options.unlimitedHours ? inst._selectedHour :
				this._formatNumber(inst.options.show24Hours ? inst._selectedHour :
				((inst._selectedHour + 11) % 12) + 1)) + inst.options.separator +
				this._formatNumber(inst._selectedMinute) +
				(inst.options.showSeconds ? inst.options.separator +
				this._formatNumber(inst._selectedSecond) : '') +
				(inst.options.show24Hours ?  '' : inst.options.ampmPrefix +
				inst.options.ampmNames[(inst._selectedHour < 12 ? 0 : 1)]);
			this._setValue(inst, currentTime);
			this._showField(inst);
		},

		/** Highlight the current date field.
			@private
			@param inst {object} The instance settings. */
		_showField: function(inst) {
			var input = inst.elem[0];
			if (inst.elem.is(':hidden') || plugin._lastInput !== input) {
				return;
			}
			var fieldSizes = [inst.elem.val().split(inst.options.separator)[0].length, 2, 2];
			var start = 0;
			var field = 0;
			while (field < inst._field) {
				start += fieldSizes[field] +
					(field === Math.max(1, inst._secondField) ? 0 : inst.options.separator.length);
				field++;
			}
			var end = start + (inst._field !== inst._ampmField ? fieldSizes[field] :
				inst.options.ampmPrefix.length + inst.options.ampmNames[0].length);
			if (input.setSelectionRange) { // Mozilla
				input.setSelectionRange(start, end);
			}
			else if (input.createTextRange) { // IE
				var range = input.createTextRange();
				range.moveStart('character', start);
				range.moveEnd('character', end - inst.elem.val().length);
				range.select();
			}
			if (!input.disabled) {
				input.focus();
			}
		},

		/** Ensure displayed single number has a leading zero.
			@private
			@param value {number} The current value.
			@return {string} Number with at least two digits. */
		_formatNumber: function(value) {
			return (value < 10 ? '0' : '') + value;
		},

		/** Update the input field and notify listeners.
			@private
			@param inst {object} The instance settings.
			@param value {string} The new value. */
		_setValue: function(inst, value) {
			if (value !== inst.elem.val()) {
				inst.elem.val(value).trigger('change');
			}
		},

		/** Move to previous/next field, or out of field altogether if appropriate.
			@private
			@param inst {object} The instance settings.
			@param offset {number} The direction of change (-1, +1).
			@param moveOut {boolean} <code>true</code> if can move out of the field.
			@return {boolean} <code>true</code> if exiting the field, <code>false</code> if not. */
		_changeField: function(inst, offset, moveOut) {
			var atFirstLast = (inst.elem.val() === '' ||
				inst._field === (offset === -1 ? 0 : Math.max(1, inst._secondField, inst._ampmField)));
			if (!atFirstLast) {
				inst._field += offset;
			}
			this._showField(inst);
			inst._lastChr = '';
			return (atFirstLast && moveOut);
		},

		/** Update the current field in the direction indicated.
			@private
			@param inst {object} The instance settings.
			@param offset {number} The amount to change by. */
		_adjustField: function(inst, offset) {
			if (inst.elem.val() === '') {
				offset = 0;
			}
			if (inst.options.unlimitedHours) {
				this._setTime(inst, [inst._selectedHour + (inst._field === 0 ? offset * inst.options.timeSteps[0] : 0),
					inst._selectedMinute + (inst._field === 1 ? offset * inst.options.timeSteps[1] : 0),
					inst._selectedSecond + (inst._field === inst._secondField ? offset * inst.options.timeSteps[2] : 0)]);
			}
			else {
			this._setTime(inst, new Date(0, 0, 0,
				inst._selectedHour + (inst._field === 0 ? offset * inst.options.timeSteps[0] : 0) +
				(inst._field === inst._ampmField ? offset * 12 : 0),
				inst._selectedMinute + (inst._field === 1 ? offset * inst.options.timeSteps[1] : 0),
					inst._selectedSecond + (inst._field === inst._secondField ? offset * inst.options.timeSteps[2] : 0)));
			}
		},

		/** Check against minimum/maximum and display time.
			@private
			@param inst {object} The instance settings.
			@param time {Date|number|string|number[]} The actual time or offset in seconds from now or
					units and periods of offsets from now or numeric period values. */
		_setTime: function(inst, time) {
			if (inst.options.unlimitedHours && $.isArray(time)) {
				var fields = time;
			}
			else {
			time = this._determineTime(time, inst);
				var fields = (time ? [time.getHours(), time.getMinutes(), time.getSeconds()] : null);
			}
			fields = this._constrainTime(inst, fields);
			time = new Date(0, 0, 0, fields[0], fields[1], fields[2]);
			// Normalise to base date
			var time = this._normaliseTime(time);
			var minTime = this._normaliseTime(this._determineTime(inst.options.minTime, inst));
			var maxTime = this._normaliseTime(this._determineTime(inst.options.maxTime, inst));
			// Ensure it is within the bounds set
			if (inst.options.unlimitedHours) {
				while (fields[2] < 0) {
					fields[2] += 60;
					fields[1]--;
				}
				while (fields[2] > 59) {
					fields[2] -= 60;
					fields[1]++;
				}
				while (fields[1] < 0) {
					fields[1] += 60;
					fields[0]--;
				}
				while (fields[1] > 59) {
					fields[1] -= 60;
					fields[0]++;
				}
				minTime = (inst.options.minTime != null && $.isArray(inst.options.minTime)) ?
					inst.options.minTime : [0, 0, 0];
				if (fields[0] < minTime[0]) {
					fields = minTime.slice(0, 3);
				}
				else if (fields[0] === minTime[0]) {
					if (fields[1] < minTime[1]) {
						fields[1] = minTime[1];
						fields[2] = minTime[2];
					}
					else if (fields[1] === minTime[1]) {
						if (fields[2] < minTime[2]) {
							fields[2] = minTime[2];
						}
					}
				}
				if (inst.options.maxTime != null && $.isArray(inst.options.maxTime)) {
					if (fields[0] > inst.options.maxTime[0]) {
						fields = inst.options.maxTime.slice(0, 3);
					}
					else if (fields[0] === inst.options.maxTime[0]) {
						if (fields[1] > inst.options.maxTime[1]) {
							fields[1] = inst.options.maxTime[1];
							fields[2] = inst.options.maxTime[2];
						}
						else if (fields[1] === inst.options.maxTime[1]) {
							if (fields[2] > inst.options.maxTime[2]) {
								fields[2] = inst.options.maxTime[2];
							}
						}
					}
				}
			}
			else {
			if (minTime && maxTime && minTime > maxTime) {
				if (time < minTime && time > maxTime) {
					time = (Math.abs(time - minTime) < Math.abs(time - maxTime) ? minTime : maxTime);
				}
			}
			else {
				time = (minTime && time < minTime ? minTime :
					(maxTime && time > maxTime ? maxTime : time));
			}
				fields[0] = time.getHours();
				fields[1] = time.getMinutes();
				fields[2] = time.getSeconds();
			}
			// Perform further restrictions if required
			if ($.isFunction(inst.options.beforeSetTime)) {
				time = inst.options.beforeSetTime.apply(inst.elem[0],
					[this.getTime(inst.elem[0]), time, minTime, maxTime]);
				fields[0] = time.getHours();
				fields[1] = time.getMinutes();
				fields[2] = time.getSeconds();
			}
			inst._selectedHour = fields[0];
			inst._selectedMinute = fields[1];
			inst._selectedSecond = fields[2];
			this._showTime(inst);
		},

		/** A time may be specified as an exact value or a relative one.
			@private
			@param setting {Date|number|string|number[]} The actual time or offset in seconds from now or
					units and periods of offsets from now or numeric period values.
			@param inst {object} The instance settings.
			@return {Date} The calculated time. */
		_determineTime: function(setting, inst) {
			var offsetNumeric = function(offset) { // E.g. +300, -2
				var time = new Date();
				time.setTime(time.getTime() + offset * 1000);
				return time;
			};
			var offsetString = function(offset) { // E.g. '+2m', '-4h', '+3h +30m' or '12:34:56PM'
				var fields = plugin._extractTime(inst, offset); // Actual time?
				var time = new Date();
				var hour = (fields ? fields[0] : time.getHours());
				var minute = (fields ? fields[1] : time.getMinutes());
				var second = (fields ? fields[2] : time.getSeconds());
				if (!fields) {
					var pattern = /([+-]?[0-9]+)\s*(s|S|m|M|h|H)?/g;
					var matches = pattern.exec(offset);
					while (matches) {
						switch (matches[2] || 's') {
							case 's' : case 'S' :
								second += parseInt(matches[1], 10); break;
							case 'm' : case 'M' :
								minute += parseInt(matches[1], 10); break;
							case 'h' : case 'H' :
								hour += parseInt(matches[1], 10); break;
						}
						matches = pattern.exec(offset);
					}
				}
				time = new Date(0, 0, 10, hour, minute, second, 0);
				if (/^!/.test(offset)) { // No wrapping
					if (time.getDate() > 10) {
						time = new Date(0, 0, 10, 23, 59, 59);
					}
					else if (time.getDate() < 10) {
						time = new Date(0, 0, 10, 0, 0, 0);
					}
				}
				return time;
			};
			var offsetArray = function(setting) {
				return new Date(0, 0, 0, setting[0], setting[1] || 0, setting[2] || 0, 0);
			};
			return (setting ? (typeof setting === 'string' ? offsetString(setting) :
				(typeof setting === 'number' ? offsetNumeric(setting) :
				($.isArray(setting) ? offsetArray(setting) : setting))) : null);
		},

		/** Normalise time object to a common date.
			@private
			@param time {Date} The original time.
			@return {Date} The normalised time. */
		_normaliseTime: function(time) {
			if (!time) {
				return null;
			}
			time.setFullYear(1900);
			time.setMonth(0);
			time.setDate(0);
			return time;
		}
	});
	
	var plugin = $.timeEntry;

})(jQuery);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS50aW1lZW50cnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoianF1ZXJ5LnRpbWVlbnRyeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvdGltZUVudHJ5Lmh0bWxcbiAgIFRpbWUgZW50cnkgZm9yIGpRdWVyeSB2Mi4wLjEuXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEp1bmUgMjAwNy5cbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9NSVQtTElDRU5TRS50eHQpIGxpY2Vuc2UuXG4gICBQbGVhc2UgYXR0cmlidXRlIHRoZSBhdXRob3IgaWYgeW91IHVzZSBpdC4gKi9cblxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxuXG5cdHZhciBwbHVnaW5OYW1lID0gJ3RpbWVFbnRyeSc7XG5cblx0LyoqIENyZWF0ZSB0aGUgdGltZSBlbnRyeSBwbHVnaW4uXG5cdFx0PHA+U2V0cyBhbiBpbnB1dCBmaWVsZCB0byBhZGQgYSBzcGlubmVyIGZvciB0aW1lIGVudHJ5LjwvcD5cblx0XHQ8cD5UaGUgdGltZSBjYW4gYmUgZW50ZXJlZCB2aWEgZGlyZWN0bHkgdHlwaW5nIHRoZSB2YWx1ZSxcblx0XHR2aWEgdGhlIGFycm93IGtleXMsIG9yIHZpYSBzcGlubmVyIGJ1dHRvbnMuXG5cdFx0SXQgaXMgY29uZmlndXJhYmxlIHRvIHNob3cgMTIgb3IgMjQtaG91ciB0aW1lLCB0byBzaG93IG9yIGhpZGUgc2Vjb25kcyxcblx0XHR0byBlbmZvcmNlIGEgbWluaW11bSBhbmQvb3IgbWF4aW11bSB0aW1lLCB0byBjaGFuZ2UgdGhlIHNwaW5uZXIgaW1hZ2UsXG5cdFx0YW5kIHRvIGNvbnN0cmFpbiB0aGUgdGltZSB0byBzdGVwcywgZS5nLiBvbmx5IG9uIHRoZSBxdWFydGVyIGhvdXJzLjwvcD5cblx0XHQ8cD5FeHBlY3RzIEhUTUwgbGlrZTo8L3A+XG5cdFx0PHByZT4mbHQ7aW5wdXQgdHlwZT1cInRleHRcIj48L3ByZT5cblx0XHQ8cD5Qcm92aWRlIGlubGluZSBjb25maWd1cmF0aW9uIGxpa2U6PC9wPlxuXHRcdDxwcmU+Jmx0O2lucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS10aW1lRW50cnk9XCJuYW1lOiAndmFsdWUnXCI+PC9wcmU+XG5cdCBcdEBtb2R1bGUgVGltZUVudHJ5XG5cdFx0QGF1Z21lbnRzIEpRUGx1Z2luXG5cdFx0QGV4YW1wbGUgJChzZWxlY3RvcikudGltZUVudHJ5KClcbiAkKHNlbGVjdG9yKS50aW1lRW50cnkoe3Nob3dTZWNvbmRzOiB0cnVlLCBtaW5UaW1lOiBuZXcgRGF0ZSgwLCAwLCAwLCAxMiwgMCwgMCl9KSAqL1xuXHQkLkpRUGx1Z2luLmNyZWF0ZVBsdWdpbih7XG5cdFxuXHRcdC8qKiBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLiAqL1xuXHRcdG5hbWU6IHBsdWdpbk5hbWUsXG5cdFx0XHRcblx0XHQvKiogVGltZSBlbnRyeSBiZWZvcmUgc2hvdyBjYWxsYmFjay5cblx0XHRcdFRyaWdnZXJlZCB3aGVuIHRoZSBpbnB1dCBmaWVsZCBpcyBmb2N1c3NlZC5cblx0XHRcdEBjYWxsYmFjayBiZWZvcmVTaG93Q2FsbGJhY2tcblx0XHRcdEBwYXJhbSBpbnB1dCB7RWxlbWVudH0gVGhlIGN1cnJlbnQgaW5wdXQgZmllbGQuXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEFueSBjaGFuZ2VzIHRvIHRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBleGFtcGxlIGJlZm9yZVNob3c6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdC8vIENyb3NzLXBvcHVsYXRlIG1pbmltdW0vbWF4aW11bSB0aW1lcyBmb3IgYSByYW5nZVxuIFx0cmV0dXJuIHttaW5UaW1lOiAoaW5wdXQuaWQgPT09ICd0aW1lVG8nID9cbiBcdFx0JCgnI3RpbWVGcm9tJykudGltZUVudHJ5KCdnZXRUaW1lJykgOiBudWxsKSwgXG4gXHRcdG1heFRpbWU6IChpbnB1dC5pZCA9PT0gJ3RpbWVGcm9tJyA/XG4gXHRcdCQoJyN0aW1lVG8nKS50aW1lRW50cnkoJ2dldFRpbWUnKSA6IG51bGwpfTtcbiB9ICovXG5cdFx0XHRcblx0XHQvKiogVGltZSBlbnRyeSBiZWZvcmUgc2V0IHRpbWUgY2FsbGJhY2suXG5cdFx0XHRUcmlnZ2VyZWQgd2hlbiB0aGUgaW5wdXQgZmllbGQgdmFsdWUgaXMgdG8gYmUgY2hhbmdlZC5cblx0XHRcdEBjYWxsYmFjayBiZWZvcmVTZXRUaW1lQ2FsbGJhY2tcblx0XHRcdEBwYXJhbSBjdXJyZW50IHtzdHJpbmd9IFRoZSBjdXJyZW50IHRpbWUgdmFsdWUgZW50ZXJlZC5cblx0XHRcdEBwYXJhbSBuZXdUaW1lIHtzdHJpbmd9IFRoZSBuZXcgdGltZSB2YWx1ZSB0byB1c2UuXG5cdFx0XHRAcGFyYW0gbWluVGltZSB7RGF0ZX0gVGhlIG1pbmltdW0gdGltZSB2YWx1ZSBhbGxvd2VkLlxuXHRcdFx0QHBhcmFtIG1heFRpbWUge0RhdGV9IFRoZSBtYXhpbXVtIHRpbWUgdmFsdWUgYWxsb3dlZC5cblx0XHRcdEByZXR1cm4ge0RhdGV9IFRoZSBhY3R1YWwgdGltZSB2YWx1ZSB0byBzZXQuXG5cdFx0XHRAZXhhbXBsZSBiZWZvcmVTZXRUaW1lOiBmdW5jdGlvbihvbGRUaW1lLCBuZXdUaW1lLCBtaW5UaW1lLCBtYXhUaW1lKSB7XG4gXHR2YXIgaW5jcmVtZW50ID0gKG5ld1RpbWUgLSAob2xkVGltZSB8fCBuZXdUaW1lKSkgPiAwO1xuIFx0aWYgKG5ld1RpbWUuZ2V0TWludXRlcygpID4gMzApIHsgLy8gRmlyc3QgaGFsZiBvZiBob3VyIG9ubHlcbiBcdFx0bmV3VGltZS5zZXRNaW51dGVzKGluY3JlbWVudCA/IDAgOiAzMCk7XG4gXHRcdG5ld1RpbWUuc2V0SG91cnMobmV3VGltZS5nZXRIb3VycygpICsgKGluY3JlbWVudCA/IDEgOiAwKSk7XG4gXHR9XG4gXHRyZXR1cm4gbmV3VGltZTtcbiB9ICovXG5cdFx0XHRcblx0XHQvKiogRGVmYXVsdCBzZXR0aW5ncyBmb3IgdGhlIHBsdWdpbi5cblx0XHRcdEBwcm9wZXJ0eSBbYXBwZW5kVGV4dD0nJ10ge3N0cmluZ30gRGlzcGxheSB0ZXh0IGZvbGxvd2luZyB0aGUgaW5wdXQgYm94LCBlLmcuIHNob3dpbmcgdGhlIGZvcm1hdC5cblx0XHRcdEBwcm9wZXJ0eSBbc2hvd1NlY29uZHM9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBzaG93IHNlY29uZHMgYXMgd2VsbCxcblx0XHRcdFx0XHRcdDxjb2RlPmZhbHNlPC9jb2RlPiBmb3IgaG91cnMvbWludXRlcyBvbmx5LlxuXHRcdFx0QHByb3BlcnR5IFt1bmxpbWl0ZWRIb3Vycz1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGFsbG93IGVudHJ5IG9mIG1vcmUgdGhhbiAyNCBob3Vycyxcblx0XHRcdFx0XHRcdDxjb2RlPmZhbHNlPC9jb2RlPiB0byByZXN0cmljdCB0byBvbmUgZGF5LlxuXHRcdFx0QHByb3BlcnR5IFt0aW1lU3RlcHM9WzEsMSwxXV0ge251bWJlcltdfSBTdGVwcyBmb3IgZWFjaCBvZiBob3Vycy9taW51dGVzL3NlY29uZHMgd2hlbiBpbmNyZW1lbnRpbmcvZGVjcmVtZW50aW5nLlxuXHRcdFx0QHByb3BlcnR5IFtpbml0aWFsRmllbGQ9bnVsbF0ge251bWJlcn0gVGhlIGZpZWxkIHRvIGhpZ2hsaWdodCBpbml0aWFsbHkgKDAgPSBob3VycywgMSA9IG1pbnV0ZXMsIC4uLiksXG5cdFx0XHRcdFx0XHRvciA8Y29kZT5udWxsPC9jb2RlPiBmb3Igbm9uZS5cblx0XHRcdEBwcm9wZXJ0eSBbbm9TZXBhcmF0b3JFbnRyeT1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIG1vdmUgdG8gbmV4dCBzdWItZmllbGQgYWZ0ZXIgdHdvIGRpZ2l0cyBlbnRyeS5cblx0XHRcdEBwcm9wZXJ0eSBbdGFiVG9FeGl0PWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gZm9yIHRhYiBrZXkgdG8gZ28gdG8gbmV4dCBlbGVtZW50LFxuXHRcdFx0XHRcdFx0PGNvZGU+ZmFsc2U8L2NvZGU+IGZvciB0YWIga2V5IHRvIHN0ZXAgdGhyb3VnaCBpbnRlcm5hbCBmaWVsZHMuXG5cdFx0XHRAcHJvcGVydHkgW3VzZU1vdXNlV2hlZWw9dHJ1ZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHVzZSBtb3VzZSB3aGVlbCBmb3IgaW5jcmVtZW50L2RlY3JlbWVudCBpZiBwb3NzaWJsZSxcblx0XHRcdFx0XHRcdDxjb2RlPmZhbHNlPC9jb2RlPiB0byBuZXZlciB1c2UgaXQuXG5cdFx0XHRAcHJvcGVydHkgW2RlZmF1bHRUaW1lPW51bGxdIHtEYXRlfG51bWJlcnxzdHJpbmd9IFRoZSB0aW1lIHRvIHVzZSBpZiBub25lIGhhcyBiZWVuIHNldCxcblx0XHRcdFx0XHRcdG9yIDxjb2RlPm51bGw8L2NvZGU+IGZvciBub3cuIFNwZWNpZnkgYXMgYSA8Y29kZT5EYXRlPC9jb2RlPiBvYmplY3QsIGFzIGEgbnVtYmVyIG9mIHNlY29uZHNcblx0XHRcdFx0XHRcdG9mZnNldCBmcm9tIG5vdywgb3IgYXMgYSBzdHJpbmcgb2Ygb2Zmc2V0cyBmcm9tIG5vdywgdXNpbmcgJ0gnIGZvciBob3Vycyxcblx0XHRcdFx0XHRcdCdNJyBmb3IgbWludXRlcywgJ1MnIGZvciBzZWNvbmRzLlxuXHRcdFx0QHByb3BlcnR5IFttaW5UaW1lPW51bGxdIHtEYXRlfG51bWJlcnxzdHJpbmd8bnVtYmVyW119IFRoZSBlYXJsaWVzdCBzZWxlY3RhYmxlIHRpbWUsXG5cdFx0XHRcdFx0XHRvciA8Y29kZT5udWxsPC9jb2RlPiBmb3Igbm8gbGltaXQuIFNlZSA8Y29kZT5kZWZhdWx0VGltZTwvY29kZT4gZm9yIHBvc3NpYmxlIGZvcm1hdHMsXG5cdFx0XHRcdFx0XHR1c2UgYXJyYXkgb2YgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgZm9yIDxjb2RlPnVubGltaXRlZEhvdXJzPC9jb2RlPi5cblx0XHRcdEBwcm9wZXJ0eSBbbWF4VGltZT1udWxsXSB7RGF0ZXxudW1iZXJ8c3RyaW5nfG51bWJlcltdfSBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgdGltZSxcblx0XHRcdFx0XHRcdG9yIDxjb2RlPm51bGw8L2NvZGU+IGZvciBubyBsaW1pdC4gU2VlIDxjb2RlPmRlZmF1bHRUaW1lPC9jb2RlPiBmb3IgcG9zc2libGUgZm9ybWF0cyxcblx0XHRcdFx0XHRcdHVzZSBhcnJheSBvZiBob3VycywgbWludXRlcywgc2Vjb25kcyBmb3IgPGNvZGU+dW5saW1pdGVkSG91cnM8L2NvZGU+LlxuXHRcdFx0QHByb3BlcnR5IFtzcGlubmVySW1hZ2U9J3NwaW5uZXJEZWZhdWx0LnBuZyddIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIGltYWdlcyB0byB1c2UgZm9yIHRoZSB0aW1lIHNwaW5uZXIgLVxuXHRcdFx0XHRcdFx0c2V2ZW4gaW1hZ2VzIHBhY2tlZCBob3Jpem9udGFsbHkgZm9yIG5vcm1hbCwgZWFjaCBidXR0b24gcHJlc3NlZFxuXHRcdFx0XHRcdFx0KGNlbnRyZSwgcHJldmlvdXMsIG5leHQsIGluY3JlbWVudCwgZGVjcmVtZW50KSwgYW5kIGRpc2FibGVkLlxuXHRcdFx0QHByb3BlcnR5IFtzcGlubmVyU2l6ZT1bMjAsMjAsOF1dIHtudW1iZXJbXX0gVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNwaW5uZXIgaW1hZ2UsXG5cdFx0XHRcdFx0XHRhbmQgc2l6ZSBvZiBjZW50cmUgYnV0dG9uIGZvciBjdXJyZW50IHRpbWUuXG5cdFx0XHRAcHJvcGVydHkgW3NwaW5uZXJCaWdJbWFnZT0nJ10ge3N0cmluZ30gVGhlIFVSTCBvZiB0aGUgaW1hZ2VzIHRvIHVzZSBmb3IgdGhlIGV4cGFuZGVkIHRpbWUgc3Bpbm5lciAtXG5cdFx0XHRcdFx0XHRzZXZlbiBpbWFnZXMgcGFja2VkIGhvcml6b250YWxseSBmb3Igbm9ybWFsLCBlYWNoIGJ1dHRvbiBwcmVzc2VkXG5cdFx0XHRcdFx0XHQoY2VudHJlLCBwcmV2aW91cywgbmV4dCwgaW5jcmVtZW50LCBkZWNyZW1lbnQpLCBhbmQgZGlzYWJsZWQuXG5cdFx0XHRAcHJvcGVydHkgW3NwaW5uZXJCaWdTaXplPVs0MCw0MCwxNl1dIHtudW1iZXJbXX0gVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGV4cGFuZGVkIHNwaW5uZXIgaW1hZ2UsXG5cdFx0XHRcdFx0XHRhbmQgc2l6ZSBvZiBjZW50cmUgYnV0dG9uIGZvciBjdXJyZW50IHRpbWUuXG5cdFx0XHRAcHJvcGVydHkgW3NwaW5uZXJJbmNEZWNPbmx5PWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gZm9yIGluY3JlbWVudC9kZWNyZW1lbnQgYnV0dG9ucyBvbmx5LCA8Y29kZT5mYWxzZTwvY29kZT4gZm9yIGFsbC5cblx0XHRcdEBwcm9wZXJ0eSBbc3Bpbm5lclJlcGVhdD1bNTAwLDI1MF1dIHtudW1iZXJbXX0gSW5pdGlhbCBhbmQgc3Vic2VxdWVudCB3YWl0cyBpbiBtaWxsaXNlY29uZHNcblx0XHRcdFx0XHRcdGZvciByZXBlYXRzIG9uIHRoZSBzcGlubmVyIGJ1dHRvbnMuXG5cdFx0XHRAcHJvcGVydHkgW2JlZm9yZVNob3c9bnVsbF0ge2JlZm9yZVNob3dDYWxsYmFja30gRnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBpbnB1dCBmaWVsZCBhbmRcblx0XHRcdFx0XHRcdHJldHVybnMgYSBzZXQgb2YgY3VzdG9tIHNldHRpbmdzIGZvciB0aGUgdGltZSBlbnRyeS5cblx0XHRcdEBwcm9wZXJ0eSBbYmVmb3JlU2V0VGltZT1udWxsXSB7YmVmb3JlU2V0VGltZUNhbGxiYWNrfSBGdW5jdGlvbiB0aGF0IHJ1bnMgYmVmb3JlIHVwZGF0aW5nIHRoZSB0aW1lLFxuXHRcdFx0XHRcdFx0dGFrZXMgdGhlIG9sZCBhbmQgbmV3IHRpbWVzLCBhbmQgbWluaW11bSBhbmQgbWF4aW11bSB0aW1lcyBhcyBwYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdFx0YW5kIHJldHVybnMgYW4gYWRqdXN0ZWQgdGltZSBpZiBuZWNlc3NhcnkuXG5cdFx0XHRAZXhhbXBsZSB7ZGVmYXVsdFRpbWU6IG5ldyBEYXRlKDAsIDAsIDAsIDgsIDMwLCAwKSwgbWluVGltZTogLTMwMCwgbWF4VGltZTogJysySCArMzBNJ30gKi9cblx0XHRkZWZhdWx0T3B0aW9uczoge1xuXHRcdFx0YXBwZW5kVGV4dDogJycsXG5cdFx0XHRzaG93U2Vjb25kczogZmFsc2UsXG5cdFx0XHR1bmxpbWl0ZWRIb3VyczogZmFsc2UsXG5cdFx0XHR0aW1lU3RlcHM6IFsxLCAxLCAxXSxcblx0XHRcdGluaXRpYWxGaWVsZDogbnVsbCxcblx0XHRcdG5vU2VwYXJhdG9yRW50cnk6IGZhbHNlLFxuXHRcdFx0dGFiVG9FeGl0OiBmYWxzZSxcblx0XHRcdHVzZU1vdXNlV2hlZWw6IHRydWUsXG5cdFx0XHRkZWZhdWx0VGltZTogbnVsbCxcblx0XHRcdG1pblRpbWU6IG51bGwsXG5cdFx0XHRtYXhUaW1lOiBudWxsLFxuXHRcdFx0c3Bpbm5lckltYWdlOiAnc3Bpbm5lckRlZmF1bHQucG5nJyxcblx0XHRcdHNwaW5uZXJTaXplOiBbMjAsIDIwLCA4XSxcblx0XHRcdHNwaW5uZXJCaWdJbWFnZTogJycsXG5cdFx0XHRzcGlubmVyQmlnU2l6ZTogWzQwLCA0MCwgMTZdLFxuXHRcdFx0c3Bpbm5lckluY0RlY09ubHk6IGZhbHNlLFxuXHRcdFx0c3Bpbm5lclJlcGVhdDogWzUwMCwgMjUwXSxcblx0XHRcdGJlZm9yZVNob3c6IG51bGwsXG5cdFx0XHRiZWZvcmVTZXRUaW1lOiBudWxsXG5cdFx0fSxcblxuXHRcdC8qKiBMb2NhbGlzYXRpb25zIGZvciB0aGUgcGx1Z2luLlxuXHRcdFx0RW50cmllcyBhcmUgb2JqZWN0cyBpbmRleGVkIGJ5IHRoZSBsYW5ndWFnZSBjb2RlICgnJyBiZWluZyB0aGUgZGVmYXVsdCBVUy9FbmdsaXNoKS5cblx0XHRcdEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXG5cdFx0XHRAcHJvcGVydHkgW3Nob3cyNEhvdXJzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gdXNlIDI0IGhvdXIgdGltZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGZvciAxMiBob3VyIChBTS9QTSkuXG5cdFx0XHRAcHJvcGVydHkgW3NlcGFyYXRvcj0nOiddIHtzdHJpbmd9IFRoZSBzZXBhcmF0b3IgYmV0d2VlbiB0aW1lIGZpZWxkcy5cblx0XHRcdEBwcm9wZXJ0eSBbYW1wbVByZWZpeD0nJ10ge3N0cmluZ30gVGhlIHNlcGFyYXRvciBiZWZvcmUgdGhlIEFNL1BNIHRleHQuXG5cdFx0XHRAcHJvcGVydHkgW2FtcG1OYW1lcz1bJ0FNJywnUE0nXV0ge3N0cmluZ1tdfSBOYW1lcyBvZiBtb3JuaW5nL2V2ZW5pbmcgbWFya2Vycy5cblx0XHRcdEBwcm9wZXJ0eSBbc3Bpbm5lclRleHRzPVsnTm93JywnUHJldmlvdXMmbmJzcDtmaWVsZCcsJ05leHQmbmJzcDtmaWVsZCcsJ0luY3JlbWVudCcsJ0RlY3JlbWVudCddXSB7c3RyaW5nW119XG5cdFx0XHRcdFx0XHRUaGUgcG9wdXAgdGV4dHMgZm9yIHRoZSBzcGlubmVyIGltYWdlIGFyZWFzLiAqL1xuXHRcdHJlZ2lvbmFsT3B0aW9uczogeyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UvY291bnRyeSBjb2RlXG5cdFx0XHQnJzogeyAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzIC0gRW5nbGlzaC9VU1xuXHRcdFx0XHRzaG93MjRIb3VyczogZmFsc2UsXG5cdFx0XHRcdHNlcGFyYXRvcjogJzonLFxuXHRcdFx0XHRhbXBtUHJlZml4OiAnJyxcblx0XHRcdFx0YW1wbU5hbWVzOiBbJ0FNJywgJ1BNJ10sXG5cdFx0XHRcdHNwaW5uZXJUZXh0czogWydOb3cnLCAnUHJldmlvdXMgZmllbGQnLCAnTmV4dCBmaWVsZCcsICdJbmNyZW1lbnQnLCAnRGVjcmVtZW50J11cblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdF9nZXR0ZXJzOiBbJ2dldE9mZnNldCcsICdnZXRUaW1lJywgJ2lzRGlzYWJsZWQnXSxcblxuXHRcdF9hcHBlbmRDbGFzczogcGx1Z2luTmFtZSArICctYXBwZW5kJywgLy8gQ2xhc3MgbmFtZSBmb3IgdGhlIGFwcGVuZGVkIGNvbnRlbnRcblx0XHRfY29udHJvbENsYXNzOiBwbHVnaW5OYW1lICsgJy1jb250cm9sJywgLy8gQ2xhc3MgbmFtZSBmb3IgdGhlIGRhdGUgZW50cnkgY29udHJvbFxuXHRcdF9leHBhbmRDbGFzczogcGx1Z2luTmFtZSArICctZXhwYW5kJywgLy8gQ2xhc3MgbmFtZSBmb3IgdGhlIGV4cGFuZGVkIHNwaW5uZXJcblxuXHRcdF9kaXNhYmxlZElucHV0czogW10sIC8vIExpc3Qgb2YgdGltZSBpbnB1dHMgdGhhdCBoYXZlIGJlZW4gZGlzYWJsZWRcblxuXHRcdF9pbnN0U2V0dGluZ3M6IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB7X2ZpZWxkOiAwLCBfc2VsZWN0ZWRIb3VyOiAwLCBfc2VsZWN0ZWRNaW51dGU6IDAsIF9zZWxlY3RlZFNlY29uZDogMH07XG5cdFx0fSxcblx0XHRcblx0XHRfcG9zdEF0dGFjaDogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xuXHRcdFx0ZWxlbS5vbignZm9jdXMuJyArIGluc3QubmFtZSwgdGhpcy5fZG9Gb2N1cykuXG5cdFx0XHRcdG9uKCdibHVyLicgKyBpbnN0Lm5hbWUsIHRoaXMuX2RvQmx1cikuXG5cdFx0XHRcdG9uKCdjbGljay4nICsgaW5zdC5uYW1lLCB0aGlzLl9kb0NsaWNrKS5cblx0XHRcdFx0b24oJ2tleWRvd24uJyArIGluc3QubmFtZSwgdGhpcy5fZG9LZXlEb3duKS5cblx0XHRcdFx0b24oJ2tleXByZXNzLicgKyBpbnN0Lm5hbWUsIHRoaXMuX2RvS2V5UHJlc3MpLlxuXHRcdFx0XHRvbigncGFzdGUuJyArIGluc3QubmFtZSwgZnVuY3Rpb24oZXZlbnQpIHsgLy8gQ2hlY2sgcGFzdGVzXG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHsgcGx1Z2luLl9wYXJzZVRpbWUoaW5zdCk7IH0sIDEpO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X29wdGlvbnNDaGFuZ2VkOiBmdW5jdGlvbihlbGVtLCBpbnN0LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSB0aGlzLl9leHRyYWN0VGltZShpbnN0KTtcblx0XHRcdCQuZXh0ZW5kKGluc3Qub3B0aW9ucywgb3B0aW9ucyk7XG5cdFx0XHRpbnN0Lm9wdGlvbnMuc2hvdzI0SG91cnMgPSBpbnN0Lm9wdGlvbnMuc2hvdzI0SG91cnMgfHwgaW5zdC5vcHRpb25zLnVubGltaXRlZEhvdXJzO1xuXHRcdFx0aW5zdC5fZmllbGQgPSAwO1xuXHRcdFx0aWYgKGN1cnJlbnRUaW1lKSB7XG5cdFx0XHRcdHRoaXMuX3NldFRpbWUoaW5zdCwgbmV3IERhdGUoMCwgMCwgMCwgY3VycmVudFRpbWVbMF0sIGN1cnJlbnRUaW1lWzFdLCBjdXJyZW50VGltZVsyXSkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIHN0dWZmIGRlcGVuZGVudCBvbiBvbGQgc2V0dGluZ3Ncblx0XHRcdGVsZW0ubmV4dCgnc3Bhbi4nICsgdGhpcy5fYXBwZW5kQ2xhc3MpLnJlbW92ZSgpO1xuXHRcdFx0ZWxlbS5wYXJlbnQoKS5maW5kKCdzcGFuLicgKyB0aGlzLl9jb250cm9sQ2xhc3MpLnJlbW92ZSgpO1xuXHRcdFx0aWYgKCQuZm4ubW91c2V3aGVlbCkge1xuXHRcdFx0XHRlbGVtLnVubW91c2V3aGVlbCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQW5kIHJlLWFkZCBpZiByZXF1ZXN0ZWRcblx0XHRcdHZhciBzcGlubmVyID0gKCFpbnN0Lm9wdGlvbnMuc3Bpbm5lckltYWdlID8gbnVsbCA6XG5cdFx0XHRcdCQoJzxzcGFuIGNsYXNzPVwiJyArIHRoaXMuX2NvbnRyb2xDbGFzcyArICdcIiBzdHlsZT1cImRpc3BsYXk6IGlubGluZS1ibG9jazsgJyArXG5cdFx0XHRcdCdiYWNrZ3JvdW5kOiB1cmwoXFwnJyArIGluc3Qub3B0aW9ucy5zcGlubmVySW1hZ2UgKyAnXFwnKSAwIDAgbm8tcmVwZWF0OyB3aWR0aDogJyArIFxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuc3Bpbm5lclNpemVbMF0gKyAncHg7IGhlaWdodDogJyArIGluc3Qub3B0aW9ucy5zcGlubmVyU2l6ZVsxXSArICdweDtcIj48L3NwYW4+JykpO1xuXHRcdFx0ZWxlbS5hZnRlcihpbnN0Lm9wdGlvbnMuYXBwZW5kVGV4dCA/ICc8c3BhbiBjbGFzcz1cIicgKyB0aGlzLl9hcHBlbmRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0aW5zdC5vcHRpb25zLmFwcGVuZFRleHQgKyAnPC9zcGFuPicgOiAnJykuYWZ0ZXIoc3Bpbm5lciB8fCAnJyk7XG5cdFx0XHQvLyBBbGxvdyBtb3VzZSB3aGVlbCB1c2FnZVxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy51c2VNb3VzZVdoZWVsICYmICQuZm4ubW91c2V3aGVlbCkge1xuXHRcdFx0XHRlbGVtLm1vdXNld2hlZWwodGhpcy5fZG9Nb3VzZVdoZWVsKTtcblx0XHRcdH1cblx0XHRcdGlmIChzcGlubmVyKSB7XG5cdFx0XHRcdHNwaW5uZXIubW91c2Vkb3duKHRoaXMuX2hhbmRsZVNwaW5uZXIpLm1vdXNldXAodGhpcy5fZW5kU3Bpbm5lcikuXG5cdFx0XHRcdFx0bW91c2VvdmVyKHRoaXMuX2V4cGFuZFNwaW5uZXIpLm1vdXNlb3V0KHRoaXMuX2VuZFNwaW5uZXIpLlxuXHRcdFx0XHRcdG1vdXNlbW92ZSh0aGlzLl9kZXNjcmliZVNwaW5uZXIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogRW5hYmxlIGEgdGltZSBlbnRyeSBpbnB1dCBhbmQgYW55IGFzc29jaWF0ZWQgc3Bpbm5lci5cblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgc2luZ2xlIGlucHV0IGZpZWxkLlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikudGltZUVudHJ5KCdlbmFibGUnKSAqL1xuXHRcdGVuYWJsZTogZnVuY3Rpb24oZWxlbSkge1xuXHRcdFx0dGhpcy5fZW5hYmxlRGlzYWJsZShlbGVtLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdC8qKiBEaXNhYmxlIGEgdGltZSBlbnRyeSBpbnB1dCBhbmQgYW55IGFzc29jaWF0ZWQgc3Bpbm5lci5cblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgc2luZ2xlIGlucHV0IGZpZWxkLlxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikudGltZUVudHJ5KCdkaXNhYmxlJykgKi9cblx0XHRkaXNhYmxlOiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHR0aGlzLl9lbmFibGVEaXNhYmxlKGVsZW0sIHRydWUpO1xuXHRcdH0sXG5cblx0XHQvKiogRW5hYmxlIG9yIGRpc2FibGUgYSB0aW1lIGVudHJ5IGlucHV0IGFuZCBhbnkgYXNzb2NpYXRlZCBzcGlubmVyLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgc2luZ2xlIGlucHV0IGZpZWxkLlxuXHRcdFx0QHBhcmFtIGRpc2FibGUge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGRpc2FibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBlbmFibGUuICovXG5cdFx0X2VuYWJsZURpc2FibGU6IGZ1bmN0aW9uKGVsZW0sIGRpc2FibGUpIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdGlmICghaW5zdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbGVtLmRpc2FibGVkID0gZGlzYWJsZTtcblx0XHRcdGlmIChlbGVtLm5leHRTaWJsaW5nICYmIGVsZW0ubmV4dFNpYmxpbmcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NwYW4nKSB7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZVNwaW5uZXIoaW5zdCwgZWxlbS5uZXh0U2libGluZywgKGRpc2FibGUgPyA1IDogLTEpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAodGhpcy5fZGlzYWJsZWRJbnB1dHMsXG5cdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IGVsZW0gPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gRGVsZXRlIGVudHJ5XG5cdFx0XHRpZiAoZGlzYWJsZSkge1xuXHRcdFx0XHR0aGlzLl9kaXNhYmxlZElucHV0cy5wdXNoKGVsZW0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogQ2hlY2sgd2hldGhlciBhbiBpbnB1dCBmaWVsZCBoYXMgYmVlbiBkaXNhYmxlZC5cblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgaW5wdXQgZmllbGQgdG8gY2hlY2suXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGlzIGZpZWxkIGhhcyBiZWVuIGRpc2FibGVkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgaXQgaXMgZW5hYmxlZC5cblx0XHRcdEBleGFtcGxlIGlmICgkKHNlbGVjdG9yKS5kYXRlRW50cnkoJ2lzRGlzYWJsZWQnKSkgey4uLn0gKi9cblx0XHRpc0Rpc2FibGVkOiBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRyZXR1cm4gJC5pbkFycmF5KGVsZW0sIHRoaXMuX2Rpc2FibGVkSW5wdXRzKSA+IC0xO1xuXHRcdH0sXG5cblx0XHRfcHJlRGVzdHJveTogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xuXHRcdFx0ZWxlbSA9ICQoZWxlbSkub2ZmKCcuJyArIHBsdWdpbk5hbWUpO1xuXHRcdFx0aWYgKCQuZm4ubW91c2V3aGVlbCkge1xuXHRcdFx0XHRlbGVtLnVubW91c2V3aGVlbCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PT0gZWxlbVswXSA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBEZWxldGUgZW50cnlcblx0XHRcdGVsZW0uc2libGluZ3MoJy4nICsgdGhpcy5fYXBwZW5kQ2xhc3MgKyAnLC4nICsgdGhpcy5fY29udHJvbENsYXNzKS5yZW1vdmUoKTtcblx0XHR9LFxuXG5cdFx0LyoqIEluaXRpYWxpc2UgdGhlIGN1cnJlbnQgdGltZSBmb3IgYSB0aW1lIGVudHJ5IGlucHV0IGZpZWxkLlxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBpbnB1dCBmaWVsZCB0byB1cGRhdGUuXG5cdFx0XHRAcGFyYW0gdGltZSB7RGF0ZXxudW1iZXJ8c3RyaW5nfSBUaGUgbmV3IHRpbWUgb3Igb2Zmc2V0IG9yIDxjb2RlPm51bGw8L2NvZGU+IHRvIGNsZWFyLlxuXHRcdFx0XHRcdEFuIGFjdHVhbCB0aW1lIG9yIG9mZnNldCBpbiBzZWNvbmRzIGZyb20gbm93IG9yIHVuaXRzIGFuZCBwZXJpb2RzIG9mIG9mZnNldHMgZnJvbSBub3cuXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS50aW1lRW50cnkoJ3NldFRpbWUnLCBuZXcgRGF0ZSgwLCAwLCAwLCAxMSwgMjIsIDMzKSlcbiAkKHNlbGVjdG9yKS50aW1lRW50cnkoJ3NldFRpbWUnLCArMzAwKVxuICQoc2VsZWN0b3IpLnRpbWVFbnRyeSgnc2V0VGltZScsICcrMUggKzMwTScpXG4gJChzZWxlY3RvcikudGltZUVudHJ5KCdzZXRUaW1lJywgbnVsbCkgKi9cblx0XHRzZXRUaW1lOiBmdW5jdGlvbihlbGVtLCB0aW1lKSB7XG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XG5cdFx0XHRpZiAoaW5zdCkge1xuXHRcdFx0XHRpZiAodGltZSA9PT0gbnVsbCB8fCB0aW1lID09PSAnJykge1xuXHRcdFx0XHRcdCQoZWxlbSkudmFsKCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIHRpbWUgPyAoJC5pc0FycmF5KHRpbWUpID8gdGltZSA6XG5cdFx0XHRcdFx0XHQodHlwZW9mIHRpbWUgPT09ICdvYmplY3QnID8gbmV3IERhdGUodGltZS5nZXRUaW1lKCkpIDogdGltZSkpIDogbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBjdXJyZW50IHRpbWUgZm9yIGEgdGltZSBlbnRyeSBpbnB1dCBmaWVsZC5cblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgaW5wdXQgZmllbGQgdG8gdXBkYXRlLlxuXHRcdFx0QHJldHVybiB7RGF0ZX0gVGhlIGN1cnJlbnQgdGltZSBvciA8Y29kZT5udWxsPC9jb2RlPiBpZiBub25lLlxuXHRcdFx0QGV4YW1wbGUgdmFyIHRpbWUgPSAkKHNlbGVjdG9yKS50aW1lRW50cnkoJ2dldFRpbWUnKSAqL1xuXHRcdGdldFRpbWU6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdHZhciBjdXJyZW50VGltZSA9IChpbnN0ID8gdGhpcy5fZXh0cmFjdFRpbWUoaW5zdCkgOiBudWxsKTtcblx0XHRcdHJldHVybiAoIWN1cnJlbnRUaW1lID8gbnVsbCA6XG5cdFx0XHRcdG5ldyBEYXRlKDAsIDAsIDAsIGN1cnJlbnRUaW1lWzBdLCBjdXJyZW50VGltZVsxXSwgY3VycmVudFRpbWVbMl0pKTtcblx0XHR9LFxuXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBtaWxsaXNlY29uZCBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IHRpbWUuXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGlucHV0IGZpZWxkIHRvIGV4YW1pbmUuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSB0aW1lIGFzIG1pbGxpc2Vjb25kcyBvZmZzZXQgb3IgemVybyBpZiBub25lLlxuXHRcdFx0QGV4YW1wbGUgdmFyIG9mZnNldCA9ICQoc2VsZWN0b3IpLnRpbWVFbnRyeSgnZ2V0T2Zmc2V0JykgKi9cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcblx0XHRcdHZhciBjdXJyZW50VGltZSA9IChpbnN0ID8gdGhpcy5fZXh0cmFjdFRpbWUoaW5zdCkgOiBudWxsKTtcblx0XHRcdHJldHVybiAoIWN1cnJlbnRUaW1lID8gMCA6XG5cdFx0XHRcdChjdXJyZW50VGltZVswXSAqIDM2MDAgKyBjdXJyZW50VGltZVsxXSAqIDYwICsgY3VycmVudFRpbWVbMl0pICogMTAwMCk7XG5cdFx0fSxcblxuXHRcdC8qKiBJbml0aWFsaXNlIGRhdGUgZW50cnkuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR8RXZlbnR9IFRoZSBpbnB1dCBmaWVsZCBvciB0aGUgZm9jdXMgZXZlbnQuICovXG5cdFx0X2RvRm9jdXM6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHRcdHZhciBpbnB1dCA9IChlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyA/IGVsZW0gOiB0aGlzKTtcblx0XHRcdGlmIChwbHVnaW4uX2xhc3RJbnB1dCA9PT0gaW5wdXQgfHwgcGx1Z2luLmlzRGlzYWJsZWQoaW5wdXQpKSB7XG5cdFx0XHRcdHBsdWdpbi5fZm9jdXNzZWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoaW5wdXQpO1xuXHRcdFx0cGx1Z2luLl9mb2N1c3NlZCA9IHRydWU7XG5cdFx0XHRwbHVnaW4uX2xhc3RJbnB1dCA9IGlucHV0O1xuXHRcdFx0cGx1Z2luLl9ibHVycmVkSW5wdXQgPSBudWxsO1xuXHRcdFx0JC5leHRlbmQoaW5zdC5vcHRpb25zLCAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5iZWZvcmVTaG93KSA/XG5cdFx0XHRcdGluc3Qub3B0aW9ucy5iZWZvcmVTaG93LmFwcGx5KGlucHV0LCBbaW5wdXRdKSA6IHt9KSk7XG5cdFx0XHRcdHBsdWdpbi5fcGFyc2VUaW1lKGluc3QsIGVsZW0ubm9kZU5hbWUgPyBudWxsIDogZWxlbSk7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBwbHVnaW4uX3Nob3dGaWVsZChpbnN0KTsgfSwgMTApO1xuXHRcdH0sXG5cblx0XHQvKiogTm90ZSB0aGF0IHRoZSBmaWVsZCBoYXMgYmVlbiBleGl0ZWQuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIGJsdXIgZXZlbnQuICovXG5cdFx0X2RvQmx1cjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHBsdWdpbi5fYmx1cnJlZElucHV0ID0gcGx1Z2luLl9sYXN0SW5wdXQ7XG5cdFx0XHRwbHVnaW4uX2xhc3RJbnB1dCA9IG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKiBTZWxlY3QgYXBwcm9wcmlhdGUgZmllbGQgcG9ydGlvbiBvbiBjbGljaywgaWYgYWxyZWFkeSBpbiB0aGUgZmllbGQuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIGNsaWNrIGV2ZW50LiAqL1xuXHRcdF9kb0NsaWNrOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGlucHV0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoaW5wdXQpO1xuXHRcdFx0dmFyIHByZXZGaWVsZCA9IGluc3QuX2ZpZWxkO1xuXHRcdFx0aWYgKCFwbHVnaW4uX2ZvY3Vzc2VkKSB7XG5cdFx0XHRcdGluc3QuX2ZpZWxkID0gcGx1Z2luLl9nZXRTZWxlY3Rpb24oaW5zdCwgaW5wdXQsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdGlmIChwcmV2RmllbGQgIT09IGluc3QuX2ZpZWxkKSB7XG5cdFx0XHRcdGluc3QuX2xhc3RDaHIgPSAnJztcblx0XHRcdH1cblx0XHRcdHBsdWdpbi5fc2hvd0ZpZWxkKGluc3QpO1xuXHRcdFx0cGx1Z2luLl9mb2N1c3NlZCA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvKiogRmluZCB0aGUgc2VsZWN0ZWQgc3ViZmllbGQgd2l0aGluIHRoZSBjb250cm9sLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIGlucHV0IHtFbGVtZW50fSBUaGUgaW5wdXQgY29udHJvbC5cblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSB0cmlnZ2VyaW5nIGV2ZW50LlxuXHRcdFx0QHJldHVybiB7bnVtYmVyfSBUaGUgc2VsZWN0ZWQgc3ViZmllbGQuICovXG5cdFx0X2dldFNlbGVjdGlvbjogZnVuY3Rpb24oaW5zdCwgaW5wdXQsIGV2ZW50KSB7XG5cdFx0XHR2YXIgc2VsZWN0ID0gMDtcblx0XHRcdHZhciBmaWVsZFNpemVzID0gW2luc3QuZWxlbS52YWwoKS5zcGxpdChpbnN0Lm9wdGlvbnMuc2VwYXJhdG9yKVswXS5sZW5ndGgsIDIsIDJdO1xuXHRcdFx0aWYgKGlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSBudWxsKSB7IC8vIFVzZSBpbnB1dCBzZWxlY3QgcmFuZ2Vcblx0XHRcdFx0dmFyIGVuZCA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGZpZWxkID0gMDsgZmllbGQgPD0gTWF0aC5tYXgoMSwgaW5zdC5fc2Vjb25kRmllbGQsIGluc3QuX2FtcG1GaWVsZCk7IGZpZWxkKyspIHtcblx0XHRcdFx0XHRlbmQgKz0gKGZpZWxkICE9PSBpbnN0Ll9hbXBtRmllbGQgPyBmaWVsZFNpemVzW2ZpZWxkXSArIGluc3Qub3B0aW9ucy5zZXBhcmF0b3IubGVuZ3RoIDpcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5hbXBtUHJlZml4Lmxlbmd0aCArIGluc3Qub3B0aW9ucy5hbXBtTmFtZXNbMF0ubGVuZ3RoKTtcblx0XHRcdFx0XHRzZWxlY3QgPSBmaWVsZDtcblx0XHRcdFx0XHRpZiAoaW5wdXQuc2VsZWN0aW9uU3RhcnQgPCBlbmQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaW5wdXQuY3JlYXRlVGV4dFJhbmdlICYmIGV2ZW50ICE9IG51bGwpIHsgLy8gQ2hlY2sgYWdhaW5zdCBib3VuZGluZyBib3hlc1xuXHRcdFx0XHR2YXIgc3JjID0gJChldmVudC5zcmNFbGVtZW50KTtcblx0XHRcdFx0dmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG5cdFx0XHRcdHZhciBjb252ZXJ0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRyZXR1cm4ge3RoaW46IDIsIG1lZGl1bTogNCwgdGhpY2s6IDZ9W3ZhbHVlXSB8fCB2YWx1ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dmFyIG9mZnNldFggPSBldmVudC5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgLVxuXHRcdFx0XHRcdChzcmMub2Zmc2V0KCkubGVmdCArIHBhcnNlSW50KGNvbnZlcnQoc3JjLmNzcygnYm9yZGVyLWxlZnQtd2lkdGgnKSksIDEwKSkgLVxuXHRcdFx0XHRcdHJhbmdlLm9mZnNldExlZnQ7IC8vIFBvc2l0aW9uIC0gbGVmdCBlZGdlIC0gYWxpZ25tZW50XG5cdFx0XHRcdGZvciAodmFyIGZpZWxkID0gMDsgZmllbGQgPD0gTWF0aC5tYXgoMSwgaW5zdC5fc2Vjb25kRmllbGQsIGluc3QuX2FtcG1GaWVsZCk7IGZpZWxkKyspIHtcblx0XHRcdFx0XHR2YXIgZW5kID0gKGZpZWxkICE9PSBpbnN0Ll9hbXBtRmllbGQgPyAoZmllbGQgKiBmaWVsZFNpemUpICsgMiA6XG5cdFx0XHRcdFx0XHQoaW5zdC5fYW1wbUZpZWxkICogZmllbGRTaXplKSArIGluc3Qub3B0aW9ucy5hbXBtUHJlZml4Lmxlbmd0aCArXG5cdFx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMuYW1wbU5hbWVzWzBdLmxlbmd0aCk7XG5cdFx0XHRcdFx0cmFuZ2UuY29sbGFwc2UoKTtcblx0XHRcdFx0XHRyYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xuXHRcdFx0XHRcdHNlbGVjdCA9IGZpZWxkO1xuXHRcdFx0XHRcdGlmIChvZmZzZXRYIDwgcmFuZ2UuYm91bmRpbmdXaWR0aCkgeyAvLyBBbmQgY29tcGFyZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VsZWN0O1xuXHRcdH0sXG5cblx0XHQvKiogSGFuZGxlIGtleXN0cm9rZXMgaW4gdGhlIGZpZWxkLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBrZXlkb3duIGV2ZW50LlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY29udGludWUsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBzdG9wIHByb2Nlc3NpbmcuICovXG5cdFx0X2RvS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChldmVudC5rZXlDb2RlID49IDQ4KSB7IC8vID49ICcwJ1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGV2ZW50LnRhcmdldCk7XG5cdFx0XHRzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcblx0XHRcdFx0Y2FzZSA5OiByZXR1cm4gKGluc3Qub3B0aW9ucy50YWJUb0V4aXQgPyB0cnVlIDogKGV2ZW50LnNoaWZ0S2V5ID9cblx0XHRcdFx0XHRcdFx0Ly8gTW92ZSB0byBwcmV2aW91cyB0aW1lIGZpZWxkLCBvciBvdXQgaWYgYXQgdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRcdFx0XHRwbHVnaW4uX2NoYW5nZUZpZWxkKGluc3QsIC0xLCB0cnVlKSA6XG5cdFx0XHRcdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCB0aW1lIGZpZWxkLCBvciBvdXQgaWYgYXQgdGhlIGVuZFxuXHRcdFx0XHRcdFx0XHRwbHVnaW4uX2NoYW5nZUZpZWxkKGluc3QsICsxLCB0cnVlKSkpO1xuXHRcdFx0XHRjYXNlIDM1OiBpZiAoZXZlbnQuY3RybEtleSkgeyAvLyBDbGVhciB0aW1lIG9uIGN0cmwrZW5kXG5cdFx0XHRcdFx0XHRcdHBsdWdpbi5fc2V0VmFsdWUoaW5zdCwgJycpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7IC8vIExhc3QgZmllbGQgb24gZW5kXG5cdFx0XHRcdFx0XHRcdGluc3QuX2ZpZWxkID0gTWF0aC5tYXgoMSwgaW5zdC5fc2Vjb25kRmllbGQsIGluc3QuX2FtcG1GaWVsZCk7XG5cdFx0XHRcdFx0XHRcdHBsdWdpbi5fYWRqdXN0RmllbGQoaW5zdCwgMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzNjogaWYgKGV2ZW50LmN0cmxLZXkpIHsgLy8gQ3VycmVudCB0aW1lIG9uIGN0cmwraG9tZVxuXHRcdFx0XHRcdFx0XHRwbHVnaW4uX3NldFRpbWUoaW5zdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHsgLy8gRmlyc3QgZmllbGQgb24gaG9tZVxuXHRcdFx0XHRcdFx0XHRpbnN0Ll9maWVsZCA9IDA7XG5cdFx0XHRcdFx0XHRcdHBsdWdpbi5fYWRqdXN0RmllbGQoaW5zdCwgMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzNzogcGx1Z2luLl9jaGFuZ2VGaWVsZChpbnN0LCAtMSwgZmFsc2UpOyBicmVhazsgLy8gUHJldmlvdXMgZmllbGQgb24gbGVmdFxuXHRcdFx0XHRjYXNlIDM4OiBwbHVnaW4uX2FkanVzdEZpZWxkKGluc3QsICsxKTsgYnJlYWs7IC8vIEluY3JlbWVudCB0aW1lIGZpZWxkIG9uIHVwXG5cdFx0XHRcdGNhc2UgMzk6IHBsdWdpbi5fY2hhbmdlRmllbGQoaW5zdCwgKzEsIGZhbHNlKTsgYnJlYWs7IC8vIE5leHQgZmllbGQgb24gcmlnaHRcblx0XHRcdFx0Y2FzZSA0MDogcGx1Z2luLl9hZGp1c3RGaWVsZChpbnN0LCAtMSk7IGJyZWFrOyAvLyBEZWNyZW1lbnQgdGltZSBmaWVsZCBvbiBkb3duXG5cdFx0XHRcdGNhc2UgNDY6IHBsdWdpbi5fc2V0VmFsdWUoaW5zdCwgJycpOyBicmVhazsgLy8gQ2xlYXIgdGltZSBvbiBkZWxldGVcblx0XHRcdFx0Y2FzZSA4OiBpbnN0Ll9sYXN0Q2hyID0gJyc7IC8vIEZhbGwgdGhyb3VnaFxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqIERpc2FsbG93IHVud2FudGVkIGNoYXJhY3RlcnMuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIGtleXByZXNzIGV2ZW50LlxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY29udGludWUsIDxjb2RlPmZhbHNlPC9jb2RlPiB0byBzdG9wIHByb2Nlc3NpbmcuICovXG5cdFx0X2RvS2V5UHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PT0gdW5kZWZpbmVkID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcblx0XHRcdGlmIChjaHIgPCAnICcpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xuXHRcdFx0cGx1Z2luLl9oYW5kbGVLZXlQcmVzcyhpbnN0LCBjaHIpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvKiogVXBkYXRlIGRhdGUgYmFzZWQgb24ga2V5c3Ryb2tlIGVudGVyZWQuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIGNociB7c3RyaW5nfSBUaGUgbmV3IGNoYXJhY3Rlci4gKi9cblx0XHRfaGFuZGxlS2V5UHJlc3M6IGZ1bmN0aW9uKGluc3QsIGNocikge1xuXHRcdFx0aWYgKGNociA9PT0gaW5zdC5vcHRpb25zLnNlcGFyYXRvcikge1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VGaWVsZChpbnN0LCArMSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoY2hyID49ICcwJyAmJiBjaHIgPD0gJzknKSB7IC8vIEFsbG93IGRpcmVjdCBlbnRyeSBvZiBkYXRlXG5cdFx0XHRcdHZhciBrZXkgPSBwYXJzZUludChjaHIsIDEwKTtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQoaW5zdC5fbGFzdENociArIGNociwgMTApO1xuXHRcdFx0XHR2YXIgaG91ciA9IChpbnN0Ll9maWVsZCAhPT0gMCA/IGluc3QuX3NlbGVjdGVkSG91ciA6XG5cdFx0XHRcdFx0KGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3VycyA/IHZhbHVlIDpcblx0XHRcdFx0XHQoaW5zdC5vcHRpb25zLnNob3cyNEhvdXJzID8gKHZhbHVlIDwgMjQgPyB2YWx1ZSA6IGtleSkgOlxuXHRcdFx0XHRcdCh2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDEyID8gdmFsdWUgOlxuXHRcdFx0XHRcdChrZXkgPiAwID8ga2V5IDogaW5zdC5fc2VsZWN0ZWRIb3VyKSkgJSAxMiArXG5cdFx0XHRcdFx0KGluc3QuX3NlbGVjdGVkSG91ciA+PSAxMiA/IDEyIDogMCkpKSk7XG5cdFx0XHRcdHZhciBtaW51dGUgPSAoaW5zdC5fZmllbGQgIT09IDEgPyBpbnN0Ll9zZWxlY3RlZE1pbnV0ZSA6XG5cdFx0XHRcdFx0KHZhbHVlIDwgNjAgPyB2YWx1ZSA6IGtleSkpO1xuXHRcdFx0XHR2YXIgc2Vjb25kID0gKGluc3QuX2ZpZWxkICE9PSBpbnN0Ll9zZWNvbmRGaWVsZCA/IGluc3QuX3NlbGVjdGVkU2Vjb25kIDpcblx0XHRcdFx0XHQodmFsdWUgPCA2MCA/IHZhbHVlIDoga2V5KSk7XG5cdFx0XHRcdHZhciBmaWVsZHMgPSB0aGlzLl9jb25zdHJhaW5UaW1lKGluc3QsIFtob3VyLCBtaW51dGUsIHNlY29uZF0pO1xuXHRcdFx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIChpbnN0Lm9wdGlvbnMudW5saW1pdGVkSG91cnMgPyBmaWVsZHMgOlxuXHRcdFx0XHRcdG5ldyBEYXRlKDAsIDAsIDAsIGZpZWxkc1swXSwgZmllbGRzWzFdLCBmaWVsZHNbMl0pKSk7XG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMubm9TZXBhcmF0b3JFbnRyeSAmJiBpbnN0Ll9sYXN0Q2hyKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlRmllbGQoaW5zdCwgKzEsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpbnN0Ll9sYXN0Q2hyID0gKGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3VycyAmJiBpbnN0Ll9maWVsZCA9PT0gMCA/IGluc3QuX2xhc3RDaHIgKyBjaHIgOiBjaHIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICghaW5zdC5vcHRpb25zLnNob3cyNEhvdXJzKSB7IC8vIFNldCBhbS9wbSBiYXNlZCBvbiBmaXJzdCBjaGFyIG9mIG5hbWVzXG5cdFx0XHRcdGNociA9IGNoci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZiAoKGNociA9PT0gaW5zdC5vcHRpb25zLmFtcG1OYW1lc1swXS5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSAmJlxuXHRcdFx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRIb3VyID49IDEyKSB8fFxuXHRcdFx0XHRcdFx0KGNociA9PT0gaW5zdC5vcHRpb25zLmFtcG1OYW1lc1sxXS5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSAmJlxuXHRcdFx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRIb3VyIDwgMTIpKSB7XG5cdFx0XHRcdFx0dmFyIHNhdmVGaWVsZCA9IGluc3QuX2ZpZWxkO1xuXHRcdFx0XHRcdGluc3QuX2ZpZWxkID0gaW5zdC5fYW1wbUZpZWxkO1xuXHRcdFx0XHRcdHRoaXMuX2FkanVzdEZpZWxkKGluc3QsICsxKTtcblx0XHRcdFx0XHRpbnN0Ll9maWVsZCA9IHNhdmVGaWVsZDtcblx0XHRcdFx0XHR0aGlzLl9zaG93RmllbGQoaW5zdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEluY3JlbWVudC9kZWNyZW1lbnQgb24gbW91c2Ugd2hlZWwgYWN0aXZpdHkuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIG1vdXNlIHdoZWVsIGV2ZW50LlxuXHRcdFx0QHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgY2hhbmdlLiAqL1xuXHRcdF9kb01vdXNlV2hlZWw6IGZ1bmN0aW9uKGV2ZW50LCBkZWx0YSkge1xuXHRcdFx0aWYgKHBsdWdpbi5pc0Rpc2FibGVkKGV2ZW50LnRhcmdldCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblx0XHRcdGluc3QuZWxlbS5mb2N1cygpO1xuXHRcdFx0aWYgKCFpbnN0LmVsZW0udmFsKCkpIHtcblx0XHRcdFx0cGx1Z2luLl9wYXJzZVRpbWUoaW5zdCk7XG5cdFx0XHR9XG5cdFx0XHRwbHVnaW4uX2FkanVzdEZpZWxkKGluc3QsIGRlbHRhKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fSxcblxuXHRcdC8qKiBFeHBhbmQgdGhlIHNwaW5uZXIsIGlmIHBvc3NpYmxlLCB0byBtYWtlIGl0IGVhc2llciB0byB1c2UuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIG1vdXNlIG92ZXIgZXZlbnQuICovXG5cdFx0X2V4cGFuZFNwaW5uZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgc3Bpbm5lciA9IHBsdWdpbi5fZ2V0U3Bpbm5lclRhcmdldChldmVudCk7XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChwbHVnaW4uX2dldElucHV0KHNwaW5uZXIpKTtcblx0XHRcdGlmIChwbHVnaW4uaXNEaXNhYmxlZChpbnN0LmVsZW1bMF0pKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuc3Bpbm5lckJpZ0ltYWdlKSB7XG5cdFx0XHRcdGluc3QuX2V4cGFuZGVkID0gdHJ1ZTtcblx0XHRcdFx0dmFyIG9mZnNldCA9ICQoc3Bpbm5lcikub2Zmc2V0KCk7XG5cdFx0XHRcdHZhciByZWxhdGl2ZSA9IG51bGw7XG5cdFx0XHRcdCQoc3Bpbm5lcikucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHBhcmVudCA9ICQodGhpcyk7XG5cdFx0XHRcdFx0aWYgKHBhcmVudC5jc3MoJ3Bvc2l0aW9uJykgPT09ICdyZWxhdGl2ZScgfHwgcGFyZW50LmNzcygncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJykge1xuXHRcdFx0XHRcdFx0cmVsYXRpdmUgPSBwYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAhcmVsYXRpdmU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQkKCc8ZGl2IGNsYXNzPVwiJyArIHBsdWdpbi5fZXhwYW5kQ2xhc3MgKyAnXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6ICcgK1xuXHRcdFx0XHRcdChvZmZzZXQubGVmdCAtIChpbnN0Lm9wdGlvbnMuc3Bpbm5lckJpZ1NpemVbMF0gLSBpbnN0Lm9wdGlvbnMuc3Bpbm5lclNpemVbMF0pIC8gMiAtXG5cdFx0XHRcdFx0KHJlbGF0aXZlID8gcmVsYXRpdmUubGVmdCA6IDApKSArICdweDsgdG9wOiAnICtcblx0XHRcdFx0XHQob2Zmc2V0LnRvcCAtIChpbnN0Lm9wdGlvbnMuc3Bpbm5lckJpZ1NpemVbMV0gLSBpbnN0Lm9wdGlvbnMuc3Bpbm5lclNpemVbMV0pIC8gMiAtXG5cdFx0XHRcdFx0KHJlbGF0aXZlID8gcmVsYXRpdmUudG9wIDogMCkpICsgJ3B4OyB3aWR0aDogJyArXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnNwaW5uZXJCaWdTaXplWzBdICsgJ3B4OyBoZWlnaHQ6ICcgK1xuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5zcGlubmVyQmlnU2l6ZVsxXSArICdweDsgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgdXJsKCcgK1xuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5zcGlubmVyQmlnSW1hZ2UgKyAnKSBuby1yZXBlYXQgMHB4IDBweDsgei1pbmRleDogMTA7XCI+PC9kaXY+JykuXG5cdFx0XHRcdFx0bW91c2Vkb3duKHBsdWdpbi5faGFuZGxlU3Bpbm5lcikubW91c2V1cChwbHVnaW4uX2VuZFNwaW5uZXIpLlxuXHRcdFx0XHRcdG1vdXNlb3V0KHBsdWdpbi5fZW5kRXhwYW5kKS5tb3VzZW1vdmUocGx1Z2luLl9kZXNjcmliZVNwaW5uZXIpLlxuXHRcdFx0XHRcdGluc2VydEFmdGVyKHNwaW5uZXIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogTG9jYXRlIHRoZSBhY3R1YWwgaW5wdXQgZmllbGQgZnJvbSB0aGUgc3Bpbm5lci5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gc3Bpbm5lciB7RWxlbWVudH0gVGhlIGN1cnJlbnQgc3Bpbm5lci5cblx0XHRcdEByZXR1cm4ge0VsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIGlucHV0LiAqL1xuXHRcdF9nZXRJbnB1dDogZnVuY3Rpb24oc3Bpbm5lcikge1xuXHRcdFx0cmV0dXJuICQoc3Bpbm5lcikuc2libGluZ3MoJy4nICsgdGhpcy5fZ2V0TWFya2VyKCkpWzBdO1xuXHRcdH0sXG5cblx0XHQvKiogQ2hhbmdlIHRoZSB0aXRsZSBiYXNlZCBvbiBwb3NpdGlvbiB3aXRoaW4gdGhlIHNwaW5uZXIuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIG1vdXNlIG1vdmUgZXZlbnQuICovXG5cdFx0X2Rlc2NyaWJlU3Bpbm5lcjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBzcGlubmVyID0gcGx1Z2luLl9nZXRTcGlubmVyVGFyZ2V0KGV2ZW50KTtcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KHBsdWdpbi5fZ2V0SW5wdXQoc3Bpbm5lcikpO1xuXHRcdFx0c3Bpbm5lci50aXRsZSA9IGluc3Qub3B0aW9ucy5zcGlubmVyVGV4dHNbcGx1Z2luLl9nZXRTcGlubmVyUmVnaW9uKGluc3QsIGV2ZW50KV07XG5cdFx0fSxcblxuXHRcdC8qKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgc3Bpbm5lci5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgbW91c2UgY2xpY2sgZXZlbnQuICovXG5cdFx0X2hhbmRsZVNwaW5uZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgc3Bpbm5lciA9IHBsdWdpbi5fZ2V0U3Bpbm5lclRhcmdldChldmVudCk7XG5cdFx0XHR2YXIgaW5wdXQgPSBwbHVnaW4uX2dldElucHV0KHNwaW5uZXIpO1xuXHRcdFx0aWYgKHBsdWdpbi5pc0Rpc2FibGVkKGlucHV0KSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5wdXQgPT09IHBsdWdpbi5fYmx1cnJlZElucHV0KSB7XG5cdFx0XHRcdHBsdWdpbi5fbGFzdElucHV0ID0gaW5wdXQ7XG5cdFx0XHRcdHBsdWdpbi5fYmx1cnJlZElucHV0ID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGlucHV0KTtcblx0XHRcdHBsdWdpbi5fZG9Gb2N1cyhpbnB1dCk7XG5cdFx0XHR2YXIgcmVnaW9uID0gcGx1Z2luLl9nZXRTcGlubmVyUmVnaW9uKGluc3QsIGV2ZW50KTtcblx0XHRcdHBsdWdpbi5fY2hhbmdlU3Bpbm5lcihpbnN0LCBzcGlubmVyLCByZWdpb24pO1xuXHRcdFx0cGx1Z2luLl9hY3Rpb25TcGlubmVyKGluc3QsIHJlZ2lvbik7XG5cdFx0XHRwbHVnaW4uX3RpbWVyID0gbnVsbDtcblx0XHRcdHBsdWdpbi5faGFuZGxpbmdTcGlubmVyID0gdHJ1ZTtcblx0XHRcdGlmIChyZWdpb24gPj0gMyAmJiBpbnN0Lm9wdGlvbnMuc3Bpbm5lclJlcGVhdFswXSkgeyAvLyBSZXBlYXQgaW5jcmVtZW50L2RlY3JlbWVudFxuXHRcdFx0XHRwbHVnaW4uX3RpbWVyID0gc2V0VGltZW91dChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHsgcGx1Z2luLl9yZXBlYXRTcGlubmVyKGluc3QsIHJlZ2lvbik7IH0sXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnNwaW5uZXJSZXBlYXRbMF0pO1xuXHRcdFx0XHQkKHNwaW5uZXIpLm9uZSgnbW91c2VvdXQnLCBwbHVnaW4uX3JlbGVhc2VTcGlubmVyKS5cblx0XHRcdFx0XHRvbmUoJ21vdXNldXAnLCBwbHVnaW4uX3JlbGVhc2VTcGlubmVyKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEFjdGlvbiBhIGNsaWNrIG9uIHRoZSBzcGlubmVyLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSByZWdpb24ge251bWJlcn0gVGhlIHNwaW5uZXIgXCJidXR0b25cIi4gKi9cblx0XHRfYWN0aW9uU3Bpbm5lcjogZnVuY3Rpb24oaW5zdCwgcmVnaW9uKSB7XG5cdFx0XHRpZiAoIWluc3QuZWxlbS52YWwoKSkge1xuXHRcdFx0XHRwbHVnaW4uX3BhcnNlVGltZShpbnN0KTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAocmVnaW9uKSB7XG5cdFx0XHRcdGNhc2UgMDogdGhpcy5fc2V0VGltZShpbnN0KTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMTogdGhpcy5fY2hhbmdlRmllbGQoaW5zdCwgLTEsIGZhbHNlKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogdGhpcy5fY2hhbmdlRmllbGQoaW5zdCwgKzEsIGZhbHNlKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMzogdGhpcy5fYWRqdXN0RmllbGQoaW5zdCwgKzEpOyBicmVhaztcblx0XHRcdFx0Y2FzZSA0OiB0aGlzLl9hZGp1c3RGaWVsZChpbnN0LCAtMSk7IGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiogUmVwZWF0IGEgY2xpY2sgb24gdGhlIHNwaW5uZXIuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIHJlZ2lvbiB7bnVtYmVyfSBUaGUgc3Bpbm5lciBcImJ1dHRvblwiLiAqL1xuXHRcdF9yZXBlYXRTcGlubmVyOiBmdW5jdGlvbihpbnN0LCByZWdpb24pIHtcblx0XHRcdGlmICghcGx1Z2luLl90aW1lcikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRwbHVnaW4uX2xhc3RJbnB1dCA9IHBsdWdpbi5fYmx1cnJlZElucHV0O1xuXHRcdFx0dGhpcy5fYWN0aW9uU3Bpbm5lcihpbnN0LCByZWdpb24pO1xuXHRcdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFxuXHRcdFx0XHRmdW5jdGlvbigpIHsgcGx1Z2luLl9yZXBlYXRTcGlubmVyKGluc3QsIHJlZ2lvbik7IH0sXG5cdFx0XHRcdGluc3Qub3B0aW9ucy5zcGlubmVyUmVwZWF0WzFdKTtcblx0XHR9LFxuXG5cdFx0LyoqIFN0b3AgYSBzcGlubmVyIHJlcGVhdC5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgbW91c2UgZXZlbnQuICovXG5cdFx0X3JlbGVhc2VTcGlubmVyOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHBsdWdpbi5fdGltZXIpO1xuXHRcdFx0cGx1Z2luLl90aW1lciA9IG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKiBUaWR5IHVwIGFmdGVyIGFuIGV4cGFuZGVkIHNwaW5uZXIuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIG1vdXNlIGV2ZW50LiAqL1xuXHRcdF9lbmRFeHBhbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRwbHVnaW4uX3RpbWVyID0gbnVsbDtcblx0XHRcdHZhciBzcGlubmVyID0gcGx1Z2luLl9nZXRTcGlubmVyVGFyZ2V0KGV2ZW50KTtcblx0XHRcdHZhciBpbnB1dCA9IHBsdWdpbi5fZ2V0SW5wdXQoc3Bpbm5lcik7XG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChpbnB1dCk7XG5cdFx0XHQkKHNwaW5uZXIpLnJlbW92ZSgpO1xuXHRcdFx0aW5zdC5fZXhwYW5kZWQgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqIFRpZHkgdXAgYWZ0ZXIgYSBzcGlubmVyIGNsaWNrLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBtb3VzZSBldmVudC4gKi9cblx0XHRfZW5kU3Bpbm5lcjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHBsdWdpbi5fdGltZXIgPSBudWxsO1xuXHRcdFx0dmFyIHNwaW5uZXIgPSBwbHVnaW4uX2dldFNwaW5uZXJUYXJnZXQoZXZlbnQpO1xuXHRcdFx0dmFyIGlucHV0ID0gcGx1Z2luLl9nZXRJbnB1dChzcGlubmVyKTtcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGlucHV0KTtcblx0XHRcdGlmICghcGx1Z2luLmlzRGlzYWJsZWQoaW5wdXQpKSB7XG5cdFx0XHRcdHBsdWdpbi5fY2hhbmdlU3Bpbm5lcihpbnN0LCBzcGlubmVyLCAtMSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGx1Z2luLl9oYW5kbGluZ1NwaW5uZXIpIHtcblx0XHRcdFx0cGx1Z2luLl9sYXN0SW5wdXQgPSBwbHVnaW4uX2JsdXJyZWRJbnB1dDtcblx0XHRcdH1cblx0XHRcdGlmIChwbHVnaW4uX2xhc3RJbnB1dCAmJiBwbHVnaW4uX2hhbmRsaW5nU3Bpbm5lcikge1xuXHRcdFx0XHRwbHVnaW4uX3Nob3dGaWVsZChpbnN0KTtcblx0XHRcdH1cblx0XHRcdHBsdWdpbi5faGFuZGxpbmdTcGlubmVyID0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgc3Bpbm5lciBmcm9tIHRoZSBldmVudC5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgbW91c2UgY2xpY2sgZXZlbnQuXG5cdFx0XHRAcmV0dXJuIHtFbGVtZW50fSBUaGUgdGFyZ2V0IGZpZWxkLiAqL1xuXHRcdF9nZXRTcGlubmVyVGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHRcdH0sXG5cblx0XHQvKiogRGV0ZXJtaW5lIHdoaWNoIFwiYnV0dG9uXCIgd2l0aGluIHRoZSBzcGlubmVyIHdhcyBjbGlja2VkLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBtb3VzZSBldmVudC5cblx0XHRcdEByZXR1cm4ge251bWJlcn0gVGhlIHNwaW5uZXIgXCJidXR0b25cIiBudW1iZXIuICovXG5cdFx0X2dldFNwaW5uZXJSZWdpb246IGZ1bmN0aW9uKGluc3QsIGV2ZW50KSB7XG5cdFx0XHR2YXIgc3Bpbm5lciA9IHRoaXMuX2dldFNwaW5uZXJUYXJnZXQoZXZlbnQpO1xuXHRcdFx0dmFyIHBvcyA9ICQoc3Bpbm5lcikub2Zmc2V0KCk7XG5cdFx0XHR2YXIgc2Nyb2xsZWQgPSBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wXTtcblx0XHRcdHZhciBsZWZ0ID0gKGluc3Qub3B0aW9ucy5zcGlubmVySW5jRGVjT25seSA/IDk5IDogZXZlbnQuY2xpZW50WCArIHNjcm9sbGVkWzBdIC0gcG9zLmxlZnQpO1xuXHRcdFx0dmFyIHRvcCA9IGV2ZW50LmNsaWVudFkgKyBzY3JvbGxlZFsxXSAtIHBvcy50b3A7XG5cdFx0XHR2YXIgc3Bpbm5lclNpemUgPSBpbnN0Lm9wdGlvbnNbaW5zdC5fZXhwYW5kZWQgPyAnc3Bpbm5lckJpZ1NpemUnIDogJ3NwaW5uZXJTaXplJ107XG5cdFx0XHR2YXIgcmlnaHQgPSAoaW5zdC5vcHRpb25zLnNwaW5uZXJJbmNEZWNPbmx5ID8gOTkgOiBzcGlubmVyU2l6ZVswXSAtIDEgLSBsZWZ0KTtcblx0XHRcdHZhciBib3R0b20gPSBzcGlubmVyU2l6ZVsxXSAtIDEgLSB0b3A7XG5cdFx0XHRpZiAoc3Bpbm5lclNpemVbMl0gPiAwICYmIE1hdGguYWJzKGxlZnQgLSByaWdodCkgPD0gc3Bpbm5lclNpemVbMl0gJiZcblx0XHRcdFx0XHRNYXRoLmFicyh0b3AgLSBib3R0b20pIDw9IHNwaW5uZXJTaXplWzJdKSB7XG5cdFx0XHRcdHJldHVybiAwOyAvLyBDZW50cmUgYnV0dG9uXG5cdFx0XHR9XG5cdFx0XHR2YXIgbWluID0gTWF0aC5taW4obGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcblx0XHRcdHJldHVybiAobWluID09PSBsZWZ0ID8gMSA6IChtaW4gPT09IHJpZ2h0ID8gMiA6IChtaW4gPT09IHRvcCA/IDMgOiA0KSkpOyAvLyBOZWFyZXN0IGVkZ2Vcblx0XHR9LFxuXG5cdFx0LyoqIENoYW5nZSB0aGUgc3Bpbm5lciBpbWFnZSBkZXBlbmRpbmcgb24gdGhlIGJ1dHRvbiBjbGlja2VkLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSBzcGlubmVyIHtFbGVtZW50fSBUaGUgc3Bpbm5lciBjb250cm9sLlxuXHRcdFx0QHBhcmFtIHJlZ2lvbiB7bnVtYmVyfSBUaGUgc3Bpbm5lciBcImJ1dHRvblwiLiAqL1xuXHRcdF9jaGFuZ2VTcGlubmVyOiBmdW5jdGlvbihpbnN0LCBzcGlubmVyLCByZWdpb24pIHtcblx0XHRcdCQoc3Bpbm5lcikuY3NzKCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgJy0nICsgKChyZWdpb24gKyAxKSAqXG5cdFx0XHRcdGluc3Qub3B0aW9uc1tpbnN0Ll9leHBhbmRlZCA/ICdzcGlubmVyQmlnU2l6ZScgOiAnc3Bpbm5lclNpemUnXVswXSkgKyAncHggMHB4Jyk7XG5cdFx0fSxcblxuXHRcdC8qKiBFeHRyYWN0IHRoZSB0aW1lIHZhbHVlIGZyb20gdGhlIGlucHV0IGZpZWxkLCBvciBkZWZhdWx0IHRvIG5vdy5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgdHJpZ2dlcmluZyBldmVudCBvciA8Y29kZT5udWxsPC9jb2RlPi4gKi9cblx0XHRfcGFyc2VUaW1lOiBmdW5jdGlvbihpbnN0LCBldmVudCkge1xuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gdGhpcy5fZXh0cmFjdFRpbWUoaW5zdCk7XG5cdFx0XHRpZiAoY3VycmVudFRpbWUpIHtcblx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRIb3VyID0gY3VycmVudFRpbWVbMF07XG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkTWludXRlID0gY3VycmVudFRpbWVbMV07XG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkU2Vjb25kID0gY3VycmVudFRpbWVbMl07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIG5vdyA9IHRoaXMuX2NvbnN0cmFpblRpbWUoaW5zdCk7XG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkSG91ciA9IG5vd1swXTtcblx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRNaW51dGUgPSBub3dbMV07XG5cdFx0XHRcdGluc3QuX3NlbGVjdGVkU2Vjb25kID0gKGluc3Qub3B0aW9ucy5zaG93U2Vjb25kcyA/IG5vd1syXSA6IDApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdC5fc2Vjb25kRmllbGQgPSAoaW5zdC5vcHRpb25zLnNob3dTZWNvbmRzID8gMiA6IC0xKTtcblx0XHRcdGluc3QuX2FtcG1GaWVsZCA9IChpbnN0Lm9wdGlvbnMuc2hvdzI0SG91cnMgPyAtMSA6IChpbnN0Lm9wdGlvbnMuc2hvd1NlY29uZHMgPyAzIDogMikpO1xuXHRcdFx0aW5zdC5fbGFzdENociA9ICcnO1xuXHRcdFx0dmFyIHBvc3RQcm9jZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChpbnN0LmVsZW0udmFsKCkgIT09ICcnKSB7XG5cdFx0XHRcdFx0cGx1Z2luLl9zaG93VGltZShpbnN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGlmICh0eXBlb2YgaW5zdC5vcHRpb25zLmluaXRpYWxGaWVsZCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0aW5zdC5fZmllbGQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihcblx0XHRcdFx0XHRNYXRoLm1heCgxLCBpbnN0Ll9zZWNvbmRGaWVsZCwgaW5zdC5fYW1wbUZpZWxkKSwgaW5zdC5vcHRpb25zLmluaXRpYWxGaWVsZCkpO1xuXHRcdFx0XHRwb3N0UHJvY2VzcygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aW5zdC5fZmllbGQgPSBwbHVnaW4uX2dldFNlbGVjdGlvbihpbnN0LCBpbnN0LmVsZW1bMF0sIGV2ZW50KTtcblx0XHRcdFx0XHRwb3N0UHJvY2VzcygpO1xuXHRcdFx0XHR9LCAwKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEV4dHJhY3QgdGhlIHRpbWUgdmFsdWUgZnJvbSBhIHN0cmluZyBhcyBhbiBhcnJheSBvZiB2YWx1ZXMsIG9yIGRlZmF1bHQgdG8gPGNvZGU+bnVsbDwvY29kZT4uXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIHZhbHVlIHtzdHJpbmd9IFRoZSBkYXRlIHRleHQuXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJbXX0gVGhlIHJldHJpZXZlZCB0aW1lIGNvbXBvbmVudHMgKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSBvclxuXHRcdFx0XHRcdDxjb2RlPm51bGw8L2NvZGU+IGlmIG5vIHZhbHVlLiAqL1xuXHRcdF9leHRyYWN0VGltZTogZnVuY3Rpb24oaW5zdCwgdmFsdWUpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgaW5zdC5lbGVtLnZhbCgpO1xuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gdmFsdWUuc3BsaXQoaW5zdC5vcHRpb25zLnNlcGFyYXRvcik7XG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnNlcGFyYXRvciA9PT0gJycgJiYgdmFsdWUgIT09ICcnKSB7XG5cdFx0XHRcdGN1cnJlbnRUaW1lWzBdID0gdmFsdWUuc3Vic3RyaW5nKDAsIDIpO1xuXHRcdFx0XHRjdXJyZW50VGltZVsxXSA9IHZhbHVlLnN1YnN0cmluZygyLCA0KTtcblx0XHRcdFx0Y3VycmVudFRpbWVbMl0gPSB2YWx1ZS5zdWJzdHJpbmcoNCwgNik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFRpbWUubGVuZ3RoID49IDIpIHtcblx0XHRcdFx0dmFyIGlzQU0gPSAhaW5zdC5vcHRpb25zLnNob3cyNEhvdXJzICYmICh2YWx1ZS5pbmRleE9mKGluc3Qub3B0aW9ucy5hbXBtTmFtZXNbMF0pID4gLTEpO1xuXHRcdFx0XHR2YXIgaXNQTSA9ICFpbnN0Lm9wdGlvbnMuc2hvdzI0SG91cnMgJiYgKHZhbHVlLmluZGV4T2YoaW5zdC5vcHRpb25zLmFtcG1OYW1lc1sxXSkgPiAtMSk7XG5cdFx0XHRcdHZhciBob3VyID0gcGFyc2VJbnQoY3VycmVudFRpbWVbMF0sIDEwKTtcblx0XHRcdFx0aG91ciA9IChpc05hTihob3VyKSA/IDAgOiBob3VyKTtcblx0XHRcdFx0aG91ciA9ICgoaXNBTSB8fCBpc1BNKSAmJiBob3VyID09PSAxMiA/IDAgOiBob3VyKSArIChpc1BNID8gMTIgOiAwKTtcblx0XHRcdFx0dmFyIG1pbnV0ZSA9IHBhcnNlSW50KGN1cnJlbnRUaW1lWzFdLCAxMCk7XG5cdFx0XHRcdG1pbnV0ZSA9IChpc05hTihtaW51dGUpID8gMCA6IG1pbnV0ZSk7XG5cdFx0XHRcdHZhciBzZWNvbmQgPSAoY3VycmVudFRpbWUubGVuZ3RoID49IDMgPyBwYXJzZUludChjdXJyZW50VGltZVsyXSwgMTApIDogMCk7XG5cdFx0XHRcdHNlY29uZCA9IChpc05hTihzZWNvbmQpIHx8ICFpbnN0Lm9wdGlvbnMuc2hvd1NlY29uZHMgPyAwIDogc2Vjb25kKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnN0cmFpblRpbWUoaW5zdCwgW2hvdXIsIG1pbnV0ZSwgc2Vjb25kXSk7XG5cdFx0XHR9IFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKiBDb25zdHJhaW4gdGhlIGdpdmVuL2N1cnJlbnQgdGltZSB0byB0aGUgdGltZSBzdGVwcy5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcGFyYW0gZmllbGRzIHtudW1iZXJbXX0gVGhlIGN1cnJlbnQgdGltZSBjb21wb25lbnRzIChob3VycywgbWludXRlcywgc2Vjb25kcykuXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJbXX0gVGhlIGNvbnN0cmFpbmVkIHRpbWUgY29tcG9uZW50cyAoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpLiAqL1xuXHRcdF9jb25zdHJhaW5UaW1lOiBmdW5jdGlvbihpbnN0LCBmaWVsZHMpIHtcblx0XHRcdHZhciBzcGVjaWZpZWQgPSAoZmllbGRzICE9PSBudWxsICYmIGZpZWxkcyAhPT0gdW5kZWZpbmVkKTtcblx0XHRcdGlmICghc3BlY2lmaWVkKSB7XG5cdFx0XHRcdHZhciBub3cgPSB0aGlzLl9kZXRlcm1pbmVUaW1lKGluc3Qub3B0aW9ucy5kZWZhdWx0VGltZSwgaW5zdCkgfHwgbmV3IERhdGUoKTtcblx0XHRcdFx0ZmllbGRzID0gW25vdy5nZXRIb3VycygpLCBub3cuZ2V0TWludXRlcygpLCBub3cuZ2V0U2Vjb25kcygpXTtcblx0XHRcdH1cblx0XHRcdHZhciByZXNldCA9IGZhbHNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0Lm9wdGlvbnMudGltZVN0ZXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChyZXNldCkge1xuXHRcdFx0XHRcdGZpZWxkc1tpXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoaW5zdC5vcHRpb25zLnRpbWVTdGVwc1tpXSA+IDEpIHtcblx0XHRcdFx0XHRmaWVsZHNbaV0gPSBNYXRoLnJvdW5kKGZpZWxkc1tpXSAvIGluc3Qub3B0aW9ucy50aW1lU3RlcHNbaV0pICpcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy50aW1lU3RlcHNbaV07XG5cdFx0XHRcdFx0cmVzZXQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmllbGRzO1xuXHRcdH0sXG5cblx0XHQvKiogU2V0IHRoZSBzZWxlY3RlZCB0aW1lIGludG8gdGhlIGlucHV0IGZpZWxkLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy4gKi9cblx0XHRfc2hvd1RpbWU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRcdHZhciBjdXJyZW50VGltZSA9IChpbnN0Lm9wdGlvbnMudW5saW1pdGVkSG91cnMgPyBpbnN0Ll9zZWxlY3RlZEhvdXIgOlxuXHRcdFx0XHR0aGlzLl9mb3JtYXROdW1iZXIoaW5zdC5vcHRpb25zLnNob3cyNEhvdXJzID8gaW5zdC5fc2VsZWN0ZWRIb3VyIDpcblx0XHRcdFx0KChpbnN0Ll9zZWxlY3RlZEhvdXIgKyAxMSkgJSAxMikgKyAxKSkgKyBpbnN0Lm9wdGlvbnMuc2VwYXJhdG9yICtcblx0XHRcdFx0dGhpcy5fZm9ybWF0TnVtYmVyKGluc3QuX3NlbGVjdGVkTWludXRlKSArXG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMuc2hvd1NlY29uZHMgPyBpbnN0Lm9wdGlvbnMuc2VwYXJhdG9yICtcblx0XHRcdFx0dGhpcy5fZm9ybWF0TnVtYmVyKGluc3QuX3NlbGVjdGVkU2Vjb25kKSA6ICcnKSArXG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMuc2hvdzI0SG91cnMgPyAgJycgOiBpbnN0Lm9wdGlvbnMuYW1wbVByZWZpeCArXG5cdFx0XHRcdGluc3Qub3B0aW9ucy5hbXBtTmFtZXNbKGluc3QuX3NlbGVjdGVkSG91ciA8IDEyID8gMCA6IDEpXSk7XG5cdFx0XHR0aGlzLl9zZXRWYWx1ZShpbnN0LCBjdXJyZW50VGltZSk7XG5cdFx0XHR0aGlzLl9zaG93RmllbGQoaW5zdCk7XG5cdFx0fSxcblxuXHRcdC8qKiBIaWdobGlnaHQgdGhlIGN1cnJlbnQgZGF0ZSBmaWVsZC5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuICovXG5cdFx0X3Nob3dGaWVsZDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdFx0dmFyIGlucHV0ID0gaW5zdC5lbGVtWzBdO1xuXHRcdFx0aWYgKGluc3QuZWxlbS5pcygnOmhpZGRlbicpIHx8IHBsdWdpbi5fbGFzdElucHV0ICE9PSBpbnB1dCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZmllbGRTaXplcyA9IFtpbnN0LmVsZW0udmFsKCkuc3BsaXQoaW5zdC5vcHRpb25zLnNlcGFyYXRvcilbMF0ubGVuZ3RoLCAyLCAyXTtcblx0XHRcdHZhciBzdGFydCA9IDA7XG5cdFx0XHR2YXIgZmllbGQgPSAwO1xuXHRcdFx0d2hpbGUgKGZpZWxkIDwgaW5zdC5fZmllbGQpIHtcblx0XHRcdFx0c3RhcnQgKz0gZmllbGRTaXplc1tmaWVsZF0gK1xuXHRcdFx0XHRcdChmaWVsZCA9PT0gTWF0aC5tYXgoMSwgaW5zdC5fc2Vjb25kRmllbGQpID8gMCA6IGluc3Qub3B0aW9ucy5zZXBhcmF0b3IubGVuZ3RoKTtcblx0XHRcdFx0ZmllbGQrKztcblx0XHRcdH1cblx0XHRcdHZhciBlbmQgPSBzdGFydCArIChpbnN0Ll9maWVsZCAhPT0gaW5zdC5fYW1wbUZpZWxkID8gZmllbGRTaXplc1tmaWVsZF0gOlxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuYW1wbVByZWZpeC5sZW5ndGggKyBpbnN0Lm9wdGlvbnMuYW1wbU5hbWVzWzBdLmxlbmd0aCk7XG5cdFx0XHRpZiAoaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UpIHsgLy8gTW96aWxsYVxuXHRcdFx0XHRpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlucHV0LmNyZWF0ZVRleHRSYW5nZSkgeyAvLyBJRVxuXHRcdFx0XHR2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcblx0XHRcdFx0cmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG5cdFx0XHRcdHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIGluc3QuZWxlbS52YWwoKS5sZW5ndGgpO1xuXHRcdFx0XHRyYW5nZS5zZWxlY3QoKTtcblx0XHRcdH1cblx0XHRcdGlmICghaW5wdXQuZGlzYWJsZWQpIHtcblx0XHRcdFx0aW5wdXQuZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIEVuc3VyZSBkaXNwbGF5ZWQgc2luZ2xlIG51bWJlciBoYXMgYSBsZWFkaW5nIHplcm8uXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIHZhbHVlIHtudW1iZXJ9IFRoZSBjdXJyZW50IHZhbHVlLlxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBOdW1iZXIgd2l0aCBhdCBsZWFzdCB0d28gZGlnaXRzLiAqL1xuXHRcdF9mb3JtYXROdW1iZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gKHZhbHVlIDwgMTAgPyAnMCcgOiAnJykgKyB2YWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgYW5kIG5vdGlmeSBsaXN0ZW5lcnMuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIHZhbHVlIHtzdHJpbmd9IFRoZSBuZXcgdmFsdWUuICovXG5cdFx0X3NldFZhbHVlOiBmdW5jdGlvbihpbnN0LCB2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9PSBpbnN0LmVsZW0udmFsKCkpIHtcblx0XHRcdFx0aW5zdC5lbGVtLnZhbCh2YWx1ZSkudHJpZ2dlcignY2hhbmdlJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKiBNb3ZlIHRvIHByZXZpb3VzL25leHQgZmllbGQsIG9yIG91dCBvZiBmaWVsZCBhbHRvZ2V0aGVyIGlmIGFwcHJvcHJpYXRlLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBpbnN0YW5jZSBzZXR0aW5ncy5cblx0XHRcdEBwYXJhbSBvZmZzZXQge251bWJlcn0gVGhlIGRpcmVjdGlvbiBvZiBjaGFuZ2UgKC0xLCArMSkuXG5cdFx0XHRAcGFyYW0gbW92ZU91dCB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY2FuIG1vdmUgb3V0IG9mIHRoZSBmaWVsZC5cblx0XHRcdEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGV4aXRpbmcgdGhlIGZpZWxkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xuXHRcdF9jaGFuZ2VGaWVsZDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBtb3ZlT3V0KSB7XG5cdFx0XHR2YXIgYXRGaXJzdExhc3QgPSAoaW5zdC5lbGVtLnZhbCgpID09PSAnJyB8fFxuXHRcdFx0XHRpbnN0Ll9maWVsZCA9PT0gKG9mZnNldCA9PT0gLTEgPyAwIDogTWF0aC5tYXgoMSwgaW5zdC5fc2Vjb25kRmllbGQsIGluc3QuX2FtcG1GaWVsZCkpKTtcblx0XHRcdGlmICghYXRGaXJzdExhc3QpIHtcblx0XHRcdFx0aW5zdC5fZmllbGQgKz0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2hvd0ZpZWxkKGluc3QpO1xuXHRcdFx0aW5zdC5fbGFzdENociA9ICcnO1xuXHRcdFx0cmV0dXJuIChhdEZpcnN0TGFzdCAmJiBtb3ZlT3V0KTtcblx0XHR9LFxuXG5cdFx0LyoqIFVwZGF0ZSB0aGUgY3VycmVudCBmaWVsZCBpbiB0aGUgZGlyZWN0aW9uIGluZGljYXRlZC5cblx0XHRcdEBwcml2YXRlXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgaW5zdGFuY2Ugc2V0dGluZ3MuXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBhbW91bnQgdG8gY2hhbmdlIGJ5LiAqL1xuXHRcdF9hZGp1c3RGaWVsZDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0KSB7XG5cdFx0XHRpZiAoaW5zdC5lbGVtLnZhbCgpID09PSAnJykge1xuXHRcdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy51bmxpbWl0ZWRIb3Vycykge1xuXHRcdFx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIFtpbnN0Ll9zZWxlY3RlZEhvdXIgKyAoaW5zdC5fZmllbGQgPT09IDAgPyBvZmZzZXQgKiBpbnN0Lm9wdGlvbnMudGltZVN0ZXBzWzBdIDogMCksXG5cdFx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRNaW51dGUgKyAoaW5zdC5fZmllbGQgPT09IDEgPyBvZmZzZXQgKiBpbnN0Lm9wdGlvbnMudGltZVN0ZXBzWzFdIDogMCksXG5cdFx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRTZWNvbmQgKyAoaW5zdC5fZmllbGQgPT09IGluc3QuX3NlY29uZEZpZWxkID8gb2Zmc2V0ICogaW5zdC5vcHRpb25zLnRpbWVTdGVwc1syXSA6IDApXSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX3NldFRpbWUoaW5zdCwgbmV3IERhdGUoMCwgMCwgMCxcblx0XHRcdFx0aW5zdC5fc2VsZWN0ZWRIb3VyICsgKGluc3QuX2ZpZWxkID09PSAwID8gb2Zmc2V0ICogaW5zdC5vcHRpb25zLnRpbWVTdGVwc1swXSA6IDApICtcblx0XHRcdFx0KGluc3QuX2ZpZWxkID09PSBpbnN0Ll9hbXBtRmllbGQgPyBvZmZzZXQgKiAxMiA6IDApLFxuXHRcdFx0XHRpbnN0Ll9zZWxlY3RlZE1pbnV0ZSArIChpbnN0Ll9maWVsZCA9PT0gMSA/IG9mZnNldCAqIGluc3Qub3B0aW9ucy50aW1lU3RlcHNbMV0gOiAwKSxcblx0XHRcdFx0XHRpbnN0Ll9zZWxlY3RlZFNlY29uZCArIChpbnN0Ll9maWVsZCA9PT0gaW5zdC5fc2Vjb25kRmllbGQgPyBvZmZzZXQgKiBpbnN0Lm9wdGlvbnMudGltZVN0ZXBzWzJdIDogMCkpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqIENoZWNrIGFnYWluc3QgbWluaW11bS9tYXhpbXVtIGFuZCBkaXNwbGF5IHRpbWUuXG5cdFx0XHRAcHJpdmF0ZVxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHBhcmFtIHRpbWUge0RhdGV8bnVtYmVyfHN0cmluZ3xudW1iZXJbXX0gVGhlIGFjdHVhbCB0aW1lIG9yIG9mZnNldCBpbiBzZWNvbmRzIGZyb20gbm93IG9yXG5cdFx0XHRcdFx0dW5pdHMgYW5kIHBlcmlvZHMgb2Ygb2Zmc2V0cyBmcm9tIG5vdyBvciBudW1lcmljIHBlcmlvZCB2YWx1ZXMuICovXG5cdFx0X3NldFRpbWU6IGZ1bmN0aW9uKGluc3QsIHRpbWUpIHtcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMudW5saW1pdGVkSG91cnMgJiYgJC5pc0FycmF5KHRpbWUpKSB7XG5cdFx0XHRcdHZhciBmaWVsZHMgPSB0aW1lO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHR0aW1lID0gdGhpcy5fZGV0ZXJtaW5lVGltZSh0aW1lLCBpbnN0KTtcblx0XHRcdFx0dmFyIGZpZWxkcyA9ICh0aW1lID8gW3RpbWUuZ2V0SG91cnMoKSwgdGltZS5nZXRNaW51dGVzKCksIHRpbWUuZ2V0U2Vjb25kcygpXSA6IG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0ZmllbGRzID0gdGhpcy5fY29uc3RyYWluVGltZShpbnN0LCBmaWVsZHMpO1xuXHRcdFx0dGltZSA9IG5ldyBEYXRlKDAsIDAsIDAsIGZpZWxkc1swXSwgZmllbGRzWzFdLCBmaWVsZHNbMl0pO1xuXHRcdFx0Ly8gTm9ybWFsaXNlIHRvIGJhc2UgZGF0ZVxuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9ub3JtYWxpc2VUaW1lKHRpbWUpO1xuXHRcdFx0dmFyIG1pblRpbWUgPSB0aGlzLl9ub3JtYWxpc2VUaW1lKHRoaXMuX2RldGVybWluZVRpbWUoaW5zdC5vcHRpb25zLm1pblRpbWUsIGluc3QpKTtcblx0XHRcdHZhciBtYXhUaW1lID0gdGhpcy5fbm9ybWFsaXNlVGltZSh0aGlzLl9kZXRlcm1pbmVUaW1lKGluc3Qub3B0aW9ucy5tYXhUaW1lLCBpbnN0KSk7XG5cdFx0XHQvLyBFbnN1cmUgaXQgaXMgd2l0aGluIHRoZSBib3VuZHMgc2V0XG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnVubGltaXRlZEhvdXJzKSB7XG5cdFx0XHRcdHdoaWxlIChmaWVsZHNbMl0gPCAwKSB7XG5cdFx0XHRcdFx0ZmllbGRzWzJdICs9IDYwO1xuXHRcdFx0XHRcdGZpZWxkc1sxXS0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChmaWVsZHNbMl0gPiA1OSkge1xuXHRcdFx0XHRcdGZpZWxkc1syXSAtPSA2MDtcblx0XHRcdFx0XHRmaWVsZHNbMV0rKztcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoZmllbGRzWzFdIDwgMCkge1xuXHRcdFx0XHRcdGZpZWxkc1sxXSArPSA2MDtcblx0XHRcdFx0XHRmaWVsZHNbMF0tLTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoZmllbGRzWzFdID4gNTkpIHtcblx0XHRcdFx0XHRmaWVsZHNbMV0gLT0gNjA7XG5cdFx0XHRcdFx0ZmllbGRzWzBdKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWluVGltZSA9IChpbnN0Lm9wdGlvbnMubWluVGltZSAhPSBudWxsICYmICQuaXNBcnJheShpbnN0Lm9wdGlvbnMubWluVGltZSkpID9cblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMubWluVGltZSA6IFswLCAwLCAwXTtcblx0XHRcdFx0aWYgKGZpZWxkc1swXSA8IG1pblRpbWVbMF0pIHtcblx0XHRcdFx0XHRmaWVsZHMgPSBtaW5UaW1lLnNsaWNlKDAsIDMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGZpZWxkc1swXSA9PT0gbWluVGltZVswXSkge1xuXHRcdFx0XHRcdGlmIChmaWVsZHNbMV0gPCBtaW5UaW1lWzFdKSB7XG5cdFx0XHRcdFx0XHRmaWVsZHNbMV0gPSBtaW5UaW1lWzFdO1xuXHRcdFx0XHRcdFx0ZmllbGRzWzJdID0gbWluVGltZVsyXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZmllbGRzWzFdID09PSBtaW5UaW1lWzFdKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmllbGRzWzJdIDwgbWluVGltZVsyXSkge1xuXHRcdFx0XHRcdFx0XHRmaWVsZHNbMl0gPSBtaW5UaW1lWzJdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5zdC5vcHRpb25zLm1heFRpbWUgIT0gbnVsbCAmJiAkLmlzQXJyYXkoaW5zdC5vcHRpb25zLm1heFRpbWUpKSB7XG5cdFx0XHRcdFx0aWYgKGZpZWxkc1swXSA+IGluc3Qub3B0aW9ucy5tYXhUaW1lWzBdKSB7XG5cdFx0XHRcdFx0XHRmaWVsZHMgPSBpbnN0Lm9wdGlvbnMubWF4VGltZS5zbGljZSgwLCAzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZmllbGRzWzBdID09PSBpbnN0Lm9wdGlvbnMubWF4VGltZVswXSkge1xuXHRcdFx0XHRcdFx0aWYgKGZpZWxkc1sxXSA+IGluc3Qub3B0aW9ucy5tYXhUaW1lWzFdKSB7XG5cdFx0XHRcdFx0XHRcdGZpZWxkc1sxXSA9IGluc3Qub3B0aW9ucy5tYXhUaW1lWzFdO1xuXHRcdFx0XHRcdFx0XHRmaWVsZHNbMl0gPSBpbnN0Lm9wdGlvbnMubWF4VGltZVsyXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGZpZWxkc1sxXSA9PT0gaW5zdC5vcHRpb25zLm1heFRpbWVbMV0pIHtcblx0XHRcdFx0XHRcdFx0aWYgKGZpZWxkc1syXSA+IGluc3Qub3B0aW9ucy5tYXhUaW1lWzJdKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzWzJdID0gaW5zdC5vcHRpb25zLm1heFRpbWVbMl07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0aWYgKG1pblRpbWUgJiYgbWF4VGltZSAmJiBtaW5UaW1lID4gbWF4VGltZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IG1pblRpbWUgJiYgdGltZSA+IG1heFRpbWUpIHtcblx0XHRcdFx0XHR0aW1lID0gKE1hdGguYWJzKHRpbWUgLSBtaW5UaW1lKSA8IE1hdGguYWJzKHRpbWUgLSBtYXhUaW1lKSA/IG1pblRpbWUgOiBtYXhUaW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRpbWUgPSAobWluVGltZSAmJiB0aW1lIDwgbWluVGltZSA/IG1pblRpbWUgOlxuXHRcdFx0XHRcdChtYXhUaW1lICYmIHRpbWUgPiBtYXhUaW1lID8gbWF4VGltZSA6IHRpbWUpKTtcblx0XHRcdH1cblx0XHRcdFx0ZmllbGRzWzBdID0gdGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRmaWVsZHNbMV0gPSB0aW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0ZmllbGRzWzJdID0gdGltZS5nZXRTZWNvbmRzKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBQZXJmb3JtIGZ1cnRoZXIgcmVzdHJpY3Rpb25zIGlmIHJlcXVpcmVkXG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5iZWZvcmVTZXRUaW1lKSkge1xuXHRcdFx0XHR0aW1lID0gaW5zdC5vcHRpb25zLmJlZm9yZVNldFRpbWUuYXBwbHkoaW5zdC5lbGVtWzBdLFxuXHRcdFx0XHRcdFt0aGlzLmdldFRpbWUoaW5zdC5lbGVtWzBdKSwgdGltZSwgbWluVGltZSwgbWF4VGltZV0pO1xuXHRcdFx0XHRmaWVsZHNbMF0gPSB0aW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdGZpZWxkc1sxXSA9IHRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRmaWVsZHNbMl0gPSB0aW1lLmdldFNlY29uZHMoKTtcblx0XHRcdH1cblx0XHRcdGluc3QuX3NlbGVjdGVkSG91ciA9IGZpZWxkc1swXTtcblx0XHRcdGluc3QuX3NlbGVjdGVkTWludXRlID0gZmllbGRzWzFdO1xuXHRcdFx0aW5zdC5fc2VsZWN0ZWRTZWNvbmQgPSBmaWVsZHNbMl07XG5cdFx0XHR0aGlzLl9zaG93VGltZShpbnN0KTtcblx0XHR9LFxuXG5cdFx0LyoqIEEgdGltZSBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGV4YWN0IHZhbHVlIG9yIGEgcmVsYXRpdmUgb25lLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSBzZXR0aW5nIHtEYXRlfG51bWJlcnxzdHJpbmd8bnVtYmVyW119IFRoZSBhY3R1YWwgdGltZSBvciBvZmZzZXQgaW4gc2Vjb25kcyBmcm9tIG5vdyBvclxuXHRcdFx0XHRcdHVuaXRzIGFuZCBwZXJpb2RzIG9mIG9mZnNldHMgZnJvbSBub3cgb3IgbnVtZXJpYyBwZXJpb2QgdmFsdWVzLlxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGluc3RhbmNlIHNldHRpbmdzLlxuXHRcdFx0QHJldHVybiB7RGF0ZX0gVGhlIGNhbGN1bGF0ZWQgdGltZS4gKi9cblx0XHRfZGV0ZXJtaW5lVGltZTogZnVuY3Rpb24oc2V0dGluZywgaW5zdCkge1xuXHRcdFx0dmFyIG9mZnNldE51bWVyaWMgPSBmdW5jdGlvbihvZmZzZXQpIHsgLy8gRS5nLiArMzAwLCAtMlxuXHRcdFx0XHR2YXIgdGltZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdHRpbWUuc2V0VGltZSh0aW1lLmdldFRpbWUoKSArIG9mZnNldCAqIDEwMDApO1xuXHRcdFx0XHRyZXR1cm4gdGltZTtcblx0XHRcdH07XG5cdFx0XHR2YXIgb2Zmc2V0U3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7IC8vIEUuZy4gJysybScsICctNGgnLCAnKzNoICszMG0nIG9yICcxMjozNDo1NlBNJ1xuXHRcdFx0XHR2YXIgZmllbGRzID0gcGx1Z2luLl9leHRyYWN0VGltZShpbnN0LCBvZmZzZXQpOyAvLyBBY3R1YWwgdGltZT9cblx0XHRcdFx0dmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHR2YXIgaG91ciA9IChmaWVsZHMgPyBmaWVsZHNbMF0gOiB0aW1lLmdldEhvdXJzKCkpO1xuXHRcdFx0XHR2YXIgbWludXRlID0gKGZpZWxkcyA/IGZpZWxkc1sxXSA6IHRpbWUuZ2V0TWludXRlcygpKTtcblx0XHRcdFx0dmFyIHNlY29uZCA9IChmaWVsZHMgPyBmaWVsZHNbMl0gOiB0aW1lLmdldFNlY29uZHMoKSk7XG5cdFx0XHRcdGlmICghZmllbGRzKSB7XG5cdFx0XHRcdFx0dmFyIHBhdHRlcm4gPSAvKFsrLV0/WzAtOV0rKVxccyooc3xTfG18TXxofEgpPy9nO1xuXHRcdFx0XHRcdHZhciBtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cdFx0XHRcdFx0d2hpbGUgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRcdHN3aXRjaCAobWF0Y2hlc1syXSB8fCAncycpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAncycgOiBjYXNlICdTJyA6XG5cdFx0XHRcdFx0XHRcdFx0c2Vjb25kICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ20nIDogY2FzZSAnTScgOlxuXHRcdFx0XHRcdFx0XHRcdG1pbnV0ZSArPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdoJyA6IGNhc2UgJ0gnIDpcblx0XHRcdFx0XHRcdFx0XHRob3VyICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbWUgPSBuZXcgRGF0ZSgwLCAwLCAxMCwgaG91ciwgbWludXRlLCBzZWNvbmQsIDApO1xuXHRcdFx0XHRpZiAoL14hLy50ZXN0KG9mZnNldCkpIHsgLy8gTm8gd3JhcHBpbmdcblx0XHRcdFx0XHRpZiAodGltZS5nZXREYXRlKCkgPiAxMCkge1xuXHRcdFx0XHRcdFx0dGltZSA9IG5ldyBEYXRlKDAsIDAsIDEwLCAyMywgNTksIDU5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAodGltZS5nZXREYXRlKCkgPCAxMCkge1xuXHRcdFx0XHRcdFx0dGltZSA9IG5ldyBEYXRlKDAsIDAsIDEwLCAwLCAwLCAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRpbWU7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIG9mZnNldEFycmF5ID0gZnVuY3Rpb24oc2V0dGluZykge1xuXHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoMCwgMCwgMCwgc2V0dGluZ1swXSwgc2V0dGluZ1sxXSB8fCAwLCBzZXR0aW5nWzJdIHx8IDAsIDApO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiAoc2V0dGluZyA/ICh0eXBlb2Ygc2V0dGluZyA9PT0gJ3N0cmluZycgPyBvZmZzZXRTdHJpbmcoc2V0dGluZykgOlxuXHRcdFx0XHQodHlwZW9mIHNldHRpbmcgPT09ICdudW1iZXInID8gb2Zmc2V0TnVtZXJpYyhzZXR0aW5nKSA6XG5cdFx0XHRcdCgkLmlzQXJyYXkoc2V0dGluZykgPyBvZmZzZXRBcnJheShzZXR0aW5nKSA6IHNldHRpbmcpKSkgOiBudWxsKTtcblx0XHR9LFxuXG5cdFx0LyoqIE5vcm1hbGlzZSB0aW1lIG9iamVjdCB0byBhIGNvbW1vbiBkYXRlLlxuXHRcdFx0QHByaXZhdGVcblx0XHRcdEBwYXJhbSB0aW1lIHtEYXRlfSBUaGUgb3JpZ2luYWwgdGltZS5cblx0XHRcdEByZXR1cm4ge0RhdGV9IFRoZSBub3JtYWxpc2VkIHRpbWUuICovXG5cdFx0X25vcm1hbGlzZVRpbWU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICghdGltZSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHRpbWUuc2V0RnVsbFllYXIoMTkwMCk7XG5cdFx0XHR0aW1lLnNldE1vbnRoKDApO1xuXHRcdFx0dGltZS5zZXREYXRlKDApO1xuXHRcdFx0cmV0dXJuIHRpbWU7XG5cdFx0fVxuXHR9KTtcblx0XG5cdHZhciBwbHVnaW4gPSAkLnRpbWVFbnRyeTtcblxufSkoalF1ZXJ5KTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
