/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/*
  jQuery utils - 0.8.5
  http://code.google.com/p/jquery-utils/

  (c) Maxime Haineault <haineault@gmail.com> 
  http://haineault.com

  MIT License (http://www.opensource.org/licenses/mit-license.php

*/

(function($){
     $.extend($.expr[':'], {
        // case insensitive version of :contains
        icontains: function(a,i,m){return (a.textContent||a.innerText||jQuery(a).text()||"").toLowerCase().indexOf(m[3].toLowerCase())>=0;}
    });

    $.iterators = {
        getText:  function() { return $(this).text(); },
        parseInt: function(v){ return parseInt(v, 10); }
    };

	$.extend({ 

        // Returns a range object
        // Author: Matthias Miller
        // Site:   http://blog.outofhanwell.com/2006/03/29/javascript-range-function/
        range:  function() {
            if (!arguments.length) { return []; }
            var min, max, step;
            if (arguments.length == 1) {
                min  = 0;
                max  = arguments[0]-1;
                step = 1;
            }
            else {
                // default step to 1 if it's zero or undefined
                min  = arguments[0];
                max  = arguments[1]-1;
                step = arguments[2] || 1;
            }
            // convert negative steps to positive and reverse min/max
            if (step < 0 && min >= max) {
                step *= -1;
                var tmp = min;
                min = max;
                max = tmp;
                min += ((max-min) % step);
            }
            var a = [];
            for (var i = min; i <= max; i += step) { a.push(i); }
            return a;
        },

        // Taken from ui.core.js. 
        // Why are you keeping this gem for yourself guys ? :|
        keyCode: {
            BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, CONTROL: 17, DELETE: 46, DOWN: 40,
            END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT:  45, LEFT: 37,
            NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108, 
            NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, 
            PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38
        },
        
        // Takes a keyboard event and return true if the keycode match the specified keycode
        keyIs: function(k, e) {
            return parseInt($.keyCode[k.toUpperCase()], 10) == parseInt((typeof(e) == 'number' )? e: e.keyCode, 10);
        },
        
        // Returns the key of an array
        keys: function(arr) {
            var o = [];
            for (k in arr) { o.push(k); }
            return o;
        },

        // Redirect to a specified url
        redirect: function(url) {
            window.location.href = url;
            return url;
        },

        // Stop event shorthand
        stop: function(e, preventDefault, stopPropagation) {
            if (preventDefault)  { e.preventDefault(); }
            if (stopPropagation) { e.stopPropagation(); }
            return preventDefault && false || true;
        },

        // Returns the basename of a path
        basename: function(path) {
            var t = path.split('/');
            return t[t.length] === '' && s || t.slice(0, t.length).join('/');
        },

        // Returns the filename of a path
        filename: function(path) {
            return path.split('/').pop();
        }, 

        // Returns a formated file size
        filesizeformat: function(bytes, suffixes){
            var b = parseInt(bytes, 10);
            var s = suffixes || ['byte', 'bytes', 'KB', 'MB', 'GB'];
            if (isNaN(b) || b === 0) { return '0 ' + s[0]; }
            if (b == 1)              { return '1 ' + s[0]; }
            if (b < 1024)            { return  b.toFixed(2) + ' ' + s[1]; }
            if (b < 1048576)         { return (b / 1024).toFixed(2) + ' ' + s[2]; }
            if (b < 1073741824)      { return (b / 1048576).toFixed(2) + ' '+ s[3]; }
            else                     { return (b / 1073741824).toFixed(2) + ' '+ s[4]; }
        },

        fileExtension: function(s) {
            var tokens = s.split('.');
            return tokens[tokens.length-1] || false;
        },
        
        // Returns true if an object is a String
        isString: function(o) {
            return typeof(o) == 'string' && true || false;
        },
        
        // Returns true if an object is a RegExp
		isRegExp: function(o) {
			return o && o.constructor.toString().indexOf('RegExp()') != -1 || false;
		},

        isObject: function(o) {
            return (typeof(o) == 'object');
        },
        
        // Convert input to currency (two decimal fixed number)
		toCurrency: function(i) {
			i = parseFloat(i, 10).toFixed(2);
			return (i=='NaN') ? '0.00' : i;
		},

        /*-------------------------------------------------------------------- 
         * javascript method: "pxToEm"
         * by:
           Scott Jehl (scott@filamentgroup.com) 
           Maggie Wachs (maggie@filamentgroup.com)
           http://www.filamentgroup.com
         *
         * Copyright (c) 2008 Filament Group
         * Dual licensed under the MIT (filamentgroup.com/examples/mit-license.txt) and GPL (filamentgroup.com/examples/gpl-license.txt) licenses.
         *
         * Description: pxToEm converts a pixel value to ems depending on inherited font size.  
         * Article: http://www.filamentgroup.com/lab/retaining_scalable_interfaces_with_pixel_to_em_conversion/
         * Demo: http://www.filamentgroup.com/examples/pxToEm/	 	
         *							
         * Options:  	 								
                scope: string or jQuery selector for font-size scoping
                reverse: Boolean, true reverses the conversion to em-px
         * Dependencies: jQuery library						  
         * Usage Example: myPixelValue.pxToEm(); or myPixelValue.pxToEm({'scope':'#navigation', reverse: true});
         *
         * Version: 2.1, 18.12.2008
         * Changelog:
         *		08.02.2007 initial Version 1.0
         *		08.01.2008 - fixed font-size calculation for IE
         *		18.12.2008 - removed native object prototyping to stay in jQuery's spirit, jsLinted (Maxime Haineault <haineault@gmail.com>)
        --------------------------------------------------------------------*/

        pxToEm: function(i, settings){
            //set defaults
            settings = jQuery.extend({
                scope: 'body',
                reverse: false
            }, settings);
            
            var pxVal = (i === '') ? 0 : parseFloat(i);
            var scopeVal;
            var getWindowWidth = function(){
                var de = document.documentElement;
                return self.innerWidth || (de && de.clientWidth) || document.body.clientWidth;
            };	
            
            /* When a percentage-based font-size is set on the body, IE returns that percent of the window width as the font-size. 
                For example, if the body font-size is 62.5% and the window width is 1000px, IE will return 625px as the font-size. 	
                When this happens, we calculate the correct body font-size (%) and multiply it by 16 (the standard browser font size) 
                to get an accurate em value. */
                        
            if (settings.scope == 'body' && $.browser.msie && (parseFloat($('body').css('font-size')) / getWindowWidth()).toFixed(1) > 0.0) {
                var calcFontSize = function(){		
                    return (parseFloat($('body').css('font-size'))/getWindowWidth()).toFixed(3) * 16;
                };
                scopeVal = calcFontSize();
            }
            else { scopeVal = parseFloat(jQuery(settings.scope).css("font-size")); }
                    
            var result = (settings.reverse === true) ? (pxVal * scopeVal).toFixed(2) + 'px' : (pxVal / scopeVal).toFixed(2) + 'em';
            return result;
        }
	});

	$.extend($.fn, { 
        type: function() {
            try { return $(this).get(0).nodeName.toLowerCase(); }
            catch(e) { return false; }
        },
        // Select a text range in a textarea
        selectRange: function(start, end){
            // use only the first one since only one input can be focused
            if ($(this).get(0).createTextRange) {
                var range = $(this).get(0).createTextRange();
                range.collapse(true);
                range.moveEnd('character',   end);
                range.moveStart('character', start);
                range.select();
            }
            else if ($(this).get(0).setSelectionRange) {
                $(this).bind('focus', function(e){
                    e.preventDefault();
                }).get(0).setSelectionRange(start, end);
            }
            return $(this);
        },

        /*-------------------------------------------------------------------- 
         * JQuery Plugin: "EqualHeights"
         * by:	Scott Jehl, Todd Parker, Maggie Costello Wachs (http://www.filamentgroup.com)
         *
         * Copyright (c) 2008 Filament Group
         * Licensed under GPL (http://www.opensource.org/licenses/gpl-license.php)
         *
         * Description: Compares the heights or widths of the top-level children of a provided element 
                and sets their min-height to the tallest height (or width to widest width). Sets in em units 
                by default if pxToEm() method is available.
         * Dependencies: jQuery library, pxToEm method	(article: 
                http://www.filamentgroup.com/lab/retaining_scalable_interfaces_with_pixel_to_em_conversion/)							  
         * Usage Example: $(element).equalHeights();
                Optional: to set min-height in px, pass a true argument: $(element).equalHeights(true);
         * Version: 2.1, 18.12.2008
         *
         * Note: Changed pxToEm call to call $.pxToEm instead, jsLinted (Maxime Haineault <haineault@gmail.com>)
        --------------------------------------------------------------------*/

        equalHeights: function(px){
            $(this).each(function(){
                var currentTallest = 0;
                $(this).children().each(function(i){
                    if ($(this).height() > currentTallest) { currentTallest = $(this).height(); }
                });
                if (!px || !$.pxToEm) { currentTallest = $.pxToEm(currentTallest); } //use ems unless px is specified
                // for ie6, set height since min-height isn't supported
                if ($.browser.msie && $.browser.version == 6.0) { $(this).children().css({'height': currentTallest}); }
                $(this).children().css({'min-height': currentTallest}); 
            });
            return this;
        },

        // Copyright (c) 2009 James Padolsey
        // http://james.padolsey.com/javascript/jquery-delay-plugin/
        delay: function(time, callback){
            jQuery.fx.step.delay = function(){};
            return this.animate({delay:1}, time, callback);
        }        
	});
})(jQuery);
/*
  jQuery strings - 0.3
  http://code.google.com/p/jquery-utils/
  
  (c) Maxime Haineault <haineault@gmail.com>
  http://haineault.com   

  MIT License (http://www.opensource.org/licenses/mit-license.php)

  Implementation of Python3K advanced string formatting
  http://www.python.org/dev/peps/pep-3101/

  Documentation: http://code.google.com/p/jquery-utils/wiki/StringFormat
  
*/
(function($){
    var strings = {
        strConversion: {
            // tries to translate any objects type into string gracefully
            __repr: function(i){
                switch(this.__getType(i)) {
                    case 'array':case 'date':case 'number':
                        return i.toString();
                    case 'object': 
                        var o = [];
                        for (x=0; x<i.length; i++) { o.push(i+': '+ this.__repr(i[x])); }
                        return o.join(', ');
                    case 'string': 
                        return i;
                    default: 
                        return i;
                }
            },
            // like typeof but less vague
            __getType: function(i) {
                if (!i || !i.constructor) { return typeof(i); }
                var match = i.constructor.toString().match(/Array|Number|String|Object|Date/);
                return match && match[0].toLowerCase() || typeof(i);
            },
            //+ Jonas Raoni Soares Silva
            // the @ sign next to "//" is interpreted by IE when using cc<underscore>on! Inserted a space.
            //  @ http://jsfromhell.com/string/pad [v1.0]
            __pad: function(str, l, s, t){
                var p = s || ' ';
                var o = str;
                if (l - str.length > 0) {
                    o = new Array(Math.ceil(l / p.length)).join(p).substr(0, t = !t ? l : t == 1 ? 0 : Math.ceil(l / 2)) + str + p.substr(0, l - t);
                }
                return o;
            },
            __getInput: function(arg, args) {
                 var key = arg.getKey();
                switch(this.__getType(args)){
                    case 'object': // Thanks to Jonathan Works for the patch
                        var keys = key.split('.');
                        var obj = args;
                        for(var subkey = 0; subkey < keys.length; subkey++){
                            obj = obj[keys[subkey]];
                        }
                        if (typeof(obj) != 'undefined') {
                            if (strings.strConversion.__getType(obj) == 'array') {
                                return arg.getFormat().match(/\.\*/) && obj[1] || obj;
                            }
                            return obj;
                        }
                        else {
                            // TODO: try by numerical index                    
                        }
                    break;
                    case 'array': 
                        key = parseInt(key, 10);
                        if (arg.getFormat().match(/\.\*/) && typeof args[key+1] != 'undefined') { return args[key+1]; }
                        else if (typeof args[key] != 'undefined') { return args[key]; }
                        else { return key; }
                    break;
                }
                return '{'+key+'}';
            },
            __formatToken: function(token, args) {
                var arg   = new Argument(token, args);
                return strings.strConversion[arg.getFormat().slice(-1)](this.__getInput(arg, args), arg);
            },

            // Signed integer decimal.
            d: function(input, arg){
                var o = parseInt(input, 10); // enforce base 10
                var p = arg.getPaddingLength();
                if (p) { return this.__pad(o.toString(), p, arg.getPaddingString(), 0); }
                else   { return o; }
            },
            // Signed integer decimal.
            i: function(input, args){ 
                return this.d(input, args);
            },
            // Unsigned octal
            o: function(input, arg){ 
                var o = input.toString(8);
                if (arg.isAlternate()) { o = this.__pad(o, o.length+1, '0', 0); }
                return this.__pad(o, arg.getPaddingLength(), arg.getPaddingString(), 0);
            },
            // Unsigned decimal
            u: function(input, args) {
                return Math.abs(this.d(input, args));
            },
            // Unsigned hexadecimal (lowercase)
            x: function(input, arg){
                var o = parseInt(input, 10).toString(16);
                o = this.__pad(o, arg.getPaddingLength(), arg.getPaddingString(),0);
                return arg.isAlternate() ? '0x'+o : o;
            },
            // Unsigned hexadecimal (uppercase)
            X: function(input, arg){
                return this.x(input, arg).toUpperCase();
            },
            // Floating point exponential format (lowercase)
            e: function(input, arg){
                return parseFloat(input, 10).toExponential(arg.getPrecision());
            },
            // Floating point exponential format (uppercase)
            E: function(input, arg){
                return this.e(input, arg).toUpperCase();
            },
            // Floating point decimal format
            f: function(input, arg){
                return this.__pad(parseFloat(input, 10).toFixed(arg.getPrecision()), arg.getPaddingLength(), arg.getPaddingString(),0);
            },
            // Floating point decimal format (alias)
            F: function(input, args){
                return this.f(input, args);
            },
            // Floating point format. Uses exponential format if exponent is greater than -4 or less than precision, decimal format otherwise
            g: function(input, arg){
                var o = parseFloat(input, 10);
                return (o.toString().length > 6) ? Math.round(o.toExponential(arg.getPrecision())): o;
            },
            // Floating point format. Uses exponential format if exponent is greater than -4 or less than precision, decimal format otherwise
            G: function(input, args){
                return this.g(input, args);
            },
            // Single character (accepts integer or single character string). 	
            c: function(input, args) {
                var match = input.match(/\w|\d/);
                return match && match[0] || '';
            },
            // String (converts any JavaScript object to anotated format)
            r: function(input, args) {
                return this.__repr(input);
            },
            // String (converts any JavaScript object using object.toString())
            s: function(input, args) {
                return input.toString && input.toString() || ''+input;
            }
        },

        format: function(str, args) {
            var end    = 0;
            var start  = 0;
            var match  = false;
            var buffer = [];
            var token  = '';
            var tmp    = (str||'').split('');
            for(start=0; start < tmp.length; start++) {
                if (tmp[start] == '{' && tmp[start+1] !='{') {
                    end   = str.indexOf('}', start);
                    token = tmp.slice(start+1, end).join('');
                    if (tmp[start-1] != '{' && tmp[end+1] != '}') {
                        var tokenArgs = (typeof arguments[1] != 'object')? arguments2Array(arguments, 2): args || [];
                        buffer.push(strings.strConversion.__formatToken(token, tokenArgs));
                    }
                    else {
                        buffer.push(token);
                    }
                }
                else if (start > end || buffer.length < 1) { buffer.push(tmp[start]); }
            }
            return (buffer.length > 1)? buffer.join(''): buffer[0];
        },

        calc: function(str, args) {
            return eval(format(str, args));
        },

        repeat: function(s, n) { 
            return new Array(n+1).join(s); 
        },

        UTF8encode: function(s) { 
            return unescape(encodeURIComponent(s)); 
        },

        UTF8decode: function(s) { 
            return decodeURIComponent(escape(s)); 
        },

        tpl: function() {
            var out = '';
            var render = true;
            // Set
            // $.tpl('ui.test', ['<span>', helloWorld ,'</span>']);
            if (arguments.length == 2 && $.isArray(arguments[1])) {
                this[arguments[0]] = arguments[1].join('');
                return $(this[arguments[0]]);
            }
            // $.tpl('ui.test', '<span>hello world</span>');
            if (arguments.length == 2 && $.isString(arguments[1])) {
                this[arguments[0]] = arguments[1];
                return $(this[arguments[0]]);
            }
            // Call
            // $.tpl('ui.test');
            if (arguments.length == 1) {
                return $(this[arguments[0]]);
            }
            // $.tpl('ui.test', false);
            if (arguments.length == 2 && arguments[1] == false) {
                return this[arguments[0]];
            }
            // $.tpl('ui.test', {value:blah});
            if (arguments.length == 2 && $.isObject(arguments[1])) {
                return $($.format(this[arguments[0]], arguments[1]));
            }
            // $.tpl('ui.test', {value:blah}, false);
            if (arguments.length == 3 && $.isObject(arguments[1])) {
                return (arguments[2] == true) 
                    ? $.format(this[arguments[0]], arguments[1])
                    : $($.format(this[arguments[0]], arguments[1]));
            }
        }
    };

    var Argument = function(arg, args) {
        this.__arg  = arg;
        this.__args = args;
        this.__max_precision = parseFloat('1.'+ (new Array(32)).join('1'), 10).toString().length-3;
        this.__def_precision = 6;
        this.getString = function(){
            return this.__arg;
        };
        this.getKey = function(){
            return this.__arg.split(':')[0];
        };
        this.getFormat = function(){
            var match = this.getString().split(':');
            return (match && match[1])? match[1]: 's';
        };
        this.getPrecision = function(){
            var match = this.getFormat().match(/\.(\d+|\*)/g);
            if (!match) { return this.__def_precision; }
            else {
                match = match[0].slice(1);
                if (match != '*') { return parseInt(match, 10); }
                else if(strings.strConversion.__getType(this.__args) == 'array') {
                    return this.__args[1] && this.__args[0] || this.__def_precision;
                }
                else if(strings.strConversion.__getType(this.__args) == 'object') {
                    return this.__args[this.getKey()] && this.__args[this.getKey()][0] || this.__def_precision;
                }
                else { return this.__def_precision; }
            }
        };
        this.getPaddingLength = function(){
            var match = false;
            if (this.isAlternate()) {
                match = this.getString().match(/0?#0?(\d+)/);
                if (match && match[1]) { return parseInt(match[1], 10); }
            }
            match = this.getString().match(/(0|\.)(\d+|\*)/g);
            return match && parseInt(match[0].slice(1), 10) || 0;
        };
        this.getPaddingString = function(){
            var o = '';
            if (this.isAlternate()) { o = ' '; }
            // 0 take precedence on alternate format
            if (this.getFormat().match(/#0|0#|^0|\.\d+/)) { o = '0'; }
            return o;
        };
        this.getFlags = function(){
            var match = this.getString().matc(/^(0|\#|\-|\+|\s)+/);
            return match && match[0].split('') || [];
        };
        this.isAlternate = function() {
            return !!this.getFormat().match(/^0?#/);
        };
    };

    var arguments2Array = function(args, shift) {
        var o = [];
        for (l=args.length, x=(shift || 0)-1; x<l;x++) { o.push(args[x]); }
        return o;
    };
    $.extend(strings);
})(jQuery);
/*
  jQuery anchor handler - 0.5
  http://code.google.com/p/jquery-utils/

  (c) Maxime Haineault <haineault@gmail.com>
  http://haineault.com   

  MIT License (http://www.opensource.org/licenses/mit-license.php)

*/

(function($){
    var hash = window.location.hash;
    var handlers  = [];
    var opt = {};

	$.extend({
		anchorHandler: {
            apply: function() {
                $.map(handlers, function(handler){
                    var match = hash.match(handler.r) && hash.match(handler.r)[0] || false;
                    if (match)  { handler.cb.apply($('a[href*='+match+']').get(0), [handler.r, hash || '']); }
                });
                return $.anchorHandler;
            },
			add: function(regexp, callback, options) {
                var opt  = $.extend({handleClick: true, preserveHash: true}, options);
                if (opt.handleClick) { 
                    $('a[href*=#]').each(function(i, a){
                        if (a.href.match(regexp)) {
                            $(a).bind('click.anchorHandler', function(){
                                if (opt.preserveHash) { window.location.hash = a.hash; }
                                return callback.apply(this, [regexp, a.href]);
                                });
                        }
                    }); 
                }
				handlers.push({r: regexp, cb: callback});
                $($.anchorHandler.apply);
				return $.anchorHandler;
			}
		}
	});
})(jQuery);
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};
/*
  jQuery countdown - 0.2
  http://code.google.com/p/jquery-utils/

  (c) Maxime Haineault <haineault@gmail.com>
  http://haineault.com   

  MIT License (http://www.opensource.org/licenses/mit-license.php)
  
*/

(function($) {
    function countdown(el, options) {
        var calc = function (target, current) {
            /* Return true if the target date has arrived,
             * an object of the time left otherwise.
             */
            var current = current || new Date();
            if (current >= target) { return true; }

            var o = {};
            var remain = Math.floor((target.getTime() - current.getTime()) / 1000);

            o.days = Math.floor(remain / 86400);
            remain %= 86400;
            o.hours = Math.floor(remain / 3600);
            remain %= 3600;
            o.minutes = Math.floor(remain / 60);
            remain %= 60;
            o.seconds = remain;
            o.years = Math.floor(o.days / 365);
            o.months = Math.floor(o.days / 30);
            o.weeks = Math.floor(o.days / 7);

            return o;
        };

        var getWeek = function(date) { 
            var onejan = new Date(date.getFullYear(),0,1);
            return Math.ceil((((date - onejan) / 86400000) + onejan.getDay())/7);
        };

        var options = $.extend({
            date: new Date(),
            modifiers: [],
            interval: 1000,
            msgFormat: '%d [day|days] %hh %mm %ss',
            msgNow: 'Now !'
        }, options);

        var tokens = {
            y: new RegExp ('\\%y(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // years 
            M: new RegExp ('\\%M(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // months 
            w: new RegExp ('\\%w(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // weeks
            d: new RegExp ('\\%d(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // days
            h: new RegExp ('\\%h(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // hours
            m: new RegExp ('\\%m(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // minutes
            s: new RegExp ('\\%s(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g')  // seconds
        };

        var formatToken = function(str, token, val) {
            return (!tokens[token])? '': str.match(/\[|\]/g) 
                    && (str.replace(tokens[token], val+'$1'+ ((parseInt(val, 10)<2)?'$2':'$3')) || '')
                    || str.replace('%'+token, val);
        };

        var format = function(str, obj) {
            var o = str;
            o = formatToken(o, 'y', obj.years);
            o = formatToken(o, 'M', obj.months);
            o = formatToken(o, 'w', obj.weeks);
            o = formatToken(o, 'd', obj.days);
            o = formatToken(o, 'h', obj.hours);
            o = formatToken(o, 'm', obj.minutes);
            o = formatToken(o, 's', obj.seconds);
            return o;
        };

        var update = function() {
            var date_obj = calc(cd.date);
            if (date_obj === true) {
                cd.stop(); clearInterval(cd.id);
                $(cd.el).html(options.msgNow);
                return true;
            }
            else {
                $(cd.el).text(format(options.msgFormat, date_obj));
            }
        };

        var apply_modifiers = function (modifiers, date) {
            if (modifiers.length === 0) {
                return date;
            }

            var modifier_re = /^([+-]\d+)([yMdhms])$/;
            var conversions = {
                s: 1000,
                m: 60 * 1000,
                h: 60 * 60 * 1000,
                d: 24 * 60 * 60 * 1000,
                M: 30 * 24 * 60 * 60 * 1000,
                y: 365 * 24 * 60 * 60 * 1000
            };

            var displacement = 0;
            for (var i = 0, n = modifiers.length; i < n; ++i) {
                var match = modifiers[i].match(modifier_re);
                if (match !== null) {
                    displacement += parseInt(match[1], 10) * conversions[match[2]];
                }
            }
            return new Date(date.getTime() + displacement);
        };

        var cd = {
            id    : setInterval(update, options.interval),
            el    : el,
            start : function(){ return new countdown($(this.el), options); },
            stop  : function(){ return clearInterval(this.id); },
            date  : apply_modifiers(options.modifiers, options.date)
        };
        $(el).data('countdown', cd);
        update();
        return $(el).data('countdown');
    }
    $.fn.countdown = function(args) { if(this.get(0)) return new countdown(this.get(0), args); };
})(jQuery);
/*
 * jQuery Cycle Plugin for light-weight slideshows
 * Examples and documentation at: http://malsup.com/jquery/cycle/
 * Copyright (c) 2007-2008 M. Alsup
 * Version: 2.24 (07/30/2008)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * Requires: jQuery v1.2.3 or later
 *
 * Based on the work of:
 *  1) Matt Oakes (http://portfolio.gizone.co.uk/applications/slideshow/)
 *  2) Torsten Baldes (http://medienfreunde.com/lab/innerfade/)
 *  3) Benjamin Sterling (http://www.benjaminsterling.com/experiments/jqShuffle/)
 */
;(function($) {

var ver = '2.24';
var ie6 = $.browser.msie && /MSIE 6.0/.test(navigator.userAgent);

function log() {
    if (window.console && window.console.log)
        window.console.log('[cycle] ' + Array.prototype.join.call(arguments,''));
};

$.fn.cycle = function(options) {
    return this.each(function() {
        if (options === undefined || options === null)
            options = {};
        if (options.constructor == String) {
            switch(options) {
            case 'stop':
                if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
                this.cycleTimeout = 0;
                $(this).data('cycle.opts', '');
                return;
            case 'pause':
                this.cyclePause = 1;
                return;
            case 'resume':
                this.cyclePause = 0;
                return;
            default:
                options = { fx: options };
            };
        }
        else if (options.constructor == Number) {
            // go to the requested slide slide
            var num = options;
            options = $(this).data('cycle.opts');
            if (!options) {
                log('options not found, can not advance slide');
                return;
            }
            if (num < 0 || num >= options.elements.length) {
                log('invalid slide index: ' + num);
                return;
            }
            options.nextSlide = num;
            if (this.cycleTimeout) {
                clearTimeout(this.cycleTimeout);
                this.cycleTimeout = 0;
            }            
            go(options.elements, options, 1, 1);
            return;
        }

        // stop existing slideshow for this container (if there is one)
        if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
        this.cycleTimeout = 0;
        this.cyclePause = 0;
        
        var $cont = $(this);
        var $slides = options.slideExpr ? $(options.slideExpr, this) : $cont.children();
        var els = $slides.get();
        if (els.length < 2) {
            log('terminating; too few slides: ' + els.length);
            return; // don't bother
        }

        // support metadata plugin (v1.0 and v2.0)
        var opts = $.extend({}, $.fn.cycle.defaults, options || {}, $.metadata ? $cont.metadata() : $.meta ? $cont.data() : {});
        if (opts.autostop) 
            opts.countdown = opts.autostopCount || els.length;

        $cont.data('cycle.opts', opts);
        opts.container = this;

        opts.elements = els;
        opts.before = opts.before ? [opts.before] : [];
        opts.after = opts.after ? [opts.after] : [];
        opts.after.unshift(function(){ opts.busy=0; });
        if (opts.continuous)
            opts.after.push(function() { go(els,opts,0,!opts.rev); });
            
        // clearType corrections
        if (ie6 && opts.cleartype && !opts.cleartypeNoBg)
            clearTypeFix($slides);

        // allow shorthand overrides of width, height and timeout
        var cls = this.className;
        opts.width = parseInt((cls.match(/w:(\d+)/)||[])[1]) || opts.width;
        opts.height = parseInt((cls.match(/h:(\d+)/)||[])[1]) || opts.height;
        opts.timeout = parseInt((cls.match(/t:(\d+)/)||[])[1]) || opts.timeout;

        if ($cont.css('position') == 'static') 
            $cont.css('position', 'relative');
        if (opts.width) 
            $cont.width(opts.width);
        if (opts.height && opts.height != 'auto') 
            $cont.height(opts.height);

        if (opts.random) {
            opts.randomMap = [];
            for (var i = 0; i < els.length; i++) 
                opts.randomMap.push(i);
            opts.randomMap.sort(function(a,b) {return Math.random() - 0.5;});
            opts.randomIndex = 0;
            opts.startingSlide = opts.randomMap[0];
        }
        else if (opts.startingSlide >= els.length)
            opts.startingSlide = 0; // catch bogus input
        var first = opts.startingSlide || 0;
        $slides.css({position: 'absolute', top:0, left:0}).hide().each(function(i) { 
            var z = first ? i >= first ? els.length - (i-first) : first-i : els.length-i;
            $(this).css('z-index', z) 
        });
        
        $(els[first]).css('opacity',1).show(); // opacity bit needed to handle reinit case
        if ($.browser.msie) els[first].style.removeAttribute('filter');

        if (opts.fit && opts.width) 
            $slides.width(opts.width);
        if (opts.fit && opts.height && opts.height != 'auto') 
            $slides.height(opts.height);
        if (opts.pause) 
            $cont.hover(function(){this.cyclePause=1;},function(){this.cyclePause=0;});

        // run transition init fn
        var init = $.fn.cycle.transitions[opts.fx];
        if ($.isFunction(init))
            init($cont, $slides, opts);
        else if (opts.fx != 'custom')
            log('unknown transition: ' + opts.fx);
        
        $slides.each(function() {
            var $el = $(this);
            this.cycleH = (opts.fit && opts.height) ? opts.height : $el.height();
            this.cycleW = (opts.fit && opts.width) ? opts.width : $el.width();
        });

        opts.cssBefore = opts.cssBefore || {};
        opts.animIn = opts.animIn || {};
        opts.animOut = opts.animOut || {};

        $slides.not(':eq('+first+')').css(opts.cssBefore);
        if (opts.cssFirst)
            $($slides[first]).css(opts.cssFirst);

        if (opts.timeout) {
            // ensure that timeout and speed settings are sane
            if (opts.speed.constructor == String)
                opts.speed = {slow: 600, fast: 200}[opts.speed] || 400;
            if (!opts.sync)
                opts.speed = opts.speed / 2;
            while((opts.timeout - opts.speed) < 250)
                opts.timeout += opts.speed;
        }
        if (opts.easing) 
            opts.easeIn = opts.easeOut = opts.easing;
        if (!opts.speedIn) 
            opts.speedIn = opts.speed;
        if (!opts.speedOut) 
            opts.speedOut = opts.speed;

 		opts.slideCount = els.length;
        opts.currSlide = first;
        if (opts.random) {
            opts.nextSlide = opts.currSlide;
            if (++opts.randomIndex == els.length) 
                opts.randomIndex = 0;
            opts.nextSlide = opts.randomMap[opts.randomIndex];
        }
        else
            opts.nextSlide = opts.startingSlide >= (els.length-1) ? 0 : opts.startingSlide+1;

        // fire artificial events
        var e0 = $slides[first];
        if (opts.before.length)
            opts.before[0].apply(e0, [e0, e0, opts, true]);
        if (opts.after.length > 1)
            opts.after[1].apply(e0, [e0, e0, opts, true]);
        
        if (opts.click && !opts.next)
            opts.next = opts.click;
        if (opts.next)
            $(opts.next).bind('click', function(){return advance(els,opts,opts.rev?-1:1)});
        if (opts.prev)
            $(opts.prev).bind('click', function(){return advance(els,opts,opts.rev?1:-1)});
        if (opts.pager)
            buildPager(els,opts);

        // expose fn for adding slides after the show has started
        opts.addSlide = function(newSlide) {
            var $s = $(newSlide), s = $s[0];
            if (!opts.autostopCount)
                opts.countdown++;
            els.push(s);
            if (opts.els) 
                opts.els.push(s); // shuffle needs this
            opts.slideCount = els.length;
            
            $s.css('position','absolute').appendTo($cont);
            
            if (ie6 && opts.cleartype && !opts.cleartypeNoBg)
                clearTypeFix($s);

            if (opts.fit && opts.width) 
                $s.width(opts.width);
            if (opts.fit && opts.height && opts.height != 'auto') 
                $slides.height(opts.height);
            s.cycleH = (opts.fit && opts.height) ? opts.height : $s.height();
            s.cycleW = (opts.fit && opts.width) ? opts.width : $s.width();

            $s.css(opts.cssBefore);

            if (opts.pager)
                $.fn.cycle.createPagerAnchor(els.length-1, s, $(opts.pager), els, opts);
            
            if (typeof opts.onAddSlide == 'function')
                opts.onAddSlide($s);
        };

        if (opts.timeout || opts.continuous)
            this.cycleTimeout = setTimeout(
                function(){go(els,opts,0,!opts.rev)}, 
                opts.continuous ? 10 : opts.timeout + (opts.delay||0));
    });
};

function go(els, opts, manual, fwd) {
    if (opts.busy) return;
    var p = opts.container, curr = els[opts.currSlide], next = els[opts.nextSlide];
    if (p.cycleTimeout === 0 && !manual) 
        return;

    if (!manual && !p.cyclePause && 
        ((opts.autostop && (--opts.countdown <= 0)) ||
        (opts.nowrap && !opts.random && opts.nextSlide < opts.currSlide))) {
        if (opts.end)
            opts.end(opts);
        return;
    }

    if (manual || !p.cyclePause) {
        if (opts.before.length)
            $.each(opts.before, function(i,o) { o.apply(next, [curr, next, opts, fwd]); });
        var after = function() {
            if ($.browser.msie && opts.cleartype)
                this.style.removeAttribute('filter');
            $.each(opts.after, function(i,o) { o.apply(next, [curr, next, opts, fwd]); });
        };

        if (opts.nextSlide != opts.currSlide) {
            opts.busy = 1;
            if (opts.fxFn)
                opts.fxFn(curr, next, opts, after, fwd);
            else if ($.isFunction($.fn.cycle[opts.fx]))
                $.fn.cycle[opts.fx](curr, next, opts, after);
            else
                $.fn.cycle.custom(curr, next, opts, after);
        }
        if (opts.random) {
            opts.currSlide = opts.nextSlide;
            if (++opts.randomIndex == els.length) 
                opts.randomIndex = 0;
            opts.nextSlide = opts.randomMap[opts.randomIndex];
        }
        else { // sequence
            var roll = (opts.nextSlide + 1) == els.length;
            opts.nextSlide = roll ? 0 : opts.nextSlide+1;
            opts.currSlide = roll ? els.length-1 : opts.nextSlide-1;
        }
        if (opts.pager)
            $.fn.cycle.updateActivePagerLink(opts.pager, opts.currSlide);
    }
    if (opts.timeout && !opts.continuous)
        p.cycleTimeout = setTimeout(function() { go(els,opts,0,!opts.rev) }, opts.timeout);
    else if (opts.continuous && p.cyclePause) 
        p.cycleTimeout = setTimeout(function() { go(els,opts,0,!opts.rev) }, 10);
};

$.fn.cycle.updateActivePagerLink = function(pager, currSlide) {
    $(pager).find('a').removeClass('activeSlide').filter('a:eq('+currSlide+')').addClass('activeSlide');
};

// advance slide forward or back
function advance(els, opts, val) {
    var p = opts.container, timeout = p.cycleTimeout;
    if (timeout) {
        clearTimeout(timeout);
        p.cycleTimeout = 0;
    }
    if (opts.random && val < 0) {
        // move back to the previously display slide
        opts.randomIndex--;
        if (--opts.randomIndex == -2)
            opts.randomIndex = els.length-2;
        else if (opts.randomIndex == -1)
            opts.randomIndex = els.length-1;
        opts.nextSlide = opts.randomMap[opts.randomIndex];
    }
    else if (opts.random) {
        if (++opts.randomIndex == els.length) 
            opts.randomIndex = 0;
        opts.nextSlide = opts.randomMap[opts.randomIndex];
    }
    else {
        opts.nextSlide = opts.currSlide + val;
        if (opts.nextSlide < 0) {
            if (opts.nowrap) return false;
            opts.nextSlide = els.length - 1;
        }
        else if (opts.nextSlide >= els.length) {
            if (opts.nowrap) return false;
            opts.nextSlide = 0;
        }
    }
    
log('nextSlide: ' + opts.nextSlide + '; randomIndex: ' + opts.randomIndex);    
    if (opts.prevNextClick && typeof opts.prevNextClick == 'function')
        opts.prevNextClick(val > 0, opts.nextSlide, els[opts.nextSlide]);
    go(els, opts, 1, val>=0);
    return false;
};

function buildPager(els, opts) {
    var $p = $(opts.pager);
    $.each(els, function(i,o) {
        $.fn.cycle.createPagerAnchor(i,o,$p,els,opts);
    });
   $.fn.cycle.updateActivePagerLink(opts.pager, opts.startingSlide);
};

$.fn.cycle.createPagerAnchor = function(i, el, $p, els, opts) {
    var $a = (typeof opts.pagerAnchorBuilder == 'function')
        ? $(opts.pagerAnchorBuilder(i,el))
        : $('<a href="#">'+(i+1)+'</a>');
    
    // don't reparent if anchor is in the dom
    if ($a.parents('body').length == 0)
        $a.appendTo($p);
        
    $a.bind(opts.pagerEvent, function() {
        opts.nextSlide = i;
        var p = opts.container, timeout = p.cycleTimeout;
        if (timeout) {
            clearTimeout(timeout);
            p.cycleTimeout = 0;
        }            
        if (typeof opts.pagerClick == 'function')
            opts.pagerClick(opts.nextSlide, els[opts.nextSlide]);
        go(els,opts,1,opts.currSlide < i);
        return false;
    });
};


// this fixes clearType problems in ie6 by setting an explicit bg color
function clearTypeFix($slides) {
    function hex(s) {
        var s = parseInt(s).toString(16);
        return s.length < 2 ? '0'+s : s;
    };
    function getBg(e) {
        for ( ; e && e.nodeName.toLowerCase() != 'html'; e = e.parentNode) {
            var v = $.css(e,'background-color');
            if (v.indexOf('rgb') >= 0 ) { 
                var rgb = v.match(/\d+/g); 
                return '#'+ hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);
            }
            if (v && v != 'transparent')
                return v;
        }
        return '#ffffff';
    };
    $slides.each(function() { $(this).css('background-color', getBg(this)); });
};


$.fn.cycle.custom = function(curr, next, opts, cb) {
    var $l = $(curr), $n = $(next);
    $n.css(opts.cssBefore);
    var fn = function() {$n.animate(opts.animIn, opts.speedIn, opts.easeIn, cb)};
    $l.animate(opts.animOut, opts.speedOut, opts.easeOut, function() {
        if (opts.cssAfter) $l.css(opts.cssAfter);
        if (!opts.sync) fn();
    });
    if (opts.sync) fn();
};

$.fn.cycle.transitions = {
    fade: function($cont, $slides, opts) {
        $slides.not(':eq('+opts.startingSlide+')').css('opacity',0);
        opts.before.push(function() { $(this).show() });
        opts.animIn    = { opacity: 1 };
        opts.animOut   = { opacity: 0 };
        opts.cssBefore = { opacity: 0 };
        opts.cssAfter  = { display: 'none' };
    }
};

$.fn.cycle.ver = function() { return ver; };

// override these globally if you like (they are all optional)
$.fn.cycle.defaults = {
    fx:           'fade', // one of: fade, shuffle, zoom, scrollLeft, etc
    timeout:       4000,  // milliseconds between slide transitions (0 to disable auto advance)
    continuous:    0,     // true to start next transition immediately after current one completes
    speed:         1000,  // speed of the transition (any valid fx speed value)
    speedIn:       null,  // speed of the 'in' transition
    speedOut:      null,  // speed of the 'out' transition
    next:          null,  // id of element to use as click trigger for next slide
    prev:          null,  // id of element to use as click trigger for previous slide
    prevNextClick: null,  // callback fn for prev/next clicks:  function(isNext, zeroBasedSlideIndex, slideElement)
    pager:         null,  // id of element to use as pager container
    pagerClick:    null,  // callback fn for pager clicks:  function(zeroBasedSlideIndex, slideElement)
    pagerEvent:   'click', // event which drives the pager navigation
    pagerAnchorBuilder: null, // callback fn for building anchor links
    before:        null,  // transition callback (scope set to element to be shown)
    after:         null,  // transition callback (scope set to element that was shown)
    end:           null,  // callback invoked when the slideshow terminates (use with autostop or nowrap options)
    easing:        null,  // easing method for both in and out transitions
    easeIn:        null,  // easing for "in" transition
    easeOut:       null,  // easing for "out" transition
    shuffle:       null,  // coords for shuffle animation, ex: { top:15, left: 200 }
    animIn:        null,  // properties that define how the slide animates in
    animOut:       null,  // properties that define how the slide animates out
    cssBefore:     null,  // properties that define the initial state of the slide before transitioning in
    cssAfter:      null,  // properties that defined the state of the slide after transitioning out
    fxFn:          null,  // function used to control the transition
    height:       'auto', // container height
    startingSlide: 0,     // zero-based index of the first slide to be displayed
    sync:          1,     // true if in/out transitions should occur simultaneously
    random:        0,     // true for random, false for sequence (not applicable to shuffle fx)
    fit:           0,     // force slides to fit container
    pause:         0,     // true to enable "pause on hover"
    autostop:      0,     // true to end slideshow after X transitions (where X == slide count)
    autostopCount: 0,     // number of transitions (optionally used with autostop to define X)
    delay:         0,     // additional delay (in ms) for first transition (hint: can be negative)
    slideExpr:     null,  // expression for selecting slides (if something other than all children is required)
    cleartype:     0,     // true if clearType corrections should be applied (for IE)
    nowrap:        0      // true to prevent slideshow from wrapping
};

})(jQuery);


/*
 * jQuery Cycle Plugin Transition Definitions
 * This script is a plugin for the jQuery Cycle Plugin
 * Examples and documentation at: http://malsup.com/jquery/cycle/
 * Copyright (c) 2007-2008 M. Alsup
 * Version:  2.22
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 */
(function($) {

//
// These functions define one-time slide initialization for the named
// transitions. To save file size feel free to remove any of these that you 
// don't need.
//

// scrollUp/Down/Left/Right
$.fn.cycle.transitions.scrollUp = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.top = next.offsetHeight;
        opts.animOut.top = 0-curr.offsetHeight;
    });
    opts.cssFirst = { top: 0 };
    opts.animIn   = { top: 0 };
    opts.cssAfter = { display: 'none' };
};
$.fn.cycle.transitions.scrollDown = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.top = 0-next.offsetHeight;
        opts.animOut.top = curr.offsetHeight;
    });
    opts.cssFirst = { top: 0 };
    opts.animIn   = { top: 0 };
    opts.cssAfter = { display: 'none' };
};
$.fn.cycle.transitions.scrollLeft = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.left = next.offsetWidth;
        opts.animOut.left = 0-curr.offsetWidth;
    });
    opts.cssFirst = { left: 0 };
    opts.animIn   = { left: 0 };
};
$.fn.cycle.transitions.scrollRight = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.left = 0-next.offsetWidth;
        opts.animOut.left = curr.offsetWidth;
    });
    opts.cssFirst = { left: 0 };
    opts.animIn   = { left: 0 };
};
$.fn.cycle.transitions.scrollHorz = function($cont, $slides, opts) {
    $cont.css('overflow','hidden').width();
//    $slides.show();
    opts.before.push(function(curr, next, opts, fwd) {
        $(this).show();
        var currW = curr.offsetWidth, nextW = next.offsetWidth;
        opts.cssBefore = fwd ? { left: nextW } : { left: -nextW };
        opts.animIn.left = 0;
        opts.animOut.left = fwd ? -currW : currW;
        $slides.not(curr).css(opts.cssBefore);
    });
    opts.cssFirst = { left: 0 };
    opts.cssAfter = { display: 'none' }
};
$.fn.cycle.transitions.scrollVert = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
//    $slides.show();
    opts.before.push(function(curr, next, opts, fwd) {
        $(this).show();
        var currH = curr.offsetHeight, nextH = next.offsetHeight;
        opts.cssBefore = fwd ? { top: -nextH } : { top: nextH };
        opts.animIn.top = 0;
        opts.animOut.top = fwd ? currH : -currH;
        $slides.not(curr).css(opts.cssBefore);
    });
    opts.cssFirst = { top: 0 };
    opts.cssAfter = { display: 'none' }
};

// slideX/slideY
$.fn.cycle.transitions.slideX = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { zIndex: 2 };
    opts.animIn  = { width: 'show' };
    opts.animOut = { width: 'hide' };
};
$.fn.cycle.transitions.slideY = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { zIndex: 2 };
    opts.animIn  = { height: 'show' };
    opts.animOut = { height: 'hide' };
};

// shuffle
$.fn.cycle.transitions.shuffle = function($cont, $slides, opts) {
    var w = $cont.css('overflow', 'visible').width();
    $slides.css({left: 0, top: 0});
    opts.before.push(function() { $(this).show() });
    opts.speed = opts.speed / 2; // shuffle has 2 transitions        
    opts.random = 0;
    opts.shuffle = opts.shuffle || {left:-w, top:15};
    opts.els = [];
    for (var i=0; i < $slides.length; i++)
        opts.els.push($slides[i]);

    for (var i=0; i < opts.startingSlide; i++)
        opts.els.push(opts.els.shift());

    // custom transition fn (hat tip to Benjamin Sterling for this bit of sweetness!)
    opts.fxFn = function(curr, next, opts, cb, fwd) {
        var $el = fwd ? $(curr) : $(next);
        $el.animate(opts.shuffle, opts.speedIn, opts.easeIn, function() {
            fwd ? opts.els.push(opts.els.shift()) : opts.els.unshift(opts.els.pop());
            if (fwd) 
                for (var i=0, len=opts.els.length; i < len; i++)
                    $(opts.els[i]).css('z-index', len-i);
            else {
                var z = $(curr).css('z-index');
                $el.css('z-index', parseInt(z)+1);
            }
            $el.animate({left:0, top:0}, opts.speedOut, opts.easeOut, function() {
                $(fwd ? this : curr).hide();
                if (cb) cb();
            });
        });
    };
    opts.onAddSlide = function($s) { $s.hide(); };
};

// turnUp/Down/Left/Right
$.fn.cycle.transitions.turnUp = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.top = next.cycleH;
        opts.animIn.height = next.cycleH;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssFirst  = { top: 0 };
    opts.cssBefore = { height: 0 };
    opts.animIn    = { top: 0 };
    opts.animOut   = { height: 0 };
    opts.cssAfter  = { display: 'none' };
};
$.fn.cycle.transitions.turnDown = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.animIn.height = next.cycleH;
        opts.animOut.top   = curr.cycleH;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssFirst  = { top: 0 };
    opts.cssBefore = { top: 0, height: 0 };
    opts.animOut   = { height: 0 };
    opts.cssAfter  = { display: 'none' };
};
$.fn.cycle.transitions.turnLeft = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.left = next.cycleW;
        opts.animIn.width = next.cycleW;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { width: 0 };
    opts.animIn    = { left: 0 };
    opts.animOut   = { width: 0 };
    opts.cssAfter  = { display: 'none' };
};
$.fn.cycle.transitions.turnRight = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.animIn.width = next.cycleW;
        opts.animOut.left = curr.cycleW;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { left: 0, width: 0 };
    opts.animIn    = { left: 0 };
    opts.animOut   = { width: 0 };
    opts.cssAfter  = { display: 'none' };
};

// zoom
$.fn.cycle.transitions.zoom = function($cont, $slides, opts) {
    opts.cssFirst = { top:0, left: 0 }; 
    opts.cssAfter = { display: 'none' };
    
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore = { width: 0, height: 0, top: next.cycleH/2, left: next.cycleW/2 };
        opts.cssAfter  = { display: 'none' };
        opts.animIn    = { top: 0, left: 0, width: next.cycleW, height: next.cycleH };
        opts.animOut   = { width: 0, height: 0, top: curr.cycleH/2, left: curr.cycleW/2 };
        $(curr).css('zIndex',2);
        $(next).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
};

// fadeZoom
$.fn.cycle.transitions.fadeZoom = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { width: 0, height: 0, opacity: 1, left: next.cycleW/2, top: next.cycleH/2, zIndex: 1 };
        opts.animIn    = { top: 0, left: 0, width: next.cycleW, height: next.cycleH };
    });    
    opts.animOut  = { opacity: 0 };
    opts.cssAfter = { zIndex: 0 };
};

// blindX
$.fn.cycle.transitions.blindX = function($cont, $slides, opts) {
    var w = $cont.css('overflow','hidden').width();
    $slides.show();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.cssBefore = { left: w, zIndex: 2 };
    opts.cssAfter = { zIndex: 1 };
    opts.animIn = { left: 0 };
    opts.animOut  = { left: w };
};
// blindY
$.fn.cycle.transitions.blindY = function($cont, $slides, opts) {
    var h = $cont.css('overflow','hidden').height();
    $slides.show();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.cssBefore = { top: h, zIndex: 2 };
    opts.cssAfter = { zIndex: 1 };
    opts.animIn = { top: 0 };
    opts.animOut  = { top: h };
};
// blindZ
$.fn.cycle.transitions.blindZ = function($cont, $slides, opts) {
    var h = $cont.css('overflow','hidden').height();
    var w = $cont.width();
    $slides.show();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.cssBefore = { top: h, left: w, zIndex: 2 };
    opts.cssAfter = { zIndex: 1 };
    opts.animIn = { top: 0, left: 0 };
    opts.animOut  = { top: h, left: w };
};

// growX - grow horizontally from centered 0 width
$.fn.cycle.transitions.growX = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { left: this.cycleW/2, width: 0, zIndex: 2 };
        opts.animIn = { left: 0, width: this.cycleW };
        opts.animOut = { left: 0 };
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide().css('zIndex',1); };
};
// growY - grow vertically from centered 0 height
$.fn.cycle.transitions.growY = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { top: this.cycleH/2, height: 0, zIndex: 2 };
        opts.animIn = { top: 0, height: this.cycleH };
        opts.animOut = { top: 0 };
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide().css('zIndex',1); };
};

// curtainX - squeeze in both edges horizontally
$.fn.cycle.transitions.curtainX = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { left: next.cycleW/2, width: 0, zIndex: 1, display: 'block' };
        opts.animIn = { left: 0, width: this.cycleW };
        opts.animOut = { left: curr.cycleW/2, width: 0 };
        $(curr).css('zIndex',2);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssAfter = { zIndex: 1, display: 'none' };
};
// curtainY - squeeze in both edges vertically
$.fn.cycle.transitions.curtainY = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { top: next.cycleH/2, height: 0, zIndex: 1, display: 'block' };
        opts.animIn = { top: 0, height: this.cycleH };
        opts.animOut = { top: curr.cycleH/2, height: 0 };
        $(curr).css('zIndex',2);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssAfter = { zIndex: 1, display: 'none' };
};

// cover - curr slide covered by next slide
$.fn.cycle.transitions.cover = function($cont, $slides, opts) {
    var d = opts.direction || 'left';
    var w = $cont.css('overflow','hidden').width();
    var h = $cont.height();
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = opts.cssBefore || {};
        opts.cssBefore.zIndex = 2;
        opts.cssBefore.display = 'block';
        
        if (d == 'right') 
            opts.cssBefore.left = -w;
        else if (d == 'up')    
            opts.cssBefore.top = h;
        else if (d == 'down')  
            opts.cssBefore.top = -h;
        else
            opts.cssBefore.left = w;
        $(curr).css('zIndex',1);
    });    
    if (!opts.animIn)  opts.animIn = { left: 0, top: 0 };
    if (!opts.animOut) opts.animOut = { left: 0, top: 0 };
    opts.cssAfter = opts.cssAfter || {};
    opts.cssAfter.zIndex = 2;
    opts.cssAfter.display = 'none';
};

// uncover - curr slide moves off next slide
$.fn.cycle.transitions.uncover = function($cont, $slides, opts) {
    var d = opts.direction || 'left';
    var w = $cont.css('overflow','hidden').width();
    var h = $cont.height();
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore.display = 'block';
        if (d == 'right') 
            opts.animOut.left = w;
        else if (d == 'up')    
            opts.animOut.top = -h;
        else if (d == 'down')  
            opts.animOut.top = h;
        else
            opts.animOut.left = -w;
        $(curr).css('zIndex',2);
        $(next).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    if (!opts.animIn)  opts.animIn = { left: 0, top: 0 };
    opts.cssBefore = opts.cssBefore || {};
    opts.cssBefore.top = 0;
    opts.cssBefore.left = 0;
    
    opts.cssAfter = opts.cssAfter || {};
    opts.cssAfter.zIndex = 1;
    opts.cssAfter.display = 'none';
};

// toss - move top slide and fade away
$.fn.cycle.transitions.toss = function($cont, $slides, opts) {
    var w = $cont.css('overflow','visible').width();
    var h = $cont.height();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',2);
        opts.cssBefore.display = 'block'; 
        // provide default toss settings if animOut not provided
        if (!opts.animOut.left && !opts.animOut.top)
            opts.animOut = { left: w*2, top: -h/2, opacity: 0 };
        else
            opts.animOut.opacity = 0;
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { left: 0, top: 0, zIndex: 1, opacity: 1 };
    opts.animIn = { left: 0 };
    opts.cssAfter = { zIndex: 2, display: 'none' };
};

// wipe - clip animation
$.fn.cycle.transitions.wipe = function($cont, $slides, opts) {
    var w = $cont.css('overflow','hidden').width();
    var h = $cont.height();
    opts.cssBefore = opts.cssBefore || {};
    var clip;
    if (opts.clip) {
        if (/l2r/.test(opts.clip))
            clip = 'rect(0px 0px '+h+'px 0px)';
        else if (/r2l/.test(opts.clip))
            clip = 'rect(0px '+w+'px '+h+'px '+w+'px)';
        else if (/t2b/.test(opts.clip))
            clip = 'rect(0px '+w+'px 0px 0px)';
        else if (/b2t/.test(opts.clip))
            clip = 'rect('+h+'px '+w+'px '+h+'px 0px)';
        else if (/zoom/.test(opts.clip)) {
            var t = parseInt(h/2);
            var l = parseInt(w/2);
            clip = 'rect('+t+'px '+l+'px '+t+'px '+l+'px)';
        }
    }
    
    opts.cssBefore.clip = opts.cssBefore.clip || clip || 'rect(0px 0px 0px 0px)';
    
    var d = opts.cssBefore.clip.match(/(\d+)/g);
    var t = parseInt(d[0]), r = parseInt(d[1]), b = parseInt(d[2]), l = parseInt(d[3]);
    
    opts.before.push(function(curr, next, opts) {
        if (curr == next) return;
        var $curr = $(curr).css('zIndex',2);
        var $next = $(next).css({
            zIndex:  3,
            display: 'block'
        });
        
        var step = 1, count = parseInt((opts.speedIn / 13)) - 1;
        function f() {
            var tt = t ? t - parseInt(step * (t/count)) : 0;
            var ll = l ? l - parseInt(step * (l/count)) : 0;
            var bb = b < h ? b + parseInt(step * ((h-b)/count || 1)) : h;
            var rr = r < w ? r + parseInt(step * ((w-r)/count || 1)) : w;
            $next.css({ clip: 'rect('+tt+'px '+rr+'px '+bb+'px '+ll+'px)' });
            (step++ <= count) ? setTimeout(f, 13) : $curr.css('display', 'none');
        }
        f();
    });    
    opts.cssAfter  = { };
    opts.animIn    = { left: 0 };
    opts.animOut   = { left: 0 };
};

})(jQuery);
/*
 jQuery delayed observer - 0.8
 http://code.google.com/p/jquery-utils/

 (c) Maxime Haineault <haineault@gmail.com>
 http://haineault.com
 
 MIT License (http://www.opensource.org/licenses/mit-license.php)
 
*/

(function($){
    $.extend($.fn, {
        delayedObserver: function(callback, delay, options){
            return this.each(function(){
                var el = $(this);
                var op = options || {};
                el.data('oldval', el.val())
                    .data('delay', delay || 0.5)
                    .data('condition', op.condition || function() { return ($(this).data('oldval') == $(this).val()); })
                    .data('callback', callback)
                    [(op.event||'keyup')](function(){
                        if (el.data('condition').apply(el)) { return; }
                        else {
                            if (el.data('timer')) { clearTimeout(el.data('timer')); }
                            el.data('timer', setTimeout(function(){
                                el.data('callback').apply(el);
                            }, el.data('delay') * 1000));
                            el.data('oldval', el.val());
                        }
                    });
            });
        }
    });
})(jQuery);
/**
 * Flash (http://jquery.lukelutman.com/plugins/flash)
 * A jQuery plugin for embedding Flash movies.
 * 
 * Version 1.0
 * November 9th, 2006
 *
 * Copyright (c) 2006 Luke Lutman (http://www.lukelutman.com)
 * Dual licensed under the MIT and GPL licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/gpl-license.php
 * 
 * Inspired by:
 * SWFObject (http://blog.deconcept.com/swfobject/)
 * UFO (http://www.bobbyvandersluis.com/ufo/)
 * sIFR (http://www.mikeindustries.com/sifr/)
 * 
 * IMPORTANT: 
 * The packed version of jQuery breaks ActiveX control
 * activation in Internet Explorer. Use JSMin to minifiy
 * jQuery (see: http://jquery.lukelutman.com/plugins/flash#activex).
 *
 **/ 
;(function(){
	
var $$;

/**
 * 
 * @desc Replace matching elements with a flash movie.
 * @author Luke Lutman
 * @version 1.0.1
 *
 * @name flash
 * @param Hash htmlOptions Options for the embed/object tag.
 * @param Hash pluginOptions Options for detecting/updating the Flash plugin (optional).
 * @param Function replace Custom block called for each matched element if flash is installed (optional).
 * @param Function update Custom block called for each matched if flash isn't installed (optional).
 * @type jQuery
 *
 * @cat plugins/flash
 * 
 * @example $('#hello').flash({ src: 'hello.swf' });
 * @desc Embed a Flash movie.
 *
 * @example $('#hello').flash({ src: 'hello.swf' }, { version: 8 });
 * @desc Embed a Flash 8 movie.
 *
 * @example $('#hello').flash({ src: 'hello.swf' }, { expressInstall: true });
 * @desc Embed a Flash movie using Express Install if flash isn't installed.
 *
 * @example $('#hello').flash({ src: 'hello.swf' }, { update: false });
 * @desc Embed a Flash movie, don't show an update message if Flash isn't installed.
 *
**/
$$ = jQuery.fn.flash = function(htmlOptions, pluginOptions, replace, update) {
	
	// Set the default block.
	var block = replace || $$.replace;
	
	// Merge the default and passed plugin options.
	pluginOptions = $$.copy($$.pluginOptions, pluginOptions);
	
	// Detect Flash.
	if(!$$.hasFlash(pluginOptions.version)) {
		// Use Express Install (if specified and Flash plugin 6,0,65 or higher is installed).
		if(pluginOptions.expressInstall && $$.hasFlash(6,0,65)) {
			// Add the necessary flashvars (merged later).
			var expressInstallOptions = {
				flashvars: {  	
					MMredirectURL: location,
					MMplayerType: 'PlugIn',
					MMdoctitle: jQuery('title').text() 
				}					
			};
		// Ask the user to update (if specified).
		} else if (pluginOptions.update) {
			// Change the block to insert the update message instead of the flash movie.
			block = update || $$.update;
		// Fail
		} else {
			// The required version of flash isn't installed.
			// Express Install is turned off, or flash 6,0,65 isn't installed.
			// Update is turned off.
			// Return without doing anything.
			return this;
		}
	}
	
	// Merge the default, express install and passed html options.
	htmlOptions = $$.copy($$.htmlOptions, expressInstallOptions, htmlOptions);
	
	// Invoke $block (with a copy of the merged html options) for each element.
	return this.each(function(){
		block.call(this, $$.copy(htmlOptions));
	});
	
};
/**
 *
 * @name flash.copy
 * @desc Copy an arbitrary number of objects into a new object.
 * @type Object
 * 
 * @example $$.copy({ foo: 1 }, { bar: 2 });
 * @result { foo: 1, bar: 2 };
 *
**/
$$.copy = function() {
	var options = {}, flashvars = {};
	for(var i = 0; i < arguments.length; i++) {
		var arg = arguments[i];
		if(arg == undefined) continue;
		jQuery.extend(options, arg);
		// don't clobber one flash vars object with another
		// merge them instead
		if(arg.flashvars == undefined) continue;
		jQuery.extend(flashvars, arg.flashvars);
	}
	options.flashvars = flashvars;
	return options;
};
/*
 * @name flash.hasFlash
 * @desc Check if a specific version of the Flash plugin is installed
 * @type Boolean
 *
**/
$$.hasFlash = function() {
	// look for a flag in the query string to bypass flash detection
	if(/hasFlash\=true/.test(location)) return true;
	if(/hasFlash\=false/.test(location)) return false;
	var pv = $$.hasFlash.playerVersion().match(/\d+/g);
	var rv = String([arguments[0], arguments[1], arguments[2]]).match(/\d+/g) || String($$.pluginOptions.version).match(/\d+/g);
	for(var i = 0; i < 3; i++) {
		pv[i] = parseInt(pv[i] || 0);
		rv[i] = parseInt(rv[i] || 0);
		// player is less than required
		if(pv[i] < rv[i]) return false;
		// player is greater than required
		if(pv[i] > rv[i]) return true;
	}
	// major version, minor version and revision match exactly
	return true;
};
/**
 *
 * @name flash.hasFlash.playerVersion
 * @desc Get the version of the installed Flash plugin.
 * @type String
 *
**/
$$.hasFlash.playerVersion = function() {
	// ie
	try {
		try {
			// avoid fp6 minor version lookup issues
			// see: http://blog.deconcept.com/2006/01/11/getvariable-setvariable-crash-internet-explorer-flash-6/
			var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
			try { axo.AllowScriptAccess = 'always';	} 
			catch(e) { return '6,0,0'; }				
		} catch(e) {}
		return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	// other browsers
	} catch(e) {
		try {
			if(navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin){
				return (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]).description.replace(/\D+/g, ",").match(/^,?(.+),?$/)[1];
			}
		} catch(e) {}		
	}
	return '0,0,0';
};
/**
 *
 * @name flash.htmlOptions
 * @desc The default set of options for the object or embed tag.
 *
**/
$$.htmlOptions = {
	height: 240,
	flashvars: {},
	pluginspage: 'http://www.adobe.com/go/getflashplayer',
	src: '#',
	type: 'application/x-shockwave-flash',
	width: 320		
};
/**
 *
 * @name flash.pluginOptions
 * @desc The default set of options for checking/updating the flash Plugin.
 *
**/
$$.pluginOptions = {
	expressInstall: false,
	update: true,
	version: '6.0.65'
};
/**
 *
 * @name flash.replace
 * @desc The default method for replacing an element with a Flash movie.
 *
**/
$$.replace = function(htmlOptions) {
	this.innerHTML = '<div class="alt">'+this.innerHTML+'</div>';
	jQuery(this)
		.addClass('flash-replaced')
		.prepend($$.transform(htmlOptions));
};
/**
 *
 * @name flash.update
 * @desc The default method for replacing an element with an update message.
 *
**/
$$.update = function(htmlOptions) {
	var url = String(location).split('?');
	url.splice(1,0,'?hasFlash=true&');
	url = url.join('');
	var msg = '<p>This content requires the Flash Player. <a href="http://www.adobe.com/go/getflashplayer">Download Flash Player</a>. Already have Flash Player? <a href="'+url+'">Click here.</a></p>';
	this.innerHTML = '<span class="alt">'+this.innerHTML+'</span>';
	jQuery(this)
		.addClass('flash-update')
		.prepend(msg);
};
/**
 *
 * @desc Convert a hash of html options to a string of attributes, using Function.apply(). 
 * @example toAttributeString.apply(htmlOptions)
 * @result foo="bar" foo="bar"
 *
**/
function toAttributeString() {
	var s = '';
	for(var key in this)
		if(typeof this[key] != 'function')
			s += key+'="'+this[key]+'" ';
	return s;		
};
/**
 *
 * @desc Convert a hash of flashvars to a url-encoded string, using Function.apply(). 
 * @example toFlashvarsString.apply(flashvarsObject)
 * @result foo=bar&foo=bar
 *
**/
function toFlashvarsString() {
	var s = '';
	for(var key in this)
		if(typeof this[key] != 'function')
			s += key+'='+encodeURIComponent(this[key])+'&';
	return s.replace(/&$/, '');		
};
/**
 *
 * @name flash.transform
 * @desc Transform a set of html options into an embed tag.
 * @type String 
 *
 * @example $$.transform(htmlOptions)
 * @result <embed src="foo.swf" ... />
 *
 * Note: The embed tag is NOT standards-compliant, but it 
 * works in all current browsers. flash.transform can be
 * overwritten with a custom function to generate more 
 * standards-compliant markup.
 *
**/
$$.transform = function(htmlOptions) {
	htmlOptions.toString = toAttributeString;
	if(htmlOptions.flashvars) htmlOptions.flashvars.toString = toFlashvarsString;
	return '<embed ' + String(htmlOptions) + '/>';		
};

/**
 *
 * Flash Player 9 Fix (http://blog.deconcept.com/2006/07/28/swfobject-143-released/)
 *
**/
if (window.attachEvent) {
	window.attachEvent("onbeforeunload", function(){
		__flash_unloadHandler = function() {};
		__flash_savedUnloadHandler = function() {};
	});
}
	
})();
(function($){
    $._i18n = { trans: {}, 'default':  'en', language: 'en' };
    $.i18n = function() {
        var getTrans = function(ns, str) {
            var trans = false;
            // check if string exists in translation
            if ($._i18n.trans[$._i18n.language] 
                && $._i18n.trans[$._i18n.language][ns]
                && $._i18n.trans[$._i18n.language][ns][str]) {
                trans = $._i18n.trans[$._i18n.language][ns][str];
            }
            // or exists in default
            else if ($._i18n.trans[$._i18n['default']] 
                     && $._i18n.trans[$._i18n['default']][ns]
                     && $._i18n.trans[$._i18n['default']][ns][str]) {
                trans = $._i18n.trans[$._i18n['default']][ns][str];
            }
            // return trans or original string
            return trans || str;
        };
        // Set language (accepted formats: en or en-US)
        if (arguments.length < 2) {
            $._i18n.language = arguments[0]; 
            return $._i18n.language;
        }
        else {
            // get translation
            if (typeof(arguments[1]) == 'string') {
                var trans = getTrans(arguments[0], arguments[1]);
                // has variables for string formating
                if (arguments[2] && typeof(arguments[2]) == 'object') {
                    return $.format(trans, arguments[2]);
                }
                else {
                    return trans;
                }
            }
            // set translation
            else {
                var tmp  = arguments[0].split('.');
                var lang = tmp[0];
                var ns   = tmp[1] || 'jQuery';
                if (!$._i18n.trans[lang]) {
                    $._i18n.trans[lang] = {};
                    $._i18n.trans[lang][ns] = arguments[1];
                }
                else {
                    $.extend($._i18n.trans[lang][ns], arguments[1]);
                }
            }
        }
    };
})(jQuery);
/*
 * Copyright (c) 2007-2008 Josh Bush (digitalbush.com)
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE. 
 */
 
/*
 * Version: 1.1.3
 * Release: 2008-04-16
 */ 
(function($) {

	//Helper Function for Caret positioning
	$.fn.caret=function(begin,end){	
		if(this.length==0) return;
		if (typeof begin == 'number') {
            end = (typeof end == 'number')?end:begin;  
			return this.each(function(){
				if(this.setSelectionRange){
					this.focus();
					this.setSelectionRange(begin,end);
				}else if (this.createTextRange){
					var range = this.createTextRange();
					range.collapse(true);
					range.moveEnd('character', end);
					range.moveStart('character', begin);
					range.select();
				}
			});
        } else {
            if (this[0].setSelectionRange){
				begin = this[0].selectionStart;
				end = this[0].selectionEnd;
			}else if (document.selection && document.selection.createRange){
				var range = document.selection.createRange();			
				begin = 0 - range.duplicate().moveStart('character', -100000);
				end = begin + range.text.length;
			}
			return {begin:begin,end:end};
        }       
	};

	//Predefined character definitions
	var charMap={
		'9':"[0-9]",
		'a':"[A-Za-z]",
		'*':"[A-Za-z0-9]"
	};
	
	//Helper method to inject character definitions
	$.mask={
		addPlaceholder : function(c,r){
			charMap[c]=r;
		}
	};
	
	$.fn.unmask=function(){
		return this.trigger("unmask");
	};
	
	//Main Method
	$.fn.mask = function(mask,settings) {	
		settings = $.extend({
			placeholder: "_",			
			completed: null
		}, settings);		
		
		//Build Regex for format validation
		var re = new RegExp("^"+	
		$.map( mask.split(""), function(c,i){		  		  
		  return charMap[c]||((/[A-Za-z0-9]/.test(c)?"":"\\")+c);
		}).join('')+				
		"$");		

		return this.each(function(){		
			var input=$(this);
			var buffer=new Array(mask.length);
			var locked=new Array(mask.length);
			var valid=false;   
			var ignore=false;  			//Variable for ignoring control keys
			var firstNonMaskPos=null; 
			
			//Build buffer layout from mask & determine the first non masked character			
			$.each( mask.split(""), function(i,c){				
				locked[i]=(charMap[c]==null);				
				buffer[i]=locked[i]?c:settings.placeholder;									
				if(!locked[i] && firstNonMaskPos==null)
					firstNonMaskPos=i;
			});		
			
			function focusEvent(){					
				checkVal();
				writeBuffer();
				setTimeout(function(){
					$(input[0]).caret(valid?mask.length:firstNonMaskPos);					
				},0);
			};
			
			function keydownEvent(e){				
				var pos=$(this).caret();
				var k = e.keyCode;
				ignore=(k < 16 || (k > 16 && k < 32 ) || (k > 32 && k < 41));
				
				//delete selection before proceeding
				if((pos.begin-pos.end)!=0 && (!ignore || k==8 || k==46)){
					clearBuffer(pos.begin,pos.end);
				}	
				//backspace and delete get special treatment
				if(k==8){//backspace					
					while(pos.begin-->=0){
						if(!locked[pos.begin]){								
							buffer[pos.begin]=settings.placeholder;
							if($.browser.opera){
								//Opera won't let you cancel the backspace, so we'll let it backspace over a dummy character.								
								s=writeBuffer();
								input.val(s.substring(0,pos.begin)+" "+s.substring(pos.begin));
								$(this).caret(pos.begin+1);								
							}else{
								writeBuffer();
								$(this).caret(Math.max(firstNonMaskPos,pos.begin));								
							}									
							return false;								
						}
					}						
				}else if(k==46){//delete
					clearBuffer(pos.begin,pos.begin+1);
					writeBuffer();
					$(this).caret(Math.max(firstNonMaskPos,pos.begin));					
					return false;
				}else if (k==27){//escape
					clearBuffer(0,mask.length);
					writeBuffer();
					$(this).caret(firstNonMaskPos);					
					return false;
				}									
			};
			
			function keypressEvent(e){					
				if(ignore){
					ignore=false;
					//Fixes Mac FF bug on backspace
					return (e.keyCode == 8)? false: null;
				}
				e=e||window.event;
				var k=e.charCode||e.keyCode||e.which;						
				var pos=$(this).caret();
								
				if(e.ctrlKey || e.altKey){//Ignore
					return true;
				}else if ((k>=41 && k<=122) ||k==32 || k>186){//typeable characters
					var p=seekNext(pos.begin-1);					
					if(p<mask.length){
						if(new RegExp(charMap[mask.charAt(p)]).test(String.fromCharCode(k))){
							buffer[p]=String.fromCharCode(k);									
							writeBuffer();
							var next=seekNext(p);
							$(this).caret(next);
							if(settings.completed && next == mask.length)
								settings.completed.call(input);
						}				
					}
				}				
				return false;				
			};
			
			function clearBuffer(start,end){
				for(var i=start;i<end&&i<mask.length;i++){
					if(!locked[i])
						buffer[i]=settings.placeholder;
				}				
			};
			
			function writeBuffer(){				
				return input.val(buffer.join('')).val();				
			};
			
			function checkVal(){	
				//try to place charcters where they belong
				var test=input.val();
				var pos=0;
				for(var i=0;i<mask.length;i++){					
					if(!locked[i]){
						buffer[i]=settings.placeholder;
						while(pos++<test.length){
							//Regex Test each char here.
							var reChar=new RegExp(charMap[mask.charAt(i)]);
							if(test.charAt(pos-1).match(reChar)){
								buffer[i]=test.charAt(pos-1);								
								break;
							}									
						}
					}
				}
				var s=writeBuffer();
				if(!s.match(re)){							
					input.val("");	
					clearBuffer(0,mask.length);
					valid=false;
				}else
					valid=true;
			};
			
			function seekNext(pos){				
				while(++pos<mask.length){					
					if(!locked[pos])
						return pos;
				}
				return mask.length;
			};
			
			input.one("unmask",function(){
				input.unbind("focus",focusEvent);
				input.unbind("blur",checkVal);
				input.unbind("keydown",keydownEvent);
				input.unbind("keypress",keypressEvent);
				if ($.browser.msie) 
					this.onpaste= null;                     
				else if ($.browser.mozilla)
					this.removeEventListener('input',checkVal,false);
			});
			input.bind("focus",focusEvent);
			input.bind("blur",checkVal);
			input.bind("keydown",keydownEvent);
			input.bind("keypress",keypressEvent);
			//Paste events for IE and Mozilla thanks to Kristinn Sigmundsson
			if ($.browser.msie) 
				this.onpaste= function(){setTimeout(checkVal,0);};                     
			else if ($.browser.mozilla)
				this.addEventListener('input',checkVal,false);
				
			checkVal();//Perform initial check for existing values
		});
	};
})(jQuery);
/* Copyright (c) 2006 Brandon Aaron (brandon.aaron@gmail.com || http://brandonaaron.net)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 *
 * $LastChangedDate: 2007-12-20 09:02:08 -0600 (Thu, 20 Dec 2007) $
 * $Rev: 4265 $
 *
 * Version: 3.0
 * 
 * Requires: $ 1.2.2+
 */

(function($) {

$.event.special.mousewheel = {
	setup: function() {
		var handler = $.event.special.mousewheel.handler;
		
		// Fix pageX, pageY, clientX and clientY for mozilla
		if ( $.browser.mozilla )
			$(this).bind('mousemove.mousewheel', function(event) {
				$.data(this, 'mwcursorposdata', {
					pageX: event.pageX,
					pageY: event.pageY,
					clientX: event.clientX,
					clientY: event.clientY
				});
			});
	
		if ( this.addEventListener )
			this.addEventListener( ($.browser.mozilla ? 'DOMMouseScroll' : 'mousewheel'), handler, false);
		else
			this.onmousewheel = handler;
	},
	
	teardown: function() {
		var handler = $.event.special.mousewheel.handler;
		
		$(this).unbind('mousemove.mousewheel');
		
		if ( this.removeEventListener )
			this.removeEventListener( ($.browser.mozilla ? 'DOMMouseScroll' : 'mousewheel'), handler, false);
		else
			this.onmousewheel = function(){};
		
		$.removeData(this, 'mwcursorposdata');
	},
	
	handler: function(event) {
		var args = Array.prototype.slice.call( arguments, 1 );
		
		event = $.event.fix(event || window.event);
		// Get correct pageX, pageY, clientX and clientY for mozilla
		$.extend( event, $.data(this, 'mwcursorposdata') || {} );
		var delta = 0, returnValue = true;
		
		if ( event.wheelDelta ) delta = event.wheelDelta/120;
		if ( event.detail     ) delta = -event.detail/3;
		if ( $.browser.opera  ) delta = -event.wheelDelta;
		
		event.data  = event.data || {};
		event.type  = "mousewheel";
		
		// Add delta to the front of the arguments
		args.unshift(delta);
		// Add event to the front of the arguments
		args.unshift(event);

		return $.event.handle.apply(this, args);
	}
};

$.fn.extend({
	mousewheel: function(fn) {
		return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
	},
	
	unmousewheel: function(fn) {
		return this.unbind("mousewheel", fn);
	}
});

})(jQuery);/*!
        Slimbox v2.02 - The ultimate lightweight Lightbox clone for jQuery
        (c) 2007-2009 Christophe Beyls <http://www.digitalia.be>
        MIT-style license.
*/

(function($) {

        // Global variables, accessible to Slimbox only
        var win = $(window), options, images, activeImage = -1, activeURL, prevImage, nextImage, compatibleOverlay, middle, centerWidth, centerHeight, ie6 = !window.XMLHttpRequest,
                operaFix = window.opera && (document.compatMode == "CSS1Compat") && ($.browser.version >= 9.3), documentElement = document.documentElement,

        // Preload images
        preload = {}, preloadPrev = new Image(), preloadNext = new Image(),

        // DOM elements
        overlay, center, image, sizer, prevLink, nextLink, bottomContainer, bottom, caption, number;

        /*
                Initialization
        */

        $(function() {
                // Append the Slimbox HTML code at the bottom of the document
                $("body").append(
                        $([
                                overlay = $('<div id="lbOverlay" />')[0],
                                center = $('<div id="lbCenter" />')[0],
                                bottomContainer = $('<div id="lbBottomContainer" />')[0]
                        ]).css("display", "none")
                );

                image = $('<div id="lbImage" />').appendTo(center).append(
                        sizer = $('<div style="position: relative;" />').append([
                                prevLink = $('<a id="lbPrevLink" href="#" />').click(previous)[0],
                                nextLink = $('<a id="lbNextLink" href="#" />').click(next)[0]
                        ])[0]
                )[0];

                bottom = $('<div id="lbBottom" />').appendTo(bottomContainer).append([
                        $('<a id="lbCloseLink" href="#" />').add(overlay).click(close)[0],
                        caption = $('<div id="lbCaption" />')[0],
                        number = $('<div id="lbNumber" />')[0],
                        $('<div style="clear: both;" />')[0]
                ])[0];
        });


        /*
                API
        */

        // Open Slimbox with the specified parameters
        $.slimbox = function(_images, startImage, _options) {
                options = $.extend({
                        loop: false,                            // Allows to navigate between first and last images
                        overlayOpacity: 0.8,                    // 1 is opaque, 0 is completely transparent (change the color in the CSS file)
                        overlayFadeDuration: 400,               // Duration of the overlay fade-in and fade-out animations (in milliseconds)
                        resizeDuration: 400,                    // Duration of each of the box resize animations (in milliseconds)
                        resizeEasing: "swing",                  // "swing" is jQuery's default easing
                        initialWidth: 250,                      // Initial width of the box (in pixels)
                        initialHeight: 250,                     // Initial height of the box (in pixels)
                        imageFadeDuration: 400,                 // Duration of the image fade-in animation (in milliseconds)
                        captionAnimationDuration: 400,          // Duration of the caption animation (in milliseconds)
                        counterText: "Image {x} of {y}",        // Translate or change as you wish, or set it to false to disable counter text for image groups
                        closeKeys: [27, 88, 67],                // Array of keycodes to close Slimbox, default: Esc (27), 'x' (88), 'c' (67)
                        previousKeys: [37, 80],                 // Array of keycodes to navigate to the previous image, default: Left arrow (37), 'p' (80)
                        nextKeys: [39, 78]                      // Array of keycodes to navigate to the next image, default: Right arrow (39), 'n' (78)
                }, _options);

                // The function is called for a single image, with URL and Title as first two arguments
                if (typeof _images == "string") {
                        _images = [[_images, startImage]];
                        startImage = 0;
                }

                middle = win.scrollTop() + ((operaFix ? documentElement.clientHeight : win.height()) / 2);
                centerWidth = options.initialWidth;
                centerHeight = options.initialHeight;
                $(center).css({top: Math.max(0, middle - (centerHeight / 2)), width: centerWidth, height: centerHeight, marginLeft: -centerWidth/2}).show();
                compatibleOverlay = ie6 || (overlay.currentStyle && (overlay.currentStyle.position != "fixed"));
                if (compatibleOverlay) overlay.style.position = "absolute";
                $(overlay).css("opacity", options.overlayOpacity).fadeIn(options.overlayFadeDuration);
                position();
                setup(1);

                images = _images;
                options.loop = options.loop && (images.length > 1);
                return changeImage(startImage);
        };

        /*
                options:        Optional options object, see jQuery.slimbox()
                linkMapper:     Optional function taking a link DOM element and an index as arguments and returning an array containing 2 elements:
                                the image URL and the image caption (may contain HTML)
                linksFilter:    Optional function taking a link DOM element and an index as arguments and returning true if the element is part of
                                the image collection that will be shown on click, false if not. "this" refers to the element that was clicked.
                                This function must always return true when the DOM element argument is "this".
        */
        $.fn.slimbox = function(_options, linkMapper, linksFilter) {
                linkMapper = linkMapper || function(el) {
                        return [el.href, el.title];
                };

                linksFilter = linksFilter || function() {
                        return true;
                };

                var links = this;

                return links.unbind("click").click(function() {
                        // Build the list of images that will be displayed
                        var link = this, startIndex = 0, filteredLinks, i = 0, length;
                        filteredLinks = $.grep(links, function(el, i) {
                                return linksFilter.call(link, el, i);
                        });

                        // We cannot use jQuery.map() because it flattens the returned array
                        for (length = filteredLinks.length; i < length; ++i) {
                                if (filteredLinks[i] == link) startIndex = i;
                                filteredLinks[i] = linkMapper(filteredLinks[i], i);
                        }

                        return $.slimbox(filteredLinks, startIndex, _options);
                });
        };


        /*
                Internal functions
        */

        function position() {
                var l = win.scrollLeft(), w = operaFix ? documentElement.clientWidth : win.width();
                $([center, bottomContainer]).css("left", l + (w / 2));
                if (compatibleOverlay) $(overlay).css({left: l, top: win.scrollTop(), width: w, height: win.height()});
        }

        function setup(open) {
                $("object").add(ie6 ? "select" : "embed").each(function(index, el) {
                        if (open) $.data(el, "slimbox", el.style.visibility);
                        el.style.visibility = open ? "hidden" : $.data(el, "slimbox");
                });
                var fn = open ? "bind" : "unbind";
                win[fn]("scroll resize", position);
                $(document)[fn]("keydown", keyDown);
        }

        function keyDown(event) {
                var code = event.keyCode, fn = $.inArray;
                // Prevent default keyboard action (like navigating inside the page)
                return (fn(code, options.closeKeys) >= 0) ? close()
                        : (fn(code, options.nextKeys) >= 0) ? next()
                        : (fn(code, options.previousKeys) >= 0) ? previous()
                        : false;
        }

        function previous() {
                return changeImage(prevImage);
        }

        function next() {
                return changeImage(nextImage);
        }

        function changeImage(imageIndex) {
                if (imageIndex >= 0) {
                        activeImage = imageIndex;
                        activeURL = images[activeImage][0];
                        prevImage = (activeImage || (options.loop ? images.length : 0)) - 1;
                        nextImage = ((activeImage + 1) % images.length) || (options.loop ? 0 : -1);

                        stop();
                        center.className = "lbLoading";

                        preload = new Image();
                        preload.onload = animateBox;
                        preload.src = activeURL;
                }

                return false;
        }

        function animateBox() {
                center.className = "";
                $(image).css({backgroundImage: "url(" + activeURL + ")", visibility: "hidden", display: ""});
                $(sizer).width(preload.width);
                $([sizer, prevLink, nextLink]).height(preload.height);

                $(caption).html(images[activeImage][1] || "");
                $(number).html((((images.length > 1) && options.counterText) || "").replace(/{x}/, activeImage + 1).replace(/{y}/, images.length));

                if (prevImage >= 0) preloadPrev.src = images[prevImage][0];
                if (nextImage >= 0) preloadNext.src = images[nextImage][0];

                centerWidth = image.offsetWidth;
                centerHeight = image.offsetHeight;
                var top = Math.max(0, middle - (centerHeight / 2));
                if (center.offsetHeight != centerHeight) {
                        $(center).animate({height: centerHeight, top: top}, options.resizeDuration, options.resizeEasing);
                }
                if (center.offsetWidth != centerWidth) {
                        $(center).animate({width: centerWidth, marginLeft: -centerWidth/2}, options.resizeDuration, options.resizeEasing);
                }
                $(center).queue(function() {
                        $(bottomContainer).css({width: centerWidth, top: top + centerHeight, marginLeft: -centerWidth/2, visibility: "hidden", display: ""});
                        $(image).css({display: "none", visibility: "", opacity: ""}).fadeIn(options.imageFadeDuration, animateCaption);
                });
        }


        function animateCaption() {
                if (prevImage >= 0) $(prevLink).show();
                if (nextImage >= 0) $(nextLink).show();
                $(bottom).css("marginTop", -bottom.offsetHeight).animate({marginTop: 0}, options.captionAnimationDuration);
                bottomContainer.style.visibility = "";
        }

        function stop() {
                preload.onload = null;
                preload.src = preloadPrev.src = preloadNext.src = activeURL;
                $([center, image, bottom]).stop(true);
                $([prevLink, nextLink, image, bottomContainer]).hide();
        }

        function close() {
                if (activeImage >= 0) {
                        stop();
                        activeImage = prevImage = nextImage = -1;
                        $(center).hide();
                        $(overlay).stop().fadeOut(options.overlayFadeDuration, setup);
                }

                return false;
        }

})(jQuery);
/*
 * timeago: a jQuery plugin, version: 0.5.1 (08/20/2008)
 * @requires jQuery v1.2 or later
 *
 * Timeago is a jQuery plugin that makes it easy to support automatically
 * updating fuzzy timestamps (e.g. "4 minutes ago" or "about 1 day ago").
 *
 * For usage and examples, visit:
 * http://timeago.yarp.com/
 *
 * Licensed under the MIT:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright (c) 2008, Ryan McGeary (ryanonjavascript -[at]- mcgeary [*dot*] org)
 */
(function($) {
  $.timeago = function(timestamp) {
    if (timestamp instanceof Date) return inWords(timestamp);
    else if (typeof timestamp == "string") return inWords($.timeago.parse(timestamp));
    else return inWords($.timeago.parse($(timestamp).attr("title")));
  };
  var $t = $.timeago;

  $.extend($.timeago, {
    settings: {
      refreshMillis: 60000,
      allowFuture: false,
      strings: {
        ago: "ago",
        fromNow: "from now",
        seconds: "less than a minute",
        minute: "about a minute",
        minutes: "%d minutes",
        hour: "about an hour",
        hours: "about %d hours",
        day: "a day",
        days: "%d days",
        month: "about a month",
        months: "%d months",
        year: "about a year",
        years: "%d years"
      }
    },
    inWords: function(distanceMillis) {
      var $l = this.settings.strings;
      var suffix = $l.ago;
      if (this.settings.allowFuture) {
        if (distanceMillis < 0) suffix = $l.fromNow;
        distanceMillis = Math.abs(distanceMillis);
      }

      var seconds = distanceMillis / 1000;
      var minutes = seconds / 60;
      var hours = minutes / 60;
      var days = hours / 24;
      var years = days / 365;

      var words = seconds < 45 && sprintf($l.seconds, Math.round(seconds)) ||
        seconds < 90 && $l.minute ||
        minutes < 45 && sprintf($l.minutes, Math.round(minutes)) ||
        minutes < 90 && $l.hour ||
        hours < 24 && sprintf($l.hours, Math.round(hours)) ||
        hours < 48 && $l.day ||
        days < 30 && sprintf($l.days, Math.floor(days)) ||
        days < 60 && $l.month ||
        days < 365 && sprintf($l.months, Math.floor(days / 30)) ||
        years < 2 && $l.year ||
        sprintf($l.years, Math.floor(years));

      return words + " " + suffix;
    },
    parse: function(iso8601) {
      var s = $.trim(iso8601);
      s = s.replace(/-/,"/").replace(/-/,"/");
      s = s.replace(/T/," ").replace(/Z/," UTC");
      s = s.replace(/([\+-]\d\d)\:?(\d\d)/," $1$2"); // -04:00 -> -0400
      return new Date(s);
    }
  });

  $.fn.timeago = function() {
    var self = this;
    self.each(refresh);

    var $s = $t.settings;
    if ($s.refreshMillis > 0) {
      setInterval(function() { self.each(refresh); }, $s.refreshMillis);
    }
    return self;
  };

  function refresh() {
    var date = $t.parse(this.title);
    if (!isNaN(date)) {
      $(this).text(inWords(date));
    }
    return this;
  }

  function inWords(date) {
    return $t.inWords(distance(date));
  }

  function distance(date) {
    return (new Date().getTime() - date.getTime());
  }

  // lame sprintf implementation
  function sprintf(string, value) {
    return string.replace(/%d/i, value);
  }

  // fix for IE6 suckage
  if ($.browser.msie && $.browser.version < 7.0) {
    document.createElement('abbr');
  }
})(jQuery);


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS51dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJqcXVlcnkudXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBqUXVlcnkgdXRpbHMgLSAwLjguNVxuICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvanF1ZXJ5LXV0aWxzL1xuXG4gIChjKSBNYXhpbWUgSGFpbmVhdWx0IDxoYWluZWF1bHRAZ21haWwuY29tPiBcbiAgaHR0cDovL2hhaW5lYXVsdC5jb21cblxuICBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblxuKi9cblxuKGZ1bmN0aW9uKCQpe1xuICAgICAkLmV4dGVuZCgkLmV4cHJbJzonXSwge1xuICAgICAgICAvLyBjYXNlIGluc2Vuc2l0aXZlIHZlcnNpb24gb2YgOmNvbnRhaW5zXG4gICAgICAgIGljb250YWluczogZnVuY3Rpb24oYSxpLG0pe3JldHVybiAoYS50ZXh0Q29udGVudHx8YS5pbm5lclRleHR8fGpRdWVyeShhKS50ZXh0KCl8fFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihtWzNdLnRvTG93ZXJDYXNlKCkpPj0wO31cbiAgICB9KTtcblxuICAgICQuaXRlcmF0b3JzID0ge1xuICAgICAgICBnZXRUZXh0OiAgZnVuY3Rpb24oKSB7IHJldHVybiAkKHRoaXMpLnRleHQoKTsgfSxcbiAgICAgICAgcGFyc2VJbnQ6IGZ1bmN0aW9uKHYpeyByZXR1cm4gcGFyc2VJbnQodiwgMTApOyB9XG4gICAgfTtcblxuXHQkLmV4dGVuZCh7IFxuXG4gICAgICAgIC8vIFJldHVybnMgYSByYW5nZSBvYmplY3RcbiAgICAgICAgLy8gQXV0aG9yOiBNYXR0aGlhcyBNaWxsZXJcbiAgICAgICAgLy8gU2l0ZTogICBodHRwOi8vYmxvZy5vdXRvZmhhbndlbGwuY29tLzIwMDYvMDMvMjkvamF2YXNjcmlwdC1yYW5nZS1mdW5jdGlvbi9cbiAgICAgICAgcmFuZ2U6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgICAgIHZhciBtaW4sIG1heCwgc3RlcDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBtaW4gID0gMDtcbiAgICAgICAgICAgICAgICBtYXggID0gYXJndW1lbnRzWzBdLTE7XG4gICAgICAgICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHN0ZXAgdG8gMSBpZiBpdCdzIHplcm8gb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgbWluICA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBtYXggID0gYXJndW1lbnRzWzFdLTE7XG4gICAgICAgICAgICAgICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udmVydCBuZWdhdGl2ZSBzdGVwcyB0byBwb3NpdGl2ZSBhbmQgcmV2ZXJzZSBtaW4vbWF4XG4gICAgICAgICAgICBpZiAoc3RlcCA8IDAgJiYgbWluID49IG1heCkge1xuICAgICAgICAgICAgICAgIHN0ZXAgKj0gLTE7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IG1pbjtcbiAgICAgICAgICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgICAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgICAgICAgICAgIG1pbiArPSAoKG1heC1taW4pICUgc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkgKz0gc3RlcCkgeyBhLnB1c2goaSk7IH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRha2VuIGZyb20gdWkuY29yZS5qcy4gXG4gICAgICAgIC8vIFdoeSBhcmUgeW91IGtlZXBpbmcgdGhpcyBnZW0gZm9yIHlvdXJzZWxmIGd1eXMgPyA6fFxuICAgICAgICBrZXlDb2RlOiB7XG4gICAgICAgICAgICBCQUNLU1BBQ0U6IDgsIENBUFNfTE9DSzogMjAsIENPTU1BOiAxODgsIENPTlRST0w6IDE3LCBERUxFVEU6IDQ2LCBET1dOOiA0MCxcbiAgICAgICAgICAgIEVORDogMzUsIEVOVEVSOiAxMywgRVNDQVBFOiAyNywgSE9NRTogMzYsIElOU0VSVDogIDQ1LCBMRUZUOiAzNyxcbiAgICAgICAgICAgIE5VTVBBRF9BREQ6IDEwNywgTlVNUEFEX0RFQ0lNQUw6IDExMCwgTlVNUEFEX0RJVklERTogMTExLCBOVU1QQURfRU5URVI6IDEwOCwgXG4gICAgICAgICAgICBOVU1QQURfTVVMVElQTFk6IDEwNiwgTlVNUEFEX1NVQlRSQUNUOiAxMDksIFBBR0VfRE9XTjogMzQsIFBBR0VfVVA6IDMzLCBcbiAgICAgICAgICAgIFBFUklPRDogMTkwLCBSSUdIVDogMzksIFNISUZUOiAxNiwgU1BBQ0U6IDMyLCBUQUI6IDksIFVQOiAzOFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLy8gVGFrZXMgYSBrZXlib2FyZCBldmVudCBhbmQgcmV0dXJuIHRydWUgaWYgdGhlIGtleWNvZGUgbWF0Y2ggdGhlIHNwZWNpZmllZCBrZXljb2RlXG4gICAgICAgIGtleUlzOiBmdW5jdGlvbihrLCBlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoJC5rZXlDb2RlW2sudG9VcHBlckNhc2UoKV0sIDEwKSA9PSBwYXJzZUludCgodHlwZW9mKGUpID09ICdudW1iZXInICk/IGU6IGUua2V5Q29kZSwgMTApO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLy8gUmV0dXJucyB0aGUga2V5IG9mIGFuIGFycmF5XG4gICAgICAgIGtleXM6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgdmFyIG8gPSBbXTtcbiAgICAgICAgICAgIGZvciAoayBpbiBhcnIpIHsgby5wdXNoKGspOyB9XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZWRpcmVjdCB0byBhIHNwZWNpZmllZCB1cmxcbiAgICAgICAgcmVkaXJlY3Q6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFN0b3AgZXZlbnQgc2hvcnRoYW5kXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uKGUsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkgIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2ZW50RGVmYXVsdCAmJiBmYWxzZSB8fCB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGJhc2VuYW1lIG9mIGEgcGF0aFxuICAgICAgICBiYXNlbmFtZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgdmFyIHQgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICByZXR1cm4gdFt0Lmxlbmd0aF0gPT09ICcnICYmIHMgfHwgdC5zbGljZSgwLCB0Lmxlbmd0aCkuam9pbignLycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGZpbGVuYW1lIG9mIGEgcGF0aFxuICAgICAgICBmaWxlbmFtZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgfSwgXG5cbiAgICAgICAgLy8gUmV0dXJucyBhIGZvcm1hdGVkIGZpbGUgc2l6ZVxuICAgICAgICBmaWxlc2l6ZWZvcm1hdDogZnVuY3Rpb24oYnl0ZXMsIHN1ZmZpeGVzKXtcbiAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQoYnl0ZXMsIDEwKTtcbiAgICAgICAgICAgIHZhciBzID0gc3VmZml4ZXMgfHwgWydieXRlJywgJ2J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJ107XG4gICAgICAgICAgICBpZiAoaXNOYU4oYikgfHwgYiA9PT0gMCkgeyByZXR1cm4gJzAgJyArIHNbMF07IH1cbiAgICAgICAgICAgIGlmIChiID09IDEpICAgICAgICAgICAgICB7IHJldHVybiAnMSAnICsgc1swXTsgfVxuICAgICAgICAgICAgaWYgKGIgPCAxMDI0KSAgICAgICAgICAgIHsgcmV0dXJuICBiLnRvRml4ZWQoMikgKyAnICcgKyBzWzFdOyB9XG4gICAgICAgICAgICBpZiAoYiA8IDEwNDg1NzYpICAgICAgICAgeyByZXR1cm4gKGIgLyAxMDI0KS50b0ZpeGVkKDIpICsgJyAnICsgc1syXTsgfVxuICAgICAgICAgICAgaWYgKGIgPCAxMDczNzQxODI0KSAgICAgIHsgcmV0dXJuIChiIC8gMTA0ODU3NikudG9GaXhlZCgyKSArICcgJysgc1szXTsgfVxuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuIChiIC8gMTA3Mzc0MTgyNCkudG9GaXhlZCgyKSArICcgJysgc1s0XTsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGVFeHRlbnNpb246IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV0gfHwgZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGlzIGEgU3RyaW5nXG4gICAgICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mKG8pID09ICdzdHJpbmcnICYmIHRydWUgfHwgZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGlzIGEgUmVnRXhwXG5cdFx0aXNSZWdFeHA6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdHJldHVybiBvICYmIG8uY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKCdSZWdFeHAoKScpICE9IC0xIHx8IGZhbHNlO1xuXHRcdH0sXG5cbiAgICAgICAgaXNPYmplY3Q6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mKG8pID09ICdvYmplY3QnKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgaW5wdXQgdG8gY3VycmVuY3kgKHR3byBkZWNpbWFsIGZpeGVkIG51bWJlcilcblx0XHR0b0N1cnJlbmN5OiBmdW5jdGlvbihpKSB7XG5cdFx0XHRpID0gcGFyc2VGbG9hdChpLCAxMCkudG9GaXhlZCgyKTtcblx0XHRcdHJldHVybiAoaT09J05hTicpID8gJzAuMDAnIDogaTtcblx0XHR9LFxuXG4gICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4gICAgICAgICAqIGphdmFzY3JpcHQgbWV0aG9kOiBcInB4VG9FbVwiXG4gICAgICAgICAqIGJ5OlxuICAgICAgICAgICBTY290dCBKZWhsIChzY290dEBmaWxhbWVudGdyb3VwLmNvbSkgXG4gICAgICAgICAgIE1hZ2dpZSBXYWNocyAobWFnZ2llQGZpbGFtZW50Z3JvdXAuY29tKVxuICAgICAgICAgICBodHRwOi8vd3d3LmZpbGFtZW50Z3JvdXAuY29tXG4gICAgICAgICAqXG4gICAgICAgICAqIENvcHlyaWdodCAoYykgMjAwOCBGaWxhbWVudCBHcm91cFxuICAgICAgICAgKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKGZpbGFtZW50Z3JvdXAuY29tL2V4YW1wbGVzL21pdC1saWNlbnNlLnR4dCkgYW5kIEdQTCAoZmlsYW1lbnRncm91cC5jb20vZXhhbXBsZXMvZ3BsLWxpY2Vuc2UudHh0KSBsaWNlbnNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVzY3JpcHRpb246IHB4VG9FbSBjb252ZXJ0cyBhIHBpeGVsIHZhbHVlIHRvIGVtcyBkZXBlbmRpbmcgb24gaW5oZXJpdGVkIGZvbnQgc2l6ZS4gIFxuICAgICAgICAgKiBBcnRpY2xlOiBodHRwOi8vd3d3LmZpbGFtZW50Z3JvdXAuY29tL2xhYi9yZXRhaW5pbmdfc2NhbGFibGVfaW50ZXJmYWNlc193aXRoX3BpeGVsX3RvX2VtX2NvbnZlcnNpb24vXG4gICAgICAgICAqIERlbW86IGh0dHA6Ly93d3cuZmlsYW1lbnRncm91cC5jb20vZXhhbXBsZXMvcHhUb0VtL1x0IFx0XG4gICAgICAgICAqXHRcdFx0XHRcdFx0XHRcbiAgICAgICAgICogT3B0aW9uczogIFx0IFx0XHRcdFx0XHRcdFx0XHRcbiAgICAgICAgICAgICAgICBzY29wZTogc3RyaW5nIG9yIGpRdWVyeSBzZWxlY3RvciBmb3IgZm9udC1zaXplIHNjb3BpbmdcbiAgICAgICAgICAgICAgICByZXZlcnNlOiBCb29sZWFuLCB0cnVlIHJldmVyc2VzIHRoZSBjb252ZXJzaW9uIHRvIGVtLXB4XG4gICAgICAgICAqIERlcGVuZGVuY2llczogalF1ZXJ5IGxpYnJhcnlcdFx0XHRcdFx0XHQgIFxuICAgICAgICAgKiBVc2FnZSBFeGFtcGxlOiBteVBpeGVsVmFsdWUucHhUb0VtKCk7IG9yIG15UGl4ZWxWYWx1ZS5weFRvRW0oeydzY29wZSc6JyNuYXZpZ2F0aW9uJywgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBWZXJzaW9uOiAyLjEsIDE4LjEyLjIwMDhcbiAgICAgICAgICogQ2hhbmdlbG9nOlxuICAgICAgICAgKlx0XHQwOC4wMi4yMDA3IGluaXRpYWwgVmVyc2lvbiAxLjBcbiAgICAgICAgICpcdFx0MDguMDEuMjAwOCAtIGZpeGVkIGZvbnQtc2l6ZSBjYWxjdWxhdGlvbiBmb3IgSUVcbiAgICAgICAgICpcdFx0MTguMTIuMjAwOCAtIHJlbW92ZWQgbmF0aXZlIG9iamVjdCBwcm90b3R5cGluZyB0byBzdGF5IGluIGpRdWVyeSdzIHNwaXJpdCwganNMaW50ZWQgKE1heGltZSBIYWluZWF1bHQgPGhhaW5lYXVsdEBnbWFpbC5jb20+KVxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgcHhUb0VtOiBmdW5jdGlvbihpLCBzZXR0aW5ncyl7XG4gICAgICAgICAgICAvL3NldCBkZWZhdWx0c1xuICAgICAgICAgICAgc2V0dGluZ3MgPSBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBzY29wZTogJ2JvZHknLFxuICAgICAgICAgICAgICAgIHJldmVyc2U6IGZhbHNlXG4gICAgICAgICAgICB9LCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBweFZhbCA9IChpID09PSAnJykgPyAwIDogcGFyc2VGbG9hdChpKTtcbiAgICAgICAgICAgIHZhciBzY29wZVZhbDtcbiAgICAgICAgICAgIHZhciBnZXRXaW5kb3dXaWR0aCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGRlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmlubmVyV2lkdGggfHwgKGRlICYmIGRlLmNsaWVudFdpZHRoKSB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgfTtcdFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBXaGVuIGEgcGVyY2VudGFnZS1iYXNlZCBmb250LXNpemUgaXMgc2V0IG9uIHRoZSBib2R5LCBJRSByZXR1cm5zIHRoYXQgcGVyY2VudCBvZiB0aGUgd2luZG93IHdpZHRoIGFzIHRoZSBmb250LXNpemUuIFxuICAgICAgICAgICAgICAgIEZvciBleGFtcGxlLCBpZiB0aGUgYm9keSBmb250LXNpemUgaXMgNjIuNSUgYW5kIHRoZSB3aW5kb3cgd2lkdGggaXMgMTAwMHB4LCBJRSB3aWxsIHJldHVybiA2MjVweCBhcyB0aGUgZm9udC1zaXplLiBcdFxuICAgICAgICAgICAgICAgIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgYm9keSBmb250LXNpemUgKCUpIGFuZCBtdWx0aXBseSBpdCBieSAxNiAodGhlIHN0YW5kYXJkIGJyb3dzZXIgZm9udCBzaXplKSBcbiAgICAgICAgICAgICAgICB0byBnZXQgYW4gYWNjdXJhdGUgZW0gdmFsdWUuICovXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY29wZSA9PSAnYm9keScgJiYgJC5icm93c2VyLm1zaWUgJiYgKHBhcnNlRmxvYXQoJCgnYm9keScpLmNzcygnZm9udC1zaXplJykpIC8gZ2V0V2luZG93V2lkdGgoKSkudG9GaXhlZCgxKSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxjRm9udFNpemUgPSBmdW5jdGlvbigpe1x0XHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KCQoJ2JvZHknKS5jc3MoJ2ZvbnQtc2l6ZScpKS9nZXRXaW5kb3dXaWR0aCgpKS50b0ZpeGVkKDMpICogMTY7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY29wZVZhbCA9IGNhbGNGb250U2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IHNjb3BlVmFsID0gcGFyc2VGbG9hdChqUXVlcnkoc2V0dGluZ3Muc2NvcGUpLmNzcyhcImZvbnQtc2l6ZVwiKSk7IH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKHNldHRpbmdzLnJldmVyc2UgPT09IHRydWUpID8gKHB4VmFsICogc2NvcGVWYWwpLnRvRml4ZWQoMikgKyAncHgnIDogKHB4VmFsIC8gc2NvcGVWYWwpLnRvRml4ZWQoMikgKyAnZW0nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXHR9KTtcblxuXHQkLmV4dGVuZCgkLmZuLCB7IFxuICAgICAgICB0eXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRyeSB7IHJldHVybiAkKHRoaXMpLmdldCgwKS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICAgICAgICBjYXRjaChlKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBTZWxlY3QgYSB0ZXh0IHJhbmdlIGluIGEgdGV4dGFyZWFcbiAgICAgICAgc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpe1xuICAgICAgICAgICAgLy8gdXNlIG9ubHkgdGhlIGZpcnN0IG9uZSBzaW5jZSBvbmx5IG9uZSBpbnB1dCBjYW4gYmUgZm9jdXNlZFxuICAgICAgICAgICAgaWYgKCQodGhpcykuZ2V0KDApLmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9ICQodGhpcykuZ2V0KDApLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsICAgZW5kKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCQodGhpcykuZ2V0KDApLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5iaW5kKCdmb2N1cycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSkuZ2V0KDApLnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcbiAgICAgICAgICogSlF1ZXJ5IFBsdWdpbjogXCJFcXVhbEhlaWdodHNcIlxuICAgICAgICAgKiBieTpcdFNjb3R0IEplaGwsIFRvZGQgUGFya2VyLCBNYWdnaWUgQ29zdGVsbG8gV2FjaHMgKGh0dHA6Ly93d3cuZmlsYW1lbnRncm91cC5jb20pXG4gICAgICAgICAqXG4gICAgICAgICAqIENvcHlyaWdodCAoYykgMjAwOCBGaWxhbWVudCBHcm91cFxuICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciBHUEwgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvZ3BsLWxpY2Vuc2UucGhwKVxuICAgICAgICAgKlxuICAgICAgICAgKiBEZXNjcmlwdGlvbjogQ29tcGFyZXMgdGhlIGhlaWdodHMgb3Igd2lkdGhzIG9mIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gb2YgYSBwcm92aWRlZCBlbGVtZW50IFxuICAgICAgICAgICAgICAgIGFuZCBzZXRzIHRoZWlyIG1pbi1oZWlnaHQgdG8gdGhlIHRhbGxlc3QgaGVpZ2h0IChvciB3aWR0aCB0byB3aWRlc3Qgd2lkdGgpLiBTZXRzIGluIGVtIHVuaXRzIFxuICAgICAgICAgICAgICAgIGJ5IGRlZmF1bHQgaWYgcHhUb0VtKCkgbWV0aG9kIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICogRGVwZW5kZW5jaWVzOiBqUXVlcnkgbGlicmFyeSwgcHhUb0VtIG1ldGhvZFx0KGFydGljbGU6IFxuICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cuZmlsYW1lbnRncm91cC5jb20vbGFiL3JldGFpbmluZ19zY2FsYWJsZV9pbnRlcmZhY2VzX3dpdGhfcGl4ZWxfdG9fZW1fY29udmVyc2lvbi8pXHRcdFx0XHRcdFx0XHQgIFxuICAgICAgICAgKiBVc2FnZSBFeGFtcGxlOiAkKGVsZW1lbnQpLmVxdWFsSGVpZ2h0cygpO1xuICAgICAgICAgICAgICAgIE9wdGlvbmFsOiB0byBzZXQgbWluLWhlaWdodCBpbiBweCwgcGFzcyBhIHRydWUgYXJndW1lbnQ6ICQoZWxlbWVudCkuZXF1YWxIZWlnaHRzKHRydWUpO1xuICAgICAgICAgKiBWZXJzaW9uOiAyLjEsIDE4LjEyLjIwMDhcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogQ2hhbmdlZCBweFRvRW0gY2FsbCB0byBjYWxsICQucHhUb0VtIGluc3RlYWQsIGpzTGludGVkIChNYXhpbWUgSGFpbmVhdWx0IDxoYWluZWF1bHRAZ21haWwuY29tPilcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIGVxdWFsSGVpZ2h0czogZnVuY3Rpb24ocHgpe1xuICAgICAgICAgICAgJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUYWxsZXN0ID0gMDtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQodGhpcykuaGVpZ2h0KCkgPiBjdXJyZW50VGFsbGVzdCkgeyBjdXJyZW50VGFsbGVzdCA9ICQodGhpcykuaGVpZ2h0KCk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXB4IHx8ICEkLnB4VG9FbSkgeyBjdXJyZW50VGFsbGVzdCA9ICQucHhUb0VtKGN1cnJlbnRUYWxsZXN0KTsgfSAvL3VzZSBlbXMgdW5sZXNzIHB4IGlzIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIC8vIGZvciBpZTYsIHNldCBoZWlnaHQgc2luY2UgbWluLWhlaWdodCBpc24ndCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBpZiAoJC5icm93c2VyLm1zaWUgJiYgJC5icm93c2VyLnZlcnNpb24gPT0gNi4wKSB7ICQodGhpcykuY2hpbGRyZW4oKS5jc3MoeydoZWlnaHQnOiBjdXJyZW50VGFsbGVzdH0pOyB9XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jaGlsZHJlbigpLmNzcyh7J21pbi1oZWlnaHQnOiBjdXJyZW50VGFsbGVzdH0pOyBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSAyMDA5IEphbWVzIFBhZG9sc2V5XG4gICAgICAgIC8vIGh0dHA6Ly9qYW1lcy5wYWRvbHNleS5jb20vamF2YXNjcmlwdC9qcXVlcnktZGVsYXktcGx1Z2luL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24odGltZSwgY2FsbGJhY2spe1xuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0ZXAuZGVsYXkgPSBmdW5jdGlvbigpe307XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtkZWxheToxfSwgdGltZSwgY2FsbGJhY2spO1xuICAgICAgICB9ICAgICAgICBcblx0fSk7XG59KShqUXVlcnkpO1xuLypcbiAgalF1ZXJ5IHN0cmluZ3MgLSAwLjNcbiAgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS11dGlscy9cbiAgXG4gIChjKSBNYXhpbWUgSGFpbmVhdWx0IDxoYWluZWF1bHRAZ21haWwuY29tPlxuICBodHRwOi8vaGFpbmVhdWx0LmNvbSAgIFxuXG4gIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcblxuICBJbXBsZW1lbnRhdGlvbiBvZiBQeXRob24zSyBhZHZhbmNlZCBzdHJpbmcgZm9ybWF0dGluZ1xuICBodHRwOi8vd3d3LnB5dGhvbi5vcmcvZGV2L3BlcHMvcGVwLTMxMDEvXG5cbiAgRG9jdW1lbnRhdGlvbjogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS11dGlscy93aWtpL1N0cmluZ0Zvcm1hdFxuICBcbiovXG4oZnVuY3Rpb24oJCl7XG4gICAgdmFyIHN0cmluZ3MgPSB7XG4gICAgICAgIHN0ckNvbnZlcnNpb246IHtcbiAgICAgICAgICAgIC8vIHRyaWVzIHRvIHRyYW5zbGF0ZSBhbnkgb2JqZWN0cyB0eXBlIGludG8gc3RyaW5nIGdyYWNlZnVsbHlcbiAgICAgICAgICAgIF9fcmVwcjogZnVuY3Rpb24oaSl7XG4gICAgICAgICAgICAgICAgc3dpdGNoKHRoaXMuX19nZXRUeXBlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpjYXNlICdkYXRlJzpjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh4PTA7IHg8aS5sZW5ndGg7IGkrKykgeyBvLnB1c2goaSsnOiAnKyB0aGlzLl9fcmVwcihpW3hdKSk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGxpa2UgdHlwZW9mIGJ1dCBsZXNzIHZhZ3VlXG4gICAgICAgICAgICBfX2dldFR5cGU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWkgfHwgIWkuY29uc3RydWN0b3IpIHsgcmV0dXJuIHR5cGVvZihpKTsgfVxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGkuY29uc3RydWN0b3IudG9TdHJpbmcoKS5tYXRjaCgvQXJyYXl8TnVtYmVyfFN0cmluZ3xPYmplY3R8RGF0ZS8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIHx8IHR5cGVvZihpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLysgSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhXG4gICAgICAgICAgICAvLyB0aGUgQCBzaWduIG5leHQgdG8gXCIvL1wiIGlzIGludGVycHJldGVkIGJ5IElFIHdoZW4gdXNpbmcgY2M8dW5kZXJzY29yZT5vbiEgSW5zZXJ0ZWQgYSBzcGFjZS5cbiAgICAgICAgICAgIC8vICBAIGh0dHA6Ly9qc2Zyb21oZWxsLmNvbS9zdHJpbmcvcGFkIFt2MS4wXVxuICAgICAgICAgICAgX19wYWQ6IGZ1bmN0aW9uKHN0ciwgbCwgcywgdCl7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBzIHx8ICcgJztcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHN0cjtcbiAgICAgICAgICAgICAgICBpZiAobCAtIHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBuZXcgQXJyYXkoTWF0aC5jZWlsKGwgLyBwLmxlbmd0aCkpLmpvaW4ocCkuc3Vic3RyKDAsIHQgPSAhdCA/IGwgOiB0ID09IDEgPyAwIDogTWF0aC5jZWlsKGwgLyAyKSkgKyBzdHIgKyBwLnN1YnN0cigwLCBsIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9fZ2V0SW5wdXQ6IGZ1bmN0aW9uKGFyZywgYXJncykge1xuICAgICAgICAgICAgICAgICB2YXIga2V5ID0gYXJnLmdldEtleSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCh0aGlzLl9fZ2V0VHlwZShhcmdzKSl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IC8vIFRoYW5rcyB0byBKb25hdGhhbiBXb3JrcyBmb3IgdGhlIHBhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHN1YmtleSA9IDA7IHN1YmtleSA8IGtleXMubGVuZ3RoOyBzdWJrZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleXNbc3Via2V5XV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKG9iaikgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5zdHJDb252ZXJzaW9uLl9fZ2V0VHlwZShvYmopID09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5nZXRGb3JtYXQoKS5tYXRjaCgvXFwuXFwqLykgJiYgb2JqWzFdIHx8IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRyeSBieSBudW1lcmljYWwgaW5kZXggICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5nZXRGb3JtYXQoKS5tYXRjaCgvXFwuXFwqLykgJiYgdHlwZW9mIGFyZ3Nba2V5KzFdICE9ICd1bmRlZmluZWQnKSB7IHJldHVybiBhcmdzW2tleSsxXTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3Nba2V5XSAhPSAndW5kZWZpbmVkJykgeyByZXR1cm4gYXJnc1trZXldOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgcmV0dXJuIGtleTsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7JytrZXkrJ30nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9fZm9ybWF0VG9rZW46IGZ1bmN0aW9uKHRva2VuLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyAgID0gbmV3IEFyZ3VtZW50KHRva2VuLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5zdHJDb252ZXJzaW9uW2FyZy5nZXRGb3JtYXQoKS5zbGljZSgtMSldKHRoaXMuX19nZXRJbnB1dChhcmcsIGFyZ3MpLCBhcmcpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gU2lnbmVkIGludGVnZXIgZGVjaW1hbC5cbiAgICAgICAgICAgIGQ6IGZ1bmN0aW9uKGlucHV0LCBhcmcpe1xuICAgICAgICAgICAgICAgIHZhciBvID0gcGFyc2VJbnQoaW5wdXQsIDEwKTsgLy8gZW5mb3JjZSBiYXNlIDEwXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBhcmcuZ2V0UGFkZGluZ0xlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChwKSB7IHJldHVybiB0aGlzLl9fcGFkKG8udG9TdHJpbmcoKSwgcCwgYXJnLmdldFBhZGRpbmdTdHJpbmcoKSwgMCk7IH1cbiAgICAgICAgICAgICAgICBlbHNlICAgeyByZXR1cm4gbzsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFNpZ25lZCBpbnRlZ2VyIGRlY2ltYWwuXG4gICAgICAgICAgICBpOiBmdW5jdGlvbihpbnB1dCwgYXJncyl7IFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmQoaW5wdXQsIGFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFVuc2lnbmVkIG9jdGFsXG4gICAgICAgICAgICBvOiBmdW5jdGlvbihpbnB1dCwgYXJnKXsgXG4gICAgICAgICAgICAgICAgdmFyIG8gPSBpbnB1dC50b1N0cmluZyg4KTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmlzQWx0ZXJuYXRlKCkpIHsgbyA9IHRoaXMuX19wYWQobywgby5sZW5ndGgrMSwgJzAnLCAwKTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fcGFkKG8sIGFyZy5nZXRQYWRkaW5nTGVuZ3RoKCksIGFyZy5nZXRQYWRkaW5nU3RyaW5nKCksIDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFVuc2lnbmVkIGRlY2ltYWxcbiAgICAgICAgICAgIHU6IGZ1bmN0aW9uKGlucHV0LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZChpbnB1dCwgYXJncykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFVuc2lnbmVkIGhleGFkZWNpbWFsIChsb3dlcmNhc2UpXG4gICAgICAgICAgICB4OiBmdW5jdGlvbihpbnB1dCwgYXJnKXtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHBhcnNlSW50KGlucHV0LCAxMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIG8gPSB0aGlzLl9fcGFkKG8sIGFyZy5nZXRQYWRkaW5nTGVuZ3RoKCksIGFyZy5nZXRQYWRkaW5nU3RyaW5nKCksMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5pc0FsdGVybmF0ZSgpID8gJzB4JytvIDogbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBVbnNpZ25lZCBoZXhhZGVjaW1hbCAodXBwZXJjYXNlKVxuICAgICAgICAgICAgWDogZnVuY3Rpb24oaW5wdXQsIGFyZyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueChpbnB1dCwgYXJnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEZsb2F0aW5nIHBvaW50IGV4cG9uZW50aWFsIGZvcm1hdCAobG93ZXJjYXNlKVxuICAgICAgICAgICAgZTogZnVuY3Rpb24oaW5wdXQsIGFyZyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoaW5wdXQsIDEwKS50b0V4cG9uZW50aWFsKGFyZy5nZXRQcmVjaXNpb24oKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRmxvYXRpbmcgcG9pbnQgZXhwb25lbnRpYWwgZm9ybWF0ICh1cHBlcmNhc2UpXG4gICAgICAgICAgICBFOiBmdW5jdGlvbihpbnB1dCwgYXJnKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lKGlucHV0LCBhcmcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRmxvYXRpbmcgcG9pbnQgZGVjaW1hbCBmb3JtYXRcbiAgICAgICAgICAgIGY6IGZ1bmN0aW9uKGlucHV0LCBhcmcpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fcGFkKHBhcnNlRmxvYXQoaW5wdXQsIDEwKS50b0ZpeGVkKGFyZy5nZXRQcmVjaXNpb24oKSksIGFyZy5nZXRQYWRkaW5nTGVuZ3RoKCksIGFyZy5nZXRQYWRkaW5nU3RyaW5nKCksMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRmxvYXRpbmcgcG9pbnQgZGVjaW1hbCBmb3JtYXQgKGFsaWFzKVxuICAgICAgICAgICAgRjogZnVuY3Rpb24oaW5wdXQsIGFyZ3Mpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmYoaW5wdXQsIGFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEZsb2F0aW5nIHBvaW50IGZvcm1hdC4gVXNlcyBleHBvbmVudGlhbCBmb3JtYXQgaWYgZXhwb25lbnQgaXMgZ3JlYXRlciB0aGFuIC00IG9yIGxlc3MgdGhhbiBwcmVjaXNpb24sIGRlY2ltYWwgZm9ybWF0IG90aGVyd2lzZVxuICAgICAgICAgICAgZzogZnVuY3Rpb24oaW5wdXQsIGFyZyl7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBwYXJzZUZsb2F0KGlucHV0LCAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChvLnRvU3RyaW5nKCkubGVuZ3RoID4gNikgPyBNYXRoLnJvdW5kKG8udG9FeHBvbmVudGlhbChhcmcuZ2V0UHJlY2lzaW9uKCkpKTogbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBGbG9hdGluZyBwb2ludCBmb3JtYXQuIFVzZXMgZXhwb25lbnRpYWwgZm9ybWF0IGlmIGV4cG9uZW50IGlzIGdyZWF0ZXIgdGhhbiAtNCBvciBsZXNzIHRoYW4gcHJlY2lzaW9uLCBkZWNpbWFsIGZvcm1hdCBvdGhlcndpc2VcbiAgICAgICAgICAgIEc6IGZ1bmN0aW9uKGlucHV0LCBhcmdzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nKGlucHV0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTaW5nbGUgY2hhcmFjdGVyIChhY2NlcHRzIGludGVnZXIgb3Igc2luZ2xlIGNoYXJhY3RlciBzdHJpbmcpLiBcdFxuICAgICAgICAgICAgYzogZnVuY3Rpb24oaW5wdXQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvXFx3fFxcZC8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFswXSB8fCAnJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTdHJpbmcgKGNvbnZlcnRzIGFueSBKYXZhU2NyaXB0IG9iamVjdCB0byBhbm90YXRlZCBmb3JtYXQpXG4gICAgICAgICAgICByOiBmdW5jdGlvbihpbnB1dCwgYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fcmVwcihpbnB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gU3RyaW5nIChjb252ZXJ0cyBhbnkgSmF2YVNjcmlwdCBvYmplY3QgdXNpbmcgb2JqZWN0LnRvU3RyaW5nKCkpXG4gICAgICAgICAgICBzOiBmdW5jdGlvbihpbnB1dCwgYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC50b1N0cmluZyAmJiBpbnB1dC50b1N0cmluZygpIHx8ICcnK2lucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oc3RyLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZW5kICAgID0gMDtcbiAgICAgICAgICAgIHZhciBzdGFydCAgPSAwO1xuICAgICAgICAgICAgdmFyIG1hdGNoICA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgdmFyIHRva2VuICA9ICcnO1xuICAgICAgICAgICAgdmFyIHRtcCAgICA9IChzdHJ8fCcnKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICBmb3Ioc3RhcnQ9MDsgc3RhcnQgPCB0bXAubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRtcFtzdGFydF0gPT0gJ3snICYmIHRtcFtzdGFydCsxXSAhPSd7Jykge1xuICAgICAgICAgICAgICAgICAgICBlbmQgICA9IHN0ci5pbmRleE9mKCd9Jywgc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRtcC5zbGljZShzdGFydCsxLCBlbmQpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wW3N0YXJ0LTFdICE9ICd7JyAmJiB0bXBbZW5kKzFdICE9ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuQXJncyA9ICh0eXBlb2YgYXJndW1lbnRzWzFdICE9ICdvYmplY3QnKT8gYXJndW1lbnRzMkFycmF5KGFyZ3VtZW50cywgMik6IGFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChzdHJpbmdzLnN0ckNvbnZlcnNpb24uX19mb3JtYXRUb2tlbih0b2tlbiwgdG9rZW5BcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgPiBlbmQgfHwgYnVmZmVyLmxlbmd0aCA8IDEpIHsgYnVmZmVyLnB1c2godG1wW3N0YXJ0XSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYnVmZmVyLmxlbmd0aCA+IDEpPyBidWZmZXIuam9pbignJyk6IGJ1ZmZlclswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxjOiBmdW5jdGlvbihzdHIsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsKGZvcm1hdChzdHIsIGFyZ3MpKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXBlYXQ6IGZ1bmN0aW9uKHMsIG4pIHsgXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KG4rMSkuam9pbihzKTsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgVVRGOGVuY29kZTogZnVuY3Rpb24ocykgeyBcbiAgICAgICAgICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocykpOyBcbiAgICAgICAgfSxcblxuICAgICAgICBVVEY4ZGVjb2RlOiBmdW5jdGlvbihzKSB7IFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocykpOyBcbiAgICAgICAgfSxcblxuICAgICAgICB0cGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9ICcnO1xuICAgICAgICAgICAgdmFyIHJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICAvLyBTZXRcbiAgICAgICAgICAgIC8vICQudHBsKCd1aS50ZXN0JywgWyc8c3Bhbj4nLCBoZWxsb1dvcmxkICwnPC9zcGFuPiddKTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIgJiYgJC5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV0uam9pbignJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpc1thcmd1bWVudHNbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICQudHBsKCd1aS50ZXN0JywgJzxzcGFuPmhlbGxvIHdvcmxkPC9zcGFuPicpO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiAmJiAkLmlzU3RyaW5nKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpc1thcmd1bWVudHNbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGxcbiAgICAgICAgICAgIC8vICQudHBsKCd1aS50ZXN0Jyk7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpc1thcmd1bWVudHNbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICQudHBsKCd1aS50ZXN0JywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiAmJiBhcmd1bWVudHNbMV0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1thcmd1bWVudHNbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJC50cGwoJ3VpLnRlc3QnLCB7dmFsdWU6YmxhaH0pO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiAmJiAkLmlzT2JqZWN0KGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCgkLmZvcm1hdCh0aGlzW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJC50cGwoJ3VpLnRlc3QnLCB7dmFsdWU6YmxhaH0sIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDMgJiYgJC5pc09iamVjdChhcmd1bWVudHNbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhcmd1bWVudHNbMl0gPT0gdHJ1ZSkgXG4gICAgICAgICAgICAgICAgICAgID8gJC5mb3JtYXQodGhpc1thcmd1bWVudHNbMF1dLCBhcmd1bWVudHNbMV0pXG4gICAgICAgICAgICAgICAgICAgIDogJCgkLmZvcm1hdCh0aGlzW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBBcmd1bWVudCA9IGZ1bmN0aW9uKGFyZywgYXJncykge1xuICAgICAgICB0aGlzLl9fYXJnICA9IGFyZztcbiAgICAgICAgdGhpcy5fX2FyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLl9fbWF4X3ByZWNpc2lvbiA9IHBhcnNlRmxvYXQoJzEuJysgKG5ldyBBcnJheSgzMikpLmpvaW4oJzEnKSwgMTApLnRvU3RyaW5nKCkubGVuZ3RoLTM7XG4gICAgICAgIHRoaXMuX19kZWZfcHJlY2lzaW9uID0gNjtcbiAgICAgICAgdGhpcy5nZXRTdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19hcmc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0S2V5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fYXJnLnNwbGl0KCc6JylbMF07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Rm9ybWF0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuZ2V0U3RyaW5nKCkuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2hbMV0pPyBtYXRjaFsxXTogJ3MnO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLmdldEZvcm1hdCgpLm1hdGNoKC9cXC4oXFxkK3xcXCopL2cpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gdGhpcy5fX2RlZl9wcmVjaXNpb247IH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hbMF0uc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9ICcqJykgeyByZXR1cm4gcGFyc2VJbnQobWF0Y2gsIDEwKTsgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3RyaW5ncy5zdHJDb252ZXJzaW9uLl9fZ2V0VHlwZSh0aGlzLl9fYXJncykgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FyZ3NbMV0gJiYgdGhpcy5fX2FyZ3NbMF0gfHwgdGhpcy5fX2RlZl9wcmVjaXNpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3RyaW5ncy5zdHJDb252ZXJzaW9uLl9fZ2V0VHlwZSh0aGlzLl9fYXJncykgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19hcmdzW3RoaXMuZ2V0S2V5KCldICYmIHRoaXMuX19hcmdzW3RoaXMuZ2V0S2V5KCldWzBdIHx8IHRoaXMuX19kZWZfcHJlY2lzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuX19kZWZfcHJlY2lzaW9uOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UGFkZGluZ0xlbmd0aCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWx0ZXJuYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMuZ2V0U3RyaW5nKCkubWF0Y2goLzA/IzA/KFxcZCspLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7IHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaCA9IHRoaXMuZ2V0U3RyaW5nKCkubWF0Y2goLygwfFxcLikoXFxkK3xcXCopL2cpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoICYmIHBhcnNlSW50KG1hdGNoWzBdLnNsaWNlKDEpLCAxMCkgfHwgMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRQYWRkaW5nU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBvID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FsdGVybmF0ZSgpKSB7IG8gPSAnICc7IH1cbiAgICAgICAgICAgIC8vIDAgdGFrZSBwcmVjZWRlbmNlIG9uIGFsdGVybmF0ZSBmb3JtYXRcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEZvcm1hdCgpLm1hdGNoKC8jMHwwI3xeMHxcXC5cXGQrLykpIHsgbyA9ICcwJzsgfVxuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RmxhZ3MgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5nZXRTdHJpbmcoKS5tYXRjKC9eKDB8XFwjfFxcLXxcXCt8XFxzKSsvKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFswXS5zcGxpdCgnJykgfHwgW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNBbHRlcm5hdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ2V0Rm9ybWF0KCkubWF0Y2goL14wPyMvKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFyZ3VtZW50czJBcnJheSA9IGZ1bmN0aW9uKGFyZ3MsIHNoaWZ0KSB7XG4gICAgICAgIHZhciBvID0gW107XG4gICAgICAgIGZvciAobD1hcmdzLmxlbmd0aCwgeD0oc2hpZnQgfHwgMCktMTsgeDxsO3grKykgeyBvLnB1c2goYXJnc1t4XSk7IH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICAkLmV4dGVuZChzdHJpbmdzKTtcbn0pKGpRdWVyeSk7XG4vKlxuICBqUXVlcnkgYW5jaG9yIGhhbmRsZXIgLSAwLjVcbiAgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS11dGlscy9cblxuICAoYykgTWF4aW1lIEhhaW5lYXVsdCA8aGFpbmVhdWx0QGdtYWlsLmNvbT5cbiAgaHR0cDovL2hhaW5lYXVsdC5jb20gICBcblxuICBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG5cbiovXG5cbihmdW5jdGlvbigkKXtcbiAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgIHZhciBoYW5kbGVycyAgPSBbXTtcbiAgICB2YXIgb3B0ID0ge307XG5cblx0JC5leHRlbmQoe1xuXHRcdGFuY2hvckhhbmRsZXI6IHtcbiAgICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkLm1hcChoYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGhhc2gubWF0Y2goaGFuZGxlci5yKSAmJiBoYXNoLm1hdGNoKGhhbmRsZXIucilbMF0gfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkgIHsgaGFuZGxlci5jYi5hcHBseSgkKCdhW2hyZWYqPScrbWF0Y2grJ10nKS5nZXQoMCksIFtoYW5kbGVyLnIsIGhhc2ggfHwgJyddKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmFuY2hvckhhbmRsZXI7XG4gICAgICAgICAgICB9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbihyZWdleHAsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdCAgPSAkLmV4dGVuZCh7aGFuZGxlQ2xpY2s6IHRydWUsIHByZXNlcnZlSGFzaDogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaGFuZGxlQ2xpY2spIHsgXG4gICAgICAgICAgICAgICAgICAgICQoJ2FbaHJlZio9I10nKS5lYWNoKGZ1bmN0aW9uKGksIGEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEuaHJlZi5tYXRjaChyZWdleHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChhKS5iaW5kKCdjbGljay5hbmNob3JIYW5kbGVyJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5wcmVzZXJ2ZUhhc2gpIHsgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBhLmhhc2g7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIFtyZWdleHAsIGEuaHJlZl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0aGFuZGxlcnMucHVzaCh7cjogcmVnZXhwLCBjYjogY2FsbGJhY2t9KTtcbiAgICAgICAgICAgICAgICAkKCQuYW5jaG9ySGFuZGxlci5hcHBseSk7XG5cdFx0XHRcdHJldHVybiAkLmFuY2hvckhhbmRsZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vKipcbiAqIENvb2tpZSBwbHVnaW5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgS2xhdXMgSGFydGwgKHN0aWxidWVyby5kZSlcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwuaHRtbFxuICpcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvb2tpZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZSBhbmQgb3RoZXIgb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsICd0aGVfdmFsdWUnKTtcbiAqIEBkZXNjIFNldCB0aGUgdmFsdWUgb2YgYSBjb29raWUuXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsICd0aGVfdmFsdWUnLCB7IGV4cGlyZXM6IDcsIHBhdGg6ICcvJywgZG9tYWluOiAnanF1ZXJ5LmNvbScsIHNlY3VyZTogdHJ1ZSB9KTtcbiAqIEBkZXNjIENyZWF0ZSBhIGNvb2tpZSB3aXRoIGFsbCBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEBleGFtcGxlICQuY29va2llKCd0aGVfY29va2llJywgJ3RoZV92YWx1ZScpO1xuICogQGRlc2MgQ3JlYXRlIGEgc2Vzc2lvbiBjb29raWUuXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsIG51bGwpO1xuICogQGRlc2MgRGVsZXRlIGEgY29va2llIGJ5IHBhc3NpbmcgbnVsbCBhcyB2YWx1ZS4gS2VlcCBpbiBtaW5kIHRoYXQgeW91IGhhdmUgdG8gdXNlIHRoZSBzYW1lIHBhdGggYW5kIGRvbWFpblxuICogICAgICAgdXNlZCB3aGVuIHRoZSBjb29raWUgd2FzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZS5cbiAqIEBwYXJhbSBTdHJpbmcgdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjb29raWUuXG4gKiBAcGFyYW0gT2JqZWN0IG9wdGlvbnMgQW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgdG8gcHJvdmlkZSBvcHRpb25hbCBjb29raWUgYXR0cmlidXRlcy5cbiAqIEBvcHRpb24gTnVtYmVyfERhdGUgZXhwaXJlcyBFaXRoZXIgYW4gaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBleHBpcmF0aW9uIGRhdGUgZnJvbSBub3cgb24gaW4gZGF5cyBvciBhIERhdGUgb2JqZWN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgbmVnYXRpdmUgdmFsdWUgaXMgc3BlY2lmaWVkIChlLmcuIGEgZGF0ZSBpbiB0aGUgcGFzdCksIHRoZSBjb29raWUgd2lsbCBiZSBkZWxldGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNldCB0byBudWxsIG9yIG9taXR0ZWQsIHRoZSBjb29raWUgd2lsbCBiZSBhIHNlc3Npb24gY29va2llIGFuZCB3aWxsIG5vdCBiZSByZXRhaW5lZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHRoZSBicm93c2VyIGV4aXRzLlxuICogQG9wdGlvbiBTdHJpbmcgcGF0aCBUaGUgdmFsdWUgb2YgdGhlIHBhdGggYXRyaWJ1dGUgb2YgdGhlIGNvb2tpZSAoZGVmYXVsdDogcGF0aCBvZiBwYWdlIHRoYXQgY3JlYXRlZCB0aGUgY29va2llKS5cbiAqIEBvcHRpb24gU3RyaW5nIGRvbWFpbiBUaGUgdmFsdWUgb2YgdGhlIGRvbWFpbiBhdHRyaWJ1dGUgb2YgdGhlIGNvb2tpZSAoZGVmYXVsdDogZG9tYWluIG9mIHBhZ2UgdGhhdCBjcmVhdGVkIHRoZSBjb29raWUpLlxuICogQG9wdGlvbiBCb29sZWFuIHNlY3VyZSBJZiB0cnVlLCB0aGUgc2VjdXJlIGF0dHJpYnV0ZSBvZiB0aGUgY29va2llIHdpbGwgYmUgc2V0IGFuZCB0aGUgY29va2llIHRyYW5zbWlzc2lvbiB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgYSBzZWN1cmUgcHJvdG9jb2wgKGxpa2UgSFRUUFMpLlxuICogQHR5cGUgdW5kZWZpbmVkXG4gKlxuICogQG5hbWUgJC5jb29raWVcbiAqIEBjYXQgUGx1Z2lucy9Db29raWVcbiAqIEBhdXRob3IgS2xhdXMgSGFydGwva2xhdXMuaGFydGxAc3RpbGJ1ZXJvLmRlXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGEgY29va2llIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKlxuICogQGV4YW1wbGUgJC5jb29raWUoJ3RoZV9jb29raWUnKTtcbiAqIEBkZXNjIEdldCB0aGUgdmFsdWUgb2YgYSBjb29raWUuXG4gKlxuICogQHBhcmFtIFN0cmluZyBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb29raWUuXG4gKiBAcmV0dXJuIFRoZSB2YWx1ZSBvZiB0aGUgY29va2llLlxuICogQHR5cGUgU3RyaW5nXG4gKlxuICogQG5hbWUgJC5jb29raWVcbiAqIEBjYXQgUGx1Z2lucy9Db29raWVcbiAqIEBhdXRob3IgS2xhdXMgSGFydGwva2xhdXMuaGFydGxAc3RpbGJ1ZXJvLmRlXG4gKi9cbmpRdWVyeS5jb29raWUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3VuZGVmaW5lZCcpIHsgLy8gbmFtZSBhbmQgdmFsdWUgZ2l2ZW4sIHNldCBjb29raWVcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIG9wdGlvbnMuZXhwaXJlcyA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBpcmVzID0gJyc7XG4gICAgICAgIGlmIChvcHRpb25zLmV4cGlyZXMgJiYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgPT0gJ251bWJlcicgfHwgb3B0aW9ucy5leHBpcmVzLnRvVVRDU3RyaW5nKSkge1xuICAgICAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwaXJlcyA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChvcHRpb25zLmV4cGlyZXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBvcHRpb25zLmV4cGlyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpOyAvLyB1c2UgZXhwaXJlcyBhdHRyaWJ1dGUsIG1heC1hZ2UgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuICAgICAgICB9XG4gICAgICAgIC8vIENBVVRJT046IE5lZWRlZCB0byBwYXJlbnRoZXNpemUgb3B0aW9ucy5wYXRoIGFuZCBvcHRpb25zLmRvbWFpblxuICAgICAgICAvLyBpbiB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb25zLCBvdGhlcndpc2UgdGhleSBldmFsdWF0ZSB0byB1bmRlZmluZWRcbiAgICAgICAgLy8gaW4gdGhlIHBhY2tlZCB2ZXJzaW9uIGZvciBzb21lIHJlYXNvbi4uLlxuICAgICAgICB2YXIgcGF0aCA9IG9wdGlvbnMucGF0aCA/ICc7IHBhdGg9JyArIChvcHRpb25zLnBhdGgpIDogJyc7XG4gICAgICAgIHZhciBkb21haW4gPSBvcHRpb25zLmRvbWFpbiA/ICc7IGRvbWFpbj0nICsgKG9wdGlvbnMuZG9tYWluKSA6ICcnO1xuICAgICAgICB2YXIgc2VjdXJlID0gb3B0aW9ucy5zZWN1cmUgPyAnOyBzZWN1cmUnIDogJyc7XG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IFtuYW1lLCAnPScsIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSksIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlXS5qb2luKCcnKTtcbiAgICB9IGVsc2UgeyAvLyBvbmx5IG5hbWUgZ2l2ZW4sIGdldCBjb29raWVcbiAgICAgICAgdmFyIGNvb2tpZVZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGRvY3VtZW50LmNvb2tpZSAmJiBkb2N1bWVudC5jb29raWUgIT0gJycpIHtcbiAgICAgICAgICAgIHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29va2llID0galF1ZXJ5LnRyaW0oY29va2llc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gRG9lcyB0aGlzIGNvb2tpZSBzdHJpbmcgYmVnaW4gd2l0aCB0aGUgbmFtZSB3ZSB3YW50P1xuICAgICAgICAgICAgICAgIGlmIChjb29raWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoICsgMSkgPT0gKG5hbWUgKyAnPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZVZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZS5zdWJzdHJpbmcobmFtZS5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2llVmFsdWU7XG4gICAgfVxufTtcbi8qXG4gIGpRdWVyeSBjb3VudGRvd24gLSAwLjJcbiAgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS11dGlscy9cblxuICAoYykgTWF4aW1lIEhhaW5lYXVsdCA8aGFpbmVhdWx0QGdtYWlsLmNvbT5cbiAgaHR0cDovL2hhaW5lYXVsdC5jb20gICBcblxuICBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gIFxuKi9cblxuKGZ1bmN0aW9uKCQpIHtcbiAgICBmdW5jdGlvbiBjb3VudGRvd24oZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNhbGMgPSBmdW5jdGlvbiAodGFyZ2V0LCBjdXJyZW50KSB7XG4gICAgICAgICAgICAvKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdGFyZ2V0IGRhdGUgaGFzIGFycml2ZWQsXG4gICAgICAgICAgICAgKiBhbiBvYmplY3Qgb2YgdGhlIHRpbWUgbGVmdCBvdGhlcndpc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY3VycmVudCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPj0gdGFyZ2V0KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgICAgIHZhciBvID0ge307XG4gICAgICAgICAgICB2YXIgcmVtYWluID0gTWF0aC5mbG9vcigodGFyZ2V0LmdldFRpbWUoKSAtIGN1cnJlbnQuZ2V0VGltZSgpKSAvIDEwMDApO1xuXG4gICAgICAgICAgICBvLmRheXMgPSBNYXRoLmZsb29yKHJlbWFpbiAvIDg2NDAwKTtcbiAgICAgICAgICAgIHJlbWFpbiAlPSA4NjQwMDtcbiAgICAgICAgICAgIG8uaG91cnMgPSBNYXRoLmZsb29yKHJlbWFpbiAvIDM2MDApO1xuICAgICAgICAgICAgcmVtYWluICU9IDM2MDA7XG4gICAgICAgICAgICBvLm1pbnV0ZXMgPSBNYXRoLmZsb29yKHJlbWFpbiAvIDYwKTtcbiAgICAgICAgICAgIHJlbWFpbiAlPSA2MDtcbiAgICAgICAgICAgIG8uc2Vjb25kcyA9IHJlbWFpbjtcbiAgICAgICAgICAgIG8ueWVhcnMgPSBNYXRoLmZsb29yKG8uZGF5cyAvIDM2NSk7XG4gICAgICAgICAgICBvLm1vbnRocyA9IE1hdGguZmxvb3Ioby5kYXlzIC8gMzApO1xuICAgICAgICAgICAgby53ZWVrcyA9IE1hdGguZmxvb3Ioby5kYXlzIC8gNyk7XG5cbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRXZWVrID0gZnVuY3Rpb24oZGF0ZSkgeyBcbiAgICAgICAgICAgIHZhciBvbmVqYW4gPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoKCgoZGF0ZSAtIG9uZWphbikgLyA4NjQwMDAwMCkgKyBvbmVqYW4uZ2V0RGF5KCkpLzcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICAgICAgICBpbnRlcnZhbDogMTAwMCxcbiAgICAgICAgICAgIG1zZ0Zvcm1hdDogJyVkIFtkYXl8ZGF5c10gJWhoICVtbSAlc3MnLFxuICAgICAgICAgICAgbXNnTm93OiAnTm93ICEnXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0b2tlbnMgPSB7XG4gICAgICAgICAgICB5OiBuZXcgUmVnRXhwICgnXFxcXCV5KC4rPylcXFxcWyhcXFxcdyspXFxcXHwoXFxcXHcrKVxcXFxdJywgJ2cnKSwgLy8geWVhcnMgXG4gICAgICAgICAgICBNOiBuZXcgUmVnRXhwICgnXFxcXCVNKC4rPylcXFxcWyhcXFxcdyspXFxcXHwoXFxcXHcrKVxcXFxdJywgJ2cnKSwgLy8gbW9udGhzIFxuICAgICAgICAgICAgdzogbmV3IFJlZ0V4cCAoJ1xcXFwldyguKz8pXFxcXFsoXFxcXHcrKVxcXFx8KFxcXFx3KylcXFxcXScsICdnJyksIC8vIHdlZWtzXG4gICAgICAgICAgICBkOiBuZXcgUmVnRXhwICgnXFxcXCVkKC4rPylcXFxcWyhcXFxcdyspXFxcXHwoXFxcXHcrKVxcXFxdJywgJ2cnKSwgLy8gZGF5c1xuICAgICAgICAgICAgaDogbmV3IFJlZ0V4cCAoJ1xcXFwlaCguKz8pXFxcXFsoXFxcXHcrKVxcXFx8KFxcXFx3KylcXFxcXScsICdnJyksIC8vIGhvdXJzXG4gICAgICAgICAgICBtOiBuZXcgUmVnRXhwICgnXFxcXCVtKC4rPylcXFxcWyhcXFxcdyspXFxcXHwoXFxcXHcrKVxcXFxdJywgJ2cnKSwgLy8gbWludXRlc1xuICAgICAgICAgICAgczogbmV3IFJlZ0V4cCAoJ1xcXFwlcyguKz8pXFxcXFsoXFxcXHcrKVxcXFx8KFxcXFx3KylcXFxcXScsICdnJykgIC8vIHNlY29uZHNcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZm9ybWF0VG9rZW4gPSBmdW5jdGlvbihzdHIsIHRva2VuLCB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoIXRva2Vuc1t0b2tlbl0pPyAnJzogc3RyLm1hdGNoKC9cXFt8XFxdL2cpIFxuICAgICAgICAgICAgICAgICAgICAmJiAoc3RyLnJlcGxhY2UodG9rZW5zW3Rva2VuXSwgdmFsKyckMScrICgocGFyc2VJbnQodmFsLCAxMCk8Mik/JyQyJzonJDMnKSkgfHwgJycpXG4gICAgICAgICAgICAgICAgICAgIHx8IHN0ci5yZXBsYWNlKCclJyt0b2tlbiwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24oc3RyLCBvYmopIHtcbiAgICAgICAgICAgIHZhciBvID0gc3RyO1xuICAgICAgICAgICAgbyA9IGZvcm1hdFRva2VuKG8sICd5Jywgb2JqLnllYXJzKTtcbiAgICAgICAgICAgIG8gPSBmb3JtYXRUb2tlbihvLCAnTScsIG9iai5tb250aHMpO1xuICAgICAgICAgICAgbyA9IGZvcm1hdFRva2VuKG8sICd3Jywgb2JqLndlZWtzKTtcbiAgICAgICAgICAgIG8gPSBmb3JtYXRUb2tlbihvLCAnZCcsIG9iai5kYXlzKTtcbiAgICAgICAgICAgIG8gPSBmb3JtYXRUb2tlbihvLCAnaCcsIG9iai5ob3Vycyk7XG4gICAgICAgICAgICBvID0gZm9ybWF0VG9rZW4obywgJ20nLCBvYmoubWludXRlcyk7XG4gICAgICAgICAgICBvID0gZm9ybWF0VG9rZW4obywgJ3MnLCBvYmouc2Vjb25kcyk7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZV9vYmogPSBjYWxjKGNkLmRhdGUpO1xuICAgICAgICAgICAgaWYgKGRhdGVfb2JqID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2Quc3RvcCgpOyBjbGVhckludGVydmFsKGNkLmlkKTtcbiAgICAgICAgICAgICAgICAkKGNkLmVsKS5odG1sKG9wdGlvbnMubXNnTm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQoY2QuZWwpLnRleHQoZm9ybWF0KG9wdGlvbnMubXNnRm9ybWF0LCBkYXRlX29iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcHBseV9tb2RpZmllcnMgPSBmdW5jdGlvbiAobW9kaWZpZXJzLCBkYXRlKSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbW9kaWZpZXJfcmUgPSAvXihbKy1dXFxkKykoW3lNZGhtc10pJC87XG4gICAgICAgICAgICB2YXIgY29udmVyc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgczogMTAwMCxcbiAgICAgICAgICAgICAgICBtOiA2MCAqIDEwMDAsXG4gICAgICAgICAgICAgICAgaDogNjAgKiA2MCAqIDEwMDAsXG4gICAgICAgICAgICAgICAgZDogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICAgICAgICAgICAgICBNOiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgICAgICAgICAgICAgeTogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG1vZGlmaWVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBtb2RpZmllcnNbaV0ubWF0Y2gobW9kaWZpZXJfcmUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSAqIGNvbnZlcnNpb25zW21hdGNoWzJdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyBkaXNwbGFjZW1lbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjZCA9IHtcbiAgICAgICAgICAgIGlkICAgIDogc2V0SW50ZXJ2YWwodXBkYXRlLCBvcHRpb25zLmludGVydmFsKSxcbiAgICAgICAgICAgIGVsICAgIDogZWwsXG4gICAgICAgICAgICBzdGFydCA6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgY291bnRkb3duKCQodGhpcy5lbCksIG9wdGlvbnMpOyB9LFxuICAgICAgICAgICAgc3RvcCAgOiBmdW5jdGlvbigpeyByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLmlkKTsgfSxcbiAgICAgICAgICAgIGRhdGUgIDogYXBwbHlfbW9kaWZpZXJzKG9wdGlvbnMubW9kaWZpZXJzLCBvcHRpb25zLmRhdGUpXG4gICAgICAgIH07XG4gICAgICAgICQoZWwpLmRhdGEoJ2NvdW50ZG93bicsIGNkKTtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIHJldHVybiAkKGVsKS5kYXRhKCdjb3VudGRvd24nKTtcbiAgICB9XG4gICAgJC5mbi5jb3VudGRvd24gPSBmdW5jdGlvbihhcmdzKSB7IGlmKHRoaXMuZ2V0KDApKSByZXR1cm4gbmV3IGNvdW50ZG93bih0aGlzLmdldCgwKSwgYXJncyk7IH07XG59KShqUXVlcnkpO1xuLypcbiAqIGpRdWVyeSBDeWNsZSBQbHVnaW4gZm9yIGxpZ2h0LXdlaWdodCBzbGlkZXNob3dzXG4gKiBFeGFtcGxlcyBhbmQgZG9jdW1lbnRhdGlvbiBhdDogaHR0cDovL21hbHN1cC5jb20vanF1ZXJ5L2N5Y2xlL1xuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMDggTS4gQWxzdXBcbiAqIFZlcnNpb246IDIuMjQgKDA3LzMwLzIwMDgpXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlczpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKiBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLmh0bWxcbiAqIFJlcXVpcmVzOiBqUXVlcnkgdjEuMi4zIG9yIGxhdGVyXG4gKlxuICogQmFzZWQgb24gdGhlIHdvcmsgb2Y6XG4gKiAgMSkgTWF0dCBPYWtlcyAoaHR0cDovL3BvcnRmb2xpby5naXpvbmUuY28udWsvYXBwbGljYXRpb25zL3NsaWRlc2hvdy8pXG4gKiAgMikgVG9yc3RlbiBCYWxkZXMgKGh0dHA6Ly9tZWRpZW5mcmV1bmRlLmNvbS9sYWIvaW5uZXJmYWRlLylcbiAqICAzKSBCZW5qYW1pbiBTdGVybGluZyAoaHR0cDovL3d3dy5iZW5qYW1pbnN0ZXJsaW5nLmNvbS9leHBlcmltZW50cy9qcVNodWZmbGUvKVxuICovXG47KGZ1bmN0aW9uKCQpIHtcblxudmFyIHZlciA9ICcyLjI0JztcbnZhciBpZTYgPSAkLmJyb3dzZXIubXNpZSAmJiAvTVNJRSA2LjAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nKVxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1tjeWNsZV0gJyArIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCcnKSk7XG59O1xuXG4kLmZuLmN5Y2xlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29uc3RydWN0b3IgPT0gU3RyaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2gob3B0aW9ucykge1xuICAgICAgICAgICAgY2FzZSAnc3RvcCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3ljbGVUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5jeWNsZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3ljbGVUaW1lb3V0ID0gMDtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ2N5Y2xlLm9wdHMnLCAnJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAncGF1c2UnOlxuICAgICAgICAgICAgICAgIHRoaXMuY3ljbGVQYXVzZSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAncmVzdW1lJzpcbiAgICAgICAgICAgICAgICB0aGlzLmN5Y2xlUGF1c2UgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgZng6IG9wdGlvbnMgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jb25zdHJ1Y3RvciA9PSBOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIGdvIHRvIHRoZSByZXF1ZXN0ZWQgc2xpZGUgc2xpZGVcbiAgICAgICAgICAgIHZhciBudW0gPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9ICQodGhpcykuZGF0YSgnY3ljbGUub3B0cycpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdvcHRpb25zIG5vdCBmb3VuZCwgY2FuIG5vdCBhZHZhbmNlIHNsaWRlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bSA8IDAgfHwgbnVtID49IG9wdGlvbnMuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdpbnZhbGlkIHNsaWRlIGluZGV4OiAnICsgbnVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLm5leHRTbGlkZSA9IG51bTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN5Y2xlVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmN5Y2xlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jeWNsZVRpbWVvdXQgPSAwO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICAgICAgZ28ob3B0aW9ucy5lbGVtZW50cywgb3B0aW9ucywgMSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9wIGV4aXN0aW5nIHNsaWRlc2hvdyBmb3IgdGhpcyBjb250YWluZXIgKGlmIHRoZXJlIGlzIG9uZSlcbiAgICAgICAgaWYgKHRoaXMuY3ljbGVUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5jeWNsZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLmN5Y2xlVGltZW91dCA9IDA7XG4gICAgICAgIHRoaXMuY3ljbGVQYXVzZSA9IDA7XG4gICAgICAgIFxuICAgICAgICB2YXIgJGNvbnQgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgJHNsaWRlcyA9IG9wdGlvbnMuc2xpZGVFeHByID8gJChvcHRpb25zLnNsaWRlRXhwciwgdGhpcykgOiAkY29udC5jaGlsZHJlbigpO1xuICAgICAgICB2YXIgZWxzID0gJHNsaWRlcy5nZXQoKTtcbiAgICAgICAgaWYgKGVscy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBsb2coJ3Rlcm1pbmF0aW5nOyB0b28gZmV3IHNsaWRlczogJyArIGVscy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBkb24ndCBib3RoZXJcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN1cHBvcnQgbWV0YWRhdGEgcGx1Z2luICh2MS4wIGFuZCB2Mi4wKVxuICAgICAgICB2YXIgb3B0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmN5Y2xlLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9LCAkLm1ldGFkYXRhID8gJGNvbnQubWV0YWRhdGEoKSA6ICQubWV0YSA/ICRjb250LmRhdGEoKSA6IHt9KTtcbiAgICAgICAgaWYgKG9wdHMuYXV0b3N0b3ApIFxuICAgICAgICAgICAgb3B0cy5jb3VudGRvd24gPSBvcHRzLmF1dG9zdG9wQ291bnQgfHwgZWxzLmxlbmd0aDtcblxuICAgICAgICAkY29udC5kYXRhKCdjeWNsZS5vcHRzJywgb3B0cyk7XG4gICAgICAgIG9wdHMuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICBvcHRzLmVsZW1lbnRzID0gZWxzO1xuICAgICAgICBvcHRzLmJlZm9yZSA9IG9wdHMuYmVmb3JlID8gW29wdHMuYmVmb3JlXSA6IFtdO1xuICAgICAgICBvcHRzLmFmdGVyID0gb3B0cy5hZnRlciA/IFtvcHRzLmFmdGVyXSA6IFtdO1xuICAgICAgICBvcHRzLmFmdGVyLnVuc2hpZnQoZnVuY3Rpb24oKXsgb3B0cy5idXN5PTA7IH0pO1xuICAgICAgICBpZiAob3B0cy5jb250aW51b3VzKVxuICAgICAgICAgICAgb3B0cy5hZnRlci5wdXNoKGZ1bmN0aW9uKCkgeyBnbyhlbHMsb3B0cywwLCFvcHRzLnJldik7IH0pO1xuICAgICAgICAgICAgXG4gICAgICAgIC8vIGNsZWFyVHlwZSBjb3JyZWN0aW9uc1xuICAgICAgICBpZiAoaWU2ICYmIG9wdHMuY2xlYXJ0eXBlICYmICFvcHRzLmNsZWFydHlwZU5vQmcpXG4gICAgICAgICAgICBjbGVhclR5cGVGaXgoJHNsaWRlcyk7XG5cbiAgICAgICAgLy8gYWxsb3cgc2hvcnRoYW5kIG92ZXJyaWRlcyBvZiB3aWR0aCwgaGVpZ2h0IGFuZCB0aW1lb3V0XG4gICAgICAgIHZhciBjbHMgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgb3B0cy53aWR0aCA9IHBhcnNlSW50KChjbHMubWF0Y2goL3c6KFxcZCspLyl8fFtdKVsxXSkgfHwgb3B0cy53aWR0aDtcbiAgICAgICAgb3B0cy5oZWlnaHQgPSBwYXJzZUludCgoY2xzLm1hdGNoKC9oOihcXGQrKS8pfHxbXSlbMV0pIHx8IG9wdHMuaGVpZ2h0O1xuICAgICAgICBvcHRzLnRpbWVvdXQgPSBwYXJzZUludCgoY2xzLm1hdGNoKC90OihcXGQrKS8pfHxbXSlbMV0pIHx8IG9wdHMudGltZW91dDtcblxuICAgICAgICBpZiAoJGNvbnQuY3NzKCdwb3NpdGlvbicpID09ICdzdGF0aWMnKSBcbiAgICAgICAgICAgICRjb250LmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgICAgaWYgKG9wdHMud2lkdGgpIFxuICAgICAgICAgICAgJGNvbnQud2lkdGgob3B0cy53aWR0aCk7XG4gICAgICAgIGlmIChvcHRzLmhlaWdodCAmJiBvcHRzLmhlaWdodCAhPSAnYXV0bycpIFxuICAgICAgICAgICAgJGNvbnQuaGVpZ2h0KG9wdHMuaGVpZ2h0KTtcblxuICAgICAgICBpZiAob3B0cy5yYW5kb20pIHtcbiAgICAgICAgICAgIG9wdHMucmFuZG9tTWFwID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykgXG4gICAgICAgICAgICAgICAgb3B0cy5yYW5kb21NYXAucHVzaChpKTtcbiAgICAgICAgICAgIG9wdHMucmFuZG9tTWFwLnNvcnQoZnVuY3Rpb24oYSxiKSB7cmV0dXJuIE1hdGgucmFuZG9tKCkgLSAwLjU7fSk7XG4gICAgICAgICAgICBvcHRzLnJhbmRvbUluZGV4ID0gMDtcbiAgICAgICAgICAgIG9wdHMuc3RhcnRpbmdTbGlkZSA9IG9wdHMucmFuZG9tTWFwWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuc3RhcnRpbmdTbGlkZSA+PSBlbHMubGVuZ3RoKVxuICAgICAgICAgICAgb3B0cy5zdGFydGluZ1NsaWRlID0gMDsgLy8gY2F0Y2ggYm9ndXMgaW5wdXRcbiAgICAgICAgdmFyIGZpcnN0ID0gb3B0cy5zdGFydGluZ1NsaWRlIHx8IDA7XG4gICAgICAgICRzbGlkZXMuY3NzKHtwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOjAsIGxlZnQ6MH0pLmhpZGUoKS5lYWNoKGZ1bmN0aW9uKGkpIHsgXG4gICAgICAgICAgICB2YXIgeiA9IGZpcnN0ID8gaSA+PSBmaXJzdCA/IGVscy5sZW5ndGggLSAoaS1maXJzdCkgOiBmaXJzdC1pIDogZWxzLmxlbmd0aC1pO1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ3otaW5kZXgnLCB6KSBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAkKGVsc1tmaXJzdF0pLmNzcygnb3BhY2l0eScsMSkuc2hvdygpOyAvLyBvcGFjaXR5IGJpdCBuZWVkZWQgdG8gaGFuZGxlIHJlaW5pdCBjYXNlXG4gICAgICAgIGlmICgkLmJyb3dzZXIubXNpZSkgZWxzW2ZpcnN0XS5zdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ2ZpbHRlcicpO1xuXG4gICAgICAgIGlmIChvcHRzLmZpdCAmJiBvcHRzLndpZHRoKSBcbiAgICAgICAgICAgICRzbGlkZXMud2lkdGgob3B0cy53aWR0aCk7XG4gICAgICAgIGlmIChvcHRzLmZpdCAmJiBvcHRzLmhlaWdodCAmJiBvcHRzLmhlaWdodCAhPSAnYXV0bycpIFxuICAgICAgICAgICAgJHNsaWRlcy5oZWlnaHQob3B0cy5oZWlnaHQpO1xuICAgICAgICBpZiAob3B0cy5wYXVzZSkgXG4gICAgICAgICAgICAkY29udC5ob3ZlcihmdW5jdGlvbigpe3RoaXMuY3ljbGVQYXVzZT0xO30sZnVuY3Rpb24oKXt0aGlzLmN5Y2xlUGF1c2U9MDt9KTtcblxuICAgICAgICAvLyBydW4gdHJhbnNpdGlvbiBpbml0IGZuXG4gICAgICAgIHZhciBpbml0ID0gJC5mbi5jeWNsZS50cmFuc2l0aW9uc1tvcHRzLmZ4XTtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihpbml0KSlcbiAgICAgICAgICAgIGluaXQoJGNvbnQsICRzbGlkZXMsIG9wdHMpO1xuICAgICAgICBlbHNlIGlmIChvcHRzLmZ4ICE9ICdjdXN0b20nKVxuICAgICAgICAgICAgbG9nKCd1bmtub3duIHRyYW5zaXRpb246ICcgKyBvcHRzLmZ4KTtcbiAgICAgICAgXG4gICAgICAgICRzbGlkZXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkZWwgPSAkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jeWNsZUggPSAob3B0cy5maXQgJiYgb3B0cy5oZWlnaHQpID8gb3B0cy5oZWlnaHQgOiAkZWwuaGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLmN5Y2xlVyA9IChvcHRzLmZpdCAmJiBvcHRzLndpZHRoKSA/IG9wdHMud2lkdGggOiAkZWwud2lkdGgoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3B0cy5jc3NCZWZvcmUgPSBvcHRzLmNzc0JlZm9yZSB8fCB7fTtcbiAgICAgICAgb3B0cy5hbmltSW4gPSBvcHRzLmFuaW1JbiB8fCB7fTtcbiAgICAgICAgb3B0cy5hbmltT3V0ID0gb3B0cy5hbmltT3V0IHx8IHt9O1xuXG4gICAgICAgICRzbGlkZXMubm90KCc6ZXEoJytmaXJzdCsnKScpLmNzcyhvcHRzLmNzc0JlZm9yZSk7XG4gICAgICAgIGlmIChvcHRzLmNzc0ZpcnN0KVxuICAgICAgICAgICAgJCgkc2xpZGVzW2ZpcnN0XSkuY3NzKG9wdHMuY3NzRmlyc3QpO1xuXG4gICAgICAgIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRpbWVvdXQgYW5kIHNwZWVkIHNldHRpbmdzIGFyZSBzYW5lXG4gICAgICAgICAgICBpZiAob3B0cy5zcGVlZC5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgb3B0cy5zcGVlZCA9IHtzbG93OiA2MDAsIGZhc3Q6IDIwMH1bb3B0cy5zcGVlZF0gfHwgNDAwO1xuICAgICAgICAgICAgaWYgKCFvcHRzLnN5bmMpXG4gICAgICAgICAgICAgICAgb3B0cy5zcGVlZCA9IG9wdHMuc3BlZWQgLyAyO1xuICAgICAgICAgICAgd2hpbGUoKG9wdHMudGltZW91dCAtIG9wdHMuc3BlZWQpIDwgMjUwKVxuICAgICAgICAgICAgICAgIG9wdHMudGltZW91dCArPSBvcHRzLnNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmVhc2luZykgXG4gICAgICAgICAgICBvcHRzLmVhc2VJbiA9IG9wdHMuZWFzZU91dCA9IG9wdHMuZWFzaW5nO1xuICAgICAgICBpZiAoIW9wdHMuc3BlZWRJbikgXG4gICAgICAgICAgICBvcHRzLnNwZWVkSW4gPSBvcHRzLnNwZWVkO1xuICAgICAgICBpZiAoIW9wdHMuc3BlZWRPdXQpIFxuICAgICAgICAgICAgb3B0cy5zcGVlZE91dCA9IG9wdHMuc3BlZWQ7XG5cbiBcdFx0b3B0cy5zbGlkZUNvdW50ID0gZWxzLmxlbmd0aDtcbiAgICAgICAgb3B0cy5jdXJyU2xpZGUgPSBmaXJzdDtcbiAgICAgICAgaWYgKG9wdHMucmFuZG9tKSB7XG4gICAgICAgICAgICBvcHRzLm5leHRTbGlkZSA9IG9wdHMuY3VyclNsaWRlO1xuICAgICAgICAgICAgaWYgKCsrb3B0cy5yYW5kb21JbmRleCA9PSBlbHMubGVuZ3RoKSBcbiAgICAgICAgICAgICAgICBvcHRzLnJhbmRvbUluZGV4ID0gMDtcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gb3B0cy5yYW5kb21NYXBbb3B0cy5yYW5kb21JbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBvcHRzLnN0YXJ0aW5nU2xpZGUgPj0gKGVscy5sZW5ndGgtMSkgPyAwIDogb3B0cy5zdGFydGluZ1NsaWRlKzE7XG5cbiAgICAgICAgLy8gZmlyZSBhcnRpZmljaWFsIGV2ZW50c1xuICAgICAgICB2YXIgZTAgPSAkc2xpZGVzW2ZpcnN0XTtcbiAgICAgICAgaWYgKG9wdHMuYmVmb3JlLmxlbmd0aClcbiAgICAgICAgICAgIG9wdHMuYmVmb3JlWzBdLmFwcGx5KGUwLCBbZTAsIGUwLCBvcHRzLCB0cnVlXSk7XG4gICAgICAgIGlmIChvcHRzLmFmdGVyLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICBvcHRzLmFmdGVyWzFdLmFwcGx5KGUwLCBbZTAsIGUwLCBvcHRzLCB0cnVlXSk7XG4gICAgICAgIFxuICAgICAgICBpZiAob3B0cy5jbGljayAmJiAhb3B0cy5uZXh0KVxuICAgICAgICAgICAgb3B0cy5uZXh0ID0gb3B0cy5jbGljaztcbiAgICAgICAgaWYgKG9wdHMubmV4dClcbiAgICAgICAgICAgICQob3B0cy5uZXh0KS5iaW5kKCdjbGljaycsIGZ1bmN0aW9uKCl7cmV0dXJuIGFkdmFuY2UoZWxzLG9wdHMsb3B0cy5yZXY/LTE6MSl9KTtcbiAgICAgICAgaWYgKG9wdHMucHJldilcbiAgICAgICAgICAgICQob3B0cy5wcmV2KS5iaW5kKCdjbGljaycsIGZ1bmN0aW9uKCl7cmV0dXJuIGFkdmFuY2UoZWxzLG9wdHMsb3B0cy5yZXY/MTotMSl9KTtcbiAgICAgICAgaWYgKG9wdHMucGFnZXIpXG4gICAgICAgICAgICBidWlsZFBhZ2VyKGVscyxvcHRzKTtcblxuICAgICAgICAvLyBleHBvc2UgZm4gZm9yIGFkZGluZyBzbGlkZXMgYWZ0ZXIgdGhlIHNob3cgaGFzIHN0YXJ0ZWRcbiAgICAgICAgb3B0cy5hZGRTbGlkZSA9IGZ1bmN0aW9uKG5ld1NsaWRlKSB7XG4gICAgICAgICAgICB2YXIgJHMgPSAkKG5ld1NsaWRlKSwgcyA9ICRzWzBdO1xuICAgICAgICAgICAgaWYgKCFvcHRzLmF1dG9zdG9wQ291bnQpXG4gICAgICAgICAgICAgICAgb3B0cy5jb3VudGRvd24rKztcbiAgICAgICAgICAgIGVscy5wdXNoKHMpO1xuICAgICAgICAgICAgaWYgKG9wdHMuZWxzKSBcbiAgICAgICAgICAgICAgICBvcHRzLmVscy5wdXNoKHMpOyAvLyBzaHVmZmxlIG5lZWRzIHRoaXNcbiAgICAgICAgICAgIG9wdHMuc2xpZGVDb3VudCA9IGVscy5sZW5ndGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICRzLmNzcygncG9zaXRpb24nLCdhYnNvbHV0ZScpLmFwcGVuZFRvKCRjb250KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGllNiAmJiBvcHRzLmNsZWFydHlwZSAmJiAhb3B0cy5jbGVhcnR5cGVOb0JnKVxuICAgICAgICAgICAgICAgIGNsZWFyVHlwZUZpeCgkcyk7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmZpdCAmJiBvcHRzLndpZHRoKSBcbiAgICAgICAgICAgICAgICAkcy53aWR0aChvcHRzLndpZHRoKTtcbiAgICAgICAgICAgIGlmIChvcHRzLmZpdCAmJiBvcHRzLmhlaWdodCAmJiBvcHRzLmhlaWdodCAhPSAnYXV0bycpIFxuICAgICAgICAgICAgICAgICRzbGlkZXMuaGVpZ2h0KG9wdHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHMuY3ljbGVIID0gKG9wdHMuZml0ICYmIG9wdHMuaGVpZ2h0KSA/IG9wdHMuaGVpZ2h0IDogJHMuaGVpZ2h0KCk7XG4gICAgICAgICAgICBzLmN5Y2xlVyA9IChvcHRzLmZpdCAmJiBvcHRzLndpZHRoKSA/IG9wdHMud2lkdGggOiAkcy53aWR0aCgpO1xuXG4gICAgICAgICAgICAkcy5jc3Mob3B0cy5jc3NCZWZvcmUpO1xuXG4gICAgICAgICAgICBpZiAob3B0cy5wYWdlcilcbiAgICAgICAgICAgICAgICAkLmZuLmN5Y2xlLmNyZWF0ZVBhZ2VyQW5jaG9yKGVscy5sZW5ndGgtMSwgcywgJChvcHRzLnBhZ2VyKSwgZWxzLCBvcHRzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uQWRkU2xpZGUgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvcHRzLm9uQWRkU2xpZGUoJHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRzLnRpbWVvdXQgfHwgb3B0cy5jb250aW51b3VzKVxuICAgICAgICAgICAgdGhpcy5jeWNsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7Z28oZWxzLG9wdHMsMCwhb3B0cy5yZXYpfSwgXG4gICAgICAgICAgICAgICAgb3B0cy5jb250aW51b3VzID8gMTAgOiBvcHRzLnRpbWVvdXQgKyAob3B0cy5kZWxheXx8MCkpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZ28oZWxzLCBvcHRzLCBtYW51YWwsIGZ3ZCkge1xuICAgIGlmIChvcHRzLmJ1c3kpIHJldHVybjtcbiAgICB2YXIgcCA9IG9wdHMuY29udGFpbmVyLCBjdXJyID0gZWxzW29wdHMuY3VyclNsaWRlXSwgbmV4dCA9IGVsc1tvcHRzLm5leHRTbGlkZV07XG4gICAgaWYgKHAuY3ljbGVUaW1lb3V0ID09PSAwICYmICFtYW51YWwpIFxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAoIW1hbnVhbCAmJiAhcC5jeWNsZVBhdXNlICYmIFxuICAgICAgICAoKG9wdHMuYXV0b3N0b3AgJiYgKC0tb3B0cy5jb3VudGRvd24gPD0gMCkpIHx8XG4gICAgICAgIChvcHRzLm5vd3JhcCAmJiAhb3B0cy5yYW5kb20gJiYgb3B0cy5uZXh0U2xpZGUgPCBvcHRzLmN1cnJTbGlkZSkpKSB7XG4gICAgICAgIGlmIChvcHRzLmVuZClcbiAgICAgICAgICAgIG9wdHMuZW5kKG9wdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hbnVhbCB8fCAhcC5jeWNsZVBhdXNlKSB7XG4gICAgICAgIGlmIChvcHRzLmJlZm9yZS5sZW5ndGgpXG4gICAgICAgICAgICAkLmVhY2gob3B0cy5iZWZvcmUsIGZ1bmN0aW9uKGksbykgeyBvLmFwcGx5KG5leHQsIFtjdXJyLCBuZXh0LCBvcHRzLCBmd2RdKTsgfSk7XG4gICAgICAgIHZhciBhZnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCQuYnJvd3Nlci5tc2llICYmIG9wdHMuY2xlYXJ0eXBlKVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdmaWx0ZXInKTtcbiAgICAgICAgICAgICQuZWFjaChvcHRzLmFmdGVyLCBmdW5jdGlvbihpLG8pIHsgby5hcHBseShuZXh0LCBbY3VyciwgbmV4dCwgb3B0cywgZndkXSk7IH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRzLm5leHRTbGlkZSAhPSBvcHRzLmN1cnJTbGlkZSkge1xuICAgICAgICAgICAgb3B0cy5idXN5ID0gMTtcbiAgICAgICAgICAgIGlmIChvcHRzLmZ4Rm4pXG4gICAgICAgICAgICAgICAgb3B0cy5meEZuKGN1cnIsIG5leHQsIG9wdHMsIGFmdGVyLCBmd2QpO1xuICAgICAgICAgICAgZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKCQuZm4uY3ljbGVbb3B0cy5meF0pKVxuICAgICAgICAgICAgICAgICQuZm4uY3ljbGVbb3B0cy5meF0oY3VyciwgbmV4dCwgb3B0cywgYWZ0ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICQuZm4uY3ljbGUuY3VzdG9tKGN1cnIsIG5leHQsIG9wdHMsIGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yYW5kb20pIHtcbiAgICAgICAgICAgIG9wdHMuY3VyclNsaWRlID0gb3B0cy5uZXh0U2xpZGU7XG4gICAgICAgICAgICBpZiAoKytvcHRzLnJhbmRvbUluZGV4ID09IGVscy5sZW5ndGgpIFxuICAgICAgICAgICAgICAgIG9wdHMucmFuZG9tSW5kZXggPSAwO1xuICAgICAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBvcHRzLnJhbmRvbU1hcFtvcHRzLnJhbmRvbUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gc2VxdWVuY2VcbiAgICAgICAgICAgIHZhciByb2xsID0gKG9wdHMubmV4dFNsaWRlICsgMSkgPT0gZWxzLmxlbmd0aDtcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gcm9sbCA/IDAgOiBvcHRzLm5leHRTbGlkZSsxO1xuICAgICAgICAgICAgb3B0cy5jdXJyU2xpZGUgPSByb2xsID8gZWxzLmxlbmd0aC0xIDogb3B0cy5uZXh0U2xpZGUtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wYWdlcilcbiAgICAgICAgICAgICQuZm4uY3ljbGUudXBkYXRlQWN0aXZlUGFnZXJMaW5rKG9wdHMucGFnZXIsIG9wdHMuY3VyclNsaWRlKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudGltZW91dCAmJiAhb3B0cy5jb250aW51b3VzKVxuICAgICAgICBwLmN5Y2xlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGdvKGVscyxvcHRzLDAsIW9wdHMucmV2KSB9LCBvcHRzLnRpbWVvdXQpO1xuICAgIGVsc2UgaWYgKG9wdHMuY29udGludW91cyAmJiBwLmN5Y2xlUGF1c2UpIFxuICAgICAgICBwLmN5Y2xlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGdvKGVscyxvcHRzLDAsIW9wdHMucmV2KSB9LCAxMCk7XG59O1xuXG4kLmZuLmN5Y2xlLnVwZGF0ZUFjdGl2ZVBhZ2VyTGluayA9IGZ1bmN0aW9uKHBhZ2VyLCBjdXJyU2xpZGUpIHtcbiAgICAkKHBhZ2VyKS5maW5kKCdhJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZVNsaWRlJykuZmlsdGVyKCdhOmVxKCcrY3VyclNsaWRlKycpJykuYWRkQ2xhc3MoJ2FjdGl2ZVNsaWRlJyk7XG59O1xuXG4vLyBhZHZhbmNlIHNsaWRlIGZvcndhcmQgb3IgYmFja1xuZnVuY3Rpb24gYWR2YW5jZShlbHMsIG9wdHMsIHZhbCkge1xuICAgIHZhciBwID0gb3B0cy5jb250YWluZXIsIHRpbWVvdXQgPSBwLmN5Y2xlVGltZW91dDtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHAuY3ljbGVUaW1lb3V0ID0gMDtcbiAgICB9XG4gICAgaWYgKG9wdHMucmFuZG9tICYmIHZhbCA8IDApIHtcbiAgICAgICAgLy8gbW92ZSBiYWNrIHRvIHRoZSBwcmV2aW91c2x5IGRpc3BsYXkgc2xpZGVcbiAgICAgICAgb3B0cy5yYW5kb21JbmRleC0tO1xuICAgICAgICBpZiAoLS1vcHRzLnJhbmRvbUluZGV4ID09IC0yKVxuICAgICAgICAgICAgb3B0cy5yYW5kb21JbmRleCA9IGVscy5sZW5ndGgtMjtcbiAgICAgICAgZWxzZSBpZiAob3B0cy5yYW5kb21JbmRleCA9PSAtMSlcbiAgICAgICAgICAgIG9wdHMucmFuZG9tSW5kZXggPSBlbHMubGVuZ3RoLTE7XG4gICAgICAgIG9wdHMubmV4dFNsaWRlID0gb3B0cy5yYW5kb21NYXBbb3B0cy5yYW5kb21JbmRleF07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdHMucmFuZG9tKSB7XG4gICAgICAgIGlmICgrK29wdHMucmFuZG9tSW5kZXggPT0gZWxzLmxlbmd0aCkgXG4gICAgICAgICAgICBvcHRzLnJhbmRvbUluZGV4ID0gMDtcbiAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBvcHRzLnJhbmRvbU1hcFtvcHRzLnJhbmRvbUluZGV4XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdHMubmV4dFNsaWRlID0gb3B0cy5jdXJyU2xpZGUgKyB2YWw7XG4gICAgICAgIGlmIChvcHRzLm5leHRTbGlkZSA8IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRzLm5vd3JhcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBlbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLm5leHRTbGlkZSA+PSBlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5ub3dyYXApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbmxvZygnbmV4dFNsaWRlOiAnICsgb3B0cy5uZXh0U2xpZGUgKyAnOyByYW5kb21JbmRleDogJyArIG9wdHMucmFuZG9tSW5kZXgpOyAgICBcbiAgICBpZiAob3B0cy5wcmV2TmV4dENsaWNrICYmIHR5cGVvZiBvcHRzLnByZXZOZXh0Q2xpY2sgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgb3B0cy5wcmV2TmV4dENsaWNrKHZhbCA+IDAsIG9wdHMubmV4dFNsaWRlLCBlbHNbb3B0cy5uZXh0U2xpZGVdKTtcbiAgICBnbyhlbHMsIG9wdHMsIDEsIHZhbD49MCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gYnVpbGRQYWdlcihlbHMsIG9wdHMpIHtcbiAgICB2YXIgJHAgPSAkKG9wdHMucGFnZXIpO1xuICAgICQuZWFjaChlbHMsIGZ1bmN0aW9uKGksbykge1xuICAgICAgICAkLmZuLmN5Y2xlLmNyZWF0ZVBhZ2VyQW5jaG9yKGksbywkcCxlbHMsb3B0cyk7XG4gICAgfSk7XG4gICAkLmZuLmN5Y2xlLnVwZGF0ZUFjdGl2ZVBhZ2VyTGluayhvcHRzLnBhZ2VyLCBvcHRzLnN0YXJ0aW5nU2xpZGUpO1xufTtcblxuJC5mbi5jeWNsZS5jcmVhdGVQYWdlckFuY2hvciA9IGZ1bmN0aW9uKGksIGVsLCAkcCwgZWxzLCBvcHRzKSB7XG4gICAgdmFyICRhID0gKHR5cGVvZiBvcHRzLnBhZ2VyQW5jaG9yQnVpbGRlciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICA/ICQob3B0cy5wYWdlckFuY2hvckJ1aWxkZXIoaSxlbCkpXG4gICAgICAgIDogJCgnPGEgaHJlZj1cIiNcIj4nKyhpKzEpKyc8L2E+Jyk7XG4gICAgXG4gICAgLy8gZG9uJ3QgcmVwYXJlbnQgaWYgYW5jaG9yIGlzIGluIHRoZSBkb21cbiAgICBpZiAoJGEucGFyZW50cygnYm9keScpLmxlbmd0aCA9PSAwKVxuICAgICAgICAkYS5hcHBlbmRUbygkcCk7XG4gICAgICAgIFxuICAgICRhLmJpbmQob3B0cy5wYWdlckV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBpO1xuICAgICAgICB2YXIgcCA9IG9wdHMuY29udGFpbmVyLCB0aW1lb3V0ID0gcC5jeWNsZVRpbWVvdXQ7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICBwLmN5Y2xlVGltZW91dCA9IDA7XG4gICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhZ2VyQ2xpY2sgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIG9wdHMucGFnZXJDbGljayhvcHRzLm5leHRTbGlkZSwgZWxzW29wdHMubmV4dFNsaWRlXSk7XG4gICAgICAgIGdvKGVscyxvcHRzLDEsb3B0cy5jdXJyU2xpZGUgPCBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufTtcblxuXG4vLyB0aGlzIGZpeGVzIGNsZWFyVHlwZSBwcm9ibGVtcyBpbiBpZTYgYnkgc2V0dGluZyBhbiBleHBsaWNpdCBiZyBjb2xvclxuZnVuY3Rpb24gY2xlYXJUeXBlRml4KCRzbGlkZXMpIHtcbiAgICBmdW5jdGlvbiBoZXgocykge1xuICAgICAgICB2YXIgcyA9IHBhcnNlSW50KHMpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/ICcwJytzIDogcztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldEJnKGUpIHtcbiAgICAgICAgZm9yICggOyBlICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAnaHRtbCc7IGUgPSBlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHZhciB2ID0gJC5jc3MoZSwnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgaWYgKHYuaW5kZXhPZigncmdiJykgPj0gMCApIHsgXG4gICAgICAgICAgICAgICAgdmFyIHJnYiA9IHYubWF0Y2goL1xcZCsvZyk7IFxuICAgICAgICAgICAgICAgIHJldHVybiAnIycrIGhleChyZ2JbMF0pICsgaGV4KHJnYlsxXSkgKyBoZXgocmdiWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ICYmIHYgIT0gJ3RyYW5zcGFyZW50JylcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyNmZmZmZmYnO1xuICAgIH07XG4gICAgJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCkgeyAkKHRoaXMpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGdldEJnKHRoaXMpKTsgfSk7XG59O1xuXG5cbiQuZm4uY3ljbGUuY3VzdG9tID0gZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cywgY2IpIHtcbiAgICB2YXIgJGwgPSAkKGN1cnIpLCAkbiA9ICQobmV4dCk7XG4gICAgJG4uY3NzKG9wdHMuY3NzQmVmb3JlKTtcbiAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHskbi5hbmltYXRlKG9wdHMuYW5pbUluLCBvcHRzLnNwZWVkSW4sIG9wdHMuZWFzZUluLCBjYil9O1xuICAgICRsLmFuaW1hdGUob3B0cy5hbmltT3V0LCBvcHRzLnNwZWVkT3V0LCBvcHRzLmVhc2VPdXQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAob3B0cy5jc3NBZnRlcikgJGwuY3NzKG9wdHMuY3NzQWZ0ZXIpO1xuICAgICAgICBpZiAoIW9wdHMuc3luYykgZm4oKTtcbiAgICB9KTtcbiAgICBpZiAob3B0cy5zeW5jKSBmbigpO1xufTtcblxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucyA9IHtcbiAgICBmYWRlOiBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgICAgICAkc2xpZGVzLm5vdCgnOmVxKCcrb3B0cy5zdGFydGluZ1NsaWRlKycpJykuY3NzKCdvcGFjaXR5JywwKTtcbiAgICAgICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbigpIHsgJCh0aGlzKS5zaG93KCkgfSk7XG4gICAgICAgIG9wdHMuYW5pbUluICAgID0geyBvcGFjaXR5OiAxIH07XG4gICAgICAgIG9wdHMuYW5pbU91dCAgID0geyBvcGFjaXR5OiAwIH07XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0geyBvcGFjaXR5OiAwIH07XG4gICAgICAgIG9wdHMuY3NzQWZ0ZXIgID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICB9XG59O1xuXG4kLmZuLmN5Y2xlLnZlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdmVyOyB9O1xuXG4vLyBvdmVycmlkZSB0aGVzZSBnbG9iYWxseSBpZiB5b3UgbGlrZSAodGhleSBhcmUgYWxsIG9wdGlvbmFsKVxuJC5mbi5jeWNsZS5kZWZhdWx0cyA9IHtcbiAgICBmeDogICAgICAgICAgICdmYWRlJywgLy8gb25lIG9mOiBmYWRlLCBzaHVmZmxlLCB6b29tLCBzY3JvbGxMZWZ0LCBldGNcbiAgICB0aW1lb3V0OiAgICAgICA0MDAwLCAgLy8gbWlsbGlzZWNvbmRzIGJldHdlZW4gc2xpZGUgdHJhbnNpdGlvbnMgKDAgdG8gZGlzYWJsZSBhdXRvIGFkdmFuY2UpXG4gICAgY29udGludW91czogICAgMCwgICAgIC8vIHRydWUgdG8gc3RhcnQgbmV4dCB0cmFuc2l0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGN1cnJlbnQgb25lIGNvbXBsZXRlc1xuICAgIHNwZWVkOiAgICAgICAgIDEwMDAsICAvLyBzcGVlZCBvZiB0aGUgdHJhbnNpdGlvbiAoYW55IHZhbGlkIGZ4IHNwZWVkIHZhbHVlKVxuICAgIHNwZWVkSW46ICAgICAgIG51bGwsICAvLyBzcGVlZCBvZiB0aGUgJ2luJyB0cmFuc2l0aW9uXG4gICAgc3BlZWRPdXQ6ICAgICAgbnVsbCwgIC8vIHNwZWVkIG9mIHRoZSAnb3V0JyB0cmFuc2l0aW9uXG4gICAgbmV4dDogICAgICAgICAgbnVsbCwgIC8vIGlkIG9mIGVsZW1lbnQgdG8gdXNlIGFzIGNsaWNrIHRyaWdnZXIgZm9yIG5leHQgc2xpZGVcbiAgICBwcmV2OiAgICAgICAgICBudWxsLCAgLy8gaWQgb2YgZWxlbWVudCB0byB1c2UgYXMgY2xpY2sgdHJpZ2dlciBmb3IgcHJldmlvdXMgc2xpZGVcbiAgICBwcmV2TmV4dENsaWNrOiBudWxsLCAgLy8gY2FsbGJhY2sgZm4gZm9yIHByZXYvbmV4dCBjbGlja3M6ICBmdW5jdGlvbihpc05leHQsIHplcm9CYXNlZFNsaWRlSW5kZXgsIHNsaWRlRWxlbWVudClcbiAgICBwYWdlcjogICAgICAgICBudWxsLCAgLy8gaWQgb2YgZWxlbWVudCB0byB1c2UgYXMgcGFnZXIgY29udGFpbmVyXG4gICAgcGFnZXJDbGljazogICAgbnVsbCwgIC8vIGNhbGxiYWNrIGZuIGZvciBwYWdlciBjbGlja3M6ICBmdW5jdGlvbih6ZXJvQmFzZWRTbGlkZUluZGV4LCBzbGlkZUVsZW1lbnQpXG4gICAgcGFnZXJFdmVudDogICAnY2xpY2snLCAvLyBldmVudCB3aGljaCBkcml2ZXMgdGhlIHBhZ2VyIG5hdmlnYXRpb25cbiAgICBwYWdlckFuY2hvckJ1aWxkZXI6IG51bGwsIC8vIGNhbGxiYWNrIGZuIGZvciBidWlsZGluZyBhbmNob3IgbGlua3NcbiAgICBiZWZvcmU6ICAgICAgICBudWxsLCAgLy8gdHJhbnNpdGlvbiBjYWxsYmFjayAoc2NvcGUgc2V0IHRvIGVsZW1lbnQgdG8gYmUgc2hvd24pXG4gICAgYWZ0ZXI6ICAgICAgICAgbnVsbCwgIC8vIHRyYW5zaXRpb24gY2FsbGJhY2sgKHNjb3BlIHNldCB0byBlbGVtZW50IHRoYXQgd2FzIHNob3duKVxuICAgIGVuZDogICAgICAgICAgIG51bGwsICAvLyBjYWxsYmFjayBpbnZva2VkIHdoZW4gdGhlIHNsaWRlc2hvdyB0ZXJtaW5hdGVzICh1c2Ugd2l0aCBhdXRvc3RvcCBvciBub3dyYXAgb3B0aW9ucylcbiAgICBlYXNpbmc6ICAgICAgICBudWxsLCAgLy8gZWFzaW5nIG1ldGhvZCBmb3IgYm90aCBpbiBhbmQgb3V0IHRyYW5zaXRpb25zXG4gICAgZWFzZUluOiAgICAgICAgbnVsbCwgIC8vIGVhc2luZyBmb3IgXCJpblwiIHRyYW5zaXRpb25cbiAgICBlYXNlT3V0OiAgICAgICBudWxsLCAgLy8gZWFzaW5nIGZvciBcIm91dFwiIHRyYW5zaXRpb25cbiAgICBzaHVmZmxlOiAgICAgICBudWxsLCAgLy8gY29vcmRzIGZvciBzaHVmZmxlIGFuaW1hdGlvbiwgZXg6IHsgdG9wOjE1LCBsZWZ0OiAyMDAgfVxuICAgIGFuaW1JbjogICAgICAgIG51bGwsICAvLyBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIGhvdyB0aGUgc2xpZGUgYW5pbWF0ZXMgaW5cbiAgICBhbmltT3V0OiAgICAgICBudWxsLCAgLy8gcHJvcGVydGllcyB0aGF0IGRlZmluZSBob3cgdGhlIHNsaWRlIGFuaW1hdGVzIG91dFxuICAgIGNzc0JlZm9yZTogICAgIG51bGwsICAvLyBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBzbGlkZSBiZWZvcmUgdHJhbnNpdGlvbmluZyBpblxuICAgIGNzc0FmdGVyOiAgICAgIG51bGwsICAvLyBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lZCB0aGUgc3RhdGUgb2YgdGhlIHNsaWRlIGFmdGVyIHRyYW5zaXRpb25pbmcgb3V0XG4gICAgZnhGbjogICAgICAgICAgbnVsbCwgIC8vIGZ1bmN0aW9uIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhbnNpdGlvblxuICAgIGhlaWdodDogICAgICAgJ2F1dG8nLCAvLyBjb250YWluZXIgaGVpZ2h0XG4gICAgc3RhcnRpbmdTbGlkZTogMCwgICAgIC8vIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIGZpcnN0IHNsaWRlIHRvIGJlIGRpc3BsYXllZFxuICAgIHN5bmM6ICAgICAgICAgIDEsICAgICAvLyB0cnVlIGlmIGluL291dCB0cmFuc2l0aW9ucyBzaG91bGQgb2NjdXIgc2ltdWx0YW5lb3VzbHlcbiAgICByYW5kb206ICAgICAgICAwLCAgICAgLy8gdHJ1ZSBmb3IgcmFuZG9tLCBmYWxzZSBmb3Igc2VxdWVuY2UgKG5vdCBhcHBsaWNhYmxlIHRvIHNodWZmbGUgZngpXG4gICAgZml0OiAgICAgICAgICAgMCwgICAgIC8vIGZvcmNlIHNsaWRlcyB0byBmaXQgY29udGFpbmVyXG4gICAgcGF1c2U6ICAgICAgICAgMCwgICAgIC8vIHRydWUgdG8gZW5hYmxlIFwicGF1c2Ugb24gaG92ZXJcIlxuICAgIGF1dG9zdG9wOiAgICAgIDAsICAgICAvLyB0cnVlIHRvIGVuZCBzbGlkZXNob3cgYWZ0ZXIgWCB0cmFuc2l0aW9ucyAod2hlcmUgWCA9PSBzbGlkZSBjb3VudClcbiAgICBhdXRvc3RvcENvdW50OiAwLCAgICAgLy8gbnVtYmVyIG9mIHRyYW5zaXRpb25zIChvcHRpb25hbGx5IHVzZWQgd2l0aCBhdXRvc3RvcCB0byBkZWZpbmUgWClcbiAgICBkZWxheTogICAgICAgICAwLCAgICAgLy8gYWRkaXRpb25hbCBkZWxheSAoaW4gbXMpIGZvciBmaXJzdCB0cmFuc2l0aW9uIChoaW50OiBjYW4gYmUgbmVnYXRpdmUpXG4gICAgc2xpZGVFeHByOiAgICAgbnVsbCwgIC8vIGV4cHJlc3Npb24gZm9yIHNlbGVjdGluZyBzbGlkZXMgKGlmIHNvbWV0aGluZyBvdGhlciB0aGFuIGFsbCBjaGlsZHJlbiBpcyByZXF1aXJlZClcbiAgICBjbGVhcnR5cGU6ICAgICAwLCAgICAgLy8gdHJ1ZSBpZiBjbGVhclR5cGUgY29ycmVjdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgKGZvciBJRSlcbiAgICBub3dyYXA6ICAgICAgICAwICAgICAgLy8gdHJ1ZSB0byBwcmV2ZW50IHNsaWRlc2hvdyBmcm9tIHdyYXBwaW5nXG59O1xuXG59KShqUXVlcnkpO1xuXG5cbi8qXG4gKiBqUXVlcnkgQ3ljbGUgUGx1Z2luIFRyYW5zaXRpb24gRGVmaW5pdGlvbnNcbiAqIFRoaXMgc2NyaXB0IGlzIGEgcGx1Z2luIGZvciB0aGUgalF1ZXJ5IEN5Y2xlIFBsdWdpblxuICogRXhhbXBsZXMgYW5kIGRvY3VtZW50YXRpb24gYXQ6IGh0dHA6Ly9tYWxzdXAuY29tL2pxdWVyeS9jeWNsZS9cbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDA4IE0uIEFsc3VwXG4gKiBWZXJzaW9uOiAgMi4yMlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICogaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4gKi9cbihmdW5jdGlvbigkKSB7XG5cbi8vXG4vLyBUaGVzZSBmdW5jdGlvbnMgZGVmaW5lIG9uZS10aW1lIHNsaWRlIGluaXRpYWxpemF0aW9uIGZvciB0aGUgbmFtZWRcbi8vIHRyYW5zaXRpb25zLiBUbyBzYXZlIGZpbGUgc2l6ZSBmZWVsIGZyZWUgdG8gcmVtb3ZlIGFueSBvZiB0aGVzZSB0aGF0IHlvdSBcbi8vIGRvbid0IG5lZWQuXG4vL1xuXG4vLyBzY3JvbGxVcC9Eb3duL0xlZnQvUmlnaHRcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuc2Nyb2xsVXAgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgICRjb250LmNzcygnb3ZlcmZsb3cnLCdoaWRkZW4nKTtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLnRvcCA9IG5leHQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBvcHRzLmFuaW1PdXQudG9wID0gMC1jdXJyLm9mZnNldEhlaWdodDtcbiAgICB9KTtcbiAgICBvcHRzLmNzc0ZpcnN0ID0geyB0b3A6IDAgfTtcbiAgICBvcHRzLmFuaW1JbiAgID0geyB0b3A6IDAgfTtcbiAgICBvcHRzLmNzc0FmdGVyID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbn07XG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnNjcm9sbERvd24gPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgICRjb250LmNzcygnb3ZlcmZsb3cnLCdoaWRkZW4nKTtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLnRvcCA9IDAtbmV4dC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIG9wdHMuYW5pbU91dC50b3AgPSBjdXJyLm9mZnNldEhlaWdodDtcbiAgICB9KTtcbiAgICBvcHRzLmNzc0ZpcnN0ID0geyB0b3A6IDAgfTtcbiAgICBvcHRzLmFuaW1JbiAgID0geyB0b3A6IDAgfTtcbiAgICBvcHRzLmNzc0FmdGVyID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbn07XG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnNjcm9sbExlZnQgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgICRjb250LmNzcygnb3ZlcmZsb3cnLCdoaWRkZW4nKTtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLmxlZnQgPSBuZXh0Lm9mZnNldFdpZHRoO1xuICAgICAgICBvcHRzLmFuaW1PdXQubGVmdCA9IDAtY3Vyci5vZmZzZXRXaWR0aDtcbiAgICB9KTtcbiAgICBvcHRzLmNzc0ZpcnN0ID0geyBsZWZ0OiAwIH07XG4gICAgb3B0cy5hbmltSW4gICA9IHsgbGVmdDogMCB9O1xufTtcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuc2Nyb2xsUmlnaHQgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgICRjb250LmNzcygnb3ZlcmZsb3cnLCdoaWRkZW4nKTtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLmxlZnQgPSAwLW5leHQub2Zmc2V0V2lkdGg7XG4gICAgICAgIG9wdHMuYW5pbU91dC5sZWZ0ID0gY3Vyci5vZmZzZXRXaWR0aDtcbiAgICB9KTtcbiAgICBvcHRzLmNzc0ZpcnN0ID0geyBsZWZ0OiAwIH07XG4gICAgb3B0cy5hbmltSW4gICA9IHsgbGVmdDogMCB9O1xufTtcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuc2Nyb2xsSG9yeiA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XG4gICAgJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpLndpZHRoKCk7XG4vLyAgICAkc2xpZGVzLnNob3coKTtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMsIGZ3ZCkge1xuICAgICAgICAkKHRoaXMpLnNob3coKTtcbiAgICAgICAgdmFyIGN1cnJXID0gY3Vyci5vZmZzZXRXaWR0aCwgbmV4dFcgPSBuZXh0Lm9mZnNldFdpZHRoO1xuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IGZ3ZCA/IHsgbGVmdDogbmV4dFcgfSA6IHsgbGVmdDogLW5leHRXIH07XG4gICAgICAgIG9wdHMuYW5pbUluLmxlZnQgPSAwO1xuICAgICAgICBvcHRzLmFuaW1PdXQubGVmdCA9IGZ3ZCA/IC1jdXJyVyA6IGN1cnJXO1xuICAgICAgICAkc2xpZGVzLm5vdChjdXJyKS5jc3Mob3B0cy5jc3NCZWZvcmUpO1xuICAgIH0pO1xuICAgIG9wdHMuY3NzRmlyc3QgPSB7IGxlZnQ6IDAgfTtcbiAgICBvcHRzLmNzc0FmdGVyID0geyBkaXNwbGF5OiAnbm9uZScgfVxufTtcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuc2Nyb2xsVmVydCA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XG4gICAgJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpO1xuLy8gICAgJHNsaWRlcy5zaG93KCk7XG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzLCBmd2QpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIHZhciBjdXJySCA9IGN1cnIub2Zmc2V0SGVpZ2h0LCBuZXh0SCA9IG5leHQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IGZ3ZCA/IHsgdG9wOiAtbmV4dEggfSA6IHsgdG9wOiBuZXh0SCB9O1xuICAgICAgICBvcHRzLmFuaW1Jbi50b3AgPSAwO1xuICAgICAgICBvcHRzLmFuaW1PdXQudG9wID0gZndkID8gY3VyckggOiAtY3Vyckg7XG4gICAgICAgICRzbGlkZXMubm90KGN1cnIpLmNzcyhvcHRzLmNzc0JlZm9yZSk7XG4gICAgfSk7XG4gICAgb3B0cy5jc3NGaXJzdCA9IHsgdG9wOiAwIH07XG4gICAgb3B0cy5jc3NBZnRlciA9IHsgZGlzcGxheTogJ25vbmUnIH1cbn07XG5cbi8vIHNsaWRlWC9zbGlkZVlcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuc2xpZGVYID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMSk7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcbiAgICBvcHRzLmNzc0JlZm9yZSA9IHsgekluZGV4OiAyIH07XG4gICAgb3B0cy5hbmltSW4gID0geyB3aWR0aDogJ3Nob3cnIH07XG4gICAgb3B0cy5hbmltT3V0ID0geyB3aWR0aDogJ2hpZGUnIH07XG59O1xuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5zbGlkZVkgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywxKTtcbiAgICB9KTsgICAgXG4gICAgb3B0cy5vbkFkZFNsaWRlID0gZnVuY3Rpb24oJHMpIHsgJHMuaGlkZSgpOyB9O1xuICAgIG9wdHMuY3NzQmVmb3JlID0geyB6SW5kZXg6IDIgfTtcbiAgICBvcHRzLmFuaW1JbiAgPSB7IGhlaWdodDogJ3Nob3cnIH07XG4gICAgb3B0cy5hbmltT3V0ID0geyBoZWlnaHQ6ICdoaWRlJyB9O1xufTtcblxuLy8gc2h1ZmZsZVxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5zaHVmZmxlID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICB2YXIgdyA9ICRjb250LmNzcygnb3ZlcmZsb3cnLCAndmlzaWJsZScpLndpZHRoKCk7XG4gICAgJHNsaWRlcy5jc3Moe2xlZnQ6IDAsIHRvcDogMH0pO1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oKSB7ICQodGhpcykuc2hvdygpIH0pO1xuICAgIG9wdHMuc3BlZWQgPSBvcHRzLnNwZWVkIC8gMjsgLy8gc2h1ZmZsZSBoYXMgMiB0cmFuc2l0aW9ucyAgICAgICAgXG4gICAgb3B0cy5yYW5kb20gPSAwO1xuICAgIG9wdHMuc2h1ZmZsZSA9IG9wdHMuc2h1ZmZsZSB8fCB7bGVmdDotdywgdG9wOjE1fTtcbiAgICBvcHRzLmVscyA9IFtdO1xuICAgIGZvciAodmFyIGk9MDsgaSA8ICRzbGlkZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIG9wdHMuZWxzLnB1c2goJHNsaWRlc1tpXSk7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBvcHRzLnN0YXJ0aW5nU2xpZGU7IGkrKylcbiAgICAgICAgb3B0cy5lbHMucHVzaChvcHRzLmVscy5zaGlmdCgpKTtcblxuICAgIC8vIGN1c3RvbSB0cmFuc2l0aW9uIGZuIChoYXQgdGlwIHRvIEJlbmphbWluIFN0ZXJsaW5nIGZvciB0aGlzIGJpdCBvZiBzd2VldG5lc3MhKVxuICAgIG9wdHMuZnhGbiA9IGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMsIGNiLCBmd2QpIHtcbiAgICAgICAgdmFyICRlbCA9IGZ3ZCA/ICQoY3VycikgOiAkKG5leHQpO1xuICAgICAgICAkZWwuYW5pbWF0ZShvcHRzLnNodWZmbGUsIG9wdHMuc3BlZWRJbiwgb3B0cy5lYXNlSW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZndkID8gb3B0cy5lbHMucHVzaChvcHRzLmVscy5zaGlmdCgpKSA6IG9wdHMuZWxzLnVuc2hpZnQob3B0cy5lbHMucG9wKCkpO1xuICAgICAgICAgICAgaWYgKGZ3ZCkgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49b3B0cy5lbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICQob3B0cy5lbHNbaV0pLmNzcygnei1pbmRleCcsIGxlbi1pKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gJChjdXJyKS5jc3MoJ3otaW5kZXgnKTtcbiAgICAgICAgICAgICAgICAkZWwuY3NzKCd6LWluZGV4JywgcGFyc2VJbnQoeikrMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkZWwuYW5pbWF0ZSh7bGVmdDowLCB0b3A6MH0sIG9wdHMuc3BlZWRPdXQsIG9wdHMuZWFzZU91dCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJChmd2QgPyB0aGlzIDogY3VycikuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjYikgY2IoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcbn07XG5cbi8vIHR1cm5VcC9Eb3duL0xlZnQvUmlnaHRcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMudHVyblVwID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLnRvcCA9IG5leHQuY3ljbGVIO1xuICAgICAgICBvcHRzLmFuaW1Jbi5oZWlnaHQgPSBuZXh0LmN5Y2xlSDtcbiAgICB9KTtcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XG4gICAgb3B0cy5jc3NGaXJzdCAgPSB7IHRvcDogMCB9O1xuICAgIG9wdHMuY3NzQmVmb3JlID0geyBoZWlnaHQ6IDAgfTtcbiAgICBvcHRzLmFuaW1JbiAgICA9IHsgdG9wOiAwIH07XG4gICAgb3B0cy5hbmltT3V0ICAgPSB7IGhlaWdodDogMCB9O1xuICAgIG9wdHMuY3NzQWZ0ZXIgID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbn07XG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnR1cm5Eb3duID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuYW5pbUluLmhlaWdodCA9IG5leHQuY3ljbGVIO1xuICAgICAgICBvcHRzLmFuaW1PdXQudG9wICAgPSBjdXJyLmN5Y2xlSDtcbiAgICB9KTtcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XG4gICAgb3B0cy5jc3NGaXJzdCAgPSB7IHRvcDogMCB9O1xuICAgIG9wdHMuY3NzQmVmb3JlID0geyB0b3A6IDAsIGhlaWdodDogMCB9O1xuICAgIG9wdHMuYW5pbU91dCAgID0geyBoZWlnaHQ6IDAgfTtcbiAgICBvcHRzLmNzc0FmdGVyICA9IHsgZGlzcGxheTogJ25vbmUnIH07XG59O1xuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy50dXJuTGVmdCA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XG4gICAgICAgICQodGhpcykuc2hvdygpO1xuICAgICAgICBvcHRzLmNzc0JlZm9yZS5sZWZ0ID0gbmV4dC5jeWNsZVc7XG4gICAgICAgIG9wdHMuYW5pbUluLndpZHRoID0gbmV4dC5jeWNsZVc7XG4gICAgfSk7XG4gICAgb3B0cy5vbkFkZFNsaWRlID0gZnVuY3Rpb24oJHMpIHsgJHMuaGlkZSgpOyB9O1xuICAgIG9wdHMuY3NzQmVmb3JlID0geyB3aWR0aDogMCB9O1xuICAgIG9wdHMuYW5pbUluICAgID0geyBsZWZ0OiAwIH07XG4gICAgb3B0cy5hbmltT3V0ICAgPSB7IHdpZHRoOiAwIH07XG4gICAgb3B0cy5jc3NBZnRlciAgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xufTtcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMudHVyblJpZ2h0ID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuYW5pbUluLndpZHRoID0gbmV4dC5jeWNsZVc7XG4gICAgICAgIG9wdHMuYW5pbU91dC5sZWZ0ID0gY3Vyci5jeWNsZVc7XG4gICAgfSk7XG4gICAgb3B0cy5vbkFkZFNsaWRlID0gZnVuY3Rpb24oJHMpIHsgJHMuaGlkZSgpOyB9O1xuICAgIG9wdHMuY3NzQmVmb3JlID0geyBsZWZ0OiAwLCB3aWR0aDogMCB9O1xuICAgIG9wdHMuYW5pbUluICAgID0geyBsZWZ0OiAwIH07XG4gICAgb3B0cy5hbmltT3V0ICAgPSB7IHdpZHRoOiAwIH07XG4gICAgb3B0cy5jc3NBZnRlciAgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xufTtcblxuLy8gem9vbVxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy56b29tID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICBvcHRzLmNzc0ZpcnN0ID0geyB0b3A6MCwgbGVmdDogMCB9OyBcbiAgICBvcHRzLmNzc0FmdGVyID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICBcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCB0b3A6IG5leHQuY3ljbGVILzIsIGxlZnQ6IG5leHQuY3ljbGVXLzIgfTtcbiAgICAgICAgb3B0cy5jc3NBZnRlciAgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuICAgICAgICBvcHRzLmFuaW1JbiAgICA9IHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogbmV4dC5jeWNsZVcsIGhlaWdodDogbmV4dC5jeWNsZUggfTtcbiAgICAgICAgb3B0cy5hbmltT3V0ICAgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHRvcDogY3Vyci5jeWNsZUgvMiwgbGVmdDogY3Vyci5jeWNsZVcvMiB9O1xuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywyKTtcbiAgICAgICAgJChuZXh0KS5jc3MoJ3pJbmRleCcsMSk7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcbn07XG5cbi8vIGZhZGVab29tXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLmZhZGVab29tID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIG9wYWNpdHk6IDEsIGxlZnQ6IG5leHQuY3ljbGVXLzIsIHRvcDogbmV4dC5jeWNsZUgvMiwgekluZGV4OiAxIH07XG4gICAgICAgIG9wdHMuYW5pbUluICAgID0geyB0b3A6IDAsIGxlZnQ6IDAsIHdpZHRoOiBuZXh0LmN5Y2xlVywgaGVpZ2h0OiBuZXh0LmN5Y2xlSCB9O1xuICAgIH0pOyAgICBcbiAgICBvcHRzLmFuaW1PdXQgID0geyBvcGFjaXR5OiAwIH07XG4gICAgb3B0cy5jc3NBZnRlciA9IHsgekluZGV4OiAwIH07XG59O1xuXG4vLyBibGluZFhcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuYmxpbmRYID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICB2YXIgdyA9ICRjb250LmNzcygnb3ZlcmZsb3cnLCdoaWRkZW4nKS53aWR0aCgpO1xuICAgICRzbGlkZXMuc2hvdygpO1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywxKTtcbiAgICB9KTsgICAgXG4gICAgb3B0cy5jc3NCZWZvcmUgPSB7IGxlZnQ6IHcsIHpJbmRleDogMiB9O1xuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IHpJbmRleDogMSB9O1xuICAgIG9wdHMuYW5pbUluID0geyBsZWZ0OiAwIH07XG4gICAgb3B0cy5hbmltT3V0ICA9IHsgbGVmdDogdyB9O1xufTtcbi8vIGJsaW5kWVxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5ibGluZFkgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgIHZhciBoID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpLmhlaWdodCgpO1xuICAgICRzbGlkZXMuc2hvdygpO1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywxKTtcbiAgICB9KTsgICAgXG4gICAgb3B0cy5jc3NCZWZvcmUgPSB7IHRvcDogaCwgekluZGV4OiAyIH07XG4gICAgb3B0cy5jc3NBZnRlciA9IHsgekluZGV4OiAxIH07XG4gICAgb3B0cy5hbmltSW4gPSB7IHRvcDogMCB9O1xuICAgIG9wdHMuYW5pbU91dCAgPSB7IHRvcDogaCB9O1xufTtcbi8vIGJsaW5kWlxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5ibGluZFogPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgIHZhciBoID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpLmhlaWdodCgpO1xuICAgIHZhciB3ID0gJGNvbnQud2lkdGgoKTtcbiAgICAkc2xpZGVzLnNob3coKTtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMSk7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMuY3NzQmVmb3JlID0geyB0b3A6IGgsIGxlZnQ6IHcsIHpJbmRleDogMiB9O1xuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IHpJbmRleDogMSB9O1xuICAgIG9wdHMuYW5pbUluID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICBvcHRzLmFuaW1PdXQgID0geyB0b3A6IGgsIGxlZnQ6IHcgfTtcbn07XG5cbi8vIGdyb3dYIC0gZ3JvdyBob3Jpem9udGFsbHkgZnJvbSBjZW50ZXJlZCAwIHdpZHRoXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLmdyb3dYID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUgPSB7IGxlZnQ6IHRoaXMuY3ljbGVXLzIsIHdpZHRoOiAwLCB6SW5kZXg6IDIgfTtcbiAgICAgICAgb3B0cy5hbmltSW4gPSB7IGxlZnQ6IDAsIHdpZHRoOiB0aGlzLmN5Y2xlVyB9O1xuICAgICAgICBvcHRzLmFuaW1PdXQgPSB7IGxlZnQ6IDAgfTtcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMSk7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKS5jc3MoJ3pJbmRleCcsMSk7IH07XG59O1xuLy8gZ3Jvd1kgLSBncm93IHZlcnRpY2FsbHkgZnJvbSBjZW50ZXJlZCAwIGhlaWdodFxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5ncm93WSA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0geyB0b3A6IHRoaXMuY3ljbGVILzIsIGhlaWdodDogMCwgekluZGV4OiAyIH07XG4gICAgICAgIG9wdHMuYW5pbUluID0geyB0b3A6IDAsIGhlaWdodDogdGhpcy5jeWNsZUggfTtcbiAgICAgICAgb3B0cy5hbmltT3V0ID0geyB0b3A6IDAgfTtcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMSk7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKS5jc3MoJ3pJbmRleCcsMSk7IH07XG59O1xuXG4vLyBjdXJ0YWluWCAtIHNxdWVlemUgaW4gYm90aCBlZGdlcyBob3Jpem9udGFsbHlcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuY3VydGFpblggPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IHsgbGVmdDogbmV4dC5jeWNsZVcvMiwgd2lkdGg6IDAsIHpJbmRleDogMSwgZGlzcGxheTogJ2Jsb2NrJyB9O1xuICAgICAgICBvcHRzLmFuaW1JbiA9IHsgbGVmdDogMCwgd2lkdGg6IHRoaXMuY3ljbGVXIH07XG4gICAgICAgIG9wdHMuYW5pbU91dCA9IHsgbGVmdDogY3Vyci5jeWNsZVcvMiwgd2lkdGg6IDAgfTtcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMik7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcbiAgICBvcHRzLmNzc0FmdGVyID0geyB6SW5kZXg6IDEsIGRpc3BsYXk6ICdub25lJyB9O1xufTtcbi8vIGN1cnRhaW5ZIC0gc3F1ZWV6ZSBpbiBib3RoIGVkZ2VzIHZlcnRpY2FsbHlcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuY3VydGFpblkgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IHsgdG9wOiBuZXh0LmN5Y2xlSC8yLCBoZWlnaHQ6IDAsIHpJbmRleDogMSwgZGlzcGxheTogJ2Jsb2NrJyB9O1xuICAgICAgICBvcHRzLmFuaW1JbiA9IHsgdG9wOiAwLCBoZWlnaHQ6IHRoaXMuY3ljbGVIIH07XG4gICAgICAgIG9wdHMuYW5pbU91dCA9IHsgdG9wOiBjdXJyLmN5Y2xlSC8yLCBoZWlnaHQ6IDAgfTtcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMik7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcbiAgICBvcHRzLmNzc0FmdGVyID0geyB6SW5kZXg6IDEsIGRpc3BsYXk6ICdub25lJyB9O1xufTtcblxuLy8gY292ZXIgLSBjdXJyIHNsaWRlIGNvdmVyZWQgYnkgbmV4dCBzbGlkZVxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5jb3ZlciA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XG4gICAgdmFyIGQgPSBvcHRzLmRpcmVjdGlvbiB8fCAnbGVmdCc7XG4gICAgdmFyIHcgPSAkY29udC5jc3MoJ292ZXJmbG93JywnaGlkZGVuJykud2lkdGgoKTtcbiAgICB2YXIgaCA9ICRjb250LmhlaWdodCgpO1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IG9wdHMuY3NzQmVmb3JlIHx8IHt9O1xuICAgICAgICBvcHRzLmNzc0JlZm9yZS56SW5kZXggPSAyO1xuICAgICAgICBvcHRzLmNzc0JlZm9yZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgXG4gICAgICAgIGlmIChkID09ICdyaWdodCcpIFxuICAgICAgICAgICAgb3B0cy5jc3NCZWZvcmUubGVmdCA9IC13O1xuICAgICAgICBlbHNlIGlmIChkID09ICd1cCcpICAgIFxuICAgICAgICAgICAgb3B0cy5jc3NCZWZvcmUudG9wID0gaDtcbiAgICAgICAgZWxzZSBpZiAoZCA9PSAnZG93bicpICBcbiAgICAgICAgICAgIG9wdHMuY3NzQmVmb3JlLnRvcCA9IC1oO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcHRzLmNzc0JlZm9yZS5sZWZ0ID0gdztcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMSk7XG4gICAgfSk7ICAgIFxuICAgIGlmICghb3B0cy5hbmltSW4pICBvcHRzLmFuaW1JbiA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgaWYgKCFvcHRzLmFuaW1PdXQpIG9wdHMuYW5pbU91dCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgb3B0cy5jc3NBZnRlciA9IG9wdHMuY3NzQWZ0ZXIgfHwge307XG4gICAgb3B0cy5jc3NBZnRlci56SW5kZXggPSAyO1xuICAgIG9wdHMuY3NzQWZ0ZXIuZGlzcGxheSA9ICdub25lJztcbn07XG5cbi8vIHVuY292ZXIgLSBjdXJyIHNsaWRlIG1vdmVzIG9mZiBuZXh0IHNsaWRlXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnVuY292ZXIgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xuICAgIHZhciBkID0gb3B0cy5kaXJlY3Rpb24gfHwgJ2xlZnQnO1xuICAgIHZhciB3ID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpLndpZHRoKCk7XG4gICAgdmFyIGggPSAkY29udC5oZWlnaHQoKTtcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGlmIChkID09ICdyaWdodCcpIFxuICAgICAgICAgICAgb3B0cy5hbmltT3V0LmxlZnQgPSB3O1xuICAgICAgICBlbHNlIGlmIChkID09ICd1cCcpICAgIFxuICAgICAgICAgICAgb3B0cy5hbmltT3V0LnRvcCA9IC1oO1xuICAgICAgICBlbHNlIGlmIChkID09ICdkb3duJykgIFxuICAgICAgICAgICAgb3B0cy5hbmltT3V0LnRvcCA9IGg7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9wdHMuYW5pbU91dC5sZWZ0ID0gLXc7XG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDIpO1xuICAgICAgICAkKG5leHQpLmNzcygnekluZGV4JywxKTtcbiAgICB9KTsgICAgXG4gICAgb3B0cy5vbkFkZFNsaWRlID0gZnVuY3Rpb24oJHMpIHsgJHMuaGlkZSgpOyB9O1xuICAgIGlmICghb3B0cy5hbmltSW4pICBvcHRzLmFuaW1JbiA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgb3B0cy5jc3NCZWZvcmUgPSBvcHRzLmNzc0JlZm9yZSB8fCB7fTtcbiAgICBvcHRzLmNzc0JlZm9yZS50b3AgPSAwO1xuICAgIG9wdHMuY3NzQmVmb3JlLmxlZnQgPSAwO1xuICAgIFxuICAgIG9wdHMuY3NzQWZ0ZXIgPSBvcHRzLmNzc0FmdGVyIHx8IHt9O1xuICAgIG9wdHMuY3NzQWZ0ZXIuekluZGV4ID0gMTtcbiAgICBvcHRzLmNzc0FmdGVyLmRpc3BsYXkgPSAnbm9uZSc7XG59O1xuXG4vLyB0b3NzIC0gbW92ZSB0b3Agc2xpZGUgYW5kIGZhZGUgYXdheVxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy50b3NzID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcbiAgICB2YXIgdyA9ICRjb250LmNzcygnb3ZlcmZsb3cnLCd2aXNpYmxlJykud2lkdGgoKTtcbiAgICB2YXIgaCA9ICRjb250LmhlaWdodCgpO1xuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywyKTtcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUuZGlzcGxheSA9ICdibG9jayc7IFxuICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgdG9zcyBzZXR0aW5ncyBpZiBhbmltT3V0IG5vdCBwcm92aWRlZFxuICAgICAgICBpZiAoIW9wdHMuYW5pbU91dC5sZWZ0ICYmICFvcHRzLmFuaW1PdXQudG9wKVxuICAgICAgICAgICAgb3B0cy5hbmltT3V0ID0geyBsZWZ0OiB3KjIsIHRvcDogLWgvMiwgb3BhY2l0eTogMCB9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcHRzLmFuaW1PdXQub3BhY2l0eSA9IDA7XG4gICAgfSk7ICAgIFxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcbiAgICBvcHRzLmNzc0JlZm9yZSA9IHsgbGVmdDogMCwgdG9wOiAwLCB6SW5kZXg6IDEsIG9wYWNpdHk6IDEgfTtcbiAgICBvcHRzLmFuaW1JbiA9IHsgbGVmdDogMCB9O1xuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IHpJbmRleDogMiwgZGlzcGxheTogJ25vbmUnIH07XG59O1xuXG4vLyB3aXBlIC0gY2xpcCBhbmltYXRpb25cbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMud2lwZSA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XG4gICAgdmFyIHcgPSAkY29udC5jc3MoJ292ZXJmbG93JywnaGlkZGVuJykud2lkdGgoKTtcbiAgICB2YXIgaCA9ICRjb250LmhlaWdodCgpO1xuICAgIG9wdHMuY3NzQmVmb3JlID0gb3B0cy5jc3NCZWZvcmUgfHwge307XG4gICAgdmFyIGNsaXA7XG4gICAgaWYgKG9wdHMuY2xpcCkge1xuICAgICAgICBpZiAoL2wyci8udGVzdChvcHRzLmNsaXApKVxuICAgICAgICAgICAgY2xpcCA9ICdyZWN0KDBweCAwcHggJytoKydweCAwcHgpJztcbiAgICAgICAgZWxzZSBpZiAoL3IybC8udGVzdChvcHRzLmNsaXApKVxuICAgICAgICAgICAgY2xpcCA9ICdyZWN0KDBweCAnK3crJ3B4ICcraCsncHggJyt3KydweCknO1xuICAgICAgICBlbHNlIGlmICgvdDJiLy50ZXN0KG9wdHMuY2xpcCkpXG4gICAgICAgICAgICBjbGlwID0gJ3JlY3QoMHB4ICcrdysncHggMHB4IDBweCknO1xuICAgICAgICBlbHNlIGlmICgvYjJ0Ly50ZXN0KG9wdHMuY2xpcCkpXG4gICAgICAgICAgICBjbGlwID0gJ3JlY3QoJytoKydweCAnK3crJ3B4ICcraCsncHggMHB4KSc7XG4gICAgICAgIGVsc2UgaWYgKC96b29tLy50ZXN0KG9wdHMuY2xpcCkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gcGFyc2VJbnQoaC8yKTtcbiAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQody8yKTtcbiAgICAgICAgICAgIGNsaXAgPSAncmVjdCgnK3QrJ3B4ICcrbCsncHggJyt0KydweCAnK2wrJ3B4KSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgb3B0cy5jc3NCZWZvcmUuY2xpcCA9IG9wdHMuY3NzQmVmb3JlLmNsaXAgfHwgY2xpcCB8fCAncmVjdCgwcHggMHB4IDBweCAwcHgpJztcbiAgICBcbiAgICB2YXIgZCA9IG9wdHMuY3NzQmVmb3JlLmNsaXAubWF0Y2goLyhcXGQrKS9nKTtcbiAgICB2YXIgdCA9IHBhcnNlSW50KGRbMF0pLCByID0gcGFyc2VJbnQoZFsxXSksIGIgPSBwYXJzZUludChkWzJdKSwgbCA9IHBhcnNlSW50KGRbM10pO1xuICAgIFxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xuICAgICAgICBpZiAoY3VyciA9PSBuZXh0KSByZXR1cm47XG4gICAgICAgIHZhciAkY3VyciA9ICQoY3VycikuY3NzKCd6SW5kZXgnLDIpO1xuICAgICAgICB2YXIgJG5leHQgPSAkKG5leHQpLmNzcyh7XG4gICAgICAgICAgICB6SW5kZXg6ICAzLFxuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGVwID0gMSwgY291bnQgPSBwYXJzZUludCgob3B0cy5zcGVlZEluIC8gMTMpKSAtIDE7XG4gICAgICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgICAgICB2YXIgdHQgPSB0ID8gdCAtIHBhcnNlSW50KHN0ZXAgKiAodC9jb3VudCkpIDogMDtcbiAgICAgICAgICAgIHZhciBsbCA9IGwgPyBsIC0gcGFyc2VJbnQoc3RlcCAqIChsL2NvdW50KSkgOiAwO1xuICAgICAgICAgICAgdmFyIGJiID0gYiA8IGggPyBiICsgcGFyc2VJbnQoc3RlcCAqICgoaC1iKS9jb3VudCB8fCAxKSkgOiBoO1xuICAgICAgICAgICAgdmFyIHJyID0gciA8IHcgPyByICsgcGFyc2VJbnQoc3RlcCAqICgody1yKS9jb3VudCB8fCAxKSkgOiB3O1xuICAgICAgICAgICAgJG5leHQuY3NzKHsgY2xpcDogJ3JlY3QoJyt0dCsncHggJytycisncHggJytiYisncHggJytsbCsncHgpJyB9KTtcbiAgICAgICAgICAgIChzdGVwKysgPD0gY291bnQpID8gc2V0VGltZW91dChmLCAxMykgOiAkY3Vyci5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICB9XG4gICAgICAgIGYoKTtcbiAgICB9KTsgICAgXG4gICAgb3B0cy5jc3NBZnRlciAgPSB7IH07XG4gICAgb3B0cy5hbmltSW4gICAgPSB7IGxlZnQ6IDAgfTtcbiAgICBvcHRzLmFuaW1PdXQgICA9IHsgbGVmdDogMCB9O1xufTtcblxufSkoalF1ZXJ5KTtcbi8qXG4galF1ZXJ5IGRlbGF5ZWQgb2JzZXJ2ZXIgLSAwLjhcbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvanF1ZXJ5LXV0aWxzL1xuXG4gKGMpIE1heGltZSBIYWluZWF1bHQgPGhhaW5lYXVsdEBnbWFpbC5jb20+XG4gaHR0cDovL2hhaW5lYXVsdC5jb21cbiBcbiBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gXG4qL1xuXG4oZnVuY3Rpb24oJCl7XG4gICAgJC5leHRlbmQoJC5mbiwge1xuICAgICAgICBkZWxheWVkT2JzZXJ2ZXI6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgb3B0aW9ucyl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgb3AgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIGVsLmRhdGEoJ29sZHZhbCcsIGVsLnZhbCgpKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YSgnZGVsYXknLCBkZWxheSB8fCAwLjUpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKCdjb25kaXRpb24nLCBvcC5jb25kaXRpb24gfHwgZnVuY3Rpb24oKSB7IHJldHVybiAoJCh0aGlzKS5kYXRhKCdvbGR2YWwnKSA9PSAkKHRoaXMpLnZhbCgpKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoJ2NhbGxiYWNrJywgY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIFsob3AuZXZlbnR8fCdrZXl1cCcpXShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmRhdGEoJ2NvbmRpdGlvbicpLmFwcGx5KGVsKSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5kYXRhKCd0aW1lcicpKSB7IGNsZWFyVGltZW91dChlbC5kYXRhKCd0aW1lcicpKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmRhdGEoJ3RpbWVyJywgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdjYWxsYmFjaycpLmFwcGx5KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlbC5kYXRhKCdkZWxheScpICogMTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmRhdGEoJ29sZHZhbCcsIGVsLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoalF1ZXJ5KTtcbi8qKlxuICogRmxhc2ggKGh0dHA6Ly9qcXVlcnkubHVrZWx1dG1hbi5jb20vcGx1Z2lucy9mbGFzaClcbiAqIEEgalF1ZXJ5IHBsdWdpbiBmb3IgZW1iZWRkaW5nIEZsYXNoIG1vdmllcy5cbiAqIFxuICogVmVyc2lvbiAxLjBcbiAqIE5vdmVtYmVyIDl0aCwgMjAwNlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNiBMdWtlIEx1dG1hbiAoaHR0cDovL3d3dy5sdWtlbHV0bWFuLmNvbSlcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvZ3BsLWxpY2Vuc2UucGhwXG4gKiBcbiAqIEluc3BpcmVkIGJ5OlxuICogU1dGT2JqZWN0IChodHRwOi8vYmxvZy5kZWNvbmNlcHQuY29tL3N3Zm9iamVjdC8pXG4gKiBVRk8gKGh0dHA6Ly93d3cuYm9iYnl2YW5kZXJzbHVpcy5jb20vdWZvLylcbiAqIHNJRlIgKGh0dHA6Ly93d3cubWlrZWluZHVzdHJpZXMuY29tL3NpZnIvKVxuICogXG4gKiBJTVBPUlRBTlQ6IFxuICogVGhlIHBhY2tlZCB2ZXJzaW9uIG9mIGpRdWVyeSBicmVha3MgQWN0aXZlWCBjb250cm9sXG4gKiBhY3RpdmF0aW9uIGluIEludGVybmV0IEV4cGxvcmVyLiBVc2UgSlNNaW4gdG8gbWluaWZpeVxuICogalF1ZXJ5IChzZWU6IGh0dHA6Ly9qcXVlcnkubHVrZWx1dG1hbi5jb20vcGx1Z2lucy9mbGFzaCNhY3RpdmV4KS5cbiAqXG4gKiovIFxuOyhmdW5jdGlvbigpe1xuXHRcbnZhciAkJDtcblxuLyoqXG4gKiBcbiAqIEBkZXNjIFJlcGxhY2UgbWF0Y2hpbmcgZWxlbWVudHMgd2l0aCBhIGZsYXNoIG1vdmllLlxuICogQGF1dGhvciBMdWtlIEx1dG1hblxuICogQHZlcnNpb24gMS4wLjFcbiAqXG4gKiBAbmFtZSBmbGFzaFxuICogQHBhcmFtIEhhc2ggaHRtbE9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGVtYmVkL29iamVjdCB0YWcuXG4gKiBAcGFyYW0gSGFzaCBwbHVnaW5PcHRpb25zIE9wdGlvbnMgZm9yIGRldGVjdGluZy91cGRhdGluZyB0aGUgRmxhc2ggcGx1Z2luIChvcHRpb25hbCkuXG4gKiBAcGFyYW0gRnVuY3Rpb24gcmVwbGFjZSBDdXN0b20gYmxvY2sgY2FsbGVkIGZvciBlYWNoIG1hdGNoZWQgZWxlbWVudCBpZiBmbGFzaCBpcyBpbnN0YWxsZWQgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSBGdW5jdGlvbiB1cGRhdGUgQ3VzdG9tIGJsb2NrIGNhbGxlZCBmb3IgZWFjaCBtYXRjaGVkIGlmIGZsYXNoIGlzbid0IGluc3RhbGxlZCAob3B0aW9uYWwpLlxuICogQHR5cGUgalF1ZXJ5XG4gKlxuICogQGNhdCBwbHVnaW5zL2ZsYXNoXG4gKiBcbiAqIEBleGFtcGxlICQoJyNoZWxsbycpLmZsYXNoKHsgc3JjOiAnaGVsbG8uc3dmJyB9KTtcbiAqIEBkZXNjIEVtYmVkIGEgRmxhc2ggbW92aWUuXG4gKlxuICogQGV4YW1wbGUgJCgnI2hlbGxvJykuZmxhc2goeyBzcmM6ICdoZWxsby5zd2YnIH0sIHsgdmVyc2lvbjogOCB9KTtcbiAqIEBkZXNjIEVtYmVkIGEgRmxhc2ggOCBtb3ZpZS5cbiAqXG4gKiBAZXhhbXBsZSAkKCcjaGVsbG8nKS5mbGFzaCh7IHNyYzogJ2hlbGxvLnN3ZicgfSwgeyBleHByZXNzSW5zdGFsbDogdHJ1ZSB9KTtcbiAqIEBkZXNjIEVtYmVkIGEgRmxhc2ggbW92aWUgdXNpbmcgRXhwcmVzcyBJbnN0YWxsIGlmIGZsYXNoIGlzbid0IGluc3RhbGxlZC5cbiAqXG4gKiBAZXhhbXBsZSAkKCcjaGVsbG8nKS5mbGFzaCh7IHNyYzogJ2hlbGxvLnN3ZicgfSwgeyB1cGRhdGU6IGZhbHNlIH0pO1xuICogQGRlc2MgRW1iZWQgYSBGbGFzaCBtb3ZpZSwgZG9uJ3Qgc2hvdyBhbiB1cGRhdGUgbWVzc2FnZSBpZiBGbGFzaCBpc24ndCBpbnN0YWxsZWQuXG4gKlxuKiovXG4kJCA9IGpRdWVyeS5mbi5mbGFzaCA9IGZ1bmN0aW9uKGh0bWxPcHRpb25zLCBwbHVnaW5PcHRpb25zLCByZXBsYWNlLCB1cGRhdGUpIHtcblx0XG5cdC8vIFNldCB0aGUgZGVmYXVsdCBibG9jay5cblx0dmFyIGJsb2NrID0gcmVwbGFjZSB8fCAkJC5yZXBsYWNlO1xuXHRcblx0Ly8gTWVyZ2UgdGhlIGRlZmF1bHQgYW5kIHBhc3NlZCBwbHVnaW4gb3B0aW9ucy5cblx0cGx1Z2luT3B0aW9ucyA9ICQkLmNvcHkoJCQucGx1Z2luT3B0aW9ucywgcGx1Z2luT3B0aW9ucyk7XG5cdFxuXHQvLyBEZXRlY3QgRmxhc2guXG5cdGlmKCEkJC5oYXNGbGFzaChwbHVnaW5PcHRpb25zLnZlcnNpb24pKSB7XG5cdFx0Ly8gVXNlIEV4cHJlc3MgSW5zdGFsbCAoaWYgc3BlY2lmaWVkIGFuZCBGbGFzaCBwbHVnaW4gNiwwLDY1IG9yIGhpZ2hlciBpcyBpbnN0YWxsZWQpLlxuXHRcdGlmKHBsdWdpbk9wdGlvbnMuZXhwcmVzc0luc3RhbGwgJiYgJCQuaGFzRmxhc2goNiwwLDY1KSkge1xuXHRcdFx0Ly8gQWRkIHRoZSBuZWNlc3NhcnkgZmxhc2h2YXJzIChtZXJnZWQgbGF0ZXIpLlxuXHRcdFx0dmFyIGV4cHJlc3NJbnN0YWxsT3B0aW9ucyA9IHtcblx0XHRcdFx0Zmxhc2h2YXJzOiB7ICBcdFxuXHRcdFx0XHRcdE1NcmVkaXJlY3RVUkw6IGxvY2F0aW9uLFxuXHRcdFx0XHRcdE1NcGxheWVyVHlwZTogJ1BsdWdJbicsXG5cdFx0XHRcdFx0TU1kb2N0aXRsZTogalF1ZXJ5KCd0aXRsZScpLnRleHQoKSBcblx0XHRcdFx0fVx0XHRcdFx0XHRcblx0XHRcdH07XG5cdFx0Ly8gQXNrIHRoZSB1c2VyIHRvIHVwZGF0ZSAoaWYgc3BlY2lmaWVkKS5cblx0XHR9IGVsc2UgaWYgKHBsdWdpbk9wdGlvbnMudXBkYXRlKSB7XG5cdFx0XHQvLyBDaGFuZ2UgdGhlIGJsb2NrIHRvIGluc2VydCB0aGUgdXBkYXRlIG1lc3NhZ2UgaW5zdGVhZCBvZiB0aGUgZmxhc2ggbW92aWUuXG5cdFx0XHRibG9jayA9IHVwZGF0ZSB8fCAkJC51cGRhdGU7XG5cdFx0Ly8gRmFpbFxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUaGUgcmVxdWlyZWQgdmVyc2lvbiBvZiBmbGFzaCBpc24ndCBpbnN0YWxsZWQuXG5cdFx0XHQvLyBFeHByZXNzIEluc3RhbGwgaXMgdHVybmVkIG9mZiwgb3IgZmxhc2ggNiwwLDY1IGlzbid0IGluc3RhbGxlZC5cblx0XHRcdC8vIFVwZGF0ZSBpcyB0dXJuZWQgb2ZmLlxuXHRcdFx0Ly8gUmV0dXJuIHdpdGhvdXQgZG9pbmcgYW55dGhpbmcuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH1cblx0XG5cdC8vIE1lcmdlIHRoZSBkZWZhdWx0LCBleHByZXNzIGluc3RhbGwgYW5kIHBhc3NlZCBodG1sIG9wdGlvbnMuXG5cdGh0bWxPcHRpb25zID0gJCQuY29weSgkJC5odG1sT3B0aW9ucywgZXhwcmVzc0luc3RhbGxPcHRpb25zLCBodG1sT3B0aW9ucyk7XG5cdFxuXHQvLyBJbnZva2UgJGJsb2NrICh3aXRoIGEgY29weSBvZiB0aGUgbWVyZ2VkIGh0bWwgb3B0aW9ucykgZm9yIGVhY2ggZWxlbWVudC5cblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuXHRcdGJsb2NrLmNhbGwodGhpcywgJCQuY29weShodG1sT3B0aW9ucykpO1xuXHR9KTtcblx0XG59O1xuLyoqXG4gKlxuICogQG5hbWUgZmxhc2guY29weVxuICogQGRlc2MgQ29weSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG9iamVjdHMgaW50byBhIG5ldyBvYmplY3QuXG4gKiBAdHlwZSBPYmplY3RcbiAqIFxuICogQGV4YW1wbGUgJCQuY29weSh7IGZvbzogMSB9LCB7IGJhcjogMiB9KTtcbiAqIEByZXN1bHQgeyBmb286IDEsIGJhcjogMiB9O1xuICpcbioqL1xuJCQuY29weSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucyA9IHt9LCBmbGFzaHZhcnMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0aWYoYXJnID09IHVuZGVmaW5lZCkgY29udGludWU7XG5cdFx0alF1ZXJ5LmV4dGVuZChvcHRpb25zLCBhcmcpO1xuXHRcdC8vIGRvbid0IGNsb2JiZXIgb25lIGZsYXNoIHZhcnMgb2JqZWN0IHdpdGggYW5vdGhlclxuXHRcdC8vIG1lcmdlIHRoZW0gaW5zdGVhZFxuXHRcdGlmKGFyZy5mbGFzaHZhcnMgPT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblx0XHRqUXVlcnkuZXh0ZW5kKGZsYXNodmFycywgYXJnLmZsYXNodmFycyk7XG5cdH1cblx0b3B0aW9ucy5mbGFzaHZhcnMgPSBmbGFzaHZhcnM7XG5cdHJldHVybiBvcHRpb25zO1xufTtcbi8qXG4gKiBAbmFtZSBmbGFzaC5oYXNGbGFzaFxuICogQGRlc2MgQ2hlY2sgaWYgYSBzcGVjaWZpYyB2ZXJzaW9uIG9mIHRoZSBGbGFzaCBwbHVnaW4gaXMgaW5zdGFsbGVkXG4gKiBAdHlwZSBCb29sZWFuXG4gKlxuKiovXG4kJC5oYXNGbGFzaCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBsb29rIGZvciBhIGZsYWcgaW4gdGhlIHF1ZXJ5IHN0cmluZyB0byBieXBhc3MgZmxhc2ggZGV0ZWN0aW9uXG5cdGlmKC9oYXNGbGFzaFxcPXRydWUvLnRlc3QobG9jYXRpb24pKSByZXR1cm4gdHJ1ZTtcblx0aWYoL2hhc0ZsYXNoXFw9ZmFsc2UvLnRlc3QobG9jYXRpb24pKSByZXR1cm4gZmFsc2U7XG5cdHZhciBwdiA9ICQkLmhhc0ZsYXNoLnBsYXllclZlcnNpb24oKS5tYXRjaCgvXFxkKy9nKTtcblx0dmFyIHJ2ID0gU3RyaW5nKFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXSkubWF0Y2goL1xcZCsvZykgfHwgU3RyaW5nKCQkLnBsdWdpbk9wdGlvbnMudmVyc2lvbikubWF0Y2goL1xcZCsvZyk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRwdltpXSA9IHBhcnNlSW50KHB2W2ldIHx8IDApO1xuXHRcdHJ2W2ldID0gcGFyc2VJbnQocnZbaV0gfHwgMCk7XG5cdFx0Ly8gcGxheWVyIGlzIGxlc3MgdGhhbiByZXF1aXJlZFxuXHRcdGlmKHB2W2ldIDwgcnZbaV0pIHJldHVybiBmYWxzZTtcblx0XHQvLyBwbGF5ZXIgaXMgZ3JlYXRlciB0aGFuIHJlcXVpcmVkXG5cdFx0aWYocHZbaV0gPiBydltpXSkgcmV0dXJuIHRydWU7XG5cdH1cblx0Ly8gbWFqb3IgdmVyc2lvbiwgbWlub3IgdmVyc2lvbiBhbmQgcmV2aXNpb24gbWF0Y2ggZXhhY3RseVxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqXG4gKiBAbmFtZSBmbGFzaC5oYXNGbGFzaC5wbGF5ZXJWZXJzaW9uXG4gKiBAZGVzYyBHZXQgdGhlIHZlcnNpb24gb2YgdGhlIGluc3RhbGxlZCBGbGFzaCBwbHVnaW4uXG4gKiBAdHlwZSBTdHJpbmdcbiAqXG4qKi9cbiQkLmhhc0ZsYXNoLnBsYXllclZlcnNpb24gPSBmdW5jdGlvbigpIHtcblx0Ly8gaWVcblx0dHJ5IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gYXZvaWQgZnA2IG1pbm9yIHZlcnNpb24gbG9va3VwIGlzc3Vlc1xuXHRcdFx0Ly8gc2VlOiBodHRwOi8vYmxvZy5kZWNvbmNlcHQuY29tLzIwMDYvMDEvMTEvZ2V0dmFyaWFibGUtc2V0dmFyaWFibGUtY3Jhc2gtaW50ZXJuZXQtZXhwbG9yZXItZmxhc2gtNi9cblx0XHRcdHZhciBheG8gPSBuZXcgQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2guNicpO1xuXHRcdFx0dHJ5IHsgYXhvLkFsbG93U2NyaXB0QWNjZXNzID0gJ2Fsd2F5cyc7XHR9IFxuXHRcdFx0Y2F0Y2goZSkgeyByZXR1cm4gJzYsMCwwJzsgfVx0XHRcdFx0XG5cdFx0fSBjYXRjaChlKSB7fVxuXHRcdHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2gnKS5HZXRWYXJpYWJsZSgnJHZlcnNpb24nKS5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXTtcblx0Ly8gb3RoZXIgYnJvd3NlcnNcblx0fSBjYXRjaChlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmKG5hdmlnYXRvci5taW1lVHlwZXNbXCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiXS5lbmFibGVkUGx1Z2luKXtcblx0XHRcdFx0cmV0dXJuIChuYXZpZ2F0b3IucGx1Z2luc1tcIlNob2Nrd2F2ZSBGbGFzaCAyLjBcIl0gfHwgbmF2aWdhdG9yLnBsdWdpbnNbXCJTaG9ja3dhdmUgRmxhc2hcIl0pLmRlc2NyaXB0aW9uLnJlcGxhY2UoL1xcRCsvZywgXCIsXCIpLm1hdGNoKC9eLD8oLispLD8kLylbMV07XG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlKSB7fVx0XHRcblx0fVxuXHRyZXR1cm4gJzAsMCwwJztcbn07XG4vKipcbiAqXG4gKiBAbmFtZSBmbGFzaC5odG1sT3B0aW9uc1xuICogQGRlc2MgVGhlIGRlZmF1bHQgc2V0IG9mIG9wdGlvbnMgZm9yIHRoZSBvYmplY3Qgb3IgZW1iZWQgdGFnLlxuICpcbioqL1xuJCQuaHRtbE9wdGlvbnMgPSB7XG5cdGhlaWdodDogMjQwLFxuXHRmbGFzaHZhcnM6IHt9LFxuXHRwbHVnaW5zcGFnZTogJ2h0dHA6Ly93d3cuYWRvYmUuY29tL2dvL2dldGZsYXNocGxheWVyJyxcblx0c3JjOiAnIycsXG5cdHR5cGU6ICdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXG5cdHdpZHRoOiAzMjBcdFx0XG59O1xuLyoqXG4gKlxuICogQG5hbWUgZmxhc2gucGx1Z2luT3B0aW9uc1xuICogQGRlc2MgVGhlIGRlZmF1bHQgc2V0IG9mIG9wdGlvbnMgZm9yIGNoZWNraW5nL3VwZGF0aW5nIHRoZSBmbGFzaCBQbHVnaW4uXG4gKlxuKiovXG4kJC5wbHVnaW5PcHRpb25zID0ge1xuXHRleHByZXNzSW5zdGFsbDogZmFsc2UsXG5cdHVwZGF0ZTogdHJ1ZSxcblx0dmVyc2lvbjogJzYuMC42NSdcbn07XG4vKipcbiAqXG4gKiBAbmFtZSBmbGFzaC5yZXBsYWNlXG4gKiBAZGVzYyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIHJlcGxhY2luZyBhbiBlbGVtZW50IHdpdGggYSBGbGFzaCBtb3ZpZS5cbiAqXG4qKi9cbiQkLnJlcGxhY2UgPSBmdW5jdGlvbihodG1sT3B0aW9ucykge1xuXHR0aGlzLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiYWx0XCI+Jyt0aGlzLmlubmVySFRNTCsnPC9kaXY+Jztcblx0alF1ZXJ5KHRoaXMpXG5cdFx0LmFkZENsYXNzKCdmbGFzaC1yZXBsYWNlZCcpXG5cdFx0LnByZXBlbmQoJCQudHJhbnNmb3JtKGh0bWxPcHRpb25zKSk7XG59O1xuLyoqXG4gKlxuICogQG5hbWUgZmxhc2gudXBkYXRlXG4gKiBAZGVzYyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIHJlcGxhY2luZyBhbiBlbGVtZW50IHdpdGggYW4gdXBkYXRlIG1lc3NhZ2UuXG4gKlxuKiovXG4kJC51cGRhdGUgPSBmdW5jdGlvbihodG1sT3B0aW9ucykge1xuXHR2YXIgdXJsID0gU3RyaW5nKGxvY2F0aW9uKS5zcGxpdCgnPycpO1xuXHR1cmwuc3BsaWNlKDEsMCwnP2hhc0ZsYXNoPXRydWUmJyk7XG5cdHVybCA9IHVybC5qb2luKCcnKTtcblx0dmFyIG1zZyA9ICc8cD5UaGlzIGNvbnRlbnQgcmVxdWlyZXMgdGhlIEZsYXNoIFBsYXllci4gPGEgaHJlZj1cImh0dHA6Ly93d3cuYWRvYmUuY29tL2dvL2dldGZsYXNocGxheWVyXCI+RG93bmxvYWQgRmxhc2ggUGxheWVyPC9hPi4gQWxyZWFkeSBoYXZlIEZsYXNoIFBsYXllcj8gPGEgaHJlZj1cIicrdXJsKydcIj5DbGljayBoZXJlLjwvYT48L3A+Jztcblx0dGhpcy5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJhbHRcIj4nK3RoaXMuaW5uZXJIVE1MKyc8L3NwYW4+Jztcblx0alF1ZXJ5KHRoaXMpXG5cdFx0LmFkZENsYXNzKCdmbGFzaC11cGRhdGUnKVxuXHRcdC5wcmVwZW5kKG1zZyk7XG59O1xuLyoqXG4gKlxuICogQGRlc2MgQ29udmVydCBhIGhhc2ggb2YgaHRtbCBvcHRpb25zIHRvIGEgc3RyaW5nIG9mIGF0dHJpYnV0ZXMsIHVzaW5nIEZ1bmN0aW9uLmFwcGx5KCkuIFxuICogQGV4YW1wbGUgdG9BdHRyaWJ1dGVTdHJpbmcuYXBwbHkoaHRtbE9wdGlvbnMpXG4gKiBAcmVzdWx0IGZvbz1cImJhclwiIGZvbz1cImJhclwiXG4gKlxuKiovXG5mdW5jdGlvbiB0b0F0dHJpYnV0ZVN0cmluZygpIHtcblx0dmFyIHMgPSAnJztcblx0Zm9yKHZhciBrZXkgaW4gdGhpcylcblx0XHRpZih0eXBlb2YgdGhpc1trZXldICE9ICdmdW5jdGlvbicpXG5cdFx0XHRzICs9IGtleSsnPVwiJyt0aGlzW2tleV0rJ1wiICc7XG5cdHJldHVybiBzO1x0XHRcbn07XG4vKipcbiAqXG4gKiBAZGVzYyBDb252ZXJ0IGEgaGFzaCBvZiBmbGFzaHZhcnMgdG8gYSB1cmwtZW5jb2RlZCBzdHJpbmcsIHVzaW5nIEZ1bmN0aW9uLmFwcGx5KCkuIFxuICogQGV4YW1wbGUgdG9GbGFzaHZhcnNTdHJpbmcuYXBwbHkoZmxhc2h2YXJzT2JqZWN0KVxuICogQHJlc3VsdCBmb289YmFyJmZvbz1iYXJcbiAqXG4qKi9cbmZ1bmN0aW9uIHRvRmxhc2h2YXJzU3RyaW5nKCkge1xuXHR2YXIgcyA9ICcnO1xuXHRmb3IodmFyIGtleSBpbiB0aGlzKVxuXHRcdGlmKHR5cGVvZiB0aGlzW2tleV0gIT0gJ2Z1bmN0aW9uJylcblx0XHRcdHMgKz0ga2V5Kyc9JytlbmNvZGVVUklDb21wb25lbnQodGhpc1trZXldKSsnJic7XG5cdHJldHVybiBzLnJlcGxhY2UoLyYkLywgJycpO1x0XHRcbn07XG4vKipcbiAqXG4gKiBAbmFtZSBmbGFzaC50cmFuc2Zvcm1cbiAqIEBkZXNjIFRyYW5zZm9ybSBhIHNldCBvZiBodG1sIG9wdGlvbnMgaW50byBhbiBlbWJlZCB0YWcuXG4gKiBAdHlwZSBTdHJpbmcgXG4gKlxuICogQGV4YW1wbGUgJCQudHJhbnNmb3JtKGh0bWxPcHRpb25zKVxuICogQHJlc3VsdCA8ZW1iZWQgc3JjPVwiZm9vLnN3ZlwiIC4uLiAvPlxuICpcbiAqIE5vdGU6IFRoZSBlbWJlZCB0YWcgaXMgTk9UIHN0YW5kYXJkcy1jb21wbGlhbnQsIGJ1dCBpdCBcbiAqIHdvcmtzIGluIGFsbCBjdXJyZW50IGJyb3dzZXJzLiBmbGFzaC50cmFuc2Zvcm0gY2FuIGJlXG4gKiBvdmVyd3JpdHRlbiB3aXRoIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIG1vcmUgXG4gKiBzdGFuZGFyZHMtY29tcGxpYW50IG1hcmt1cC5cbiAqXG4qKi9cbiQkLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGh0bWxPcHRpb25zKSB7XG5cdGh0bWxPcHRpb25zLnRvU3RyaW5nID0gdG9BdHRyaWJ1dGVTdHJpbmc7XG5cdGlmKGh0bWxPcHRpb25zLmZsYXNodmFycykgaHRtbE9wdGlvbnMuZmxhc2h2YXJzLnRvU3RyaW5nID0gdG9GbGFzaHZhcnNTdHJpbmc7XG5cdHJldHVybiAnPGVtYmVkICcgKyBTdHJpbmcoaHRtbE9wdGlvbnMpICsgJy8+JztcdFx0XG59O1xuXG4vKipcbiAqXG4gKiBGbGFzaCBQbGF5ZXIgOSBGaXggKGh0dHA6Ly9ibG9nLmRlY29uY2VwdC5jb20vMjAwNi8wNy8yOC9zd2ZvYmplY3QtMTQzLXJlbGVhc2VkLylcbiAqXG4qKi9cbmlmICh3aW5kb3cuYXR0YWNoRXZlbnQpIHtcblx0d2luZG93LmF0dGFjaEV2ZW50KFwib25iZWZvcmV1bmxvYWRcIiwgZnVuY3Rpb24oKXtcblx0XHRfX2ZsYXNoX3VubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuXHRcdF9fZmxhc2hfc2F2ZWRVbmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcblx0fSk7XG59XG5cdFxufSkoKTtcbihmdW5jdGlvbigkKXtcbiAgICAkLl9pMThuID0geyB0cmFuczoge30sICdkZWZhdWx0JzogICdlbicsIGxhbmd1YWdlOiAnZW4nIH07XG4gICAgJC5pMThuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnZXRUcmFucyA9IGZ1bmN0aW9uKG5zLCBzdHIpIHtcbiAgICAgICAgICAgIHZhciB0cmFucyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgc3RyaW5nIGV4aXN0cyBpbiB0cmFuc2xhdGlvblxuICAgICAgICAgICAgaWYgKCQuX2kxOG4udHJhbnNbJC5faTE4bi5sYW5ndWFnZV0gXG4gICAgICAgICAgICAgICAgJiYgJC5faTE4bi50cmFuc1skLl9pMThuLmxhbmd1YWdlXVtuc11cbiAgICAgICAgICAgICAgICAmJiAkLl9pMThuLnRyYW5zWyQuX2kxOG4ubGFuZ3VhZ2VdW25zXVtzdHJdKSB7XG4gICAgICAgICAgICAgICAgdHJhbnMgPSAkLl9pMThuLnRyYW5zWyQuX2kxOG4ubGFuZ3VhZ2VdW25zXVtzdHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3IgZXhpc3RzIGluIGRlZmF1bHRcbiAgICAgICAgICAgIGVsc2UgaWYgKCQuX2kxOG4udHJhbnNbJC5faTE4blsnZGVmYXVsdCddXSBcbiAgICAgICAgICAgICAgICAgICAgICYmICQuX2kxOG4udHJhbnNbJC5faTE4blsnZGVmYXVsdCddXVtuc11cbiAgICAgICAgICAgICAgICAgICAgICYmICQuX2kxOG4udHJhbnNbJC5faTE4blsnZGVmYXVsdCddXVtuc11bc3RyXSkge1xuICAgICAgICAgICAgICAgIHRyYW5zID0gJC5faTE4bi50cmFuc1skLl9pMThuWydkZWZhdWx0J11dW25zXVtzdHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIHRyYW5zIG9yIG9yaWdpbmFsIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zIHx8IHN0cjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2V0IGxhbmd1YWdlIChhY2NlcHRlZCBmb3JtYXRzOiBlbiBvciBlbi1VUylcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAkLl9pMThuLmxhbmd1YWdlID0gYXJndW1lbnRzWzBdOyBcbiAgICAgICAgICAgIHJldHVybiAkLl9pMThuLmxhbmd1YWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0IHRyYW5zbGF0aW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZ3VtZW50c1sxXSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBnZXRUcmFucyhhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICAgICAgLy8gaGFzIHZhcmlhYmxlcyBmb3Igc3RyaW5nIGZvcm1hdGluZ1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMl0gJiYgdHlwZW9mKGFyZ3VtZW50c1syXSkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuZm9ybWF0KHRyYW5zLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCAgPSBhcmd1bWVudHNbMF0uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZyA9IHRtcFswXTtcbiAgICAgICAgICAgICAgICB2YXIgbnMgICA9IHRtcFsxXSB8fCAnalF1ZXJ5JztcbiAgICAgICAgICAgICAgICBpZiAoISQuX2kxOG4udHJhbnNbbGFuZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgJC5faTE4bi50cmFuc1tsYW5nXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAkLl9pMThuLnRyYW5zW2xhbmddW25zXSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKCQuX2kxOG4udHJhbnNbbGFuZ11bbnNdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KShqUXVlcnkpO1xuLypcbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDA4IEpvc2ggQnVzaCAoZGlnaXRhbGJ1c2guY29tKVxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLiBcbiAqL1xuIFxuLypcbiAqIFZlcnNpb246IDEuMS4zXG4gKiBSZWxlYXNlOiAyMDA4LTA0LTE2XG4gKi8gXG4oZnVuY3Rpb24oJCkge1xuXG5cdC8vSGVscGVyIEZ1bmN0aW9uIGZvciBDYXJldCBwb3NpdGlvbmluZ1xuXHQkLmZuLmNhcmV0PWZ1bmN0aW9uKGJlZ2luLGVuZCl7XHRcblx0XHRpZih0aGlzLmxlbmd0aD09MCkgcmV0dXJuO1xuXHRcdGlmICh0eXBlb2YgYmVnaW4gPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVuZCA9ICh0eXBlb2YgZW5kID09ICdudW1iZXInKT9lbmQ6YmVnaW47ICBcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdFx0aWYodGhpcy5zZXRTZWxlY3Rpb25SYW5nZSl7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UoYmVnaW4sZW5kKTtcblx0XHRcdFx0fWVsc2UgaWYgKHRoaXMuY3JlYXRlVGV4dFJhbmdlKXtcblx0XHRcdFx0XHR2YXIgcmFuZ2UgPSB0aGlzLmNyZWF0ZVRleHRSYW5nZSgpO1xuXHRcdFx0XHRcdHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuXHRcdFx0XHRcdHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XG5cdFx0XHRcdFx0cmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBiZWdpbik7XG5cdFx0XHRcdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0uc2V0U2VsZWN0aW9uUmFuZ2Upe1xuXHRcdFx0XHRiZWdpbiA9IHRoaXNbMF0uc2VsZWN0aW9uU3RhcnQ7XG5cdFx0XHRcdGVuZCA9IHRoaXNbMF0uc2VsZWN0aW9uRW5kO1xuXHRcdFx0fWVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2Upe1xuXHRcdFx0XHR2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcdFx0XHRcblx0XHRcdFx0YmVnaW4gPSAwIC0gcmFuZ2UuZHVwbGljYXRlKCkubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtMTAwMDAwKTtcblx0XHRcdFx0ZW5kID0gYmVnaW4gKyByYW5nZS50ZXh0Lmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7YmVnaW46YmVnaW4sZW5kOmVuZH07XG4gICAgICAgIH0gICAgICAgXG5cdH07XG5cblx0Ly9QcmVkZWZpbmVkIGNoYXJhY3RlciBkZWZpbml0aW9uc1xuXHR2YXIgY2hhck1hcD17XG5cdFx0JzknOlwiWzAtOV1cIixcblx0XHQnYSc6XCJbQS1aYS16XVwiLFxuXHRcdCcqJzpcIltBLVphLXowLTldXCJcblx0fTtcblx0XG5cdC8vSGVscGVyIG1ldGhvZCB0byBpbmplY3QgY2hhcmFjdGVyIGRlZmluaXRpb25zXG5cdCQubWFzaz17XG5cdFx0YWRkUGxhY2Vob2xkZXIgOiBmdW5jdGlvbihjLHIpe1xuXHRcdFx0Y2hhck1hcFtjXT1yO1xuXHRcdH1cblx0fTtcblx0XG5cdCQuZm4udW5tYXNrPWZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMudHJpZ2dlcihcInVubWFza1wiKTtcblx0fTtcblx0XG5cdC8vTWFpbiBNZXRob2Rcblx0JC5mbi5tYXNrID0gZnVuY3Rpb24obWFzayxzZXR0aW5ncykge1x0XG5cdFx0c2V0dGluZ3MgPSAkLmV4dGVuZCh7XG5cdFx0XHRwbGFjZWhvbGRlcjogXCJfXCIsXHRcdFx0XG5cdFx0XHRjb21wbGV0ZWQ6IG51bGxcblx0XHR9LCBzZXR0aW5ncyk7XHRcdFxuXHRcdFxuXHRcdC8vQnVpbGQgUmVnZXggZm9yIGZvcm1hdCB2YWxpZGF0aW9uXG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIl5cIitcdFxuXHRcdCQubWFwKCBtYXNrLnNwbGl0KFwiXCIpLCBmdW5jdGlvbihjLGkpe1x0XHQgIFx0XHQgIFxuXHRcdCAgcmV0dXJuIGNoYXJNYXBbY118fCgoL1tBLVphLXowLTldLy50ZXN0KGMpP1wiXCI6XCJcXFxcXCIpK2MpO1xuXHRcdH0pLmpvaW4oJycpK1x0XHRcdFx0XG5cdFx0XCIkXCIpO1x0XHRcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcdFx0XG5cdFx0XHR2YXIgaW5wdXQ9JCh0aGlzKTtcblx0XHRcdHZhciBidWZmZXI9bmV3IEFycmF5KG1hc2subGVuZ3RoKTtcblx0XHRcdHZhciBsb2NrZWQ9bmV3IEFycmF5KG1hc2subGVuZ3RoKTtcblx0XHRcdHZhciB2YWxpZD1mYWxzZTsgICBcblx0XHRcdHZhciBpZ25vcmU9ZmFsc2U7ICBcdFx0XHQvL1ZhcmlhYmxlIGZvciBpZ25vcmluZyBjb250cm9sIGtleXNcblx0XHRcdHZhciBmaXJzdE5vbk1hc2tQb3M9bnVsbDsgXG5cdFx0XHRcblx0XHRcdC8vQnVpbGQgYnVmZmVyIGxheW91dCBmcm9tIG1hc2sgJiBkZXRlcm1pbmUgdGhlIGZpcnN0IG5vbiBtYXNrZWQgY2hhcmFjdGVyXHRcdFx0XG5cdFx0XHQkLmVhY2goIG1hc2suc3BsaXQoXCJcIiksIGZ1bmN0aW9uKGksYyl7XHRcdFx0XHRcblx0XHRcdFx0bG9ja2VkW2ldPShjaGFyTWFwW2NdPT1udWxsKTtcdFx0XHRcdFxuXHRcdFx0XHRidWZmZXJbaV09bG9ja2VkW2ldP2M6c2V0dGluZ3MucGxhY2Vob2xkZXI7XHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdGlmKCFsb2NrZWRbaV0gJiYgZmlyc3ROb25NYXNrUG9zPT1udWxsKVxuXHRcdFx0XHRcdGZpcnN0Tm9uTWFza1Bvcz1pO1xuXHRcdFx0fSk7XHRcdFxuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiBmb2N1c0V2ZW50KCl7XHRcdFx0XHRcdFxuXHRcdFx0XHRjaGVja1ZhbCgpO1xuXHRcdFx0XHR3cml0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0JChpbnB1dFswXSkuY2FyZXQodmFsaWQ/bWFzay5sZW5ndGg6Zmlyc3ROb25NYXNrUG9zKTtcdFx0XHRcdFx0XG5cdFx0XHRcdH0sMCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiBrZXlkb3duRXZlbnQoZSl7XHRcdFx0XHRcblx0XHRcdFx0dmFyIHBvcz0kKHRoaXMpLmNhcmV0KCk7XG5cdFx0XHRcdHZhciBrID0gZS5rZXlDb2RlO1xuXHRcdFx0XHRpZ25vcmU9KGsgPCAxNiB8fCAoayA+IDE2ICYmIGsgPCAzMiApIHx8IChrID4gMzIgJiYgayA8IDQxKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL2RlbGV0ZSBzZWxlY3Rpb24gYmVmb3JlIHByb2NlZWRpbmdcblx0XHRcdFx0aWYoKHBvcy5iZWdpbi1wb3MuZW5kKSE9MCAmJiAoIWlnbm9yZSB8fCBrPT04IHx8IGs9PTQ2KSl7XG5cdFx0XHRcdFx0Y2xlYXJCdWZmZXIocG9zLmJlZ2luLHBvcy5lbmQpO1xuXHRcdFx0XHR9XHRcblx0XHRcdFx0Ly9iYWNrc3BhY2UgYW5kIGRlbGV0ZSBnZXQgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRcdFx0aWYoaz09OCl7Ly9iYWNrc3BhY2VcdFx0XHRcdFx0XG5cdFx0XHRcdFx0d2hpbGUocG9zLmJlZ2luLS0+PTApe1xuXHRcdFx0XHRcdFx0aWYoIWxvY2tlZFtwb3MuYmVnaW5dKXtcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcltwb3MuYmVnaW5dPXNldHRpbmdzLnBsYWNlaG9sZGVyO1xuXHRcdFx0XHRcdFx0XHRpZigkLmJyb3dzZXIub3BlcmEpe1xuXHRcdFx0XHRcdFx0XHRcdC8vT3BlcmEgd29uJ3QgbGV0IHlvdSBjYW5jZWwgdGhlIGJhY2tzcGFjZSwgc28gd2UnbGwgbGV0IGl0IGJhY2tzcGFjZSBvdmVyIGEgZHVtbXkgY2hhcmFjdGVyLlx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRzPXdyaXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRcdFx0aW5wdXQudmFsKHMuc3Vic3RyaW5nKDAscG9zLmJlZ2luKStcIiBcIitzLnN1YnN0cmluZyhwb3MuYmVnaW4pKTtcblx0XHRcdFx0XHRcdFx0XHQkKHRoaXMpLmNhcmV0KHBvcy5iZWdpbisxKTtcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRcdHdyaXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRcdFx0JCh0aGlzKS5jYXJldChNYXRoLm1heChmaXJzdE5vbk1hc2tQb3MscG9zLmJlZ2luKSk7XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR9XHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVx0XHRcdFx0XHRcdFxuXHRcdFx0XHR9ZWxzZSBpZihrPT00Nil7Ly9kZWxldGVcblx0XHRcdFx0XHRjbGVhckJ1ZmZlcihwb3MuYmVnaW4scG9zLmJlZ2luKzEpO1xuXHRcdFx0XHRcdHdyaXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0JCh0aGlzKS5jYXJldChNYXRoLm1heChmaXJzdE5vbk1hc2tQb3MscG9zLmJlZ2luKSk7XHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fWVsc2UgaWYgKGs9PTI3KXsvL2VzY2FwZVxuXHRcdFx0XHRcdGNsZWFyQnVmZmVyKDAsbWFzay5sZW5ndGgpO1xuXHRcdFx0XHRcdHdyaXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0JCh0aGlzKS5jYXJldChmaXJzdE5vbk1hc2tQb3MpO1x0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uIGtleXByZXNzRXZlbnQoZSl7XHRcdFx0XHRcdFxuXHRcdFx0XHRpZihpZ25vcmUpe1xuXHRcdFx0XHRcdGlnbm9yZT1mYWxzZTtcblx0XHRcdFx0XHQvL0ZpeGVzIE1hYyBGRiBidWcgb24gYmFja3NwYWNlXG5cdFx0XHRcdFx0cmV0dXJuIChlLmtleUNvZGUgPT0gOCk/IGZhbHNlOiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGU9ZXx8d2luZG93LmV2ZW50O1xuXHRcdFx0XHR2YXIgaz1lLmNoYXJDb2RlfHxlLmtleUNvZGV8fGUud2hpY2g7XHRcdFx0XHRcdFx0XG5cdFx0XHRcdHZhciBwb3M9JCh0aGlzKS5jYXJldCgpO1xuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRpZihlLmN0cmxLZXkgfHwgZS5hbHRLZXkpey8vSWdub3JlXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1lbHNlIGlmICgoaz49NDEgJiYgazw9MTIyKSB8fGs9PTMyIHx8IGs+MTg2KXsvL3R5cGVhYmxlIGNoYXJhY3RlcnNcblx0XHRcdFx0XHR2YXIgcD1zZWVrTmV4dChwb3MuYmVnaW4tMSk7XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKHA8bWFzay5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0aWYobmV3IFJlZ0V4cChjaGFyTWFwW21hc2suY2hhckF0KHApXSkudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGspKSl7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcltwXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGspO1x0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR3cml0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRcdFx0XHR2YXIgbmV4dD1zZWVrTmV4dChwKTtcblx0XHRcdFx0XHRcdFx0JCh0aGlzKS5jYXJldChuZXh0KTtcblx0XHRcdFx0XHRcdFx0aWYoc2V0dGluZ3MuY29tcGxldGVkICYmIG5leHQgPT0gbWFzay5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3MuY29tcGxldGVkLmNhbGwoaW5wdXQpO1xuXHRcdFx0XHRcdFx0fVx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1x0XHRcdFx0XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiBjbGVhckJ1ZmZlcihzdGFydCxlbmQpe1xuXHRcdFx0XHRmb3IodmFyIGk9c3RhcnQ7aTxlbmQmJmk8bWFzay5sZW5ndGg7aSsrKXtcblx0XHRcdFx0XHRpZighbG9ja2VkW2ldKVxuXHRcdFx0XHRcdFx0YnVmZmVyW2ldPXNldHRpbmdzLnBsYWNlaG9sZGVyO1xuXHRcdFx0XHR9XHRcdFx0XHRcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uIHdyaXRlQnVmZmVyKCl7XHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGlucHV0LnZhbChidWZmZXIuam9pbignJykpLnZhbCgpO1x0XHRcdFx0XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiBjaGVja1ZhbCgpe1x0XG5cdFx0XHRcdC8vdHJ5IHRvIHBsYWNlIGNoYXJjdGVycyB3aGVyZSB0aGV5IGJlbG9uZ1xuXHRcdFx0XHR2YXIgdGVzdD1pbnB1dC52YWwoKTtcblx0XHRcdFx0dmFyIHBvcz0wO1xuXHRcdFx0XHRmb3IodmFyIGk9MDtpPG1hc2subGVuZ3RoO2krKyl7XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKCFsb2NrZWRbaV0pe1xuXHRcdFx0XHRcdFx0YnVmZmVyW2ldPXNldHRpbmdzLnBsYWNlaG9sZGVyO1xuXHRcdFx0XHRcdFx0d2hpbGUocG9zKys8dGVzdC5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0XHQvL1JlZ2V4IFRlc3QgZWFjaCBjaGFyIGhlcmUuXG5cdFx0XHRcdFx0XHRcdHZhciByZUNoYXI9bmV3IFJlZ0V4cChjaGFyTWFwW21hc2suY2hhckF0KGkpXSk7XG5cdFx0XHRcdFx0XHRcdGlmKHRlc3QuY2hhckF0KHBvcy0xKS5tYXRjaChyZUNoYXIpKXtcblx0XHRcdFx0XHRcdFx0XHRidWZmZXJbaV09dGVzdC5jaGFyQXQocG9zLTEpO1x0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcz13cml0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRpZighcy5tYXRjaChyZSkpe1x0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aW5wdXQudmFsKFwiXCIpO1x0XG5cdFx0XHRcdFx0Y2xlYXJCdWZmZXIoMCxtYXNrLmxlbmd0aCk7XG5cdFx0XHRcdFx0dmFsaWQ9ZmFsc2U7XG5cdFx0XHRcdH1lbHNlXG5cdFx0XHRcdFx0dmFsaWQ9dHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uIHNlZWtOZXh0KHBvcyl7XHRcdFx0XHRcblx0XHRcdFx0d2hpbGUoKytwb3M8bWFzay5sZW5ndGgpe1x0XHRcdFx0XHRcblx0XHRcdFx0XHRpZighbG9ja2VkW3Bvc10pXG5cdFx0XHRcdFx0XHRyZXR1cm4gcG9zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXNrLmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlucHV0Lm9uZShcInVubWFza1wiLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGlucHV0LnVuYmluZChcImZvY3VzXCIsZm9jdXNFdmVudCk7XG5cdFx0XHRcdGlucHV0LnVuYmluZChcImJsdXJcIixjaGVja1ZhbCk7XG5cdFx0XHRcdGlucHV0LnVuYmluZChcImtleWRvd25cIixrZXlkb3duRXZlbnQpO1xuXHRcdFx0XHRpbnB1dC51bmJpbmQoXCJrZXlwcmVzc1wiLGtleXByZXNzRXZlbnQpO1xuXHRcdFx0XHRpZiAoJC5icm93c2VyLm1zaWUpIFxuXHRcdFx0XHRcdHRoaXMub25wYXN0ZT0gbnVsbDsgICAgICAgICAgICAgICAgICAgICBcblx0XHRcdFx0ZWxzZSBpZiAoJC5icm93c2VyLm1vemlsbGEpXG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsY2hlY2tWYWwsZmFsc2UpO1xuXHRcdFx0fSk7XG5cdFx0XHRpbnB1dC5iaW5kKFwiZm9jdXNcIixmb2N1c0V2ZW50KTtcblx0XHRcdGlucHV0LmJpbmQoXCJibHVyXCIsY2hlY2tWYWwpO1xuXHRcdFx0aW5wdXQuYmluZChcImtleWRvd25cIixrZXlkb3duRXZlbnQpO1xuXHRcdFx0aW5wdXQuYmluZChcImtleXByZXNzXCIsa2V5cHJlc3NFdmVudCk7XG5cdFx0XHQvL1Bhc3RlIGV2ZW50cyBmb3IgSUUgYW5kIE1vemlsbGEgdGhhbmtzIHRvIEtyaXN0aW5uIFNpZ211bmRzc29uXG5cdFx0XHRpZiAoJC5icm93c2VyLm1zaWUpIFxuXHRcdFx0XHR0aGlzLm9ucGFzdGU9IGZ1bmN0aW9uKCl7c2V0VGltZW91dChjaGVja1ZhbCwwKTt9OyAgICAgICAgICAgICAgICAgICAgIFxuXHRcdFx0ZWxzZSBpZiAoJC5icm93c2VyLm1vemlsbGEpXG5cdFx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLGNoZWNrVmFsLGZhbHNlKTtcblx0XHRcdFx0XG5cdFx0XHRjaGVja1ZhbCgpOy8vUGVyZm9ybSBpbml0aWFsIGNoZWNrIGZvciBleGlzdGluZyB2YWx1ZXNcblx0XHR9KTtcblx0fTtcbn0pKGpRdWVyeSk7XG4vKiBDb3B5cmlnaHQgKGMpIDIwMDYgQnJhbmRvbiBBYXJvbiAoYnJhbmRvbi5hYXJvbkBnbWFpbC5jb20gfHwgaHR0cDovL2JyYW5kb25hYXJvbi5uZXQpXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuICogYW5kIEdQTCAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9ncGwtbGljZW5zZS5waHApIGxpY2Vuc2VzLlxuICogVGhhbmtzIHRvOiBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsLyBmb3Igc29tZSBwb2ludGVycy5cbiAqIFRoYW5rcyB0bzogTWF0aGlhcyBCYW5rKGh0dHA6Ly93d3cubWF0aGlhcy1iYW5rLmRlKSBmb3IgYSBzY29wZSBidWcgZml4LlxuICpcbiAqICRMYXN0Q2hhbmdlZERhdGU6IDIwMDctMTItMjAgMDk6MDI6MDggLTA2MDAgKFRodSwgMjAgRGVjIDIwMDcpICRcbiAqICRSZXY6IDQyNjUgJFxuICpcbiAqIFZlcnNpb246IDMuMFxuICogXG4gKiBSZXF1aXJlczogJCAxLjIuMitcbiAqL1xuXG4oZnVuY3Rpb24oJCkge1xuXG4kLmV2ZW50LnNwZWNpYWwubW91c2V3aGVlbCA9IHtcblx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVyID0gJC5ldmVudC5zcGVjaWFsLm1vdXNld2hlZWwuaGFuZGxlcjtcblx0XHRcblx0XHQvLyBGaXggcGFnZVgsIHBhZ2VZLCBjbGllbnRYIGFuZCBjbGllbnRZIGZvciBtb3ppbGxhXG5cdFx0aWYgKCAkLmJyb3dzZXIubW96aWxsYSApXG5cdFx0XHQkKHRoaXMpLmJpbmQoJ21vdXNlbW92ZS5tb3VzZXdoZWVsJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0JC5kYXRhKHRoaXMsICdtd2N1cnNvcnBvc2RhdGEnLCB7XG5cdFx0XHRcdFx0cGFnZVg6IGV2ZW50LnBhZ2VYLFxuXHRcdFx0XHRcdHBhZ2VZOiBldmVudC5wYWdlWSxcblx0XHRcdFx0XHRjbGllbnRYOiBldmVudC5jbGllbnRYLFxuXHRcdFx0XHRcdGNsaWVudFk6IGV2ZW50LmNsaWVudFlcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XG5cdFx0aWYgKCB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgKVxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCAoJC5icm93c2VyLm1vemlsbGEgPyAnRE9NTW91c2VTY3JvbGwnIDogJ21vdXNld2hlZWwnKSwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMub25tb3VzZXdoZWVsID0gaGFuZGxlcjtcblx0fSxcblx0XG5cdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFuZGxlciA9ICQuZXZlbnQuc3BlY2lhbC5tb3VzZXdoZWVsLmhhbmRsZXI7XG5cdFx0XG5cdFx0JCh0aGlzKS51bmJpbmQoJ21vdXNlbW92ZS5tb3VzZXdoZWVsJyk7XG5cdFx0XG5cdFx0aWYgKCB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgKVxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCAoJC5icm93c2VyLm1vemlsbGEgPyAnRE9NTW91c2VTY3JvbGwnIDogJ21vdXNld2hlZWwnKSwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMub25tb3VzZXdoZWVsID0gZnVuY3Rpb24oKXt9O1xuXHRcdFxuXHRcdCQucmVtb3ZlRGF0YSh0aGlzLCAnbXdjdXJzb3Jwb3NkYXRhJyk7XG5cdH0sXG5cdFxuXHRoYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdFxuXHRcdGV2ZW50ID0gJC5ldmVudC5maXgoZXZlbnQgfHwgd2luZG93LmV2ZW50KTtcblx0XHQvLyBHZXQgY29ycmVjdCBwYWdlWCwgcGFnZVksIGNsaWVudFggYW5kIGNsaWVudFkgZm9yIG1vemlsbGFcblx0XHQkLmV4dGVuZCggZXZlbnQsICQuZGF0YSh0aGlzLCAnbXdjdXJzb3Jwb3NkYXRhJykgfHwge30gKTtcblx0XHR2YXIgZGVsdGEgPSAwLCByZXR1cm5WYWx1ZSA9IHRydWU7XG5cdFx0XG5cdFx0aWYgKCBldmVudC53aGVlbERlbHRhICkgZGVsdGEgPSBldmVudC53aGVlbERlbHRhLzEyMDtcblx0XHRpZiAoIGV2ZW50LmRldGFpbCAgICAgKSBkZWx0YSA9IC1ldmVudC5kZXRhaWwvMztcblx0XHRpZiAoICQuYnJvd3Nlci5vcGVyYSAgKSBkZWx0YSA9IC1ldmVudC53aGVlbERlbHRhO1xuXHRcdFxuXHRcdGV2ZW50LmRhdGEgID0gZXZlbnQuZGF0YSB8fCB7fTtcblx0XHRldmVudC50eXBlICA9IFwibW91c2V3aGVlbFwiO1xuXHRcdFxuXHRcdC8vIEFkZCBkZWx0YSB0byB0aGUgZnJvbnQgb2YgdGhlIGFyZ3VtZW50c1xuXHRcdGFyZ3MudW5zaGlmdChkZWx0YSk7XG5cdFx0Ly8gQWRkIGV2ZW50IHRvIHRoZSBmcm9udCBvZiB0aGUgYXJndW1lbnRzXG5cdFx0YXJncy51bnNoaWZ0KGV2ZW50KTtcblxuXHRcdHJldHVybiAkLmV2ZW50LmhhbmRsZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0fVxufTtcblxuJC5mbi5leHRlbmQoe1xuXHRtb3VzZXdoZWVsOiBmdW5jdGlvbihmbikge1xuXHRcdHJldHVybiBmbiA/IHRoaXMuYmluZChcIm1vdXNld2hlZWxcIiwgZm4pIDogdGhpcy50cmlnZ2VyKFwibW91c2V3aGVlbFwiKTtcblx0fSxcblx0XG5cdHVubW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcblx0XHRyZXR1cm4gdGhpcy51bmJpbmQoXCJtb3VzZXdoZWVsXCIsIGZuKTtcblx0fVxufSk7XG5cbn0pKGpRdWVyeSk7LyohXG4gICAgICAgIFNsaW1ib3ggdjIuMDIgLSBUaGUgdWx0aW1hdGUgbGlnaHR3ZWlnaHQgTGlnaHRib3ggY2xvbmUgZm9yIGpRdWVyeVxuICAgICAgICAoYykgMjAwNy0yMDA5IENocmlzdG9waGUgQmV5bHMgPGh0dHA6Ly93d3cuZGlnaXRhbGlhLmJlPlxuICAgICAgICBNSVQtc3R5bGUgbGljZW5zZS5cbiovXG5cbihmdW5jdGlvbigkKSB7XG5cbiAgICAgICAgLy8gR2xvYmFsIHZhcmlhYmxlcywgYWNjZXNzaWJsZSB0byBTbGltYm94IG9ubHlcbiAgICAgICAgdmFyIHdpbiA9ICQod2luZG93KSwgb3B0aW9ucywgaW1hZ2VzLCBhY3RpdmVJbWFnZSA9IC0xLCBhY3RpdmVVUkwsIHByZXZJbWFnZSwgbmV4dEltYWdlLCBjb21wYXRpYmxlT3ZlcmxheSwgbWlkZGxlLCBjZW50ZXJXaWR0aCwgY2VudGVySGVpZ2h0LCBpZTYgPSAhd2luZG93LlhNTEh0dHBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIG9wZXJhRml4ID0gd2luZG93Lm9wZXJhICYmIChkb2N1bWVudC5jb21wYXRNb2RlID09IFwiQ1NTMUNvbXBhdFwiKSAmJiAoJC5icm93c2VyLnZlcnNpb24gPj0gOS4zKSwgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXG4gICAgICAgIC8vIFByZWxvYWQgaW1hZ2VzXG4gICAgICAgIHByZWxvYWQgPSB7fSwgcHJlbG9hZFByZXYgPSBuZXcgSW1hZ2UoKSwgcHJlbG9hZE5leHQgPSBuZXcgSW1hZ2UoKSxcblxuICAgICAgICAvLyBET00gZWxlbWVudHNcbiAgICAgICAgb3ZlcmxheSwgY2VudGVyLCBpbWFnZSwgc2l6ZXIsIHByZXZMaW5rLCBuZXh0TGluaywgYm90dG9tQ29udGFpbmVyLCBib3R0b20sIGNhcHRpb24sIG51bWJlcjtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgICAgIEluaXRpYWxpemF0aW9uXG4gICAgICAgICovXG5cbiAgICAgICAgJChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIFNsaW1ib3ggSFRNTCBjb2RlIGF0IHRoZSBib3R0b20gb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgJChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSAkKCc8ZGl2IGlkPVwibGJPdmVybGF5XCIgLz4nKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gJCgnPGRpdiBpZD1cImxiQ2VudGVyXCIgLz4nKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gJCgnPGRpdiBpZD1cImxiQm90dG9tQ29udGFpbmVyXCIgLz4nKVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSAkKCc8ZGl2IGlkPVwibGJJbWFnZVwiIC8+JykuYXBwZW5kVG8oY2VudGVyKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplciA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7XCIgLz4nKS5hcHBlbmQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGluayA9ICQoJzxhIGlkPVwibGJQcmV2TGlua1wiIGhyZWY9XCIjXCIgLz4nKS5jbGljayhwcmV2aW91cylbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5rID0gJCgnPGEgaWQ9XCJsYk5leHRMaW5rXCIgaHJlZj1cIiNcIiAvPicpLmNsaWNrKG5leHQpWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVswXVxuICAgICAgICAgICAgICAgIClbMF07XG5cbiAgICAgICAgICAgICAgICBib3R0b20gPSAkKCc8ZGl2IGlkPVwibGJCb3R0b21cIiAvPicpLmFwcGVuZFRvKGJvdHRvbUNvbnRhaW5lcikuYXBwZW5kKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxhIGlkPVwibGJDbG9zZUxpbmtcIiBocmVmPVwiI1wiIC8+JykuYWRkKG92ZXJsYXkpLmNsaWNrKGNsb3NlKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHRpb24gPSAkKCc8ZGl2IGlkPVwibGJDYXB0aW9uXCIgLz4nKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciA9ICQoJzxkaXYgaWQ9XCJsYk51bWJlclwiIC8+JylbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8ZGl2IHN0eWxlPVwiY2xlYXI6IGJvdGg7XCIgLz4nKVswXVxuICAgICAgICAgICAgICAgIF0pWzBdO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgQVBJXG4gICAgICAgICovXG5cbiAgICAgICAgLy8gT3BlbiBTbGltYm94IHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzXG4gICAgICAgICQuc2xpbWJveCA9IGZ1bmN0aW9uKF9pbWFnZXMsIHN0YXJ0SW1hZ2UsIF9vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3A6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd3MgdG8gbmF2aWdhdGUgYmV0d2VlbiBmaXJzdCBhbmQgbGFzdCBpbWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXlPcGFjaXR5OiAwLjgsICAgICAgICAgICAgICAgICAgICAvLyAxIGlzIG9wYXF1ZSwgMCBpcyBjb21wbGV0ZWx5IHRyYW5zcGFyZW50IChjaGFuZ2UgdGhlIGNvbG9yIGluIHRoZSBDU1MgZmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXlGYWRlRHVyYXRpb246IDQwMCwgICAgICAgICAgICAgICAvLyBEdXJhdGlvbiBvZiB0aGUgb3ZlcmxheSBmYWRlLWluIGFuZCBmYWRlLW91dCBhbmltYXRpb25zIChpbiBtaWxsaXNlY29uZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVEdXJhdGlvbjogNDAwLCAgICAgICAgICAgICAgICAgICAgLy8gRHVyYXRpb24gb2YgZWFjaCBvZiB0aGUgYm94IHJlc2l6ZSBhbmltYXRpb25zIChpbiBtaWxsaXNlY29uZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVFYXNpbmc6IFwic3dpbmdcIiwgICAgICAgICAgICAgICAgICAvLyBcInN3aW5nXCIgaXMgalF1ZXJ5J3MgZGVmYXVsdCBlYXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxXaWR0aDogMjUwLCAgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsIHdpZHRoIG9mIHRoZSBib3ggKGluIHBpeGVscylcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxIZWlnaHQ6IDI1MCwgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsIGhlaWdodCBvZiB0aGUgYm94IChpbiBwaXhlbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUZhZGVEdXJhdGlvbjogNDAwLCAgICAgICAgICAgICAgICAgLy8gRHVyYXRpb24gb2YgdGhlIGltYWdlIGZhZGUtaW4gYW5pbWF0aW9uIChpbiBtaWxsaXNlY29uZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0aW9uQW5pbWF0aW9uRHVyYXRpb246IDQwMCwgICAgICAgICAgLy8gRHVyYXRpb24gb2YgdGhlIGNhcHRpb24gYW5pbWF0aW9uIChpbiBtaWxsaXNlY29uZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyVGV4dDogXCJJbWFnZSB7eH0gb2Yge3l9XCIsICAgICAgICAvLyBUcmFuc2xhdGUgb3IgY2hhbmdlIGFzIHlvdSB3aXNoLCBvciBzZXQgaXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjb3VudGVyIHRleHQgZm9yIGltYWdlIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VLZXlzOiBbMjcsIDg4LCA2N10sICAgICAgICAgICAgICAgIC8vIEFycmF5IG9mIGtleWNvZGVzIHRvIGNsb3NlIFNsaW1ib3gsIGRlZmF1bHQ6IEVzYyAoMjcpLCAneCcgKDg4KSwgJ2MnICg2NylcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzS2V5czogWzM3LCA4MF0sICAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBrZXljb2RlcyB0byBuYXZpZ2F0ZSB0byB0aGUgcHJldmlvdXMgaW1hZ2UsIGRlZmF1bHQ6IExlZnQgYXJyb3cgKDM3KSwgJ3AnICg4MClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRLZXlzOiBbMzksIDc4XSAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBrZXljb2RlcyB0byBuYXZpZ2F0ZSB0byB0aGUgbmV4dCBpbWFnZSwgZGVmYXVsdDogUmlnaHQgYXJyb3cgKDM5KSwgJ24nICg3OClcbiAgICAgICAgICAgICAgICB9LCBfb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBhIHNpbmdsZSBpbWFnZSwgd2l0aCBVUkwgYW5kIFRpdGxlIGFzIGZpcnN0IHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9pbWFnZXMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ltYWdlcyA9IFtbX2ltYWdlcywgc3RhcnRJbWFnZV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbWFnZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWlkZGxlID0gd2luLnNjcm9sbFRvcCgpICsgKChvcGVyYUZpeCA/IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiB3aW4uaGVpZ2h0KCkpIC8gMik7XG4gICAgICAgICAgICAgICAgY2VudGVyV2lkdGggPSBvcHRpb25zLmluaXRpYWxXaWR0aDtcbiAgICAgICAgICAgICAgICBjZW50ZXJIZWlnaHQgPSBvcHRpb25zLmluaXRpYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgJChjZW50ZXIpLmNzcyh7dG9wOiBNYXRoLm1heCgwLCBtaWRkbGUgLSAoY2VudGVySGVpZ2h0IC8gMikpLCB3aWR0aDogY2VudGVyV2lkdGgsIGhlaWdodDogY2VudGVySGVpZ2h0LCBtYXJnaW5MZWZ0OiAtY2VudGVyV2lkdGgvMn0pLnNob3coKTtcbiAgICAgICAgICAgICAgICBjb21wYXRpYmxlT3ZlcmxheSA9IGllNiB8fCAob3ZlcmxheS5jdXJyZW50U3R5bGUgJiYgKG92ZXJsYXkuY3VycmVudFN0eWxlLnBvc2l0aW9uICE9IFwiZml4ZWRcIikpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXRpYmxlT3ZlcmxheSkgb3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICAkKG92ZXJsYXkpLmNzcyhcIm9wYWNpdHlcIiwgb3B0aW9ucy5vdmVybGF5T3BhY2l0eSkuZmFkZUluKG9wdGlvbnMub3ZlcmxheUZhZGVEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBzZXR1cCgxKTtcblxuICAgICAgICAgICAgICAgIGltYWdlcyA9IF9pbWFnZXM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wID0gb3B0aW9ucy5sb29wICYmIChpbWFnZXMubGVuZ3RoID4gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUltYWdlKHN0YXJ0SW1hZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgb3B0aW9uczogICAgICAgIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LCBzZWUgalF1ZXJ5LnNsaW1ib3goKVxuICAgICAgICAgICAgICAgIGxpbmtNYXBwZXI6ICAgICBPcHRpb25hbCBmdW5jdGlvbiB0YWtpbmcgYSBsaW5rIERPTSBlbGVtZW50IGFuZCBhbiBpbmRleCBhcyBhcmd1bWVudHMgYW5kIHJldHVybmluZyBhbiBhcnJheSBjb250YWluaW5nIDIgZWxlbWVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbWFnZSBVUkwgYW5kIHRoZSBpbWFnZSBjYXB0aW9uIChtYXkgY29udGFpbiBIVE1MKVxuICAgICAgICAgICAgICAgIGxpbmtzRmlsdGVyOiAgICBPcHRpb25hbCBmdW5jdGlvbiB0YWtpbmcgYSBsaW5rIERPTSBlbGVtZW50IGFuZCBhbiBpbmRleCBhcyBhcmd1bWVudHMgYW5kIHJldHVybmluZyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIHBhcnQgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGltYWdlIGNvbGxlY3Rpb24gdGhhdCB3aWxsIGJlIHNob3duIG9uIGNsaWNrLCBmYWxzZSBpZiBub3QuIFwidGhpc1wiIHJlZmVycyB0byB0aGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIG11c3QgYWx3YXlzIHJldHVybiB0cnVlIHdoZW4gdGhlIERPTSBlbGVtZW50IGFyZ3VtZW50IGlzIFwidGhpc1wiLlxuICAgICAgICAqL1xuICAgICAgICAkLmZuLnNsaW1ib3ggPSBmdW5jdGlvbihfb3B0aW9ucywgbGlua01hcHBlciwgbGlua3NGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBsaW5rTWFwcGVyID0gbGlua01hcHBlciB8fCBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbC5ocmVmLCBlbC50aXRsZV07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxpbmtzRmlsdGVyID0gbGlua3NGaWx0ZXIgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmtzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5rcy51bmJpbmQoXCJjbGlja1wiKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBsaXN0IG9mIGltYWdlcyB0aGF0IHdpbGwgYmUgZGlzcGxheWVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMsIHN0YXJ0SW5kZXggPSAwLCBmaWx0ZXJlZExpbmtzLCBpID0gMCwgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRMaW5rcyA9ICQuZ3JlcChsaW5rcywgZnVuY3Rpb24oZWwsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtzRmlsdGVyLmNhbGwobGluaywgZWwsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgalF1ZXJ5Lm1hcCgpIGJlY2F1c2UgaXQgZmxhdHRlbnMgdGhlIHJldHVybmVkIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IGZpbHRlcmVkTGlua3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkTGlua3NbaV0gPT0gbGluaykgc3RhcnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkTGlua3NbaV0gPSBsaW5rTWFwcGVyKGZpbHRlcmVkTGlua3NbaV0sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5zbGltYm94KGZpbHRlcmVkTGlua3MsIHN0YXJ0SW5kZXgsIF9vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgSW50ZXJuYWwgZnVuY3Rpb25zXG4gICAgICAgICovXG5cbiAgICAgICAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSB3aW4uc2Nyb2xsTGVmdCgpLCB3ID0gb3BlcmFGaXggPyBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiB3aW4ud2lkdGgoKTtcbiAgICAgICAgICAgICAgICAkKFtjZW50ZXIsIGJvdHRvbUNvbnRhaW5lcl0pLmNzcyhcImxlZnRcIiwgbCArICh3IC8gMikpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXRpYmxlT3ZlcmxheSkgJChvdmVybGF5KS5jc3Moe2xlZnQ6IGwsIHRvcDogd2luLnNjcm9sbFRvcCgpLCB3aWR0aDogdywgaGVpZ2h0OiB3aW4uaGVpZ2h0KCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwKG9wZW4pIHtcbiAgICAgICAgICAgICAgICAkKFwib2JqZWN0XCIpLmFkZChpZTYgPyBcInNlbGVjdFwiIDogXCJlbWJlZFwiKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW4pICQuZGF0YShlbCwgXCJzbGltYm94XCIsIGVsLnN0eWxlLnZpc2liaWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUudmlzaWJpbGl0eSA9IG9wZW4gPyBcImhpZGRlblwiIDogJC5kYXRhKGVsLCBcInNsaW1ib3hcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gb3BlbiA/IFwiYmluZFwiIDogXCJ1bmJpbmRcIjtcbiAgICAgICAgICAgICAgICB3aW5bZm5dKFwic2Nyb2xsIHJlc2l6ZVwiLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgJChkb2N1bWVudClbZm5dKFwia2V5ZG93blwiLCBrZXlEb3duKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGtleURvd24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGV2ZW50LmtleUNvZGUsIGZuID0gJC5pbkFycmF5O1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBrZXlib2FyZCBhY3Rpb24gKGxpa2UgbmF2aWdhdGluZyBpbnNpZGUgdGhlIHBhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChmbihjb2RlLCBvcHRpb25zLmNsb3NlS2V5cykgPj0gMCkgPyBjbG9zZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChmbihjb2RlLCBvcHRpb25zLm5leHRLZXlzKSA+PSAwKSA/IG5leHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoZm4oY29kZSwgb3B0aW9ucy5wcmV2aW91c0tleXMpID49IDApID8gcHJldmlvdXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VJbWFnZShwcmV2SW1hZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlSW1hZ2UobmV4dEltYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZUltYWdlKGltYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVJbWFnZSA9IGltYWdlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVVUkwgPSBpbWFnZXNbYWN0aXZlSW1hZ2VdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkltYWdlID0gKGFjdGl2ZUltYWdlIHx8IChvcHRpb25zLmxvb3AgPyBpbWFnZXMubGVuZ3RoIDogMCkpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJbWFnZSA9ICgoYWN0aXZlSW1hZ2UgKyAxKSAlIGltYWdlcy5sZW5ndGgpIHx8IChvcHRpb25zLmxvb3AgPyAwIDogLTEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIuY2xhc3NOYW1lID0gXCJsYkxvYWRpbmdcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZC5vbmxvYWQgPSBhbmltYXRlQm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZC5zcmMgPSBhY3RpdmVVUkw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZUJveCgpIHtcbiAgICAgICAgICAgICAgICBjZW50ZXIuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAkKGltYWdlKS5jc3Moe2JhY2tncm91bmRJbWFnZTogXCJ1cmwoXCIgKyBhY3RpdmVVUkwgKyBcIilcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJcIn0pO1xuICAgICAgICAgICAgICAgICQoc2l6ZXIpLndpZHRoKHByZWxvYWQud2lkdGgpO1xuICAgICAgICAgICAgICAgICQoW3NpemVyLCBwcmV2TGluaywgbmV4dExpbmtdKS5oZWlnaHQocHJlbG9hZC5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgJChjYXB0aW9uKS5odG1sKGltYWdlc1thY3RpdmVJbWFnZV1bMV0gfHwgXCJcIik7XG4gICAgICAgICAgICAgICAgJChudW1iZXIpLmh0bWwoKCgoaW1hZ2VzLmxlbmd0aCA+IDEpICYmIG9wdGlvbnMuY291bnRlclRleHQpIHx8IFwiXCIpLnJlcGxhY2UoL3t4fS8sIGFjdGl2ZUltYWdlICsgMSkucmVwbGFjZSgve3l9LywgaW1hZ2VzLmxlbmd0aCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZJbWFnZSA+PSAwKSBwcmVsb2FkUHJldi5zcmMgPSBpbWFnZXNbcHJldkltYWdlXVswXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEltYWdlID49IDApIHByZWxvYWROZXh0LnNyYyA9IGltYWdlc1tuZXh0SW1hZ2VdWzBdO1xuXG4gICAgICAgICAgICAgICAgY2VudGVyV2lkdGggPSBpbWFnZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICBjZW50ZXJIZWlnaHQgPSBpbWFnZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IE1hdGgubWF4KDAsIG1pZGRsZSAtIChjZW50ZXJIZWlnaHQgLyAyKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlci5vZmZzZXRIZWlnaHQgIT0gY2VudGVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGNlbnRlcikuYW5pbWF0ZSh7aGVpZ2h0OiBjZW50ZXJIZWlnaHQsIHRvcDogdG9wfSwgb3B0aW9ucy5yZXNpemVEdXJhdGlvbiwgb3B0aW9ucy5yZXNpemVFYXNpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2VudGVyLm9mZnNldFdpZHRoICE9IGNlbnRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGNlbnRlcikuYW5pbWF0ZSh7d2lkdGg6IGNlbnRlcldpZHRoLCBtYXJnaW5MZWZ0OiAtY2VudGVyV2lkdGgvMn0sIG9wdGlvbnMucmVzaXplRHVyYXRpb24sIG9wdGlvbnMucmVzaXplRWFzaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJChjZW50ZXIpLnF1ZXVlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChib3R0b21Db250YWluZXIpLmNzcyh7d2lkdGg6IGNlbnRlcldpZHRoLCB0b3A6IHRvcCArIGNlbnRlckhlaWdodCwgbWFyZ2luTGVmdDogLWNlbnRlcldpZHRoLzIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiXCJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoaW1hZ2UpLmNzcyh7ZGlzcGxheTogXCJub25lXCIsIHZpc2liaWxpdHk6IFwiXCIsIG9wYWNpdHk6IFwiXCJ9KS5mYWRlSW4ob3B0aW9ucy5pbWFnZUZhZGVEdXJhdGlvbiwgYW5pbWF0ZUNhcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiBhbmltYXRlQ2FwdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldkltYWdlID49IDApICQocHJldkxpbmspLnNob3coKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEltYWdlID49IDApICQobmV4dExpbmspLnNob3coKTtcbiAgICAgICAgICAgICAgICAkKGJvdHRvbSkuY3NzKFwibWFyZ2luVG9wXCIsIC1ib3R0b20ub2Zmc2V0SGVpZ2h0KS5hbmltYXRlKHttYXJnaW5Ub3A6IDB9LCBvcHRpb25zLmNhcHRpb25BbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgICAgICBwcmVsb2FkLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcHJlbG9hZC5zcmMgPSBwcmVsb2FkUHJldi5zcmMgPSBwcmVsb2FkTmV4dC5zcmMgPSBhY3RpdmVVUkw7XG4gICAgICAgICAgICAgICAgJChbY2VudGVyLCBpbWFnZSwgYm90dG9tXSkuc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgICAkKFtwcmV2TGluaywgbmV4dExpbmssIGltYWdlLCBib3R0b21Db250YWluZXJdKS5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlSW1hZ2UgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlSW1hZ2UgPSBwcmV2SW1hZ2UgPSBuZXh0SW1hZ2UgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoY2VudGVyKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKG92ZXJsYXkpLnN0b3AoKS5mYWRlT3V0KG9wdGlvbnMub3ZlcmxheUZhZGVEdXJhdGlvbiwgc2V0dXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG59KShqUXVlcnkpO1xuLypcbiAqIHRpbWVhZ286IGEgalF1ZXJ5IHBsdWdpbiwgdmVyc2lvbjogMC41LjEgKDA4LzIwLzIwMDgpXG4gKiBAcmVxdWlyZXMgalF1ZXJ5IHYxLjIgb3IgbGF0ZXJcbiAqXG4gKiBUaW1lYWdvIGlzIGEgalF1ZXJ5IHBsdWdpbiB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gc3VwcG9ydCBhdXRvbWF0aWNhbGx5XG4gKiB1cGRhdGluZyBmdXp6eSB0aW1lc3RhbXBzIChlLmcuIFwiNCBtaW51dGVzIGFnb1wiIG9yIFwiYWJvdXQgMSBkYXkgYWdvXCIpLlxuICpcbiAqIEZvciB1c2FnZSBhbmQgZXhhbXBsZXMsIHZpc2l0OlxuICogaHR0cDovL3RpbWVhZ28ueWFycC5jb20vXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVDpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA4LCBSeWFuIE1jR2VhcnkgKHJ5YW5vbmphdmFzY3JpcHQgLVthdF0tIG1jZ2VhcnkgWypkb3QqXSBvcmcpXG4gKi9cbihmdW5jdGlvbigkKSB7XG4gICQudGltZWFnbyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIGlmICh0aW1lc3RhbXAgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gaW5Xb3Jkcyh0aW1lc3RhbXApO1xuICAgIGVsc2UgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGluV29yZHMoJC50aW1lYWdvLnBhcnNlKHRpbWVzdGFtcCkpO1xuICAgIGVsc2UgcmV0dXJuIGluV29yZHMoJC50aW1lYWdvLnBhcnNlKCQodGltZXN0YW1wKS5hdHRyKFwidGl0bGVcIikpKTtcbiAgfTtcbiAgdmFyICR0ID0gJC50aW1lYWdvO1xuXG4gICQuZXh0ZW5kKCQudGltZWFnbywge1xuICAgIHNldHRpbmdzOiB7XG4gICAgICByZWZyZXNoTWlsbGlzOiA2MDAwMCxcbiAgICAgIGFsbG93RnV0dXJlOiBmYWxzZSxcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgYWdvOiBcImFnb1wiLFxuICAgICAgICBmcm9tTm93OiBcImZyb20gbm93XCIsXG4gICAgICAgIHNlY29uZHM6IFwibGVzcyB0aGFuIGEgbWludXRlXCIsXG4gICAgICAgIG1pbnV0ZTogXCJhYm91dCBhIG1pbnV0ZVwiLFxuICAgICAgICBtaW51dGVzOiBcIiVkIG1pbnV0ZXNcIixcbiAgICAgICAgaG91cjogXCJhYm91dCBhbiBob3VyXCIsXG4gICAgICAgIGhvdXJzOiBcImFib3V0ICVkIGhvdXJzXCIsXG4gICAgICAgIGRheTogXCJhIGRheVwiLFxuICAgICAgICBkYXlzOiBcIiVkIGRheXNcIixcbiAgICAgICAgbW9udGg6IFwiYWJvdXQgYSBtb250aFwiLFxuICAgICAgICBtb250aHM6IFwiJWQgbW9udGhzXCIsXG4gICAgICAgIHllYXI6IFwiYWJvdXQgYSB5ZWFyXCIsXG4gICAgICAgIHllYXJzOiBcIiVkIHllYXJzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGluV29yZHM6IGZ1bmN0aW9uKGRpc3RhbmNlTWlsbGlzKSB7XG4gICAgICB2YXIgJGwgPSB0aGlzLnNldHRpbmdzLnN0cmluZ3M7XG4gICAgICB2YXIgc3VmZml4ID0gJGwuYWdvO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dGdXR1cmUpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlTWlsbGlzIDwgMCkgc3VmZml4ID0gJGwuZnJvbU5vdztcbiAgICAgICAgZGlzdGFuY2VNaWxsaXMgPSBNYXRoLmFicyhkaXN0YW5jZU1pbGxpcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWNvbmRzID0gZGlzdGFuY2VNaWxsaXMgLyAxMDAwO1xuICAgICAgdmFyIG1pbnV0ZXMgPSBzZWNvbmRzIC8gNjA7XG4gICAgICB2YXIgaG91cnMgPSBtaW51dGVzIC8gNjA7XG4gICAgICB2YXIgZGF5cyA9IGhvdXJzIC8gMjQ7XG4gICAgICB2YXIgeWVhcnMgPSBkYXlzIC8gMzY1O1xuXG4gICAgICB2YXIgd29yZHMgPSBzZWNvbmRzIDwgNDUgJiYgc3ByaW50ZigkbC5zZWNvbmRzLCBNYXRoLnJvdW5kKHNlY29uZHMpKSB8fFxuICAgICAgICBzZWNvbmRzIDwgOTAgJiYgJGwubWludXRlIHx8XG4gICAgICAgIG1pbnV0ZXMgPCA0NSAmJiBzcHJpbnRmKCRsLm1pbnV0ZXMsIE1hdGgucm91bmQobWludXRlcykpIHx8XG4gICAgICAgIG1pbnV0ZXMgPCA5MCAmJiAkbC5ob3VyIHx8XG4gICAgICAgIGhvdXJzIDwgMjQgJiYgc3ByaW50ZigkbC5ob3VycywgTWF0aC5yb3VuZChob3VycykpIHx8XG4gICAgICAgIGhvdXJzIDwgNDggJiYgJGwuZGF5IHx8XG4gICAgICAgIGRheXMgPCAzMCAmJiBzcHJpbnRmKCRsLmRheXMsIE1hdGguZmxvb3IoZGF5cykpIHx8XG4gICAgICAgIGRheXMgPCA2MCAmJiAkbC5tb250aCB8fFxuICAgICAgICBkYXlzIDwgMzY1ICYmIHNwcmludGYoJGwubW9udGhzLCBNYXRoLmZsb29yKGRheXMgLyAzMCkpIHx8XG4gICAgICAgIHllYXJzIDwgMiAmJiAkbC55ZWFyIHx8XG4gICAgICAgIHNwcmludGYoJGwueWVhcnMsIE1hdGguZmxvb3IoeWVhcnMpKTtcblxuICAgICAgcmV0dXJuIHdvcmRzICsgXCIgXCIgKyBzdWZmaXg7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oaXNvODYwMSkge1xuICAgICAgdmFyIHMgPSAkLnRyaW0oaXNvODYwMSk7XG4gICAgICBzID0gcy5yZXBsYWNlKC8tLyxcIi9cIikucmVwbGFjZSgvLS8sXCIvXCIpO1xuICAgICAgcyA9IHMucmVwbGFjZSgvVC8sXCIgXCIpLnJlcGxhY2UoL1ovLFwiIFVUQ1wiKTtcbiAgICAgIHMgPSBzLnJlcGxhY2UoLyhbXFwrLV1cXGRcXGQpXFw6PyhcXGRcXGQpLyxcIiAkMSQyXCIpOyAvLyAtMDQ6MDAgLT4gLTA0MDBcbiAgICAgIHJldHVybiBuZXcgRGF0ZShzKTtcbiAgICB9XG4gIH0pO1xuXG4gICQuZm4udGltZWFnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmVhY2gocmVmcmVzaCk7XG5cbiAgICB2YXIgJHMgPSAkdC5zZXR0aW5ncztcbiAgICBpZiAoJHMucmVmcmVzaE1pbGxpcyA+IDApIHtcbiAgICAgIHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyBzZWxmLmVhY2gocmVmcmVzaCk7IH0sICRzLnJlZnJlc2hNaWxsaXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgIHZhciBkYXRlID0gJHQucGFyc2UodGhpcy50aXRsZSk7XG4gICAgaWYgKCFpc05hTihkYXRlKSkge1xuICAgICAgJCh0aGlzKS50ZXh0KGluV29yZHMoZGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluV29yZHMoZGF0ZSkge1xuICAgIHJldHVybiAkdC5pbldvcmRzKGRpc3RhbmNlKGRhdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3RhbmNlKGRhdGUpIHtcbiAgICByZXR1cm4gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lKCkpO1xuICB9XG5cbiAgLy8gbGFtZSBzcHJpbnRmIGltcGxlbWVudGF0aW9uXG4gIGZ1bmN0aW9uIHNwcmludGYoc3RyaW5nLCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJWQvaSwgdmFsdWUpO1xuICB9XG5cbiAgLy8gZml4IGZvciBJRTYgc3Vja2FnZVxuICBpZiAoJC5icm93c2VyLm1zaWUgJiYgJC5icm93c2VyLnZlcnNpb24gPCA3LjApIHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhYmJyJyk7XG4gIH1cbn0pKGpRdWVyeSk7XG5cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
