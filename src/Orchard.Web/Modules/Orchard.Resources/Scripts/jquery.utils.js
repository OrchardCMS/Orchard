/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/*
  jQuery utils - 0.8.5
  http://code.google.com/p/jquery-utils/

  (c) Maxime Haineault <haineault@gmail.com> 
  http://haineault.com

  MIT License (http://www.opensource.org/licenses/mit-license.php

*/

(function($){
     $.extend($.expr[':'], {
        // case insensitive version of :contains
        icontains: function(a,i,m){return (a.textContent||a.innerText||jQuery(a).text()||"").toLowerCase().indexOf(m[3].toLowerCase())>=0;}
    });

    $.iterators = {
        getText:  function() { return $(this).text(); },
        parseInt: function(v){ return parseInt(v, 10); }
    };

	$.extend({ 

        // Returns a range object
        // Author: Matthias Miller
        // Site:   http://blog.outofhanwell.com/2006/03/29/javascript-range-function/
        range:  function() {
            if (!arguments.length) { return []; }
            var min, max, step;
            if (arguments.length == 1) {
                min  = 0;
                max  = arguments[0]-1;
                step = 1;
            }
            else {
                // default step to 1 if it's zero or undefined
                min  = arguments[0];
                max  = arguments[1]-1;
                step = arguments[2] || 1;
            }
            // convert negative steps to positive and reverse min/max
            if (step < 0 && min >= max) {
                step *= -1;
                var tmp = min;
                min = max;
                max = tmp;
                min += ((max-min) % step);
            }
            var a = [];
            for (var i = min; i <= max; i += step) { a.push(i); }
            return a;
        },

        // Taken from ui.core.js. 
        // Why are you keeping this gem for yourself guys ? :|
        keyCode: {
            BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, CONTROL: 17, DELETE: 46, DOWN: 40,
            END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT:  45, LEFT: 37,
            NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108, 
            NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, 
            PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38
        },
        
        // Takes a keyboard event and return true if the keycode match the specified keycode
        keyIs: function(k, e) {
            return parseInt($.keyCode[k.toUpperCase()], 10) == parseInt((typeof(e) == 'number' )? e: e.keyCode, 10);
        },
        
        // Returns the key of an array
        keys: function(arr) {
            var o = [];
            for (k in arr) { o.push(k); }
            return o;
        },

        // Redirect to a specified url
        redirect: function(url) {
            window.location.href = url;
            return url;
        },

        // Stop event shorthand
        stop: function(e, preventDefault, stopPropagation) {
            if (preventDefault)  { e.preventDefault(); }
            if (stopPropagation) { e.stopPropagation(); }
            return preventDefault && false || true;
        },

        // Returns the basename of a path
        basename: function(path) {
            var t = path.split('/');
            return t[t.length] === '' && s || t.slice(0, t.length).join('/');
        },

        // Returns the filename of a path
        filename: function(path) {
            return path.split('/').pop();
        }, 

        // Returns a formated file size
        filesizeformat: function(bytes, suffixes){
            var b = parseInt(bytes, 10);
            var s = suffixes || ['byte', 'bytes', 'KB', 'MB', 'GB'];
            if (isNaN(b) || b === 0) { return '0 ' + s[0]; }
            if (b == 1)              { return '1 ' + s[0]; }
            if (b < 1024)            { return  b.toFixed(2) + ' ' + s[1]; }
            if (b < 1048576)         { return (b / 1024).toFixed(2) + ' ' + s[2]; }
            if (b < 1073741824)      { return (b / 1048576).toFixed(2) + ' '+ s[3]; }
            else                     { return (b / 1073741824).toFixed(2) + ' '+ s[4]; }
        },

        fileExtension: function(s) {
            var tokens = s.split('.');
            return tokens[tokens.length-1] || false;
        },
        
        // Returns true if an object is a String
        isString: function(o) {
            return typeof(o) == 'string' && true || false;
        },
        
        // Returns true if an object is a RegExp
		isRegExp: function(o) {
			return o && o.constructor.toString().indexOf('RegExp()') != -1 || false;
		},

        isObject: function(o) {
            return (typeof(o) == 'object');
        },
        
        // Convert input to currency (two decimal fixed number)
		toCurrency: function(i) {
			i = parseFloat(i, 10).toFixed(2);
			return (i=='NaN') ? '0.00' : i;
		},

        /*-------------------------------------------------------------------- 
         * javascript method: "pxToEm"
         * by:
           Scott Jehl (scott@filamentgroup.com) 
           Maggie Wachs (maggie@filamentgroup.com)
           http://www.filamentgroup.com
         *
         * Copyright (c) 2008 Filament Group
         * Dual licensed under the MIT (filamentgroup.com/examples/mit-license.txt) and GPL (filamentgroup.com/examples/gpl-license.txt) licenses.
         *
         * Description: pxToEm converts a pixel value to ems depending on inherited font size.  
         * Article: http://www.filamentgroup.com/lab/retaining_scalable_interfaces_with_pixel_to_em_conversion/
         * Demo: http://www.filamentgroup.com/examples/pxToEm/	 	
         *							
         * Options:  	 								
                scope: string or jQuery selector for font-size scoping
                reverse: Boolean, true reverses the conversion to em-px
         * Dependencies: jQuery library						  
         * Usage Example: myPixelValue.pxToEm(); or myPixelValue.pxToEm({'scope':'#navigation', reverse: true});
         *
         * Version: 2.1, 18.12.2008
         * Changelog:
         *		08.02.2007 initial Version 1.0
         *		08.01.2008 - fixed font-size calculation for IE
         *		18.12.2008 - removed native object prototyping to stay in jQuery's spirit, jsLinted (Maxime Haineault <haineault@gmail.com>)
        --------------------------------------------------------------------*/

        pxToEm: function(i, settings){
            //set defaults
            settings = jQuery.extend({
                scope: 'body',
                reverse: false
            }, settings);
            
            var pxVal = (i === '') ? 0 : parseFloat(i);
            var scopeVal;
            var getWindowWidth = function(){
                var de = document.documentElement;
                return self.innerWidth || (de && de.clientWidth) || document.body.clientWidth;
            };	
            
            /* When a percentage-based font-size is set on the body, IE returns that percent of the window width as the font-size. 
                For example, if the body font-size is 62.5% and the window width is 1000px, IE will return 625px as the font-size. 	
                When this happens, we calculate the correct body font-size (%) and multiply it by 16 (the standard browser font size) 
                to get an accurate em value. */
                        
            if (settings.scope == 'body' && $.browser.msie && (parseFloat($('body').css('font-size')) / getWindowWidth()).toFixed(1) > 0.0) {
                var calcFontSize = function(){		
                    return (parseFloat($('body').css('font-size'))/getWindowWidth()).toFixed(3) * 16;
                };
                scopeVal = calcFontSize();
            }
            else { scopeVal = parseFloat(jQuery(settings.scope).css("font-size")); }
                    
            var result = (settings.reverse === true) ? (pxVal * scopeVal).toFixed(2) + 'px' : (pxVal / scopeVal).toFixed(2) + 'em';
            return result;
        }
	});

	$.extend($.fn, { 
        type: function() {
            try { return $(this).get(0).nodeName.toLowerCase(); }
            catch(e) { return false; }
        },
        // Select a text range in a textarea
        selectRange: function(start, end){
            // use only the first one since only one input can be focused
            if ($(this).get(0).createTextRange) {
                var range = $(this).get(0).createTextRange();
                range.collapse(true);
                range.moveEnd('character',   end);
                range.moveStart('character', start);
                range.select();
            }
            else if ($(this).get(0).setSelectionRange) {
                $(this).bind('focus', function(e){
                    e.preventDefault();
                }).get(0).setSelectionRange(start, end);
            }
            return $(this);
        },

        /*-------------------------------------------------------------------- 
         * JQuery Plugin: "EqualHeights"
         * by:	Scott Jehl, Todd Parker, Maggie Costello Wachs (http://www.filamentgroup.com)
         *
         * Copyright (c) 2008 Filament Group
         * Licensed under GPL (http://www.opensource.org/licenses/gpl-license.php)
         *
         * Description: Compares the heights or widths of the top-level children of a provided element 
                and sets their min-height to the tallest height (or width to widest width). Sets in em units 
                by default if pxToEm() method is available.
         * Dependencies: jQuery library, pxToEm method	(article: 
                http://www.filamentgroup.com/lab/retaining_scalable_interfaces_with_pixel_to_em_conversion/)							  
         * Usage Example: $(element).equalHeights();
                Optional: to set min-height in px, pass a true argument: $(element).equalHeights(true);
         * Version: 2.1, 18.12.2008
         *
         * Note: Changed pxToEm call to call $.pxToEm instead, jsLinted (Maxime Haineault <haineault@gmail.com>)
        --------------------------------------------------------------------*/

        equalHeights: function(px){
            $(this).each(function(){
                var currentTallest = 0;
                $(this).children().each(function(i){
                    if ($(this).height() > currentTallest) { currentTallest = $(this).height(); }
                });
                if (!px || !$.pxToEm) { currentTallest = $.pxToEm(currentTallest); } //use ems unless px is specified
                // for ie6, set height since min-height isn't supported
                if ($.browser.msie && $.browser.version == 6.0) { $(this).children().css({'height': currentTallest}); }
                $(this).children().css({'min-height': currentTallest}); 
            });
            return this;
        },

        // Copyright (c) 2009 James Padolsey
        // http://james.padolsey.com/javascript/jquery-delay-plugin/
        delay: function(time, callback){
            jQuery.fx.step.delay = function(){};
            return this.animate({delay:1}, time, callback);
        }        
	});
})(jQuery);
/*
  jQuery strings - 0.3
  http://code.google.com/p/jquery-utils/
  
  (c) Maxime Haineault <haineault@gmail.com>
  http://haineault.com   

  MIT License (http://www.opensource.org/licenses/mit-license.php)

  Implementation of Python3K advanced string formatting
  http://www.python.org/dev/peps/pep-3101/

  Documentation: http://code.google.com/p/jquery-utils/wiki/StringFormat
  
*/
(function($){
    var strings = {
        strConversion: {
            // tries to translate any objects type into string gracefully
            __repr: function(i){
                switch(this.__getType(i)) {
                    case 'array':case 'date':case 'number':
                        return i.toString();
                    case 'object': 
                        var o = [];
                        for (x=0; x<i.length; i++) { o.push(i+': '+ this.__repr(i[x])); }
                        return o.join(', ');
                    case 'string': 
                        return i;
                    default: 
                        return i;
                }
            },
            // like typeof but less vague
            __getType: function(i) {
                if (!i || !i.constructor) { return typeof(i); }
                var match = i.constructor.toString().match(/Array|Number|String|Object|Date/);
                return match && match[0].toLowerCase() || typeof(i);
            },
            //+ Jonas Raoni Soares Silva
            // the @ sign next to "//" is interpreted by IE when using cc<underscore>on! Inserted a space.
            //  @ http://jsfromhell.com/string/pad [v1.0]
            __pad: function(str, l, s, t){
                var p = s || ' ';
                var o = str;
                if (l - str.length > 0) {
                    o = new Array(Math.ceil(l / p.length)).join(p).substr(0, t = !t ? l : t == 1 ? 0 : Math.ceil(l / 2)) + str + p.substr(0, l - t);
                }
                return o;
            },
            __getInput: function(arg, args) {
                 var key = arg.getKey();
                switch(this.__getType(args)){
                    case 'object': // Thanks to Jonathan Works for the patch
                        var keys = key.split('.');
                        var obj = args;
                        for(var subkey = 0; subkey < keys.length; subkey++){
                            obj = obj[keys[subkey]];
                        }
                        if (typeof(obj) != 'undefined') {
                            if (strings.strConversion.__getType(obj) == 'array') {
                                return arg.getFormat().match(/\.\*/) && obj[1] || obj;
                            }
                            return obj;
                        }
                        else {
                            // TODO: try by numerical index                    
                        }
                    break;
                    case 'array': 
                        key = parseInt(key, 10);
                        if (arg.getFormat().match(/\.\*/) && typeof args[key+1] != 'undefined') { return args[key+1]; }
                        else if (typeof args[key] != 'undefined') { return args[key]; }
                        else { return key; }
                    break;
                }
                return '{'+key+'}';
            },
            __formatToken: function(token, args) {
                var arg   = new Argument(token, args);
                return strings.strConversion[arg.getFormat().slice(-1)](this.__getInput(arg, args), arg);
            },

            // Signed integer decimal.
            d: function(input, arg){
                var o = parseInt(input, 10); // enforce base 10
                var p = arg.getPaddingLength();
                if (p) { return this.__pad(o.toString(), p, arg.getPaddingString(), 0); }
                else   { return o; }
            },
            // Signed integer decimal.
            i: function(input, args){ 
                return this.d(input, args);
            },
            // Unsigned octal
            o: function(input, arg){ 
                var o = input.toString(8);
                if (arg.isAlternate()) { o = this.__pad(o, o.length+1, '0', 0); }
                return this.__pad(o, arg.getPaddingLength(), arg.getPaddingString(), 0);
            },
            // Unsigned decimal
            u: function(input, args) {
                return Math.abs(this.d(input, args));
            },
            // Unsigned hexadecimal (lowercase)
            x: function(input, arg){
                var o = parseInt(input, 10).toString(16);
                o = this.__pad(o, arg.getPaddingLength(), arg.getPaddingString(),0);
                return arg.isAlternate() ? '0x'+o : o;
            },
            // Unsigned hexadecimal (uppercase)
            X: function(input, arg){
                return this.x(input, arg).toUpperCase();
            },
            // Floating point exponential format (lowercase)
            e: function(input, arg){
                return parseFloat(input, 10).toExponential(arg.getPrecision());
            },
            // Floating point exponential format (uppercase)
            E: function(input, arg){
                return this.e(input, arg).toUpperCase();
            },
            // Floating point decimal format
            f: function(input, arg){
                return this.__pad(parseFloat(input, 10).toFixed(arg.getPrecision()), arg.getPaddingLength(), arg.getPaddingString(),0);
            },
            // Floating point decimal format (alias)
            F: function(input, args){
                return this.f(input, args);
            },
            // Floating point format. Uses exponential format if exponent is greater than -4 or less than precision, decimal format otherwise
            g: function(input, arg){
                var o = parseFloat(input, 10);
                return (o.toString().length > 6) ? Math.round(o.toExponential(arg.getPrecision())): o;
            },
            // Floating point format. Uses exponential format if exponent is greater than -4 or less than precision, decimal format otherwise
            G: function(input, args){
                return this.g(input, args);
            },
            // Single character (accepts integer or single character string). 	
            c: function(input, args) {
                var match = input.match(/\w|\d/);
                return match && match[0] || '';
            },
            // String (converts any JavaScript object to anotated format)
            r: function(input, args) {
                return this.__repr(input);
            },
            // String (converts any JavaScript object using object.toString())
            s: function(input, args) {
                return input.toString && input.toString() || ''+input;
            }
        },

        format: function(str, args) {
            var end    = 0;
            var start  = 0;
            var match  = false;
            var buffer = [];
            var token  = '';
            var tmp    = (str||'').split('');
            for(start=0; start < tmp.length; start++) {
                if (tmp[start] == '{' && tmp[start+1] !='{') {
                    end   = str.indexOf('}', start);
                    token = tmp.slice(start+1, end).join('');
                    if (tmp[start-1] != '{' && tmp[end+1] != '}') {
                        var tokenArgs = (typeof arguments[1] != 'object')? arguments2Array(arguments, 2): args || [];
                        buffer.push(strings.strConversion.__formatToken(token, tokenArgs));
                    }
                    else {
                        buffer.push(token);
                    }
                }
                else if (start > end || buffer.length < 1) { buffer.push(tmp[start]); }
            }
            return (buffer.length > 1)? buffer.join(''): buffer[0];
        },

        calc: function(str, args) {
            return eval(format(str, args));
        },

        repeat: function(s, n) { 
            return new Array(n+1).join(s); 
        },

        UTF8encode: function(s) { 
            return unescape(encodeURIComponent(s)); 
        },

        UTF8decode: function(s) { 
            return decodeURIComponent(escape(s)); 
        },

        tpl: function() {
            var out = '';
            var render = true;
            // Set
            // $.tpl('ui.test', ['<span>', helloWorld ,'</span>']);
            if (arguments.length == 2 && $.isArray(arguments[1])) {
                this[arguments[0]] = arguments[1].join('');
                return $(this[arguments[0]]);
            }
            // $.tpl('ui.test', '<span>hello world</span>');
            if (arguments.length == 2 && $.isString(arguments[1])) {
                this[arguments[0]] = arguments[1];
                return $(this[arguments[0]]);
            }
            // Call
            // $.tpl('ui.test');
            if (arguments.length == 1) {
                return $(this[arguments[0]]);
            }
            // $.tpl('ui.test', false);
            if (arguments.length == 2 && arguments[1] == false) {
                return this[arguments[0]];
            }
            // $.tpl('ui.test', {value:blah});
            if (arguments.length == 2 && $.isObject(arguments[1])) {
                return $($.format(this[arguments[0]], arguments[1]));
            }
            // $.tpl('ui.test', {value:blah}, false);
            if (arguments.length == 3 && $.isObject(arguments[1])) {
                return (arguments[2] == true) 
                    ? $.format(this[arguments[0]], arguments[1])
                    : $($.format(this[arguments[0]], arguments[1]));
            }
        }
    };

    var Argument = function(arg, args) {
        this.__arg  = arg;
        this.__args = args;
        this.__max_precision = parseFloat('1.'+ (new Array(32)).join('1'), 10).toString().length-3;
        this.__def_precision = 6;
        this.getString = function(){
            return this.__arg;
        };
        this.getKey = function(){
            return this.__arg.split(':')[0];
        };
        this.getFormat = function(){
            var match = this.getString().split(':');
            return (match && match[1])? match[1]: 's';
        };
        this.getPrecision = function(){
            var match = this.getFormat().match(/\.(\d+|\*)/g);
            if (!match) { return this.__def_precision; }
            else {
                match = match[0].slice(1);
                if (match != '*') { return parseInt(match, 10); }
                else if(strings.strConversion.__getType(this.__args) == 'array') {
                    return this.__args[1] && this.__args[0] || this.__def_precision;
                }
                else if(strings.strConversion.__getType(this.__args) == 'object') {
                    return this.__args[this.getKey()] && this.__args[this.getKey()][0] || this.__def_precision;
                }
                else { return this.__def_precision; }
            }
        };
        this.getPaddingLength = function(){
            var match = false;
            if (this.isAlternate()) {
                match = this.getString().match(/0?#0?(\d+)/);
                if (match && match[1]) { return parseInt(match[1], 10); }
            }
            match = this.getString().match(/(0|\.)(\d+|\*)/g);
            return match && parseInt(match[0].slice(1), 10) || 0;
        };
        this.getPaddingString = function(){
            var o = '';
            if (this.isAlternate()) { o = ' '; }
            // 0 take precedence on alternate format
            if (this.getFormat().match(/#0|0#|^0|\.\d+/)) { o = '0'; }
            return o;
        };
        this.getFlags = function(){
            var match = this.getString().matc(/^(0|\#|\-|\+|\s)+/);
            return match && match[0].split('') || [];
        };
        this.isAlternate = function() {
            return !!this.getFormat().match(/^0?#/);
        };
    };

    var arguments2Array = function(args, shift) {
        var o = [];
        for (l=args.length, x=(shift || 0)-1; x<l;x++) { o.push(args[x]); }
        return o;
    };
    $.extend(strings);
})(jQuery);
/*
  jQuery anchor handler - 0.5
  http://code.google.com/p/jquery-utils/

  (c) Maxime Haineault <haineault@gmail.com>
  http://haineault.com   

  MIT License (http://www.opensource.org/licenses/mit-license.php)

*/

(function($){
    var hash = window.location.hash;
    var handlers  = [];
    var opt = {};

	$.extend({
		anchorHandler: {
            apply: function() {
                $.map(handlers, function(handler){
                    var match = hash.match(handler.r) && hash.match(handler.r)[0] || false;
                    if (match)  { handler.cb.apply($('a[href*='+match+']').get(0), [handler.r, hash || '']); }
                });
                return $.anchorHandler;
            },
			add: function(regexp, callback, options) {
                var opt  = $.extend({handleClick: true, preserveHash: true}, options);
                if (opt.handleClick) { 
                    $('a[href*=#]').each(function(i, a){
                        if (a.href.match(regexp)) {
                            $(a).bind('click.anchorHandler', function(){
                                if (opt.preserveHash) { window.location.hash = a.hash; }
                                return callback.apply(this, [regexp, a.href]);
                                });
                        }
                    }); 
                }
				handlers.push({r: regexp, cb: callback});
                $($.anchorHandler.apply);
				return $.anchorHandler;
			}
		}
	});
})(jQuery);
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};
/*
  jQuery countdown - 0.2
  http://code.google.com/p/jquery-utils/

  (c) Maxime Haineault <haineault@gmail.com>
  http://haineault.com   

  MIT License (http://www.opensource.org/licenses/mit-license.php)
  
*/

(function($) {
    function countdown(el, options) {
        var calc = function (target, current) {
            /* Return true if the target date has arrived,
             * an object of the time left otherwise.
             */
            var current = current || new Date();
            if (current >= target) { return true; }

            var o = {};
            var remain = Math.floor((target.getTime() - current.getTime()) / 1000);

            o.days = Math.floor(remain / 86400);
            remain %= 86400;
            o.hours = Math.floor(remain / 3600);
            remain %= 3600;
            o.minutes = Math.floor(remain / 60);
            remain %= 60;
            o.seconds = remain;
            o.years = Math.floor(o.days / 365);
            o.months = Math.floor(o.days / 30);
            o.weeks = Math.floor(o.days / 7);

            return o;
        };

        var getWeek = function(date) { 
            var onejan = new Date(date.getFullYear(),0,1);
            return Math.ceil((((date - onejan) / 86400000) + onejan.getDay())/7);
        };

        var options = $.extend({
            date: new Date(),
            modifiers: [],
            interval: 1000,
            msgFormat: '%d [day|days] %hh %mm %ss',
            msgNow: 'Now !'
        }, options);

        var tokens = {
            y: new RegExp ('\\%y(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // years 
            M: new RegExp ('\\%M(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // months 
            w: new RegExp ('\\%w(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // weeks
            d: new RegExp ('\\%d(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // days
            h: new RegExp ('\\%h(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // hours
            m: new RegExp ('\\%m(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g'), // minutes
            s: new RegExp ('\\%s(.+?)\\[(\\w+)\\|(\\w+)\\]', 'g')  // seconds
        };

        var formatToken = function(str, token, val) {
            return (!tokens[token])? '': str.match(/\[|\]/g) 
                    && (str.replace(tokens[token], val+'$1'+ ((parseInt(val, 10)<2)?'$2':'$3')) || '')
                    || str.replace('%'+token, val);
        };

        var format = function(str, obj) {
            var o = str;
            o = formatToken(o, 'y', obj.years);
            o = formatToken(o, 'M', obj.months);
            o = formatToken(o, 'w', obj.weeks);
            o = formatToken(o, 'd', obj.days);
            o = formatToken(o, 'h', obj.hours);
            o = formatToken(o, 'm', obj.minutes);
            o = formatToken(o, 's', obj.seconds);
            return o;
        };

        var update = function() {
            var date_obj = calc(cd.date);
            if (date_obj === true) {
                cd.stop(); clearInterval(cd.id);
                $(cd.el).html(options.msgNow);
                return true;
            }
            else {
                $(cd.el).text(format(options.msgFormat, date_obj));
            }
        };

        var apply_modifiers = function (modifiers, date) {
            if (modifiers.length === 0) {
                return date;
            }

            var modifier_re = /^([+-]\d+)([yMdhms])$/;
            var conversions = {
                s: 1000,
                m: 60 * 1000,
                h: 60 * 60 * 1000,
                d: 24 * 60 * 60 * 1000,
                M: 30 * 24 * 60 * 60 * 1000,
                y: 365 * 24 * 60 * 60 * 1000
            };

            var displacement = 0;
            for (var i = 0, n = modifiers.length; i < n; ++i) {
                var match = modifiers[i].match(modifier_re);
                if (match !== null) {
                    displacement += parseInt(match[1], 10) * conversions[match[2]];
                }
            }
            return new Date(date.getTime() + displacement);
        };

        var cd = {
            id    : setInterval(update, options.interval),
            el    : el,
            start : function(){ return new countdown($(this.el), options); },
            stop  : function(){ return clearInterval(this.id); },
            date  : apply_modifiers(options.modifiers, options.date)
        };
        $(el).data('countdown', cd);
        update();
        return $(el).data('countdown');
    }
    $.fn.countdown = function(args) { if(this.get(0)) return new countdown(this.get(0), args); };
})(jQuery);
/*
 * jQuery Cycle Plugin for light-weight slideshows
 * Examples and documentation at: http://malsup.com/jquery/cycle/
 * Copyright (c) 2007-2008 M. Alsup
 * Version: 2.24 (07/30/2008)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * Requires: jQuery v1.2.3 or later
 *
 * Based on the work of:
 *  1) Matt Oakes (http://portfolio.gizone.co.uk/applications/slideshow/)
 *  2) Torsten Baldes (http://medienfreunde.com/lab/innerfade/)
 *  3) Benjamin Sterling (http://www.benjaminsterling.com/experiments/jqShuffle/)
 */
;(function($) {

var ver = '2.24';
var ie6 = $.browser.msie && /MSIE 6.0/.test(navigator.userAgent);

function log() {
    if (window.console && window.console.log)
        window.console.log('[cycle] ' + Array.prototype.join.call(arguments,''));
};

$.fn.cycle = function(options) {
    return this.each(function() {
        if (options === undefined || options === null)
            options = {};
        if (options.constructor == String) {
            switch(options) {
            case 'stop':
                if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
                this.cycleTimeout = 0;
                $(this).data('cycle.opts', '');
                return;
            case 'pause':
                this.cyclePause = 1;
                return;
            case 'resume':
                this.cyclePause = 0;
                return;
            default:
                options = { fx: options };
            };
        }
        else if (options.constructor == Number) {
            // go to the requested slide slide
            var num = options;
            options = $(this).data('cycle.opts');
            if (!options) {
                log('options not found, can not advance slide');
                return;
            }
            if (num < 0 || num >= options.elements.length) {
                log('invalid slide index: ' + num);
                return;
            }
            options.nextSlide = num;
            if (this.cycleTimeout) {
                clearTimeout(this.cycleTimeout);
                this.cycleTimeout = 0;
            }            
            go(options.elements, options, 1, 1);
            return;
        }

        // stop existing slideshow for this container (if there is one)
        if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
        this.cycleTimeout = 0;
        this.cyclePause = 0;
        
        var $cont = $(this);
        var $slides = options.slideExpr ? $(options.slideExpr, this) : $cont.children();
        var els = $slides.get();
        if (els.length < 2) {
            log('terminating; too few slides: ' + els.length);
            return; // don't bother
        }

        // support metadata plugin (v1.0 and v2.0)
        var opts = $.extend({}, $.fn.cycle.defaults, options || {}, $.metadata ? $cont.metadata() : $.meta ? $cont.data() : {});
        if (opts.autostop) 
            opts.countdown = opts.autostopCount || els.length;

        $cont.data('cycle.opts', opts);
        opts.container = this;

        opts.elements = els;
        opts.before = opts.before ? [opts.before] : [];
        opts.after = opts.after ? [opts.after] : [];
        opts.after.unshift(function(){ opts.busy=0; });
        if (opts.continuous)
            opts.after.push(function() { go(els,opts,0,!opts.rev); });
            
        // clearType corrections
        if (ie6 && opts.cleartype && !opts.cleartypeNoBg)
            clearTypeFix($slides);

        // allow shorthand overrides of width, height and timeout
        var cls = this.className;
        opts.width = parseInt((cls.match(/w:(\d+)/)||[])[1]) || opts.width;
        opts.height = parseInt((cls.match(/h:(\d+)/)||[])[1]) || opts.height;
        opts.timeout = parseInt((cls.match(/t:(\d+)/)||[])[1]) || opts.timeout;

        if ($cont.css('position') == 'static') 
            $cont.css('position', 'relative');
        if (opts.width) 
            $cont.width(opts.width);
        if (opts.height && opts.height != 'auto') 
            $cont.height(opts.height);

        if (opts.random) {
            opts.randomMap = [];
            for (var i = 0; i < els.length; i++) 
                opts.randomMap.push(i);
            opts.randomMap.sort(function(a,b) {return Math.random() - 0.5;});
            opts.randomIndex = 0;
            opts.startingSlide = opts.randomMap[0];
        }
        else if (opts.startingSlide >= els.length)
            opts.startingSlide = 0; // catch bogus input
        var first = opts.startingSlide || 0;
        $slides.css({position: 'absolute', top:0, left:0}).hide().each(function(i) { 
            var z = first ? i >= first ? els.length - (i-first) : first-i : els.length-i;
            $(this).css('z-index', z) 
        });
        
        $(els[first]).css('opacity',1).show(); // opacity bit needed to handle reinit case
        if ($.browser.msie) els[first].style.removeAttribute('filter');

        if (opts.fit && opts.width) 
            $slides.width(opts.width);
        if (opts.fit && opts.height && opts.height != 'auto') 
            $slides.height(opts.height);
        if (opts.pause) 
            $cont.hover(function(){this.cyclePause=1;},function(){this.cyclePause=0;});

        // run transition init fn
        var init = $.fn.cycle.transitions[opts.fx];
        if ($.isFunction(init))
            init($cont, $slides, opts);
        else if (opts.fx != 'custom')
            log('unknown transition: ' + opts.fx);
        
        $slides.each(function() {
            var $el = $(this);
            this.cycleH = (opts.fit && opts.height) ? opts.height : $el.height();
            this.cycleW = (opts.fit && opts.width) ? opts.width : $el.width();
        });

        opts.cssBefore = opts.cssBefore || {};
        opts.animIn = opts.animIn || {};
        opts.animOut = opts.animOut || {};

        $slides.not(':eq('+first+')').css(opts.cssBefore);
        if (opts.cssFirst)
            $($slides[first]).css(opts.cssFirst);

        if (opts.timeout) {
            // ensure that timeout and speed settings are sane
            if (opts.speed.constructor == String)
                opts.speed = {slow: 600, fast: 200}[opts.speed] || 400;
            if (!opts.sync)
                opts.speed = opts.speed / 2;
            while((opts.timeout - opts.speed) < 250)
                opts.timeout += opts.speed;
        }
        if (opts.easing) 
            opts.easeIn = opts.easeOut = opts.easing;
        if (!opts.speedIn) 
            opts.speedIn = opts.speed;
        if (!opts.speedOut) 
            opts.speedOut = opts.speed;

 		opts.slideCount = els.length;
        opts.currSlide = first;
        if (opts.random) {
            opts.nextSlide = opts.currSlide;
            if (++opts.randomIndex == els.length) 
                opts.randomIndex = 0;
            opts.nextSlide = opts.randomMap[opts.randomIndex];
        }
        else
            opts.nextSlide = opts.startingSlide >= (els.length-1) ? 0 : opts.startingSlide+1;

        // fire artificial events
        var e0 = $slides[first];
        if (opts.before.length)
            opts.before[0].apply(e0, [e0, e0, opts, true]);
        if (opts.after.length > 1)
            opts.after[1].apply(e0, [e0, e0, opts, true]);
        
        if (opts.click && !opts.next)
            opts.next = opts.click;
        if (opts.next)
            $(opts.next).bind('click', function(){return advance(els,opts,opts.rev?-1:1)});
        if (opts.prev)
            $(opts.prev).bind('click', function(){return advance(els,opts,opts.rev?1:-1)});
        if (opts.pager)
            buildPager(els,opts);

        // expose fn for adding slides after the show has started
        opts.addSlide = function(newSlide) {
            var $s = $(newSlide), s = $s[0];
            if (!opts.autostopCount)
                opts.countdown++;
            els.push(s);
            if (opts.els) 
                opts.els.push(s); // shuffle needs this
            opts.slideCount = els.length;
            
            $s.css('position','absolute').appendTo($cont);
            
            if (ie6 && opts.cleartype && !opts.cleartypeNoBg)
                clearTypeFix($s);

            if (opts.fit && opts.width) 
                $s.width(opts.width);
            if (opts.fit && opts.height && opts.height != 'auto') 
                $slides.height(opts.height);
            s.cycleH = (opts.fit && opts.height) ? opts.height : $s.height();
            s.cycleW = (opts.fit && opts.width) ? opts.width : $s.width();

            $s.css(opts.cssBefore);

            if (opts.pager)
                $.fn.cycle.createPagerAnchor(els.length-1, s, $(opts.pager), els, opts);
            
            if (typeof opts.onAddSlide == 'function')
                opts.onAddSlide($s);
        };

        if (opts.timeout || opts.continuous)
            this.cycleTimeout = setTimeout(
                function(){go(els,opts,0,!opts.rev)}, 
                opts.continuous ? 10 : opts.timeout + (opts.delay||0));
    });
};

function go(els, opts, manual, fwd) {
    if (opts.busy) return;
    var p = opts.container, curr = els[opts.currSlide], next = els[opts.nextSlide];
    if (p.cycleTimeout === 0 && !manual) 
        return;

    if (!manual && !p.cyclePause && 
        ((opts.autostop && (--opts.countdown <= 0)) ||
        (opts.nowrap && !opts.random && opts.nextSlide < opts.currSlide))) {
        if (opts.end)
            opts.end(opts);
        return;
    }

    if (manual || !p.cyclePause) {
        if (opts.before.length)
            $.each(opts.before, function(i,o) { o.apply(next, [curr, next, opts, fwd]); });
        var after = function() {
            if ($.browser.msie && opts.cleartype)
                this.style.removeAttribute('filter');
            $.each(opts.after, function(i,o) { o.apply(next, [curr, next, opts, fwd]); });
        };

        if (opts.nextSlide != opts.currSlide) {
            opts.busy = 1;
            if (opts.fxFn)
                opts.fxFn(curr, next, opts, after, fwd);
            else if ($.isFunction($.fn.cycle[opts.fx]))
                $.fn.cycle[opts.fx](curr, next, opts, after);
            else
                $.fn.cycle.custom(curr, next, opts, after);
        }
        if (opts.random) {
            opts.currSlide = opts.nextSlide;
            if (++opts.randomIndex == els.length) 
                opts.randomIndex = 0;
            opts.nextSlide = opts.randomMap[opts.randomIndex];
        }
        else { // sequence
            var roll = (opts.nextSlide + 1) == els.length;
            opts.nextSlide = roll ? 0 : opts.nextSlide+1;
            opts.currSlide = roll ? els.length-1 : opts.nextSlide-1;
        }
        if (opts.pager)
            $.fn.cycle.updateActivePagerLink(opts.pager, opts.currSlide);
    }
    if (opts.timeout && !opts.continuous)
        p.cycleTimeout = setTimeout(function() { go(els,opts,0,!opts.rev) }, opts.timeout);
    else if (opts.continuous && p.cyclePause) 
        p.cycleTimeout = setTimeout(function() { go(els,opts,0,!opts.rev) }, 10);
};

$.fn.cycle.updateActivePagerLink = function(pager, currSlide) {
    $(pager).find('a').removeClass('activeSlide').filter('a:eq('+currSlide+')').addClass('activeSlide');
};

// advance slide forward or back
function advance(els, opts, val) {
    var p = opts.container, timeout = p.cycleTimeout;
    if (timeout) {
        clearTimeout(timeout);
        p.cycleTimeout = 0;
    }
    if (opts.random && val < 0) {
        // move back to the previously display slide
        opts.randomIndex--;
        if (--opts.randomIndex == -2)
            opts.randomIndex = els.length-2;
        else if (opts.randomIndex == -1)
            opts.randomIndex = els.length-1;
        opts.nextSlide = opts.randomMap[opts.randomIndex];
    }
    else if (opts.random) {
        if (++opts.randomIndex == els.length) 
            opts.randomIndex = 0;
        opts.nextSlide = opts.randomMap[opts.randomIndex];
    }
    else {
        opts.nextSlide = opts.currSlide + val;
        if (opts.nextSlide < 0) {
            if (opts.nowrap) return false;
            opts.nextSlide = els.length - 1;
        }
        else if (opts.nextSlide >= els.length) {
            if (opts.nowrap) return false;
            opts.nextSlide = 0;
        }
    }
    
log('nextSlide: ' + opts.nextSlide + '; randomIndex: ' + opts.randomIndex);    
    if (opts.prevNextClick && typeof opts.prevNextClick == 'function')
        opts.prevNextClick(val > 0, opts.nextSlide, els[opts.nextSlide]);
    go(els, opts, 1, val>=0);
    return false;
};

function buildPager(els, opts) {
    var $p = $(opts.pager);
    $.each(els, function(i,o) {
        $.fn.cycle.createPagerAnchor(i,o,$p,els,opts);
    });
   $.fn.cycle.updateActivePagerLink(opts.pager, opts.startingSlide);
};

$.fn.cycle.createPagerAnchor = function(i, el, $p, els, opts) {
    var $a = (typeof opts.pagerAnchorBuilder == 'function')
        ? $(opts.pagerAnchorBuilder(i,el))
        : $('<a href="#">'+(i+1)+'</a>');
    
    // don't reparent if anchor is in the dom
    if ($a.parents('body').length == 0)
        $a.appendTo($p);
        
    $a.bind(opts.pagerEvent, function() {
        opts.nextSlide = i;
        var p = opts.container, timeout = p.cycleTimeout;
        if (timeout) {
            clearTimeout(timeout);
            p.cycleTimeout = 0;
        }            
        if (typeof opts.pagerClick == 'function')
            opts.pagerClick(opts.nextSlide, els[opts.nextSlide]);
        go(els,opts,1,opts.currSlide < i);
        return false;
    });
};


// this fixes clearType problems in ie6 by setting an explicit bg color
function clearTypeFix($slides) {
    function hex(s) {
        var s = parseInt(s).toString(16);
        return s.length < 2 ? '0'+s : s;
    };
    function getBg(e) {
        for ( ; e && e.nodeName.toLowerCase() != 'html'; e = e.parentNode) {
            var v = $.css(e,'background-color');
            if (v.indexOf('rgb') >= 0 ) { 
                var rgb = v.match(/\d+/g); 
                return '#'+ hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);
            }
            if (v && v != 'transparent')
                return v;
        }
        return '#ffffff';
    };
    $slides.each(function() { $(this).css('background-color', getBg(this)); });
};


$.fn.cycle.custom = function(curr, next, opts, cb) {
    var $l = $(curr), $n = $(next);
    $n.css(opts.cssBefore);
    var fn = function() {$n.animate(opts.animIn, opts.speedIn, opts.easeIn, cb)};
    $l.animate(opts.animOut, opts.speedOut, opts.easeOut, function() {
        if (opts.cssAfter) $l.css(opts.cssAfter);
        if (!opts.sync) fn();
    });
    if (opts.sync) fn();
};

$.fn.cycle.transitions = {
    fade: function($cont, $slides, opts) {
        $slides.not(':eq('+opts.startingSlide+')').css('opacity',0);
        opts.before.push(function() { $(this).show() });
        opts.animIn    = { opacity: 1 };
        opts.animOut   = { opacity: 0 };
        opts.cssBefore = { opacity: 0 };
        opts.cssAfter  = { display: 'none' };
    }
};

$.fn.cycle.ver = function() { return ver; };

// override these globally if you like (they are all optional)
$.fn.cycle.defaults = {
    fx:           'fade', // one of: fade, shuffle, zoom, scrollLeft, etc
    timeout:       4000,  // milliseconds between slide transitions (0 to disable auto advance)
    continuous:    0,     // true to start next transition immediately after current one completes
    speed:         1000,  // speed of the transition (any valid fx speed value)
    speedIn:       null,  // speed of the 'in' transition
    speedOut:      null,  // speed of the 'out' transition
    next:          null,  // id of element to use as click trigger for next slide
    prev:          null,  // id of element to use as click trigger for previous slide
    prevNextClick: null,  // callback fn for prev/next clicks:  function(isNext, zeroBasedSlideIndex, slideElement)
    pager:         null,  // id of element to use as pager container
    pagerClick:    null,  // callback fn for pager clicks:  function(zeroBasedSlideIndex, slideElement)
    pagerEvent:   'click', // event which drives the pager navigation
    pagerAnchorBuilder: null, // callback fn for building anchor links
    before:        null,  // transition callback (scope set to element to be shown)
    after:         null,  // transition callback (scope set to element that was shown)
    end:           null,  // callback invoked when the slideshow terminates (use with autostop or nowrap options)
    easing:        null,  // easing method for both in and out transitions
    easeIn:        null,  // easing for "in" transition
    easeOut:       null,  // easing for "out" transition
    shuffle:       null,  // coords for shuffle animation, ex: { top:15, left: 200 }
    animIn:        null,  // properties that define how the slide animates in
    animOut:       null,  // properties that define how the slide animates out
    cssBefore:     null,  // properties that define the initial state of the slide before transitioning in
    cssAfter:      null,  // properties that defined the state of the slide after transitioning out
    fxFn:          null,  // function used to control the transition
    height:       'auto', // container height
    startingSlide: 0,     // zero-based index of the first slide to be displayed
    sync:          1,     // true if in/out transitions should occur simultaneously
    random:        0,     // true for random, false for sequence (not applicable to shuffle fx)
    fit:           0,     // force slides to fit container
    pause:         0,     // true to enable "pause on hover"
    autostop:      0,     // true to end slideshow after X transitions (where X == slide count)
    autostopCount: 0,     // number of transitions (optionally used with autostop to define X)
    delay:         0,     // additional delay (in ms) for first transition (hint: can be negative)
    slideExpr:     null,  // expression for selecting slides (if something other than all children is required)
    cleartype:     0,     // true if clearType corrections should be applied (for IE)
    nowrap:        0      // true to prevent slideshow from wrapping
};

})(jQuery);


/*
 * jQuery Cycle Plugin Transition Definitions
 * This script is a plugin for the jQuery Cycle Plugin
 * Examples and documentation at: http://malsup.com/jquery/cycle/
 * Copyright (c) 2007-2008 M. Alsup
 * Version:  2.22
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 */
(function($) {

//
// These functions define one-time slide initialization for the named
// transitions. To save file size feel free to remove any of these that you 
// don't need.
//

// scrollUp/Down/Left/Right
$.fn.cycle.transitions.scrollUp = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.top = next.offsetHeight;
        opts.animOut.top = 0-curr.offsetHeight;
    });
    opts.cssFirst = { top: 0 };
    opts.animIn   = { top: 0 };
    opts.cssAfter = { display: 'none' };
};
$.fn.cycle.transitions.scrollDown = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.top = 0-next.offsetHeight;
        opts.animOut.top = curr.offsetHeight;
    });
    opts.cssFirst = { top: 0 };
    opts.animIn   = { top: 0 };
    opts.cssAfter = { display: 'none' };
};
$.fn.cycle.transitions.scrollLeft = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.left = next.offsetWidth;
        opts.animOut.left = 0-curr.offsetWidth;
    });
    opts.cssFirst = { left: 0 };
    opts.animIn   = { left: 0 };
};
$.fn.cycle.transitions.scrollRight = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.left = 0-next.offsetWidth;
        opts.animOut.left = curr.offsetWidth;
    });
    opts.cssFirst = { left: 0 };
    opts.animIn   = { left: 0 };
};
$.fn.cycle.transitions.scrollHorz = function($cont, $slides, opts) {
    $cont.css('overflow','hidden').width();
//    $slides.show();
    opts.before.push(function(curr, next, opts, fwd) {
        $(this).show();
        var currW = curr.offsetWidth, nextW = next.offsetWidth;
        opts.cssBefore = fwd ? { left: nextW } : { left: -nextW };
        opts.animIn.left = 0;
        opts.animOut.left = fwd ? -currW : currW;
        $slides.not(curr).css(opts.cssBefore);
    });
    opts.cssFirst = { left: 0 };
    opts.cssAfter = { display: 'none' }
};
$.fn.cycle.transitions.scrollVert = function($cont, $slides, opts) {
    $cont.css('overflow','hidden');
//    $slides.show();
    opts.before.push(function(curr, next, opts, fwd) {
        $(this).show();
        var currH = curr.offsetHeight, nextH = next.offsetHeight;
        opts.cssBefore = fwd ? { top: -nextH } : { top: nextH };
        opts.animIn.top = 0;
        opts.animOut.top = fwd ? currH : -currH;
        $slides.not(curr).css(opts.cssBefore);
    });
    opts.cssFirst = { top: 0 };
    opts.cssAfter = { display: 'none' }
};

// slideX/slideY
$.fn.cycle.transitions.slideX = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { zIndex: 2 };
    opts.animIn  = { width: 'show' };
    opts.animOut = { width: 'hide' };
};
$.fn.cycle.transitions.slideY = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { zIndex: 2 };
    opts.animIn  = { height: 'show' };
    opts.animOut = { height: 'hide' };
};

// shuffle
$.fn.cycle.transitions.shuffle = function($cont, $slides, opts) {
    var w = $cont.css('overflow', 'visible').width();
    $slides.css({left: 0, top: 0});
    opts.before.push(function() { $(this).show() });
    opts.speed = opts.speed / 2; // shuffle has 2 transitions        
    opts.random = 0;
    opts.shuffle = opts.shuffle || {left:-w, top:15};
    opts.els = [];
    for (var i=0; i < $slides.length; i++)
        opts.els.push($slides[i]);

    for (var i=0; i < opts.startingSlide; i++)
        opts.els.push(opts.els.shift());

    // custom transition fn (hat tip to Benjamin Sterling for this bit of sweetness!)
    opts.fxFn = function(curr, next, opts, cb, fwd) {
        var $el = fwd ? $(curr) : $(next);
        $el.animate(opts.shuffle, opts.speedIn, opts.easeIn, function() {
            fwd ? opts.els.push(opts.els.shift()) : opts.els.unshift(opts.els.pop());
            if (fwd) 
                for (var i=0, len=opts.els.length; i < len; i++)
                    $(opts.els[i]).css('z-index', len-i);
            else {
                var z = $(curr).css('z-index');
                $el.css('z-index', parseInt(z)+1);
            }
            $el.animate({left:0, top:0}, opts.speedOut, opts.easeOut, function() {
                $(fwd ? this : curr).hide();
                if (cb) cb();
            });
        });
    };
    opts.onAddSlide = function($s) { $s.hide(); };
};

// turnUp/Down/Left/Right
$.fn.cycle.transitions.turnUp = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.top = next.cycleH;
        opts.animIn.height = next.cycleH;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssFirst  = { top: 0 };
    opts.cssBefore = { height: 0 };
    opts.animIn    = { top: 0 };
    opts.animOut   = { height: 0 };
    opts.cssAfter  = { display: 'none' };
};
$.fn.cycle.transitions.turnDown = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.animIn.height = next.cycleH;
        opts.animOut.top   = curr.cycleH;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssFirst  = { top: 0 };
    opts.cssBefore = { top: 0, height: 0 };
    opts.animOut   = { height: 0 };
    opts.cssAfter  = { display: 'none' };
};
$.fn.cycle.transitions.turnLeft = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore.left = next.cycleW;
        opts.animIn.width = next.cycleW;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { width: 0 };
    opts.animIn    = { left: 0 };
    opts.animOut   = { width: 0 };
    opts.cssAfter  = { display: 'none' };
};
$.fn.cycle.transitions.turnRight = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.animIn.width = next.cycleW;
        opts.animOut.left = curr.cycleW;
    });
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { left: 0, width: 0 };
    opts.animIn    = { left: 0 };
    opts.animOut   = { width: 0 };
    opts.cssAfter  = { display: 'none' };
};

// zoom
$.fn.cycle.transitions.zoom = function($cont, $slides, opts) {
    opts.cssFirst = { top:0, left: 0 }; 
    opts.cssAfter = { display: 'none' };
    
    opts.before.push(function(curr, next, opts) {
        $(this).show();
        opts.cssBefore = { width: 0, height: 0, top: next.cycleH/2, left: next.cycleW/2 };
        opts.cssAfter  = { display: 'none' };
        opts.animIn    = { top: 0, left: 0, width: next.cycleW, height: next.cycleH };
        opts.animOut   = { width: 0, height: 0, top: curr.cycleH/2, left: curr.cycleW/2 };
        $(curr).css('zIndex',2);
        $(next).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
};

// fadeZoom
$.fn.cycle.transitions.fadeZoom = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { width: 0, height: 0, opacity: 1, left: next.cycleW/2, top: next.cycleH/2, zIndex: 1 };
        opts.animIn    = { top: 0, left: 0, width: next.cycleW, height: next.cycleH };
    });    
    opts.animOut  = { opacity: 0 };
    opts.cssAfter = { zIndex: 0 };
};

// blindX
$.fn.cycle.transitions.blindX = function($cont, $slides, opts) {
    var w = $cont.css('overflow','hidden').width();
    $slides.show();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.cssBefore = { left: w, zIndex: 2 };
    opts.cssAfter = { zIndex: 1 };
    opts.animIn = { left: 0 };
    opts.animOut  = { left: w };
};
// blindY
$.fn.cycle.transitions.blindY = function($cont, $slides, opts) {
    var h = $cont.css('overflow','hidden').height();
    $slides.show();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.cssBefore = { top: h, zIndex: 2 };
    opts.cssAfter = { zIndex: 1 };
    opts.animIn = { top: 0 };
    opts.animOut  = { top: h };
};
// blindZ
$.fn.cycle.transitions.blindZ = function($cont, $slides, opts) {
    var h = $cont.css('overflow','hidden').height();
    var w = $cont.width();
    $slides.show();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',1);
    });    
    opts.cssBefore = { top: h, left: w, zIndex: 2 };
    opts.cssAfter = { zIndex: 1 };
    opts.animIn = { top: 0, left: 0 };
    opts.animOut  = { top: h, left: w };
};

// growX - grow horizontally from centered 0 width
$.fn.cycle.transitions.growX = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { left: this.cycleW/2, width: 0, zIndex: 2 };
        opts.animIn = { left: 0, width: this.cycleW };
        opts.animOut = { left: 0 };
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide().css('zIndex',1); };
};
// growY - grow vertically from centered 0 height
$.fn.cycle.transitions.growY = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { top: this.cycleH/2, height: 0, zIndex: 2 };
        opts.animIn = { top: 0, height: this.cycleH };
        opts.animOut = { top: 0 };
        $(curr).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide().css('zIndex',1); };
};

// curtainX - squeeze in both edges horizontally
$.fn.cycle.transitions.curtainX = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { left: next.cycleW/2, width: 0, zIndex: 1, display: 'block' };
        opts.animIn = { left: 0, width: this.cycleW };
        opts.animOut = { left: curr.cycleW/2, width: 0 };
        $(curr).css('zIndex',2);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssAfter = { zIndex: 1, display: 'none' };
};
// curtainY - squeeze in both edges vertically
$.fn.cycle.transitions.curtainY = function($cont, $slides, opts) {
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = { top: next.cycleH/2, height: 0, zIndex: 1, display: 'block' };
        opts.animIn = { top: 0, height: this.cycleH };
        opts.animOut = { top: curr.cycleH/2, height: 0 };
        $(curr).css('zIndex',2);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssAfter = { zIndex: 1, display: 'none' };
};

// cover - curr slide covered by next slide
$.fn.cycle.transitions.cover = function($cont, $slides, opts) {
    var d = opts.direction || 'left';
    var w = $cont.css('overflow','hidden').width();
    var h = $cont.height();
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore = opts.cssBefore || {};
        opts.cssBefore.zIndex = 2;
        opts.cssBefore.display = 'block';
        
        if (d == 'right') 
            opts.cssBefore.left = -w;
        else if (d == 'up')    
            opts.cssBefore.top = h;
        else if (d == 'down')  
            opts.cssBefore.top = -h;
        else
            opts.cssBefore.left = w;
        $(curr).css('zIndex',1);
    });    
    if (!opts.animIn)  opts.animIn = { left: 0, top: 0 };
    if (!opts.animOut) opts.animOut = { left: 0, top: 0 };
    opts.cssAfter = opts.cssAfter || {};
    opts.cssAfter.zIndex = 2;
    opts.cssAfter.display = 'none';
};

// uncover - curr slide moves off next slide
$.fn.cycle.transitions.uncover = function($cont, $slides, opts) {
    var d = opts.direction || 'left';
    var w = $cont.css('overflow','hidden').width();
    var h = $cont.height();
    opts.before.push(function(curr, next, opts) {
        opts.cssBefore.display = 'block';
        if (d == 'right') 
            opts.animOut.left = w;
        else if (d == 'up')    
            opts.animOut.top = -h;
        else if (d == 'down')  
            opts.animOut.top = h;
        else
            opts.animOut.left = -w;
        $(curr).css('zIndex',2);
        $(next).css('zIndex',1);
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    if (!opts.animIn)  opts.animIn = { left: 0, top: 0 };
    opts.cssBefore = opts.cssBefore || {};
    opts.cssBefore.top = 0;
    opts.cssBefore.left = 0;
    
    opts.cssAfter = opts.cssAfter || {};
    opts.cssAfter.zIndex = 1;
    opts.cssAfter.display = 'none';
};

// toss - move top slide and fade away
$.fn.cycle.transitions.toss = function($cont, $slides, opts) {
    var w = $cont.css('overflow','visible').width();
    var h = $cont.height();
    opts.before.push(function(curr, next, opts) {
        $(curr).css('zIndex',2);
        opts.cssBefore.display = 'block'; 
        // provide default toss settings if animOut not provided
        if (!opts.animOut.left && !opts.animOut.top)
            opts.animOut = { left: w*2, top: -h/2, opacity: 0 };
        else
            opts.animOut.opacity = 0;
    });    
    opts.onAddSlide = function($s) { $s.hide(); };
    opts.cssBefore = { left: 0, top: 0, zIndex: 1, opacity: 1 };
    opts.animIn = { left: 0 };
    opts.cssAfter = { zIndex: 2, display: 'none' };
};

// wipe - clip animation
$.fn.cycle.transitions.wipe = function($cont, $slides, opts) {
    var w = $cont.css('overflow','hidden').width();
    var h = $cont.height();
    opts.cssBefore = opts.cssBefore || {};
    var clip;
    if (opts.clip) {
        if (/l2r/.test(opts.clip))
            clip = 'rect(0px 0px '+h+'px 0px)';
        else if (/r2l/.test(opts.clip))
            clip = 'rect(0px '+w+'px '+h+'px '+w+'px)';
        else if (/t2b/.test(opts.clip))
            clip = 'rect(0px '+w+'px 0px 0px)';
        else if (/b2t/.test(opts.clip))
            clip = 'rect('+h+'px '+w+'px '+h+'px 0px)';
        else if (/zoom/.test(opts.clip)) {
            var t = parseInt(h/2);
            var l = parseInt(w/2);
            clip = 'rect('+t+'px '+l+'px '+t+'px '+l+'px)';
        }
    }
    
    opts.cssBefore.clip = opts.cssBefore.clip || clip || 'rect(0px 0px 0px 0px)';
    
    var d = opts.cssBefore.clip.match(/(\d+)/g);
    var t = parseInt(d[0]), r = parseInt(d[1]), b = parseInt(d[2]), l = parseInt(d[3]);
    
    opts.before.push(function(curr, next, opts) {
        if (curr == next) return;
        var $curr = $(curr).css('zIndex',2);
        var $next = $(next).css({
            zIndex:  3,
            display: 'block'
        });
        
        var step = 1, count = parseInt((opts.speedIn / 13)) - 1;
        function f() {
            var tt = t ? t - parseInt(step * (t/count)) : 0;
            var ll = l ? l - parseInt(step * (l/count)) : 0;
            var bb = b < h ? b + parseInt(step * ((h-b)/count || 1)) : h;
            var rr = r < w ? r + parseInt(step * ((w-r)/count || 1)) : w;
            $next.css({ clip: 'rect('+tt+'px '+rr+'px '+bb+'px '+ll+'px)' });
            (step++ <= count) ? setTimeout(f, 13) : $curr.css('display', 'none');
        }
        f();
    });    
    opts.cssAfter  = { };
    opts.animIn    = { left: 0 };
    opts.animOut   = { left: 0 };
};

})(jQuery);
/*
 jQuery delayed observer - 0.8
 http://code.google.com/p/jquery-utils/

 (c) Maxime Haineault <haineault@gmail.com>
 http://haineault.com
 
 MIT License (http://www.opensource.org/licenses/mit-license.php)
 
*/

(function($){
    $.extend($.fn, {
        delayedObserver: function(callback, delay, options){
            return this.each(function(){
                var el = $(this);
                var op = options || {};
                el.data('oldval', el.val())
                    .data('delay', delay || 0.5)
                    .data('condition', op.condition || function() { return ($(this).data('oldval') == $(this).val()); })
                    .data('callback', callback)
                    [(op.event||'keyup')](function(){
                        if (el.data('condition').apply(el)) { return; }
                        else {
                            if (el.data('timer')) { clearTimeout(el.data('timer')); }
                            el.data('timer', setTimeout(function(){
                                el.data('callback').apply(el);
                            }, el.data('delay') * 1000));
                            el.data('oldval', el.val());
                        }
                    });
            });
        }
    });
})(jQuery);
/**
 * Flash (http://jquery.lukelutman.com/plugins/flash)
 * A jQuery plugin for embedding Flash movies.
 * 
 * Version 1.0
 * November 9th, 2006
 *
 * Copyright (c) 2006 Luke Lutman (http://www.lukelutman.com)
 * Dual licensed under the MIT and GPL licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/gpl-license.php
 * 
 * Inspired by:
 * SWFObject (http://blog.deconcept.com/swfobject/)
 * UFO (http://www.bobbyvandersluis.com/ufo/)
 * sIFR (http://www.mikeindustries.com/sifr/)
 * 
 * IMPORTANT: 
 * The packed version of jQuery breaks ActiveX control
 * activation in Internet Explorer. Use JSMin to minifiy
 * jQuery (see: http://jquery.lukelutman.com/plugins/flash#activex).
 *
 **/ 
;(function(){
	
var $$;

/**
 * 
 * @desc Replace matching elements with a flash movie.
 * @author Luke Lutman
 * @version 1.0.1
 *
 * @name flash
 * @param Hash htmlOptions Options for the embed/object tag.
 * @param Hash pluginOptions Options for detecting/updating the Flash plugin (optional).
 * @param Function replace Custom block called for each matched element if flash is installed (optional).
 * @param Function update Custom block called for each matched if flash isn't installed (optional).
 * @type jQuery
 *
 * @cat plugins/flash
 * 
 * @example $('#hello').flash({ src: 'hello.swf' });
 * @desc Embed a Flash movie.
 *
 * @example $('#hello').flash({ src: 'hello.swf' }, { version: 8 });
 * @desc Embed a Flash 8 movie.
 *
 * @example $('#hello').flash({ src: 'hello.swf' }, { expressInstall: true });
 * @desc Embed a Flash movie using Express Install if flash isn't installed.
 *
 * @example $('#hello').flash({ src: 'hello.swf' }, { update: false });
 * @desc Embed a Flash movie, don't show an update message if Flash isn't installed.
 *
**/
$$ = jQuery.fn.flash = function(htmlOptions, pluginOptions, replace, update) {
	
	// Set the default block.
	var block = replace || $$.replace;
	
	// Merge the default and passed plugin options.
	pluginOptions = $$.copy($$.pluginOptions, pluginOptions);
	
	// Detect Flash.
	if(!$$.hasFlash(pluginOptions.version)) {
		// Use Express Install (if specified and Flash plugin 6,0,65 or higher is installed).
		if(pluginOptions.expressInstall && $$.hasFlash(6,0,65)) {
			// Add the necessary flashvars (merged later).
			var expressInstallOptions = {
				flashvars: {  	
					MMredirectURL: location,
					MMplayerType: 'PlugIn',
					MMdoctitle: jQuery('title').text() 
				}					
			};
		// Ask the user to update (if specified).
		} else if (pluginOptions.update) {
			// Change the block to insert the update message instead of the flash movie.
			block = update || $$.update;
		// Fail
		} else {
			// The required version of flash isn't installed.
			// Express Install is turned off, or flash 6,0,65 isn't installed.
			// Update is turned off.
			// Return without doing anything.
			return this;
		}
	}
	
	// Merge the default, express install and passed html options.
	htmlOptions = $$.copy($$.htmlOptions, expressInstallOptions, htmlOptions);
	
	// Invoke $block (with a copy of the merged html options) for each element.
	return this.each(function(){
		block.call(this, $$.copy(htmlOptions));
	});
	
};
/**
 *
 * @name flash.copy
 * @desc Copy an arbitrary number of objects into a new object.
 * @type Object
 * 
 * @example $$.copy({ foo: 1 }, { bar: 2 });
 * @result { foo: 1, bar: 2 };
 *
**/
$$.copy = function() {
	var options = {}, flashvars = {};
	for(var i = 0; i < arguments.length; i++) {
		var arg = arguments[i];
		if(arg == undefined) continue;
		jQuery.extend(options, arg);
		// don't clobber one flash vars object with another
		// merge them instead
		if(arg.flashvars == undefined) continue;
		jQuery.extend(flashvars, arg.flashvars);
	}
	options.flashvars = flashvars;
	return options;
};
/*
 * @name flash.hasFlash
 * @desc Check if a specific version of the Flash plugin is installed
 * @type Boolean
 *
**/
$$.hasFlash = function() {
	// look for a flag in the query string to bypass flash detection
	if(/hasFlash\=true/.test(location)) return true;
	if(/hasFlash\=false/.test(location)) return false;
	var pv = $$.hasFlash.playerVersion().match(/\d+/g);
	var rv = String([arguments[0], arguments[1], arguments[2]]).match(/\d+/g) || String($$.pluginOptions.version).match(/\d+/g);
	for(var i = 0; i < 3; i++) {
		pv[i] = parseInt(pv[i] || 0);
		rv[i] = parseInt(rv[i] || 0);
		// player is less than required
		if(pv[i] < rv[i]) return false;
		// player is greater than required
		if(pv[i] > rv[i]) return true;
	}
	// major version, minor version and revision match exactly
	return true;
};
/**
 *
 * @name flash.hasFlash.playerVersion
 * @desc Get the version of the installed Flash plugin.
 * @type String
 *
**/
$$.hasFlash.playerVersion = function() {
	// ie
	try {
		try {
			// avoid fp6 minor version lookup issues
			// see: http://blog.deconcept.com/2006/01/11/getvariable-setvariable-crash-internet-explorer-flash-6/
			var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
			try { axo.AllowScriptAccess = 'always';	} 
			catch(e) { return '6,0,0'; }				
		} catch(e) {}
		return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	// other browsers
	} catch(e) {
		try {
			if(navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin){
				return (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]).description.replace(/\D+/g, ",").match(/^,?(.+),?$/)[1];
			}
		} catch(e) {}		
	}
	return '0,0,0';
};
/**
 *
 * @name flash.htmlOptions
 * @desc The default set of options for the object or embed tag.
 *
**/
$$.htmlOptions = {
	height: 240,
	flashvars: {},
	pluginspage: 'http://www.adobe.com/go/getflashplayer',
	src: '#',
	type: 'application/x-shockwave-flash',
	width: 320		
};
/**
 *
 * @name flash.pluginOptions
 * @desc The default set of options for checking/updating the flash Plugin.
 *
**/
$$.pluginOptions = {
	expressInstall: false,
	update: true,
	version: '6.0.65'
};
/**
 *
 * @name flash.replace
 * @desc The default method for replacing an element with a Flash movie.
 *
**/
$$.replace = function(htmlOptions) {
	this.innerHTML = '<div class="alt">'+this.innerHTML+'</div>';
	jQuery(this)
		.addClass('flash-replaced')
		.prepend($$.transform(htmlOptions));
};
/**
 *
 * @name flash.update
 * @desc The default method for replacing an element with an update message.
 *
**/
$$.update = function(htmlOptions) {
	var url = String(location).split('?');
	url.splice(1,0,'?hasFlash=true&');
	url = url.join('');
	var msg = '<p>This content requires the Flash Player. <a href="http://www.adobe.com/go/getflashplayer">Download Flash Player</a>. Already have Flash Player? <a href="'+url+'">Click here.</a></p>';
	this.innerHTML = '<span class="alt">'+this.innerHTML+'</span>';
	jQuery(this)
		.addClass('flash-update')
		.prepend(msg);
};
/**
 *
 * @desc Convert a hash of html options to a string of attributes, using Function.apply(). 
 * @example toAttributeString.apply(htmlOptions)
 * @result foo="bar" foo="bar"
 *
**/
function toAttributeString() {
	var s = '';
	for(var key in this)
		if(typeof this[key] != 'function')
			s += key+'="'+this[key]+'" ';
	return s;		
};
/**
 *
 * @desc Convert a hash of flashvars to a url-encoded string, using Function.apply(). 
 * @example toFlashvarsString.apply(flashvarsObject)
 * @result foo=bar&foo=bar
 *
**/
function toFlashvarsString() {
	var s = '';
	for(var key in this)
		if(typeof this[key] != 'function')
			s += key+'='+encodeURIComponent(this[key])+'&';
	return s.replace(/&$/, '');		
};
/**
 *
 * @name flash.transform
 * @desc Transform a set of html options into an embed tag.
 * @type String 
 *
 * @example $$.transform(htmlOptions)
 * @result <embed src="foo.swf" ... />
 *
 * Note: The embed tag is NOT standards-compliant, but it 
 * works in all current browsers. flash.transform can be
 * overwritten with a custom function to generate more 
 * standards-compliant markup.
 *
**/
$$.transform = function(htmlOptions) {
	htmlOptions.toString = toAttributeString;
	if(htmlOptions.flashvars) htmlOptions.flashvars.toString = toFlashvarsString;
	return '<embed ' + String(htmlOptions) + '/>';		
};

/**
 *
 * Flash Player 9 Fix (http://blog.deconcept.com/2006/07/28/swfobject-143-released/)
 *
**/
if (window.attachEvent) {
	window.attachEvent("onbeforeunload", function(){
		__flash_unloadHandler = function() {};
		__flash_savedUnloadHandler = function() {};
	});
}
	
})();
(function($){
    $._i18n = { trans: {}, 'default':  'en', language: 'en' };
    $.i18n = function() {
        var getTrans = function(ns, str) {
            var trans = false;
            // check if string exists in translation
            if ($._i18n.trans[$._i18n.language] 
                && $._i18n.trans[$._i18n.language][ns]
                && $._i18n.trans[$._i18n.language][ns][str]) {
                trans = $._i18n.trans[$._i18n.language][ns][str];
            }
            // or exists in default
            else if ($._i18n.trans[$._i18n['default']] 
                     && $._i18n.trans[$._i18n['default']][ns]
                     && $._i18n.trans[$._i18n['default']][ns][str]) {
                trans = $._i18n.trans[$._i18n['default']][ns][str];
            }
            // return trans or original string
            return trans || str;
        };
        // Set language (accepted formats: en or en-US)
        if (arguments.length < 2) {
            $._i18n.language = arguments[0]; 
            return $._i18n.language;
        }
        else {
            // get translation
            if (typeof(arguments[1]) == 'string') {
                var trans = getTrans(arguments[0], arguments[1]);
                // has variables for string formating
                if (arguments[2] && typeof(arguments[2]) == 'object') {
                    return $.format(trans, arguments[2]);
                }
                else {
                    return trans;
                }
            }
            // set translation
            else {
                var tmp  = arguments[0].split('.');
                var lang = tmp[0];
                var ns   = tmp[1] || 'jQuery';
                if (!$._i18n.trans[lang]) {
                    $._i18n.trans[lang] = {};
                    $._i18n.trans[lang][ns] = arguments[1];
                }
                else {
                    $.extend($._i18n.trans[lang][ns], arguments[1]);
                }
            }
        }
    };
})(jQuery);
/*
 * Copyright (c) 2007-2008 Josh Bush (digitalbush.com)
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE. 
 */
 
/*
 * Version: 1.1.3
 * Release: 2008-04-16
 */ 
(function($) {

	//Helper Function for Caret positioning
	$.fn.caret=function(begin,end){	
		if(this.length==0) return;
		if (typeof begin == 'number') {
            end = (typeof end == 'number')?end:begin;  
			return this.each(function(){
				if(this.setSelectionRange){
					this.focus();
					this.setSelectionRange(begin,end);
				}else if (this.createTextRange){
					var range = this.createTextRange();
					range.collapse(true);
					range.moveEnd('character', end);
					range.moveStart('character', begin);
					range.select();
				}
			});
        } else {
            if (this[0].setSelectionRange){
				begin = this[0].selectionStart;
				end = this[0].selectionEnd;
			}else if (document.selection && document.selection.createRange){
				var range = document.selection.createRange();			
				begin = 0 - range.duplicate().moveStart('character', -100000);
				end = begin + range.text.length;
			}
			return {begin:begin,end:end};
        }       
	};

	//Predefined character definitions
	var charMap={
		'9':"[0-9]",
		'a':"[A-Za-z]",
		'*':"[A-Za-z0-9]"
	};
	
	//Helper method to inject character definitions
	$.mask={
		addPlaceholder : function(c,r){
			charMap[c]=r;
		}
	};
	
	$.fn.unmask=function(){
		return this.trigger("unmask");
	};
	
	//Main Method
	$.fn.mask = function(mask,settings) {	
		settings = $.extend({
			placeholder: "_",			
			completed: null
		}, settings);		
		
		//Build Regex for format validation
		var re = new RegExp("^"+	
		$.map( mask.split(""), function(c,i){		  		  
		  return charMap[c]||((/[A-Za-z0-9]/.test(c)?"":"\\")+c);
		}).join('')+				
		"$");		

		return this.each(function(){		
			var input=$(this);
			var buffer=new Array(mask.length);
			var locked=new Array(mask.length);
			var valid=false;   
			var ignore=false;  			//Variable for ignoring control keys
			var firstNonMaskPos=null; 
			
			//Build buffer layout from mask & determine the first non masked character			
			$.each( mask.split(""), function(i,c){				
				locked[i]=(charMap[c]==null);				
				buffer[i]=locked[i]?c:settings.placeholder;									
				if(!locked[i] && firstNonMaskPos==null)
					firstNonMaskPos=i;
			});		
			
			function focusEvent(){					
				checkVal();
				writeBuffer();
				setTimeout(function(){
					$(input[0]).caret(valid?mask.length:firstNonMaskPos);					
				},0);
			};
			
			function keydownEvent(e){				
				var pos=$(this).caret();
				var k = e.keyCode;
				ignore=(k < 16 || (k > 16 && k < 32 ) || (k > 32 && k < 41));
				
				//delete selection before proceeding
				if((pos.begin-pos.end)!=0 && (!ignore || k==8 || k==46)){
					clearBuffer(pos.begin,pos.end);
				}	
				//backspace and delete get special treatment
				if(k==8){//backspace					
					while(pos.begin-->=0){
						if(!locked[pos.begin]){								
							buffer[pos.begin]=settings.placeholder;
							if($.browser.opera){
								//Opera won't let you cancel the backspace, so we'll let it backspace over a dummy character.								
								s=writeBuffer();
								input.val(s.substring(0,pos.begin)+" "+s.substring(pos.begin));
								$(this).caret(pos.begin+1);								
							}else{
								writeBuffer();
								$(this).caret(Math.max(firstNonMaskPos,pos.begin));								
							}									
							return false;								
						}
					}						
				}else if(k==46){//delete
					clearBuffer(pos.begin,pos.begin+1);
					writeBuffer();
					$(this).caret(Math.max(firstNonMaskPos,pos.begin));					
					return false;
				}else if (k==27){//escape
					clearBuffer(0,mask.length);
					writeBuffer();
					$(this).caret(firstNonMaskPos);					
					return false;
				}									
			};
			
			function keypressEvent(e){					
				if(ignore){
					ignore=false;
					//Fixes Mac FF bug on backspace
					return (e.keyCode == 8)? false: null;
				}
				e=e||window.event;
				var k=e.charCode||e.keyCode||e.which;						
				var pos=$(this).caret();
								
				if(e.ctrlKey || e.altKey){//Ignore
					return true;
				}else if ((k>=41 && k<=122) ||k==32 || k>186){//typeable characters
					var p=seekNext(pos.begin-1);					
					if(p<mask.length){
						if(new RegExp(charMap[mask.charAt(p)]).test(String.fromCharCode(k))){
							buffer[p]=String.fromCharCode(k);									
							writeBuffer();
							var next=seekNext(p);
							$(this).caret(next);
							if(settings.completed && next == mask.length)
								settings.completed.call(input);
						}				
					}
				}				
				return false;				
			};
			
			function clearBuffer(start,end){
				for(var i=start;i<end&&i<mask.length;i++){
					if(!locked[i])
						buffer[i]=settings.placeholder;
				}				
			};
			
			function writeBuffer(){				
				return input.val(buffer.join('')).val();				
			};
			
			function checkVal(){	
				//try to place charcters where they belong
				var test=input.val();
				var pos=0;
				for(var i=0;i<mask.length;i++){					
					if(!locked[i]){
						buffer[i]=settings.placeholder;
						while(pos++<test.length){
							//Regex Test each char here.
							var reChar=new RegExp(charMap[mask.charAt(i)]);
							if(test.charAt(pos-1).match(reChar)){
								buffer[i]=test.charAt(pos-1);								
								break;
							}									
						}
					}
				}
				var s=writeBuffer();
				if(!s.match(re)){							
					input.val("");	
					clearBuffer(0,mask.length);
					valid=false;
				}else
					valid=true;
			};
			
			function seekNext(pos){				
				while(++pos<mask.length){					
					if(!locked[pos])
						return pos;
				}
				return mask.length;
			};
			
			input.one("unmask",function(){
				input.unbind("focus",focusEvent);
				input.unbind("blur",checkVal);
				input.unbind("keydown",keydownEvent);
				input.unbind("keypress",keypressEvent);
				if ($.browser.msie) 
					this.onpaste= null;                     
				else if ($.browser.mozilla)
					this.removeEventListener('input',checkVal,false);
			});
			input.bind("focus",focusEvent);
			input.bind("blur",checkVal);
			input.bind("keydown",keydownEvent);
			input.bind("keypress",keypressEvent);
			//Paste events for IE and Mozilla thanks to Kristinn Sigmundsson
			if ($.browser.msie) 
				this.onpaste= function(){setTimeout(checkVal,0);};                     
			else if ($.browser.mozilla)
				this.addEventListener('input',checkVal,false);
				
			checkVal();//Perform initial check for existing values
		});
	};
})(jQuery);
/* Copyright (c) 2006 Brandon Aaron (brandon.aaron@gmail.com || http://brandonaaron.net)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 *
 * $LastChangedDate: 2007-12-20 09:02:08 -0600 (Thu, 20 Dec 2007) $
 * $Rev: 4265 $
 *
 * Version: 3.0
 * 
 * Requires: $ 1.2.2+
 */

(function($) {

$.event.special.mousewheel = {
	setup: function() {
		var handler = $.event.special.mousewheel.handler;
		
		// Fix pageX, pageY, clientX and clientY for mozilla
		if ( $.browser.mozilla )
			$(this).bind('mousemove.mousewheel', function(event) {
				$.data(this, 'mwcursorposdata', {
					pageX: event.pageX,
					pageY: event.pageY,
					clientX: event.clientX,
					clientY: event.clientY
				});
			});
	
		if ( this.addEventListener )
			this.addEventListener( ($.browser.mozilla ? 'DOMMouseScroll' : 'mousewheel'), handler, false);
		else
			this.onmousewheel = handler;
	},
	
	teardown: function() {
		var handler = $.event.special.mousewheel.handler;
		
		$(this).unbind('mousemove.mousewheel');
		
		if ( this.removeEventListener )
			this.removeEventListener( ($.browser.mozilla ? 'DOMMouseScroll' : 'mousewheel'), handler, false);
		else
			this.onmousewheel = function(){};
		
		$.removeData(this, 'mwcursorposdata');
	},
	
	handler: function(event) {
		var args = Array.prototype.slice.call( arguments, 1 );
		
		event = $.event.fix(event || window.event);
		// Get correct pageX, pageY, clientX and clientY for mozilla
		$.extend( event, $.data(this, 'mwcursorposdata') || {} );
		var delta = 0, returnValue = true;
		
		if ( event.wheelDelta ) delta = event.wheelDelta/120;
		if ( event.detail     ) delta = -event.detail/3;
		if ( $.browser.opera  ) delta = -event.wheelDelta;
		
		event.data  = event.data || {};
		event.type  = "mousewheel";
		
		// Add delta to the front of the arguments
		args.unshift(delta);
		// Add event to the front of the arguments
		args.unshift(event);

		return $.event.handle.apply(this, args);
	}
};

$.fn.extend({
	mousewheel: function(fn) {
		return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
	},
	
	unmousewheel: function(fn) {
		return this.unbind("mousewheel", fn);
	}
});

})(jQuery);/*!
        Slimbox v2.02 - The ultimate lightweight Lightbox clone for jQuery
        (c) 2007-2009 Christophe Beyls <http://www.digitalia.be>
        MIT-style license.
*/

(function($) {

        // Global variables, accessible to Slimbox only
        var win = $(window), options, images, activeImage = -1, activeURL, prevImage, nextImage, compatibleOverlay, middle, centerWidth, centerHeight, ie6 = !window.XMLHttpRequest,
                operaFix = window.opera && (document.compatMode == "CSS1Compat") && ($.browser.version >= 9.3), documentElement = document.documentElement,

        // Preload images
        preload = {}, preloadPrev = new Image(), preloadNext = new Image(),

        // DOM elements
        overlay, center, image, sizer, prevLink, nextLink, bottomContainer, bottom, caption, number;

        /*
                Initialization
        */

        $(function() {
                // Append the Slimbox HTML code at the bottom of the document
                $("body").append(
                        $([
                                overlay = $('<div id="lbOverlay" />')[0],
                                center = $('<div id="lbCenter" />')[0],
                                bottomContainer = $('<div id="lbBottomContainer" />')[0]
                        ]).css("display", "none")
                );

                image = $('<div id="lbImage" />').appendTo(center).append(
                        sizer = $('<div style="position: relative;" />').append([
                                prevLink = $('<a id="lbPrevLink" href="#" />').click(previous)[0],
                                nextLink = $('<a id="lbNextLink" href="#" />').click(next)[0]
                        ])[0]
                )[0];

                bottom = $('<div id="lbBottom" />').appendTo(bottomContainer).append([
                        $('<a id="lbCloseLink" href="#" />').add(overlay).click(close)[0],
                        caption = $('<div id="lbCaption" />')[0],
                        number = $('<div id="lbNumber" />')[0],
                        $('<div style="clear: both;" />')[0]
                ])[0];
        });


        /*
                API
        */

        // Open Slimbox with the specified parameters
        $.slimbox = function(_images, startImage, _options) {
                options = $.extend({
                        loop: false,                            // Allows to navigate between first and last images
                        overlayOpacity: 0.8,                    // 1 is opaque, 0 is completely transparent (change the color in the CSS file)
                        overlayFadeDuration: 400,               // Duration of the overlay fade-in and fade-out animations (in milliseconds)
                        resizeDuration: 400,                    // Duration of each of the box resize animations (in milliseconds)
                        resizeEasing: "swing",                  // "swing" is jQuery's default easing
                        initialWidth: 250,                      // Initial width of the box (in pixels)
                        initialHeight: 250,                     // Initial height of the box (in pixels)
                        imageFadeDuration: 400,                 // Duration of the image fade-in animation (in milliseconds)
                        captionAnimationDuration: 400,          // Duration of the caption animation (in milliseconds)
                        counterText: "Image {x} of {y}",        // Translate or change as you wish, or set it to false to disable counter text for image groups
                        closeKeys: [27, 88, 67],                // Array of keycodes to close Slimbox, default: Esc (27), 'x' (88), 'c' (67)
                        previousKeys: [37, 80],                 // Array of keycodes to navigate to the previous image, default: Left arrow (37), 'p' (80)
                        nextKeys: [39, 78]                      // Array of keycodes to navigate to the next image, default: Right arrow (39), 'n' (78)
                }, _options);

                // The function is called for a single image, with URL and Title as first two arguments
                if (typeof _images == "string") {
                        _images = [[_images, startImage]];
                        startImage = 0;
                }

                middle = win.scrollTop() + ((operaFix ? documentElement.clientHeight : win.height()) / 2);
                centerWidth = options.initialWidth;
                centerHeight = options.initialHeight;
                $(center).css({top: Math.max(0, middle - (centerHeight / 2)), width: centerWidth, height: centerHeight, marginLeft: -centerWidth/2}).show();
                compatibleOverlay = ie6 || (overlay.currentStyle && (overlay.currentStyle.position != "fixed"));
                if (compatibleOverlay) overlay.style.position = "absolute";
                $(overlay).css("opacity", options.overlayOpacity).fadeIn(options.overlayFadeDuration);
                position();
                setup(1);

                images = _images;
                options.loop = options.loop && (images.length > 1);
                return changeImage(startImage);
        };

        /*
                options:        Optional options object, see jQuery.slimbox()
                linkMapper:     Optional function taking a link DOM element and an index as arguments and returning an array containing 2 elements:
                                the image URL and the image caption (may contain HTML)
                linksFilter:    Optional function taking a link DOM element and an index as arguments and returning true if the element is part of
                                the image collection that will be shown on click, false if not. "this" refers to the element that was clicked.
                                This function must always return true when the DOM element argument is "this".
        */
        $.fn.slimbox = function(_options, linkMapper, linksFilter) {
                linkMapper = linkMapper || function(el) {
                        return [el.href, el.title];
                };

                linksFilter = linksFilter || function() {
                        return true;
                };

                var links = this;

                return links.unbind("click").click(function() {
                        // Build the list of images that will be displayed
                        var link = this, startIndex = 0, filteredLinks, i = 0, length;
                        filteredLinks = $.grep(links, function(el, i) {
                                return linksFilter.call(link, el, i);
                        });

                        // We cannot use jQuery.map() because it flattens the returned array
                        for (length = filteredLinks.length; i < length; ++i) {
                                if (filteredLinks[i] == link) startIndex = i;
                                filteredLinks[i] = linkMapper(filteredLinks[i], i);
                        }

                        return $.slimbox(filteredLinks, startIndex, _options);
                });
        };


        /*
                Internal functions
        */

        function position() {
                var l = win.scrollLeft(), w = operaFix ? documentElement.clientWidth : win.width();
                $([center, bottomContainer]).css("left", l + (w / 2));
                if (compatibleOverlay) $(overlay).css({left: l, top: win.scrollTop(), width: w, height: win.height()});
        }

        function setup(open) {
                $("object").add(ie6 ? "select" : "embed").each(function(index, el) {
                        if (open) $.data(el, "slimbox", el.style.visibility);
                        el.style.visibility = open ? "hidden" : $.data(el, "slimbox");
                });
                var fn = open ? "bind" : "unbind";
                win[fn]("scroll resize", position);
                $(document)[fn]("keydown", keyDown);
        }

        function keyDown(event) {
                var code = event.keyCode, fn = $.inArray;
                // Prevent default keyboard action (like navigating inside the page)
                return (fn(code, options.closeKeys) >= 0) ? close()
                        : (fn(code, options.nextKeys) >= 0) ? next()
                        : (fn(code, options.previousKeys) >= 0) ? previous()
                        : false;
        }

        function previous() {
                return changeImage(prevImage);
        }

        function next() {
                return changeImage(nextImage);
        }

        function changeImage(imageIndex) {
                if (imageIndex >= 0) {
                        activeImage = imageIndex;
                        activeURL = images[activeImage][0];
                        prevImage = (activeImage || (options.loop ? images.length : 0)) - 1;
                        nextImage = ((activeImage + 1) % images.length) || (options.loop ? 0 : -1);

                        stop();
                        center.className = "lbLoading";

                        preload = new Image();
                        preload.onload = animateBox;
                        preload.src = activeURL;
                }

                return false;
        }

        function animateBox() {
                center.className = "";
                $(image).css({backgroundImage: "url(" + activeURL + ")", visibility: "hidden", display: ""});
                $(sizer).width(preload.width);
                $([sizer, prevLink, nextLink]).height(preload.height);

                $(caption).html(images[activeImage][1] || "");
                $(number).html((((images.length > 1) && options.counterText) || "").replace(/{x}/, activeImage + 1).replace(/{y}/, images.length));

                if (prevImage >= 0) preloadPrev.src = images[prevImage][0];
                if (nextImage >= 0) preloadNext.src = images[nextImage][0];

                centerWidth = image.offsetWidth;
                centerHeight = image.offsetHeight;
                var top = Math.max(0, middle - (centerHeight / 2));
                if (center.offsetHeight != centerHeight) {
                        $(center).animate({height: centerHeight, top: top}, options.resizeDuration, options.resizeEasing);
                }
                if (center.offsetWidth != centerWidth) {
                        $(center).animate({width: centerWidth, marginLeft: -centerWidth/2}, options.resizeDuration, options.resizeEasing);
                }
                $(center).queue(function() {
                        $(bottomContainer).css({width: centerWidth, top: top + centerHeight, marginLeft: -centerWidth/2, visibility: "hidden", display: ""});
                        $(image).css({display: "none", visibility: "", opacity: ""}).fadeIn(options.imageFadeDuration, animateCaption);
                });
        }


        function animateCaption() {
                if (prevImage >= 0) $(prevLink).show();
                if (nextImage >= 0) $(nextLink).show();
                $(bottom).css("marginTop", -bottom.offsetHeight).animate({marginTop: 0}, options.captionAnimationDuration);
                bottomContainer.style.visibility = "";
        }

        function stop() {
                preload.onload = null;
                preload.src = preloadPrev.src = preloadNext.src = activeURL;
                $([center, image, bottom]).stop(true);
                $([prevLink, nextLink, image, bottomContainer]).hide();
        }

        function close() {
                if (activeImage >= 0) {
                        stop();
                        activeImage = prevImage = nextImage = -1;
                        $(center).hide();
                        $(overlay).stop().fadeOut(options.overlayFadeDuration, setup);
                }

                return false;
        }

})(jQuery);
/*
 * timeago: a jQuery plugin, version: 0.5.1 (08/20/2008)
 * @requires jQuery v1.2 or later
 *
 * Timeago is a jQuery plugin that makes it easy to support automatically
 * updating fuzzy timestamps (e.g. "4 minutes ago" or "about 1 day ago").
 *
 * For usage and examples, visit:
 * http://timeago.yarp.com/
 *
 * Licensed under the MIT:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright (c) 2008, Ryan McGeary (ryanonjavascript -[at]- mcgeary [*dot*] org)
 */
(function($) {
  $.timeago = function(timestamp) {
    if (timestamp instanceof Date) return inWords(timestamp);
    else if (typeof timestamp == "string") return inWords($.timeago.parse(timestamp));
    else return inWords($.timeago.parse($(timestamp).attr("title")));
  };
  var $t = $.timeago;

  $.extend($.timeago, {
    settings: {
      refreshMillis: 60000,
      allowFuture: false,
      strings: {
        ago: "ago",
        fromNow: "from now",
        seconds: "less than a minute",
        minute: "about a minute",
        minutes: "%d minutes",
        hour: "about an hour",
        hours: "about %d hours",
        day: "a day",
        days: "%d days",
        month: "about a month",
        months: "%d months",
        year: "about a year",
        years: "%d years"
      }
    },
    inWords: function(distanceMillis) {
      var $l = this.settings.strings;
      var suffix = $l.ago;
      if (this.settings.allowFuture) {
        if (distanceMillis < 0) suffix = $l.fromNow;
        distanceMillis = Math.abs(distanceMillis);
      }

      var seconds = distanceMillis / 1000;
      var minutes = seconds / 60;
      var hours = minutes / 60;
      var days = hours / 24;
      var years = days / 365;

      var words = seconds < 45 && sprintf($l.seconds, Math.round(seconds)) ||
        seconds < 90 && $l.minute ||
        minutes < 45 && sprintf($l.minutes, Math.round(minutes)) ||
        minutes < 90 && $l.hour ||
        hours < 24 && sprintf($l.hours, Math.round(hours)) ||
        hours < 48 && $l.day ||
        days < 30 && sprintf($l.days, Math.floor(days)) ||
        days < 60 && $l.month ||
        days < 365 && sprintf($l.months, Math.floor(days / 30)) ||
        years < 2 && $l.year ||
        sprintf($l.years, Math.floor(years));

      return words + " " + suffix;
    },
    parse: function(iso8601) {
      var s = $.trim(iso8601);
      s = s.replace(/-/,"/").replace(/-/,"/");
      s = s.replace(/T/," ").replace(/Z/," UTC");
      s = s.replace(/([\+-]\d\d)\:?(\d\d)/," $1$2"); // -04:00 -> -0400
      return new Date(s);
    }
  });

  $.fn.timeago = function() {
    var self = this;
    self.each(refresh);

    var $s = $t.settings;
    if ($s.refreshMillis > 0) {
      setInterval(function() { self.each(refresh); }, $s.refreshMillis);
    }
    return self;
  };

  function refresh() {
    var date = $t.parse(this.title);
    if (!isNaN(date)) {
      $(this).text(inWords(date));
    }
    return this;
  }

  function inWords(date) {
    return $t.inWords(distance(date));
  }

  function distance(date) {
    return (new Date().getTime() - date.getTime());
  }

  // lame sprintf implementation
  function sprintf(string, value) {
    return string.replace(/%d/i, value);
  }

  // fix for IE6 suckage
  if ($.browser.msie && $.browser.version < 7.0) {
    document.createElement('abbr');
  }
})(jQuery);


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS51dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJqcXVlcnkudXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gIGpRdWVyeSB1dGlscyAtIDAuOC41XHJcbiAgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS11dGlscy9cclxuXHJcbiAgKGMpIE1heGltZSBIYWluZWF1bHQgPGhhaW5lYXVsdEBnbWFpbC5jb20+IFxyXG4gIGh0dHA6Ly9oYWluZWF1bHQuY29tXHJcblxyXG4gIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cclxuKi9cclxuXHJcbihmdW5jdGlvbigkKXtcclxuICAgICAkLmV4dGVuZCgkLmV4cHJbJzonXSwge1xyXG4gICAgICAgIC8vIGNhc2UgaW5zZW5zaXRpdmUgdmVyc2lvbiBvZiA6Y29udGFpbnNcclxuICAgICAgICBpY29udGFpbnM6IGZ1bmN0aW9uKGEsaSxtKXtyZXR1cm4gKGEudGV4dENvbnRlbnR8fGEuaW5uZXJUZXh0fHxqUXVlcnkoYSkudGV4dCgpfHxcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YobVszXS50b0xvd2VyQ2FzZSgpKT49MDt9XHJcbiAgICB9KTtcclxuXHJcbiAgICAkLml0ZXJhdG9ycyA9IHtcclxuICAgICAgICBnZXRUZXh0OiAgZnVuY3Rpb24oKSB7IHJldHVybiAkKHRoaXMpLnRleHQoKTsgfSxcclxuICAgICAgICBwYXJzZUludDogZnVuY3Rpb24odil7IHJldHVybiBwYXJzZUludCh2LCAxMCk7IH1cclxuICAgIH07XHJcblxyXG5cdCQuZXh0ZW5kKHsgXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgYSByYW5nZSBvYmplY3RcclxuICAgICAgICAvLyBBdXRob3I6IE1hdHRoaWFzIE1pbGxlclxyXG4gICAgICAgIC8vIFNpdGU6ICAgaHR0cDovL2Jsb2cub3V0b2ZoYW53ZWxsLmNvbS8yMDA2LzAzLzI5L2phdmFzY3JpcHQtcmFuZ2UtZnVuY3Rpb24vXHJcbiAgICAgICAgcmFuZ2U6ICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IHJldHVybiBbXTsgfVxyXG4gICAgICAgICAgICB2YXIgbWluLCBtYXgsIHN0ZXA7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIG1pbiAgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWF4ICA9IGFyZ3VtZW50c1swXS0xO1xyXG4gICAgICAgICAgICAgICAgc3RlcCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHN0ZXAgdG8gMSBpZiBpdCdzIHplcm8gb3IgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBtaW4gID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgbWF4ICA9IGFyZ3VtZW50c1sxXS0xO1xyXG4gICAgICAgICAgICAgICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgbmVnYXRpdmUgc3RlcHMgdG8gcG9zaXRpdmUgYW5kIHJldmVyc2UgbWluL21heFxyXG4gICAgICAgICAgICBpZiAoc3RlcCA8IDAgJiYgbWluID49IG1heCkge1xyXG4gICAgICAgICAgICAgICAgc3RlcCAqPSAtMTtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBtaW47XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBtYXg7XHJcbiAgICAgICAgICAgICAgICBtYXggPSB0bXA7XHJcbiAgICAgICAgICAgICAgICBtaW4gKz0gKChtYXgtbWluKSAlIHN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBtaW47IGkgPD0gbWF4OyBpICs9IHN0ZXApIHsgYS5wdXNoKGkpOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFRha2VuIGZyb20gdWkuY29yZS5qcy4gXHJcbiAgICAgICAgLy8gV2h5IGFyZSB5b3Uga2VlcGluZyB0aGlzIGdlbSBmb3IgeW91cnNlbGYgZ3V5cyA/IDp8XHJcbiAgICAgICAga2V5Q29kZToge1xyXG4gICAgICAgICAgICBCQUNLU1BBQ0U6IDgsIENBUFNfTE9DSzogMjAsIENPTU1BOiAxODgsIENPTlRST0w6IDE3LCBERUxFVEU6IDQ2LCBET1dOOiA0MCxcclxuICAgICAgICAgICAgRU5EOiAzNSwgRU5URVI6IDEzLCBFU0NBUEU6IDI3LCBIT01FOiAzNiwgSU5TRVJUOiAgNDUsIExFRlQ6IDM3LFxyXG4gICAgICAgICAgICBOVU1QQURfQUREOiAxMDcsIE5VTVBBRF9ERUNJTUFMOiAxMTAsIE5VTVBBRF9ESVZJREU6IDExMSwgTlVNUEFEX0VOVEVSOiAxMDgsIFxyXG4gICAgICAgICAgICBOVU1QQURfTVVMVElQTFk6IDEwNiwgTlVNUEFEX1NVQlRSQUNUOiAxMDksIFBBR0VfRE9XTjogMzQsIFBBR0VfVVA6IDMzLCBcclxuICAgICAgICAgICAgUEVSSU9EOiAxOTAsIFJJR0hUOiAzOSwgU0hJRlQ6IDE2LCBTUEFDRTogMzIsIFRBQjogOSwgVVA6IDM4XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBUYWtlcyBhIGtleWJvYXJkIGV2ZW50IGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGUga2V5Y29kZSBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleWNvZGVcclxuICAgICAgICBrZXlJczogZnVuY3Rpb24oaywgZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoJC5rZXlDb2RlW2sudG9VcHBlckNhc2UoKV0sIDEwKSA9PSBwYXJzZUludCgodHlwZW9mKGUpID09ICdudW1iZXInICk/IGU6IGUua2V5Q29kZSwgMTApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUga2V5IG9mIGFuIGFycmF5XHJcbiAgICAgICAga2V5czogZnVuY3Rpb24oYXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gW107XHJcbiAgICAgICAgICAgIGZvciAoayBpbiBhcnIpIHsgby5wdXNoKGspOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJlZGlyZWN0IHRvIGEgc3BlY2lmaWVkIHVybFxyXG4gICAgICAgIHJlZGlyZWN0OiBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gU3RvcCBldmVudCBzaG9ydGhhbmRcclxuICAgICAgICBzdG9wOiBmdW5jdGlvbihlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkgIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XHJcbiAgICAgICAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24pIHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldmVudERlZmF1bHQgJiYgZmFsc2UgfHwgdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBiYXNlbmFtZSBvZiBhIHBhdGhcclxuICAgICAgICBiYXNlbmFtZTogZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRbdC5sZW5ndGhdID09PSAnJyAmJiBzIHx8IHQuc2xpY2UoMCwgdC5sZW5ndGgpLmpvaW4oJy8nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBmaWxlbmFtZSBvZiBhIHBhdGhcclxuICAgICAgICBmaWxlbmFtZTogZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnLycpLnBvcCgpO1xyXG4gICAgICAgIH0sIFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIGEgZm9ybWF0ZWQgZmlsZSBzaXplXHJcbiAgICAgICAgZmlsZXNpemVmb3JtYXQ6IGZ1bmN0aW9uKGJ5dGVzLCBzdWZmaXhlcyl7XHJcbiAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQoYnl0ZXMsIDEwKTtcclxuICAgICAgICAgICAgdmFyIHMgPSBzdWZmaXhlcyB8fCBbJ2J5dGUnLCAnYnl0ZXMnLCAnS0InLCAnTUInLCAnR0InXTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKGIpIHx8IGIgPT09IDApIHsgcmV0dXJuICcwICcgKyBzWzBdOyB9XHJcbiAgICAgICAgICAgIGlmIChiID09IDEpICAgICAgICAgICAgICB7IHJldHVybiAnMSAnICsgc1swXTsgfVxyXG4gICAgICAgICAgICBpZiAoYiA8IDEwMjQpICAgICAgICAgICAgeyByZXR1cm4gIGIudG9GaXhlZCgyKSArICcgJyArIHNbMV07IH1cclxuICAgICAgICAgICAgaWYgKGIgPCAxMDQ4NTc2KSAgICAgICAgIHsgcmV0dXJuIChiIC8gMTAyNCkudG9GaXhlZCgyKSArICcgJyArIHNbMl07IH1cclxuICAgICAgICAgICAgaWYgKGIgPCAxMDczNzQxODI0KSAgICAgIHsgcmV0dXJuIChiIC8gMTA0ODU3NikudG9GaXhlZCgyKSArICcgJysgc1szXTsgfVxyXG4gICAgICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgeyByZXR1cm4gKGIgLyAxMDczNzQxODI0KS50b0ZpeGVkKDIpICsgJyAnKyBzWzRdOyB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlsZUV4dGVuc2lvbjogZnVuY3Rpb24ocykge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gcy5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV0gfHwgZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGlzIGEgU3RyaW5nXHJcbiAgICAgICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZihvKSA9PSAnc3RyaW5nJyAmJiB0cnVlIHx8IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBpcyBhIFJlZ0V4cFxyXG5cdFx0aXNSZWdFeHA6IGZ1bmN0aW9uKG8pIHtcclxuXHRcdFx0cmV0dXJuIG8gJiYgby5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoJ1JlZ0V4cCgpJykgIT0gLTEgfHwgZmFsc2U7XHJcblx0XHR9LFxyXG5cclxuICAgICAgICBpc09iamVjdDogZnVuY3Rpb24obykge1xyXG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZihvKSA9PSAnb2JqZWN0Jyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb252ZXJ0IGlucHV0IHRvIGN1cnJlbmN5ICh0d28gZGVjaW1hbCBmaXhlZCBudW1iZXIpXHJcblx0XHR0b0N1cnJlbmN5OiBmdW5jdGlvbihpKSB7XHJcblx0XHRcdGkgPSBwYXJzZUZsb2F0KGksIDEwKS50b0ZpeGVkKDIpO1xyXG5cdFx0XHRyZXR1cm4gKGk9PSdOYU4nKSA/ICcwLjAwJyA6IGk7XHJcblx0XHR9LFxyXG5cclxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxyXG4gICAgICAgICAqIGphdmFzY3JpcHQgbWV0aG9kOiBcInB4VG9FbVwiXHJcbiAgICAgICAgICogYnk6XHJcbiAgICAgICAgICAgU2NvdHQgSmVobCAoc2NvdHRAZmlsYW1lbnRncm91cC5jb20pIFxyXG4gICAgICAgICAgIE1hZ2dpZSBXYWNocyAobWFnZ2llQGZpbGFtZW50Z3JvdXAuY29tKVxyXG4gICAgICAgICAgIGh0dHA6Ly93d3cuZmlsYW1lbnRncm91cC5jb21cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIENvcHlyaWdodCAoYykgMjAwOCBGaWxhbWVudCBHcm91cFxyXG4gICAgICAgICAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCAoZmlsYW1lbnRncm91cC5jb20vZXhhbXBsZXMvbWl0LWxpY2Vuc2UudHh0KSBhbmQgR1BMIChmaWxhbWVudGdyb3VwLmNvbS9leGFtcGxlcy9ncGwtbGljZW5zZS50eHQpIGxpY2Vuc2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRGVzY3JpcHRpb246IHB4VG9FbSBjb252ZXJ0cyBhIHBpeGVsIHZhbHVlIHRvIGVtcyBkZXBlbmRpbmcgb24gaW5oZXJpdGVkIGZvbnQgc2l6ZS4gIFxyXG4gICAgICAgICAqIEFydGljbGU6IGh0dHA6Ly93d3cuZmlsYW1lbnRncm91cC5jb20vbGFiL3JldGFpbmluZ19zY2FsYWJsZV9pbnRlcmZhY2VzX3dpdGhfcGl4ZWxfdG9fZW1fY29udmVyc2lvbi9cclxuICAgICAgICAgKiBEZW1vOiBodHRwOi8vd3d3LmZpbGFtZW50Z3JvdXAuY29tL2V4YW1wbGVzL3B4VG9FbS9cdCBcdFxyXG4gICAgICAgICAqXHRcdFx0XHRcdFx0XHRcclxuICAgICAgICAgKiBPcHRpb25zOiAgXHQgXHRcdFx0XHRcdFx0XHRcdFxyXG4gICAgICAgICAgICAgICAgc2NvcGU6IHN0cmluZyBvciBqUXVlcnkgc2VsZWN0b3IgZm9yIGZvbnQtc2l6ZSBzY29waW5nXHJcbiAgICAgICAgICAgICAgICByZXZlcnNlOiBCb29sZWFuLCB0cnVlIHJldmVyc2VzIHRoZSBjb252ZXJzaW9uIHRvIGVtLXB4XHJcbiAgICAgICAgICogRGVwZW5kZW5jaWVzOiBqUXVlcnkgbGlicmFyeVx0XHRcdFx0XHRcdCAgXHJcbiAgICAgICAgICogVXNhZ2UgRXhhbXBsZTogbXlQaXhlbFZhbHVlLnB4VG9FbSgpOyBvciBteVBpeGVsVmFsdWUucHhUb0VtKHsnc2NvcGUnOicjbmF2aWdhdGlvbicsIHJldmVyc2U6IHRydWV9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFZlcnNpb246IDIuMSwgMTguMTIuMjAwOFxyXG4gICAgICAgICAqIENoYW5nZWxvZzpcclxuICAgICAgICAgKlx0XHQwOC4wMi4yMDA3IGluaXRpYWwgVmVyc2lvbiAxLjBcclxuICAgICAgICAgKlx0XHQwOC4wMS4yMDA4IC0gZml4ZWQgZm9udC1zaXplIGNhbGN1bGF0aW9uIGZvciBJRVxyXG4gICAgICAgICAqXHRcdDE4LjEyLjIwMDggLSByZW1vdmVkIG5hdGl2ZSBvYmplY3QgcHJvdG90eXBpbmcgdG8gc3RheSBpbiBqUXVlcnkncyBzcGlyaXQsIGpzTGludGVkIChNYXhpbWUgSGFpbmVhdWx0IDxoYWluZWF1bHRAZ21haWwuY29tPilcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgICAgIHB4VG9FbTogZnVuY3Rpb24oaSwgc2V0dGluZ3Mpe1xyXG4gICAgICAgICAgICAvL3NldCBkZWZhdWx0c1xyXG4gICAgICAgICAgICBzZXR0aW5ncyA9IGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgc2NvcGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgIHJldmVyc2U6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBweFZhbCA9IChpID09PSAnJykgPyAwIDogcGFyc2VGbG9hdChpKTtcclxuICAgICAgICAgICAgdmFyIHNjb3BlVmFsO1xyXG4gICAgICAgICAgICB2YXIgZ2V0V2luZG93V2lkdGggPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5uZXJXaWR0aCB8fCAoZGUgJiYgZGUuY2xpZW50V2lkdGgpIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIH07XHRcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8qIFdoZW4gYSBwZXJjZW50YWdlLWJhc2VkIGZvbnQtc2l6ZSBpcyBzZXQgb24gdGhlIGJvZHksIElFIHJldHVybnMgdGhhdCBwZXJjZW50IG9mIHRoZSB3aW5kb3cgd2lkdGggYXMgdGhlIGZvbnQtc2l6ZS4gXHJcbiAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgaWYgdGhlIGJvZHkgZm9udC1zaXplIGlzIDYyLjUlIGFuZCB0aGUgd2luZG93IHdpZHRoIGlzIDEwMDBweCwgSUUgd2lsbCByZXR1cm4gNjI1cHggYXMgdGhlIGZvbnQtc2l6ZS4gXHRcclxuICAgICAgICAgICAgICAgIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgYm9keSBmb250LXNpemUgKCUpIGFuZCBtdWx0aXBseSBpdCBieSAxNiAodGhlIHN0YW5kYXJkIGJyb3dzZXIgZm9udCBzaXplKSBcclxuICAgICAgICAgICAgICAgIHRvIGdldCBhbiBhY2N1cmF0ZSBlbSB2YWx1ZS4gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY29wZSA9PSAnYm9keScgJiYgJC5icm93c2VyLm1zaWUgJiYgKHBhcnNlRmxvYXQoJCgnYm9keScpLmNzcygnZm9udC1zaXplJykpIC8gZ2V0V2luZG93V2lkdGgoKSkudG9GaXhlZCgxKSA+IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGNGb250U2l6ZSA9IGZ1bmN0aW9uKCl7XHRcdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VGbG9hdCgkKCdib2R5JykuY3NzKCdmb250LXNpemUnKSkvZ2V0V2luZG93V2lkdGgoKSkudG9GaXhlZCgzKSAqIDE2O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHNjb3BlVmFsID0gY2FsY0ZvbnRTaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IHNjb3BlVmFsID0gcGFyc2VGbG9hdChqUXVlcnkoc2V0dGluZ3Muc2NvcGUpLmNzcyhcImZvbnQtc2l6ZVwiKSk7IH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IChzZXR0aW5ncy5yZXZlcnNlID09PSB0cnVlKSA/IChweFZhbCAqIHNjb3BlVmFsKS50b0ZpeGVkKDIpICsgJ3B4JyA6IChweFZhbCAvIHNjb3BlVmFsKS50b0ZpeGVkKDIpICsgJ2VtJztcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblx0fSk7XHJcblxyXG5cdCQuZXh0ZW5kKCQuZm4sIHsgXHJcbiAgICAgICAgdHlwZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRyeSB7IHJldHVybiAkKHRoaXMpLmdldCgwKS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBTZWxlY3QgYSB0ZXh0IHJhbmdlIGluIGEgdGV4dGFyZWFcclxuICAgICAgICBzZWxlY3RSYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCl7XHJcbiAgICAgICAgICAgIC8vIHVzZSBvbmx5IHRoZSBmaXJzdCBvbmUgc2luY2Ugb25seSBvbmUgaW5wdXQgY2FuIGJlIGZvY3VzZWRcclxuICAgICAgICAgICAgaWYgKCQodGhpcykuZ2V0KDApLmNyZWF0ZVRleHRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gJCh0aGlzKS5nZXQoMCkuY3JlYXRlVGV4dFJhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsICAgZW5kKTtcclxuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJCh0aGlzKS5nZXQoMCkuc2V0U2VsZWN0aW9uUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICQodGhpcykuYmluZCgnZm9jdXMnLCBmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9KS5nZXQoMCkuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcclxuICAgICAgICAgKiBKUXVlcnkgUGx1Z2luOiBcIkVxdWFsSGVpZ2h0c1wiXHJcbiAgICAgICAgICogYnk6XHRTY290dCBKZWhsLCBUb2RkIFBhcmtlciwgTWFnZ2llIENvc3RlbGxvIFdhY2hzIChodHRwOi8vd3d3LmZpbGFtZW50Z3JvdXAuY29tKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEZpbGFtZW50IEdyb3VwXHJcbiAgICAgICAgICogTGljZW5zZWQgdW5kZXIgR1BMIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL2dwbC1saWNlbnNlLnBocClcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIERlc2NyaXB0aW9uOiBDb21wYXJlcyB0aGUgaGVpZ2h0cyBvciB3aWR0aHMgb2YgdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBvZiBhIHByb3ZpZGVkIGVsZW1lbnQgXHJcbiAgICAgICAgICAgICAgICBhbmQgc2V0cyB0aGVpciBtaW4taGVpZ2h0IHRvIHRoZSB0YWxsZXN0IGhlaWdodCAob3Igd2lkdGggdG8gd2lkZXN0IHdpZHRoKS4gU2V0cyBpbiBlbSB1bml0cyBcclxuICAgICAgICAgICAgICAgIGJ5IGRlZmF1bHQgaWYgcHhUb0VtKCkgbWV0aG9kIGlzIGF2YWlsYWJsZS5cclxuICAgICAgICAgKiBEZXBlbmRlbmNpZXM6IGpRdWVyeSBsaWJyYXJ5LCBweFRvRW0gbWV0aG9kXHQoYXJ0aWNsZTogXHJcbiAgICAgICAgICAgICAgICBodHRwOi8vd3d3LmZpbGFtZW50Z3JvdXAuY29tL2xhYi9yZXRhaW5pbmdfc2NhbGFibGVfaW50ZXJmYWNlc193aXRoX3BpeGVsX3RvX2VtX2NvbnZlcnNpb24vKVx0XHRcdFx0XHRcdFx0ICBcclxuICAgICAgICAgKiBVc2FnZSBFeGFtcGxlOiAkKGVsZW1lbnQpLmVxdWFsSGVpZ2h0cygpO1xyXG4gICAgICAgICAgICAgICAgT3B0aW9uYWw6IHRvIHNldCBtaW4taGVpZ2h0IGluIHB4LCBwYXNzIGEgdHJ1ZSBhcmd1bWVudDogJChlbGVtZW50KS5lcXVhbEhlaWdodHModHJ1ZSk7XHJcbiAgICAgICAgICogVmVyc2lvbjogMi4xLCAxOC4xMi4yMDA4XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOb3RlOiBDaGFuZ2VkIHB4VG9FbSBjYWxsIHRvIGNhbGwgJC5weFRvRW0gaW5zdGVhZCwganNMaW50ZWQgKE1heGltZSBIYWluZWF1bHQgPGhhaW5lYXVsdEBnbWFpbC5jb20+KVxyXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAgICAgZXF1YWxIZWlnaHRzOiBmdW5jdGlvbihweCl7XHJcbiAgICAgICAgICAgICQodGhpcykuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUYWxsZXN0ID0gMDtcclxuICAgICAgICAgICAgICAgICQodGhpcykuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmhlaWdodCgpID4gY3VycmVudFRhbGxlc3QpIHsgY3VycmVudFRhbGxlc3QgPSAkKHRoaXMpLmhlaWdodCgpOyB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICghcHggfHwgISQucHhUb0VtKSB7IGN1cnJlbnRUYWxsZXN0ID0gJC5weFRvRW0oY3VycmVudFRhbGxlc3QpOyB9IC8vdXNlIGVtcyB1bmxlc3MgcHggaXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgaWU2LCBzZXQgaGVpZ2h0IHNpbmNlIG1pbi1oZWlnaHQgaXNuJ3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoJC5icm93c2VyLm1zaWUgJiYgJC5icm93c2VyLnZlcnNpb24gPT0gNi4wKSB7ICQodGhpcykuY2hpbGRyZW4oKS5jc3MoeydoZWlnaHQnOiBjdXJyZW50VGFsbGVzdH0pOyB9XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNoaWxkcmVuKCkuY3NzKHsnbWluLWhlaWdodCc6IGN1cnJlbnRUYWxsZXN0fSk7IFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSAyMDA5IEphbWVzIFBhZG9sc2V5XHJcbiAgICAgICAgLy8gaHR0cDovL2phbWVzLnBhZG9sc2V5LmNvbS9qYXZhc2NyaXB0L2pxdWVyeS1kZWxheS1wbHVnaW4vXHJcbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uKHRpbWUsIGNhbGxiYWNrKXtcclxuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0ZXAuZGVsYXkgPSBmdW5jdGlvbigpe307XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoe2RlbGF5OjF9LCB0aW1lLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSAgICAgICAgXHJcblx0fSk7XHJcbn0pKGpRdWVyeSk7XHJcbi8qXHJcbiAgalF1ZXJ5IHN0cmluZ3MgLSAwLjNcclxuICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvanF1ZXJ5LXV0aWxzL1xyXG4gIFxyXG4gIChjKSBNYXhpbWUgSGFpbmVhdWx0IDxoYWluZWF1bHRAZ21haWwuY29tPlxyXG4gIGh0dHA6Ly9oYWluZWF1bHQuY29tICAgXHJcblxyXG4gIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcclxuXHJcbiAgSW1wbGVtZW50YXRpb24gb2YgUHl0aG9uM0sgYWR2YW5jZWQgc3RyaW5nIGZvcm1hdHRpbmdcclxuICBodHRwOi8vd3d3LnB5dGhvbi5vcmcvZGV2L3BlcHMvcGVwLTMxMDEvXHJcblxyXG4gIERvY3VtZW50YXRpb246IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qcXVlcnktdXRpbHMvd2lraS9TdHJpbmdGb3JtYXRcclxuICBcclxuKi9cclxuKGZ1bmN0aW9uKCQpe1xyXG4gICAgdmFyIHN0cmluZ3MgPSB7XHJcbiAgICAgICAgc3RyQ29udmVyc2lvbjoge1xyXG4gICAgICAgICAgICAvLyB0cmllcyB0byB0cmFuc2xhdGUgYW55IG9iamVjdHMgdHlwZSBpbnRvIHN0cmluZyBncmFjZWZ1bGx5XHJcbiAgICAgICAgICAgIF9fcmVwcjogZnVuY3Rpb24oaSl7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2godGhpcy5fX2dldFR5cGUoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhcnJheSc6Y2FzZSAnZGF0ZSc6Y2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh4PTA7IHg8aS5sZW5ndGg7IGkrKykgeyBvLnB1c2goaSsnOiAnKyB0aGlzLl9fcmVwcihpW3hdKSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBsaWtlIHR5cGVvZiBidXQgbGVzcyB2YWd1ZVxyXG4gICAgICAgICAgICBfX2dldFR5cGU6IGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaSB8fCAhaS5jb25zdHJ1Y3RvcikgeyByZXR1cm4gdHlwZW9mKGkpOyB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBpLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkubWF0Y2goL0FycmF5fE51bWJlcnxTdHJpbmd8T2JqZWN0fERhdGUvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIHx8IHR5cGVvZihpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8rIEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YVxyXG4gICAgICAgICAgICAvLyB0aGUgQCBzaWduIG5leHQgdG8gXCIvL1wiIGlzIGludGVycHJldGVkIGJ5IElFIHdoZW4gdXNpbmcgY2M8dW5kZXJzY29yZT5vbiEgSW5zZXJ0ZWQgYSBzcGFjZS5cclxuICAgICAgICAgICAgLy8gIEAgaHR0cDovL2pzZnJvbWhlbGwuY29tL3N0cmluZy9wYWQgW3YxLjBdXHJcbiAgICAgICAgICAgIF9fcGFkOiBmdW5jdGlvbihzdHIsIGwsIHMsIHQpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBzIHx8ICcgJztcclxuICAgICAgICAgICAgICAgIHZhciBvID0gc3RyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGwgLSBzdHIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG8gPSBuZXcgQXJyYXkoTWF0aC5jZWlsKGwgLyBwLmxlbmd0aCkpLmpvaW4ocCkuc3Vic3RyKDAsIHQgPSAhdCA/IGwgOiB0ID09IDEgPyAwIDogTWF0aC5jZWlsKGwgLyAyKSkgKyBzdHIgKyBwLnN1YnN0cigwLCBsIC0gdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX19nZXRJbnB1dDogZnVuY3Rpb24oYXJnLCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGFyZy5nZXRLZXkoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCh0aGlzLl9fZ2V0VHlwZShhcmdzKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogLy8gVGhhbmtzIHRvIEpvbmF0aGFuIFdvcmtzIGZvciB0aGUgcGF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgc3Via2V5ID0gMDsgc3Via2V5IDwga2V5cy5sZW5ndGg7IHN1YmtleSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtrZXlzW3N1YmtleV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yob2JqKSAhPSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3Muc3RyQ29udmVyc2lvbi5fX2dldFR5cGUob2JqKSA9PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5nZXRGb3JtYXQoKS5tYXRjaCgvXFwuXFwqLykgJiYgb2JqWzFdIHx8IG9iajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0cnkgYnkgbnVtZXJpY2FsIGluZGV4ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmdldEZvcm1hdCgpLm1hdGNoKC9cXC5cXCovKSAmJiB0eXBlb2YgYXJnc1trZXkrMV0gIT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGFyZ3Nba2V5KzFdOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmdzW2tleV0gIT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGFyZ3Nba2V5XTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgcmV0dXJuIGtleTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd7JytrZXkrJ30nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfX2Zvcm1hdFRva2VuOiBmdW5jdGlvbih0b2tlbiwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZyAgID0gbmV3IEFyZ3VtZW50KHRva2VuLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLnN0ckNvbnZlcnNpb25bYXJnLmdldEZvcm1hdCgpLnNsaWNlKC0xKV0odGhpcy5fX2dldElucHV0KGFyZywgYXJncyksIGFyZyk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBTaWduZWQgaW50ZWdlciBkZWNpbWFsLlxyXG4gICAgICAgICAgICBkOiBmdW5jdGlvbihpbnB1dCwgYXJnKXtcclxuICAgICAgICAgICAgICAgIHZhciBvID0gcGFyc2VJbnQoaW5wdXQsIDEwKTsgLy8gZW5mb3JjZSBiYXNlIDEwXHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGFyZy5nZXRQYWRkaW5nTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocCkgeyByZXR1cm4gdGhpcy5fX3BhZChvLnRvU3RyaW5nKCksIHAsIGFyZy5nZXRQYWRkaW5nU3RyaW5nKCksIDApOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlICAgeyByZXR1cm4gbzsgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBTaWduZWQgaW50ZWdlciBkZWNpbWFsLlxyXG4gICAgICAgICAgICBpOiBmdW5jdGlvbihpbnB1dCwgYXJncyl7IFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZChpbnB1dCwgYXJncyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIFVuc2lnbmVkIG9jdGFsXHJcbiAgICAgICAgICAgIG86IGZ1bmN0aW9uKGlucHV0LCBhcmcpeyBcclxuICAgICAgICAgICAgICAgIHZhciBvID0gaW5wdXQudG9TdHJpbmcoOCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmlzQWx0ZXJuYXRlKCkpIHsgbyA9IHRoaXMuX19wYWQobywgby5sZW5ndGgrMSwgJzAnLCAwKTsgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19wYWQobywgYXJnLmdldFBhZGRpbmdMZW5ndGgoKSwgYXJnLmdldFBhZGRpbmdTdHJpbmcoKSwgMCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIFVuc2lnbmVkIGRlY2ltYWxcclxuICAgICAgICAgICAgdTogZnVuY3Rpb24oaW5wdXQsIGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmQoaW5wdXQsIGFyZ3MpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gVW5zaWduZWQgaGV4YWRlY2ltYWwgKGxvd2VyY2FzZSlcclxuICAgICAgICAgICAgeDogZnVuY3Rpb24oaW5wdXQsIGFyZyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHBhcnNlSW50KGlucHV0LCAxMCkudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICAgICAgbyA9IHRoaXMuX19wYWQobywgYXJnLmdldFBhZGRpbmdMZW5ndGgoKSwgYXJnLmdldFBhZGRpbmdTdHJpbmcoKSwwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmcuaXNBbHRlcm5hdGUoKSA/ICcweCcrbyA6IG87XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIFVuc2lnbmVkIGhleGFkZWNpbWFsICh1cHBlcmNhc2UpXHJcbiAgICAgICAgICAgIFg6IGZ1bmN0aW9uKGlucHV0LCBhcmcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueChpbnB1dCwgYXJnKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBGbG9hdGluZyBwb2ludCBleHBvbmVudGlhbCBmb3JtYXQgKGxvd2VyY2FzZSlcclxuICAgICAgICAgICAgZTogZnVuY3Rpb24oaW5wdXQsIGFyZyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChpbnB1dCwgMTApLnRvRXhwb25lbnRpYWwoYXJnLmdldFByZWNpc2lvbigpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gRmxvYXRpbmcgcG9pbnQgZXhwb25lbnRpYWwgZm9ybWF0ICh1cHBlcmNhc2UpXHJcbiAgICAgICAgICAgIEU6IGZ1bmN0aW9uKGlucHV0LCBhcmcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZShpbnB1dCwgYXJnKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBGbG9hdGluZyBwb2ludCBkZWNpbWFsIGZvcm1hdFxyXG4gICAgICAgICAgICBmOiBmdW5jdGlvbihpbnB1dCwgYXJnKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fcGFkKHBhcnNlRmxvYXQoaW5wdXQsIDEwKS50b0ZpeGVkKGFyZy5nZXRQcmVjaXNpb24oKSksIGFyZy5nZXRQYWRkaW5nTGVuZ3RoKCksIGFyZy5nZXRQYWRkaW5nU3RyaW5nKCksMCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIEZsb2F0aW5nIHBvaW50IGRlY2ltYWwgZm9ybWF0IChhbGlhcylcclxuICAgICAgICAgICAgRjogZnVuY3Rpb24oaW5wdXQsIGFyZ3Mpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZihpbnB1dCwgYXJncyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIEZsb2F0aW5nIHBvaW50IGZvcm1hdC4gVXNlcyBleHBvbmVudGlhbCBmb3JtYXQgaWYgZXhwb25lbnQgaXMgZ3JlYXRlciB0aGFuIC00IG9yIGxlc3MgdGhhbiBwcmVjaXNpb24sIGRlY2ltYWwgZm9ybWF0IG90aGVyd2lzZVxyXG4gICAgICAgICAgICBnOiBmdW5jdGlvbihpbnB1dCwgYXJnKXtcclxuICAgICAgICAgICAgICAgIHZhciBvID0gcGFyc2VGbG9hdChpbnB1dCwgMTApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChvLnRvU3RyaW5nKCkubGVuZ3RoID4gNikgPyBNYXRoLnJvdW5kKG8udG9FeHBvbmVudGlhbChhcmcuZ2V0UHJlY2lzaW9uKCkpKTogbztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gRmxvYXRpbmcgcG9pbnQgZm9ybWF0LiBVc2VzIGV4cG9uZW50aWFsIGZvcm1hdCBpZiBleHBvbmVudCBpcyBncmVhdGVyIHRoYW4gLTQgb3IgbGVzcyB0aGFuIHByZWNpc2lvbiwgZGVjaW1hbCBmb3JtYXQgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgIEc6IGZ1bmN0aW9uKGlucHV0LCBhcmdzKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmcoaW5wdXQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBTaW5nbGUgY2hhcmFjdGVyIChhY2NlcHRzIGludGVnZXIgb3Igc2luZ2xlIGNoYXJhY3RlciBzdHJpbmcpLiBcdFxyXG4gICAgICAgICAgICBjOiBmdW5jdGlvbihpbnB1dCwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goL1xcd3xcXGQvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFswXSB8fCAnJztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gU3RyaW5nIChjb252ZXJ0cyBhbnkgSmF2YVNjcmlwdCBvYmplY3QgdG8gYW5vdGF0ZWQgZm9ybWF0KVxyXG4gICAgICAgICAgICByOiBmdW5jdGlvbihpbnB1dCwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19yZXByKGlucHV0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gU3RyaW5nIChjb252ZXJ0cyBhbnkgSmF2YVNjcmlwdCBvYmplY3QgdXNpbmcgb2JqZWN0LnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgIHM6IGZ1bmN0aW9uKGlucHV0LCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcgJiYgaW5wdXQudG9TdHJpbmcoKSB8fCAnJytpbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oc3RyLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBlbmQgICAgPSAwO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgID0gMDtcclxuICAgICAgICAgICAgdmFyIG1hdGNoICA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiAgPSAnJztcclxuICAgICAgICAgICAgdmFyIHRtcCAgICA9IChzdHJ8fCcnKS5zcGxpdCgnJyk7XHJcbiAgICAgICAgICAgIGZvcihzdGFydD0wOyBzdGFydCA8IHRtcC5sZW5ndGg7IHN0YXJ0KyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0bXBbc3RhcnRdID09ICd7JyAmJiB0bXBbc3RhcnQrMV0gIT0neycpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgICA9IHN0ci5pbmRleE9mKCd9Jywgc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG1wLnNsaWNlKHN0YXJ0KzEsIGVuZCkuam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFtzdGFydC0xXSAhPSAneycgJiYgdG1wW2VuZCsxXSAhPSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuQXJncyA9ICh0eXBlb2YgYXJndW1lbnRzWzFdICE9ICdvYmplY3QnKT8gYXJndW1lbnRzMkFycmF5KGFyZ3VtZW50cywgMik6IGFyZ3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHN0cmluZ3Muc3RyQ29udmVyc2lvbi5fX2Zvcm1hdFRva2VuKHRva2VuLCB0b2tlbkFyZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydCA+IGVuZCB8fCBidWZmZXIubGVuZ3RoIDwgMSkgeyBidWZmZXIucHVzaCh0bXBbc3RhcnRdKTsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoYnVmZmVyLmxlbmd0aCA+IDEpPyBidWZmZXIuam9pbignJyk6IGJ1ZmZlclswXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjYWxjOiBmdW5jdGlvbihzdHIsIGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2YWwoZm9ybWF0KHN0ciwgYXJncykpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlcGVhdDogZnVuY3Rpb24ocywgbikgeyBcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShuKzEpLmpvaW4ocyk7IFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFVURjhlbmNvZGU6IGZ1bmN0aW9uKHMpIHsgXHJcbiAgICAgICAgICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocykpOyBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBVVEY4ZGVjb2RlOiBmdW5jdGlvbihzKSB7IFxyXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzKSk7IFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRwbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSAnJztcclxuICAgICAgICAgICAgdmFyIHJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIFNldFxyXG4gICAgICAgICAgICAvLyAkLnRwbCgndWkudGVzdCcsIFsnPHNwYW4+JywgaGVsbG9Xb3JsZCAsJzwvc3Bhbj4nXSk7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIgJiYgJC5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXS5qb2luKCcnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXNbYXJndW1lbnRzWzBdXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gJC50cGwoJ3VpLnRlc3QnLCAnPHNwYW4+aGVsbG8gd29ybGQ8L3NwYW4+Jyk7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIgJiYgJC5pc1N0cmluZyhhcmd1bWVudHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzW2FyZ3VtZW50c1swXV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENhbGxcclxuICAgICAgICAgICAgLy8gJC50cGwoJ3VpLnRlc3QnKTtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpc1thcmd1bWVudHNbMF1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAkLnRwbCgndWkudGVzdCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiAmJiBhcmd1bWVudHNbMV0gPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2FyZ3VtZW50c1swXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gJC50cGwoJ3VpLnRlc3QnLCB7dmFsdWU6YmxhaH0pO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmICQuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoJC5mb3JtYXQodGhpc1thcmd1bWVudHNbMF1dLCBhcmd1bWVudHNbMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAkLnRwbCgndWkudGVzdCcsIHt2YWx1ZTpibGFofSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzICYmICQuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhcmd1bWVudHNbMl0gPT0gdHJ1ZSkgXHJcbiAgICAgICAgICAgICAgICAgICAgPyAkLmZvcm1hdCh0aGlzW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50c1sxXSlcclxuICAgICAgICAgICAgICAgICAgICA6ICQoJC5mb3JtYXQodGhpc1thcmd1bWVudHNbMF1dLCBhcmd1bWVudHNbMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIEFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fX2FyZyAgPSBhcmc7XHJcbiAgICAgICAgdGhpcy5fX2FyZ3MgPSBhcmdzO1xyXG4gICAgICAgIHRoaXMuX19tYXhfcHJlY2lzaW9uID0gcGFyc2VGbG9hdCgnMS4nKyAobmV3IEFycmF5KDMyKSkuam9pbignMScpLCAxMCkudG9TdHJpbmcoKS5sZW5ndGgtMztcclxuICAgICAgICB0aGlzLl9fZGVmX3ByZWNpc2lvbiA9IDY7XHJcbiAgICAgICAgdGhpcy5nZXRTdHJpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FyZztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0S2V5ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19hcmcuc3BsaXQoJzonKVswXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0Rm9ybWF0ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5nZXRTdHJpbmcoKS5zcGxpdCgnOicpO1xyXG4gICAgICAgICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoWzFdKT8gbWF0Y2hbMV06ICdzJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5nZXRGb3JtYXQoKS5tYXRjaCgvXFwuKFxcZCt8XFwqKS9nKTtcclxuICAgICAgICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gdGhpcy5fX2RlZl9wcmVjaXNpb247IH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoWzBdLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9ICcqJykgeyByZXR1cm4gcGFyc2VJbnQobWF0Y2gsIDEwKTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdHJpbmdzLnN0ckNvbnZlcnNpb24uX19nZXRUeXBlKHRoaXMuX19hcmdzKSA9PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19hcmdzWzFdICYmIHRoaXMuX19hcmdzWzBdIHx8IHRoaXMuX19kZWZfcHJlY2lzaW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdHJpbmdzLnN0ckNvbnZlcnNpb24uX19nZXRUeXBlKHRoaXMuX19hcmdzKSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fYXJnc1t0aGlzLmdldEtleSgpXSAmJiB0aGlzLl9fYXJnc1t0aGlzLmdldEtleSgpXVswXSB8fCB0aGlzLl9fZGVmX3ByZWNpc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5fX2RlZl9wcmVjaXNpb247IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZXRQYWRkaW5nTGVuZ3RoID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWx0ZXJuYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5nZXRTdHJpbmcoKS5tYXRjaCgvMD8jMD8oXFxkKykvKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkgeyByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hdGNoID0gdGhpcy5nZXRTdHJpbmcoKS5tYXRjaCgvKDB8XFwuKShcXGQrfFxcKikvZyk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBwYXJzZUludChtYXRjaFswXS5zbGljZSgxKSwgMTApIHx8IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldFBhZGRpbmdTdHJpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgbyA9ICcnO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0FsdGVybmF0ZSgpKSB7IG8gPSAnICc7IH1cclxuICAgICAgICAgICAgLy8gMCB0YWtlIHByZWNlZGVuY2Ugb24gYWx0ZXJuYXRlIGZvcm1hdFxyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRGb3JtYXQoKS5tYXRjaCgvIzB8MCN8XjB8XFwuXFxkKy8pKSB7IG8gPSAnMCc7IH1cclxuICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldEZsYWdzID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5nZXRTdHJpbmcoKS5tYXRjKC9eKDB8XFwjfFxcLXxcXCt8XFxzKSsvKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzBdLnNwbGl0KCcnKSB8fCBbXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaXNBbHRlcm5hdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRGb3JtYXQoKS5tYXRjaCgvXjA/Iy8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBhcmd1bWVudHMyQXJyYXkgPSBmdW5jdGlvbihhcmdzLCBzaGlmdCkge1xyXG4gICAgICAgIHZhciBvID0gW107XHJcbiAgICAgICAgZm9yIChsPWFyZ3MubGVuZ3RoLCB4PShzaGlmdCB8fCAwKS0xOyB4PGw7eCsrKSB7IG8ucHVzaChhcmdzW3hdKTsgfVxyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfTtcclxuICAgICQuZXh0ZW5kKHN0cmluZ3MpO1xyXG59KShqUXVlcnkpO1xyXG4vKlxyXG4gIGpRdWVyeSBhbmNob3IgaGFuZGxlciAtIDAuNVxyXG4gIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qcXVlcnktdXRpbHMvXHJcblxyXG4gIChjKSBNYXhpbWUgSGFpbmVhdWx0IDxoYWluZWF1bHRAZ21haWwuY29tPlxyXG4gIGh0dHA6Ly9oYWluZWF1bHQuY29tICAgXHJcblxyXG4gIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcclxuXHJcbiovXHJcblxyXG4oZnVuY3Rpb24oJCl7XHJcbiAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xyXG4gICAgdmFyIGhhbmRsZXJzICA9IFtdO1xyXG4gICAgdmFyIG9wdCA9IHt9O1xyXG5cclxuXHQkLmV4dGVuZCh7XHJcblx0XHRhbmNob3JIYW5kbGVyOiB7XHJcbiAgICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICQubWFwKGhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBoYXNoLm1hdGNoKGhhbmRsZXIucikgJiYgaGFzaC5tYXRjaChoYW5kbGVyLnIpWzBdIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkgIHsgaGFuZGxlci5jYi5hcHBseSgkKCdhW2hyZWYqPScrbWF0Y2grJ10nKS5nZXQoMCksIFtoYW5kbGVyLnIsIGhhc2ggfHwgJyddKTsgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5hbmNob3JIYW5kbGVyO1xyXG4gICAgICAgICAgICB9LFxyXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKHJlZ2V4cCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHQgID0gJC5leHRlbmQoe2hhbmRsZUNsaWNrOiB0cnVlLCBwcmVzZXJ2ZUhhc2g6IHRydWV9LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHQuaGFuZGxlQ2xpY2spIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgJCgnYVtocmVmKj0jXScpLmVhY2goZnVuY3Rpb24oaSwgYSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmhyZWYubWF0Y2gocmVnZXhwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChhKS5iaW5kKCdjbGljay5hbmNob3JIYW5kbGVyJywgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0LnByZXNlcnZlSGFzaCkgeyB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGEuaGFzaDsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBbcmVnZXhwLCBhLmhyZWZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pOyBcclxuICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0XHRoYW5kbGVycy5wdXNoKHtyOiByZWdleHAsIGNiOiBjYWxsYmFja30pO1xyXG4gICAgICAgICAgICAgICAgJCgkLmFuY2hvckhhbmRsZXIuYXBwbHkpO1xyXG5cdFx0XHRcdHJldHVybiAkLmFuY2hvckhhbmRsZXI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxufSkoalF1ZXJ5KTtcclxuLyoqXHJcbiAqIENvb2tpZSBwbHVnaW5cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDA2IEtsYXVzIEhhcnRsIChzdGlsYnVlcm8uZGUpXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxyXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG4gKiBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLmh0bWxcclxuICpcclxuICovXHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgY29va2llIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlIGFuZCBvdGhlciBvcHRpb25hbCBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsICd0aGVfdmFsdWUnKTtcclxuICogQGRlc2MgU2V0IHRoZSB2YWx1ZSBvZiBhIGNvb2tpZS5cclxuICogQGV4YW1wbGUgJC5jb29raWUoJ3RoZV9jb29raWUnLCAndGhlX3ZhbHVlJywgeyBleHBpcmVzOiA3LCBwYXRoOiAnLycsIGRvbWFpbjogJ2pxdWVyeS5jb20nLCBzZWN1cmU6IHRydWUgfSk7XHJcbiAqIEBkZXNjIENyZWF0ZSBhIGNvb2tpZSB3aXRoIGFsbCBhdmFpbGFibGUgb3B0aW9ucy5cclxuICogQGV4YW1wbGUgJC5jb29raWUoJ3RoZV9jb29raWUnLCAndGhlX3ZhbHVlJyk7XHJcbiAqIEBkZXNjIENyZWF0ZSBhIHNlc3Npb24gY29va2llLlxyXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsIG51bGwpO1xyXG4gKiBAZGVzYyBEZWxldGUgYSBjb29raWUgYnkgcGFzc2luZyBudWxsIGFzIHZhbHVlLiBLZWVwIGluIG1pbmQgdGhhdCB5b3UgaGF2ZSB0byB1c2UgdGhlIHNhbWUgcGF0aCBhbmQgZG9tYWluXHJcbiAqICAgICAgIHVzZWQgd2hlbiB0aGUgY29va2llIHdhcyBzZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBTdHJpbmcgbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29va2llLlxyXG4gKiBAcGFyYW0gU3RyaW5nIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgY29va2llLlxyXG4gKiBAcGFyYW0gT2JqZWN0IG9wdGlvbnMgQW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgdG8gcHJvdmlkZSBvcHRpb25hbCBjb29raWUgYXR0cmlidXRlcy5cclxuICogQG9wdGlvbiBOdW1iZXJ8RGF0ZSBleHBpcmVzIEVpdGhlciBhbiBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIGV4cGlyYXRpb24gZGF0ZSBmcm9tIG5vdyBvbiBpbiBkYXlzIG9yIGEgRGF0ZSBvYmplY3QuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIG5lZ2F0aXZlIHZhbHVlIGlzIHNwZWNpZmllZCAoZS5nLiBhIGRhdGUgaW4gdGhlIHBhc3QpLCB0aGUgY29va2llIHdpbGwgYmUgZGVsZXRlZC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNldCB0byBudWxsIG9yIG9taXR0ZWQsIHRoZSBjb29raWUgd2lsbCBiZSBhIHNlc3Npb24gY29va2llIGFuZCB3aWxsIG5vdCBiZSByZXRhaW5lZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdGhlIGJyb3dzZXIgZXhpdHMuXHJcbiAqIEBvcHRpb24gU3RyaW5nIHBhdGggVGhlIHZhbHVlIG9mIHRoZSBwYXRoIGF0cmlidXRlIG9mIHRoZSBjb29raWUgKGRlZmF1bHQ6IHBhdGggb2YgcGFnZSB0aGF0IGNyZWF0ZWQgdGhlIGNvb2tpZSkuXHJcbiAqIEBvcHRpb24gU3RyaW5nIGRvbWFpbiBUaGUgdmFsdWUgb2YgdGhlIGRvbWFpbiBhdHRyaWJ1dGUgb2YgdGhlIGNvb2tpZSAoZGVmYXVsdDogZG9tYWluIG9mIHBhZ2UgdGhhdCBjcmVhdGVkIHRoZSBjb29raWUpLlxyXG4gKiBAb3B0aW9uIEJvb2xlYW4gc2VjdXJlIElmIHRydWUsIHRoZSBzZWN1cmUgYXR0cmlidXRlIG9mIHRoZSBjb29raWUgd2lsbCBiZSBzZXQgYW5kIHRoZSBjb29raWUgdHJhbnNtaXNzaW9uIHdpbGxcclxuICogICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlIGEgc2VjdXJlIHByb3RvY29sIChsaWtlIEhUVFBTKS5cclxuICogQHR5cGUgdW5kZWZpbmVkXHJcbiAqXHJcbiAqIEBuYW1lICQuY29va2llXHJcbiAqIEBjYXQgUGx1Z2lucy9Db29raWVcclxuICogQGF1dGhvciBLbGF1cyBIYXJ0bC9rbGF1cy5oYXJ0bEBzdGlsYnVlcm8uZGVcclxuICovXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBvZiBhIGNvb2tpZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gKlxyXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScpO1xyXG4gKiBAZGVzYyBHZXQgdGhlIHZhbHVlIG9mIGEgY29va2llLlxyXG4gKlxyXG4gKiBAcGFyYW0gU3RyaW5nIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZS5cclxuICogQHJldHVybiBUaGUgdmFsdWUgb2YgdGhlIGNvb2tpZS5cclxuICogQHR5cGUgU3RyaW5nXHJcbiAqXHJcbiAqIEBuYW1lICQuY29va2llXHJcbiAqIEBjYXQgUGx1Z2lucy9Db29raWVcclxuICogQGF1dGhvciBLbGF1cyBIYXJ0bC9rbGF1cy5oYXJ0bEBzdGlsYnVlcm8uZGVcclxuICovXHJcbmpRdWVyeS5jb29raWUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJykgeyAvLyBuYW1lIGFuZCB2YWx1ZSBnaXZlbiwgc2V0IGNvb2tpZVxyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICBvcHRpb25zLmV4cGlyZXMgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV4cGlyZXMgPSAnJztcclxuICAgICAgICBpZiAob3B0aW9ucy5leHBpcmVzICYmICh0eXBlb2Ygb3B0aW9ucy5leHBpcmVzID09ICdudW1iZXInIHx8IG9wdGlvbnMuZXhwaXJlcy50b1VUQ1N0cmluZykpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHBpcmVzID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChvcHRpb25zLmV4cGlyZXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlID0gb3B0aW9ucy5leHBpcmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIHVzZSBleHBpcmVzIGF0dHJpYnV0ZSwgbWF4LWFnZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENBVVRJT046IE5lZWRlZCB0byBwYXJlbnRoZXNpemUgb3B0aW9ucy5wYXRoIGFuZCBvcHRpb25zLmRvbWFpblxyXG4gICAgICAgIC8vIGluIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbnMsIG90aGVyd2lzZSB0aGV5IGV2YWx1YXRlIHRvIHVuZGVmaW5lZFxyXG4gICAgICAgIC8vIGluIHRoZSBwYWNrZWQgdmVyc2lvbiBmb3Igc29tZSByZWFzb24uLi5cclxuICAgICAgICB2YXIgcGF0aCA9IG9wdGlvbnMucGF0aCA/ICc7IHBhdGg9JyArIChvcHRpb25zLnBhdGgpIDogJyc7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8gJzsgZG9tYWluPScgKyAob3B0aW9ucy5kb21haW4pIDogJyc7XHJcbiAgICAgICAgdmFyIHNlY3VyZSA9IG9wdGlvbnMuc2VjdXJlID8gJzsgc2VjdXJlJyA6ICcnO1xyXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IFtuYW1lLCAnPScsIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSksIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlXS5qb2luKCcnKTtcclxuICAgIH0gZWxzZSB7IC8vIG9ubHkgbmFtZSBnaXZlbiwgZ2V0IGNvb2tpZVxyXG4gICAgICAgIHZhciBjb29raWVWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmNvb2tpZSAmJiBkb2N1bWVudC5jb29raWUgIT0gJycpIHtcclxuICAgICAgICAgICAgdmFyIGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29va2llID0galF1ZXJ5LnRyaW0oY29va2llc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAvLyBEb2VzIHRoaXMgY29va2llIHN0cmluZyBiZWdpbiB3aXRoIHRoZSBuYW1lIHdlIHdhbnQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoY29va2llLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCArIDEpID09IChuYW1lICsgJz0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZVZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZS5zdWJzdHJpbmcobmFtZS5sZW5ndGggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tpZVZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG4vKlxyXG4gIGpRdWVyeSBjb3VudGRvd24gLSAwLjJcclxuICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvanF1ZXJ5LXV0aWxzL1xyXG5cclxuICAoYykgTWF4aW1lIEhhaW5lYXVsdCA8aGFpbmVhdWx0QGdtYWlsLmNvbT5cclxuICBodHRwOi8vaGFpbmVhdWx0LmNvbSAgIFxyXG5cclxuICBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXHJcbiAgXHJcbiovXHJcblxyXG4oZnVuY3Rpb24oJCkge1xyXG4gICAgZnVuY3Rpb24gY291bnRkb3duKGVsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGNhbGMgPSBmdW5jdGlvbiAodGFyZ2V0LCBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIC8qIFJldHVybiB0cnVlIGlmIHRoZSB0YXJnZXQgZGF0ZSBoYXMgYXJyaXZlZCxcclxuICAgICAgICAgICAgICogYW4gb2JqZWN0IG9mIHRoZSB0aW1lIGxlZnQgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50IHx8IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID49IHRhcmdldCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG8gPSB7fTtcclxuICAgICAgICAgICAgdmFyIHJlbWFpbiA9IE1hdGguZmxvb3IoKHRhcmdldC5nZXRUaW1lKCkgLSBjdXJyZW50LmdldFRpbWUoKSkgLyAxMDAwKTtcclxuXHJcbiAgICAgICAgICAgIG8uZGF5cyA9IE1hdGguZmxvb3IocmVtYWluIC8gODY0MDApO1xyXG4gICAgICAgICAgICByZW1haW4gJT0gODY0MDA7XHJcbiAgICAgICAgICAgIG8uaG91cnMgPSBNYXRoLmZsb29yKHJlbWFpbiAvIDM2MDApO1xyXG4gICAgICAgICAgICByZW1haW4gJT0gMzYwMDtcclxuICAgICAgICAgICAgby5taW51dGVzID0gTWF0aC5mbG9vcihyZW1haW4gLyA2MCk7XHJcbiAgICAgICAgICAgIHJlbWFpbiAlPSA2MDtcclxuICAgICAgICAgICAgby5zZWNvbmRzID0gcmVtYWluO1xyXG4gICAgICAgICAgICBvLnllYXJzID0gTWF0aC5mbG9vcihvLmRheXMgLyAzNjUpO1xyXG4gICAgICAgICAgICBvLm1vbnRocyA9IE1hdGguZmxvb3Ioby5kYXlzIC8gMzApO1xyXG4gICAgICAgICAgICBvLndlZWtzID0gTWF0aC5mbG9vcihvLmRheXMgLyA3KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBnZXRXZWVrID0gZnVuY3Rpb24oZGF0ZSkgeyBcclxuICAgICAgICAgICAgdmFyIG9uZWphbiA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwwLDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCgoKGRhdGUgLSBvbmVqYW4pIC8gODY0MDAwMDApICsgb25lamFuLmdldERheSgpKS83KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcclxuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgaW50ZXJ2YWw6IDEwMDAsXHJcbiAgICAgICAgICAgIG1zZ0Zvcm1hdDogJyVkIFtkYXl8ZGF5c10gJWhoICVtbSAlc3MnLFxyXG4gICAgICAgICAgICBtc2dOb3c6ICdOb3cgISdcclxuICAgICAgICB9LCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdmFyIHRva2VucyA9IHtcclxuICAgICAgICAgICAgeTogbmV3IFJlZ0V4cCAoJ1xcXFwleSguKz8pXFxcXFsoXFxcXHcrKVxcXFx8KFxcXFx3KylcXFxcXScsICdnJyksIC8vIHllYXJzIFxyXG4gICAgICAgICAgICBNOiBuZXcgUmVnRXhwICgnXFxcXCVNKC4rPylcXFxcWyhcXFxcdyspXFxcXHwoXFxcXHcrKVxcXFxdJywgJ2cnKSwgLy8gbW9udGhzIFxyXG4gICAgICAgICAgICB3OiBuZXcgUmVnRXhwICgnXFxcXCV3KC4rPylcXFxcWyhcXFxcdyspXFxcXHwoXFxcXHcrKVxcXFxdJywgJ2cnKSwgLy8gd2Vla3NcclxuICAgICAgICAgICAgZDogbmV3IFJlZ0V4cCAoJ1xcXFwlZCguKz8pXFxcXFsoXFxcXHcrKVxcXFx8KFxcXFx3KylcXFxcXScsICdnJyksIC8vIGRheXNcclxuICAgICAgICAgICAgaDogbmV3IFJlZ0V4cCAoJ1xcXFwlaCguKz8pXFxcXFsoXFxcXHcrKVxcXFx8KFxcXFx3KylcXFxcXScsICdnJyksIC8vIGhvdXJzXHJcbiAgICAgICAgICAgIG06IG5ldyBSZWdFeHAgKCdcXFxcJW0oLis/KVxcXFxbKFxcXFx3KylcXFxcfChcXFxcdyspXFxcXF0nLCAnZycpLCAvLyBtaW51dGVzXHJcbiAgICAgICAgICAgIHM6IG5ldyBSZWdFeHAgKCdcXFxcJXMoLis/KVxcXFxbKFxcXFx3KylcXFxcfChcXFxcdyspXFxcXF0nLCAnZycpICAvLyBzZWNvbmRzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGZvcm1hdFRva2VuID0gZnVuY3Rpb24oc3RyLCB0b2tlbiwgdmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoIXRva2Vuc1t0b2tlbl0pPyAnJzogc3RyLm1hdGNoKC9cXFt8XFxdL2cpIFxyXG4gICAgICAgICAgICAgICAgICAgICYmIChzdHIucmVwbGFjZSh0b2tlbnNbdG9rZW5dLCB2YWwrJyQxJysgKChwYXJzZUludCh2YWwsIDEwKTwyKT8nJDInOickMycpKSB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICB8fCBzdHIucmVwbGFjZSgnJScrdG9rZW4sIHZhbCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKHN0ciwgb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gc3RyO1xyXG4gICAgICAgICAgICBvID0gZm9ybWF0VG9rZW4obywgJ3knLCBvYmoueWVhcnMpO1xyXG4gICAgICAgICAgICBvID0gZm9ybWF0VG9rZW4obywgJ00nLCBvYmoubW9udGhzKTtcclxuICAgICAgICAgICAgbyA9IGZvcm1hdFRva2VuKG8sICd3Jywgb2JqLndlZWtzKTtcclxuICAgICAgICAgICAgbyA9IGZvcm1hdFRva2VuKG8sICdkJywgb2JqLmRheXMpO1xyXG4gICAgICAgICAgICBvID0gZm9ybWF0VG9rZW4obywgJ2gnLCBvYmouaG91cnMpO1xyXG4gICAgICAgICAgICBvID0gZm9ybWF0VG9rZW4obywgJ20nLCBvYmoubWludXRlcyk7XHJcbiAgICAgICAgICAgIG8gPSBmb3JtYXRUb2tlbihvLCAncycsIG9iai5zZWNvbmRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZV9vYmogPSBjYWxjKGNkLmRhdGUpO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZV9vYmogPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNkLnN0b3AoKTsgY2xlYXJJbnRlcnZhbChjZC5pZCk7XHJcbiAgICAgICAgICAgICAgICAkKGNkLmVsKS5odG1sKG9wdGlvbnMubXNnTm93KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJChjZC5lbCkudGV4dChmb3JtYXQob3B0aW9ucy5tc2dGb3JtYXQsIGRhdGVfb2JqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgYXBwbHlfbW9kaWZpZXJzID0gZnVuY3Rpb24gKG1vZGlmaWVycywgZGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBtb2RpZmllcl9yZSA9IC9eKFsrLV1cXGQrKShbeU1kaG1zXSkkLztcclxuICAgICAgICAgICAgdmFyIGNvbnZlcnNpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgczogMTAwMCxcclxuICAgICAgICAgICAgICAgIG06IDYwICogMTAwMCxcclxuICAgICAgICAgICAgICAgIGg6IDYwICogNjAgKiAxMDAwLFxyXG4gICAgICAgICAgICAgICAgZDogMjQgKiA2MCAqIDYwICogMTAwMCxcclxuICAgICAgICAgICAgICAgIE06IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcclxuICAgICAgICAgICAgICAgIHk6IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDBcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXNwbGFjZW1lbnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG1vZGlmaWVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1vZGlmaWVyc1tpXS5tYXRjaChtb2RpZmllcl9yZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSAqIGNvbnZlcnNpb25zW21hdGNoWzJdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBjZCA9IHtcclxuICAgICAgICAgICAgaWQgICAgOiBzZXRJbnRlcnZhbCh1cGRhdGUsIG9wdGlvbnMuaW50ZXJ2YWwpLFxyXG4gICAgICAgICAgICBlbCAgICA6IGVsLFxyXG4gICAgICAgICAgICBzdGFydCA6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgY291bnRkb3duKCQodGhpcy5lbCksIG9wdGlvbnMpOyB9LFxyXG4gICAgICAgICAgICBzdG9wICA6IGZ1bmN0aW9uKCl7IHJldHVybiBjbGVhckludGVydmFsKHRoaXMuaWQpOyB9LFxyXG4gICAgICAgICAgICBkYXRlICA6IGFwcGx5X21vZGlmaWVycyhvcHRpb25zLm1vZGlmaWVycywgb3B0aW9ucy5kYXRlKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgJChlbCkuZGF0YSgnY291bnRkb3duJywgY2QpO1xyXG4gICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiAkKGVsKS5kYXRhKCdjb3VudGRvd24nKTtcclxuICAgIH1cclxuICAgICQuZm4uY291bnRkb3duID0gZnVuY3Rpb24oYXJncykgeyBpZih0aGlzLmdldCgwKSkgcmV0dXJuIG5ldyBjb3VudGRvd24odGhpcy5nZXQoMCksIGFyZ3MpOyB9O1xyXG59KShqUXVlcnkpO1xyXG4vKlxyXG4gKiBqUXVlcnkgQ3ljbGUgUGx1Z2luIGZvciBsaWdodC13ZWlnaHQgc2xpZGVzaG93c1xyXG4gKiBFeGFtcGxlcyBhbmQgZG9jdW1lbnRhdGlvbiBhdDogaHR0cDovL21hbHN1cC5jb20vanF1ZXJ5L2N5Y2xlL1xyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAwOCBNLiBBbHN1cFxyXG4gKiBWZXJzaW9uOiAyLjI0ICgwNy8zMC8yMDA4KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlczpcclxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICogaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXHJcbiAqIFJlcXVpcmVzOiBqUXVlcnkgdjEuMi4zIG9yIGxhdGVyXHJcbiAqXHJcbiAqIEJhc2VkIG9uIHRoZSB3b3JrIG9mOlxyXG4gKiAgMSkgTWF0dCBPYWtlcyAoaHR0cDovL3BvcnRmb2xpby5naXpvbmUuY28udWsvYXBwbGljYXRpb25zL3NsaWRlc2hvdy8pXHJcbiAqICAyKSBUb3JzdGVuIEJhbGRlcyAoaHR0cDovL21lZGllbmZyZXVuZGUuY29tL2xhYi9pbm5lcmZhZGUvKVxyXG4gKiAgMykgQmVuamFtaW4gU3RlcmxpbmcgKGh0dHA6Ly93d3cuYmVuamFtaW5zdGVybGluZy5jb20vZXhwZXJpbWVudHMvanFTaHVmZmxlLylcclxuICovXHJcbjsoZnVuY3Rpb24oJCkge1xyXG5cclxudmFyIHZlciA9ICcyLjI0JztcclxudmFyIGllNiA9ICQuYnJvd3Nlci5tc2llICYmIC9NU0lFIDYuMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuXHJcbmZ1bmN0aW9uIGxvZygpIHtcclxuICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpXHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdbY3ljbGVdICcgKyBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywnJykpO1xyXG59O1xyXG5cclxuJC5mbi5jeWNsZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zID09PSBudWxsKVxyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29uc3RydWN0b3IgPT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0b3AnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3ljbGVUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5jeWNsZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jeWNsZVRpbWVvdXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdjeWNsZS5vcHRzJywgJycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlICdwYXVzZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN5Y2xlUGF1c2UgPSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlICdyZXN1bWUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jeWNsZVBhdXNlID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGZ4OiBvcHRpb25zIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29uc3RydWN0b3IgPT0gTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIC8vIGdvIHRvIHRoZSByZXF1ZXN0ZWQgc2xpZGUgc2xpZGVcclxuICAgICAgICAgICAgdmFyIG51bSA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSAkKHRoaXMpLmRhdGEoJ2N5Y2xlLm9wdHMnKTtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBsb2coJ29wdGlvbnMgbm90IGZvdW5kLCBjYW4gbm90IGFkdmFuY2Ugc2xpZGUnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobnVtIDwgMCB8fCBudW0gPj0gb3B0aW9ucy5lbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnaW52YWxpZCBzbGlkZSBpbmRleDogJyArIG51bSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy5uZXh0U2xpZGUgPSBudW07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN5Y2xlVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY3ljbGVUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3ljbGVUaW1lb3V0ID0gMDtcclxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnbyhvcHRpb25zLmVsZW1lbnRzLCBvcHRpb25zLCAxLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc3RvcCBleGlzdGluZyBzbGlkZXNob3cgZm9yIHRoaXMgY29udGFpbmVyIChpZiB0aGVyZSBpcyBvbmUpXHJcbiAgICAgICAgaWYgKHRoaXMuY3ljbGVUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5jeWNsZVRpbWVvdXQpO1xyXG4gICAgICAgIHRoaXMuY3ljbGVUaW1lb3V0ID0gMDtcclxuICAgICAgICB0aGlzLmN5Y2xlUGF1c2UgPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciAkY29udCA9ICQodGhpcyk7XHJcbiAgICAgICAgdmFyICRzbGlkZXMgPSBvcHRpb25zLnNsaWRlRXhwciA/ICQob3B0aW9ucy5zbGlkZUV4cHIsIHRoaXMpIDogJGNvbnQuY2hpbGRyZW4oKTtcclxuICAgICAgICB2YXIgZWxzID0gJHNsaWRlcy5nZXQoKTtcclxuICAgICAgICBpZiAoZWxzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgbG9nKCd0ZXJtaW5hdGluZzsgdG9vIGZldyBzbGlkZXM6ICcgKyBlbHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBkb24ndCBib3RoZXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN1cHBvcnQgbWV0YWRhdGEgcGx1Z2luICh2MS4wIGFuZCB2Mi4wKVxyXG4gICAgICAgIHZhciBvcHRzID0gJC5leHRlbmQoe30sICQuZm4uY3ljbGUuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30sICQubWV0YWRhdGEgPyAkY29udC5tZXRhZGF0YSgpIDogJC5tZXRhID8gJGNvbnQuZGF0YSgpIDoge30pO1xyXG4gICAgICAgIGlmIChvcHRzLmF1dG9zdG9wKSBcclxuICAgICAgICAgICAgb3B0cy5jb3VudGRvd24gPSBvcHRzLmF1dG9zdG9wQ291bnQgfHwgZWxzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgJGNvbnQuZGF0YSgnY3ljbGUub3B0cycsIG9wdHMpO1xyXG4gICAgICAgIG9wdHMuY29udGFpbmVyID0gdGhpcztcclxuXHJcbiAgICAgICAgb3B0cy5lbGVtZW50cyA9IGVscztcclxuICAgICAgICBvcHRzLmJlZm9yZSA9IG9wdHMuYmVmb3JlID8gW29wdHMuYmVmb3JlXSA6IFtdO1xyXG4gICAgICAgIG9wdHMuYWZ0ZXIgPSBvcHRzLmFmdGVyID8gW29wdHMuYWZ0ZXJdIDogW107XHJcbiAgICAgICAgb3B0cy5hZnRlci51bnNoaWZ0KGZ1bmN0aW9uKCl7IG9wdHMuYnVzeT0wOyB9KTtcclxuICAgICAgICBpZiAob3B0cy5jb250aW51b3VzKVxyXG4gICAgICAgICAgICBvcHRzLmFmdGVyLnB1c2goZnVuY3Rpb24oKSB7IGdvKGVscyxvcHRzLDAsIW9wdHMucmV2KTsgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vIGNsZWFyVHlwZSBjb3JyZWN0aW9uc1xyXG4gICAgICAgIGlmIChpZTYgJiYgb3B0cy5jbGVhcnR5cGUgJiYgIW9wdHMuY2xlYXJ0eXBlTm9CZylcclxuICAgICAgICAgICAgY2xlYXJUeXBlRml4KCRzbGlkZXMpO1xyXG5cclxuICAgICAgICAvLyBhbGxvdyBzaG9ydGhhbmQgb3ZlcnJpZGVzIG9mIHdpZHRoLCBoZWlnaHQgYW5kIHRpbWVvdXRcclxuICAgICAgICB2YXIgY2xzID0gdGhpcy5jbGFzc05hbWU7XHJcbiAgICAgICAgb3B0cy53aWR0aCA9IHBhcnNlSW50KChjbHMubWF0Y2goL3c6KFxcZCspLyl8fFtdKVsxXSkgfHwgb3B0cy53aWR0aDtcclxuICAgICAgICBvcHRzLmhlaWdodCA9IHBhcnNlSW50KChjbHMubWF0Y2goL2g6KFxcZCspLyl8fFtdKVsxXSkgfHwgb3B0cy5oZWlnaHQ7XHJcbiAgICAgICAgb3B0cy50aW1lb3V0ID0gcGFyc2VJbnQoKGNscy5tYXRjaCgvdDooXFxkKykvKXx8W10pWzFdKSB8fCBvcHRzLnRpbWVvdXQ7XHJcblxyXG4gICAgICAgIGlmICgkY29udC5jc3MoJ3Bvc2l0aW9uJykgPT0gJ3N0YXRpYycpIFxyXG4gICAgICAgICAgICAkY29udC5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XHJcbiAgICAgICAgaWYgKG9wdHMud2lkdGgpIFxyXG4gICAgICAgICAgICAkY29udC53aWR0aChvcHRzLndpZHRoKTtcclxuICAgICAgICBpZiAob3B0cy5oZWlnaHQgJiYgb3B0cy5oZWlnaHQgIT0gJ2F1dG8nKSBcclxuICAgICAgICAgICAgJGNvbnQuaGVpZ2h0KG9wdHMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdHMucmFuZG9tKSB7XHJcbiAgICAgICAgICAgIG9wdHMucmFuZG9tTWFwID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSBcclxuICAgICAgICAgICAgICAgIG9wdHMucmFuZG9tTWFwLnB1c2goaSk7XHJcbiAgICAgICAgICAgIG9wdHMucmFuZG9tTWFwLnNvcnQoZnVuY3Rpb24oYSxiKSB7cmV0dXJuIE1hdGgucmFuZG9tKCkgLSAwLjU7fSk7XHJcbiAgICAgICAgICAgIG9wdHMucmFuZG9tSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBvcHRzLnN0YXJ0aW5nU2xpZGUgPSBvcHRzLnJhbmRvbU1hcFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0cy5zdGFydGluZ1NsaWRlID49IGVscy5sZW5ndGgpXHJcbiAgICAgICAgICAgIG9wdHMuc3RhcnRpbmdTbGlkZSA9IDA7IC8vIGNhdGNoIGJvZ3VzIGlucHV0XHJcbiAgICAgICAgdmFyIGZpcnN0ID0gb3B0cy5zdGFydGluZ1NsaWRlIHx8IDA7XHJcbiAgICAgICAgJHNsaWRlcy5jc3Moe3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6MCwgbGVmdDowfSkuaGlkZSgpLmVhY2goZnVuY3Rpb24oaSkgeyBcclxuICAgICAgICAgICAgdmFyIHogPSBmaXJzdCA/IGkgPj0gZmlyc3QgPyBlbHMubGVuZ3RoIC0gKGktZmlyc3QpIDogZmlyc3QtaSA6IGVscy5sZW5ndGgtaTtcclxuICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ3otaW5kZXgnLCB6KSBcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAkKGVsc1tmaXJzdF0pLmNzcygnb3BhY2l0eScsMSkuc2hvdygpOyAvLyBvcGFjaXR5IGJpdCBuZWVkZWQgdG8gaGFuZGxlIHJlaW5pdCBjYXNlXHJcbiAgICAgICAgaWYgKCQuYnJvd3Nlci5tc2llKSBlbHNbZmlyc3RdLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7XHJcblxyXG4gICAgICAgIGlmIChvcHRzLmZpdCAmJiBvcHRzLndpZHRoKSBcclxuICAgICAgICAgICAgJHNsaWRlcy53aWR0aChvcHRzLndpZHRoKTtcclxuICAgICAgICBpZiAob3B0cy5maXQgJiYgb3B0cy5oZWlnaHQgJiYgb3B0cy5oZWlnaHQgIT0gJ2F1dG8nKSBcclxuICAgICAgICAgICAgJHNsaWRlcy5oZWlnaHQob3B0cy5oZWlnaHQpO1xyXG4gICAgICAgIGlmIChvcHRzLnBhdXNlKSBcclxuICAgICAgICAgICAgJGNvbnQuaG92ZXIoZnVuY3Rpb24oKXt0aGlzLmN5Y2xlUGF1c2U9MTt9LGZ1bmN0aW9uKCl7dGhpcy5jeWNsZVBhdXNlPTA7fSk7XHJcblxyXG4gICAgICAgIC8vIHJ1biB0cmFuc2l0aW9uIGluaXQgZm5cclxuICAgICAgICB2YXIgaW5pdCA9ICQuZm4uY3ljbGUudHJhbnNpdGlvbnNbb3B0cy5meF07XHJcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihpbml0KSlcclxuICAgICAgICAgICAgaW5pdCgkY29udCwgJHNsaWRlcywgb3B0cyk7XHJcbiAgICAgICAgZWxzZSBpZiAob3B0cy5meCAhPSAnY3VzdG9tJylcclxuICAgICAgICAgICAgbG9nKCd1bmtub3duIHRyYW5zaXRpb246ICcgKyBvcHRzLmZ4KTtcclxuICAgICAgICBcclxuICAgICAgICAkc2xpZGVzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciAkZWwgPSAkKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmN5Y2xlSCA9IChvcHRzLmZpdCAmJiBvcHRzLmhlaWdodCkgPyBvcHRzLmhlaWdodCA6ICRlbC5oZWlnaHQoKTtcclxuICAgICAgICAgICAgdGhpcy5jeWNsZVcgPSAob3B0cy5maXQgJiYgb3B0cy53aWR0aCkgPyBvcHRzLndpZHRoIDogJGVsLndpZHRoKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0gb3B0cy5jc3NCZWZvcmUgfHwge307XHJcbiAgICAgICAgb3B0cy5hbmltSW4gPSBvcHRzLmFuaW1JbiB8fCB7fTtcclxuICAgICAgICBvcHRzLmFuaW1PdXQgPSBvcHRzLmFuaW1PdXQgfHwge307XHJcblxyXG4gICAgICAgICRzbGlkZXMubm90KCc6ZXEoJytmaXJzdCsnKScpLmNzcyhvcHRzLmNzc0JlZm9yZSk7XHJcbiAgICAgICAgaWYgKG9wdHMuY3NzRmlyc3QpXHJcbiAgICAgICAgICAgICQoJHNsaWRlc1tmaXJzdF0pLmNzcyhvcHRzLmNzc0ZpcnN0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdHMudGltZW91dCkge1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aW1lb3V0IGFuZCBzcGVlZCBzZXR0aW5ncyBhcmUgc2FuZVxyXG4gICAgICAgICAgICBpZiAob3B0cy5zcGVlZC5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXHJcbiAgICAgICAgICAgICAgICBvcHRzLnNwZWVkID0ge3Nsb3c6IDYwMCwgZmFzdDogMjAwfVtvcHRzLnNwZWVkXSB8fCA0MDA7XHJcbiAgICAgICAgICAgIGlmICghb3B0cy5zeW5jKVxyXG4gICAgICAgICAgICAgICAgb3B0cy5zcGVlZCA9IG9wdHMuc3BlZWQgLyAyO1xyXG4gICAgICAgICAgICB3aGlsZSgob3B0cy50aW1lb3V0IC0gb3B0cy5zcGVlZCkgPCAyNTApXHJcbiAgICAgICAgICAgICAgICBvcHRzLnRpbWVvdXQgKz0gb3B0cy5zcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMuZWFzaW5nKSBcclxuICAgICAgICAgICAgb3B0cy5lYXNlSW4gPSBvcHRzLmVhc2VPdXQgPSBvcHRzLmVhc2luZztcclxuICAgICAgICBpZiAoIW9wdHMuc3BlZWRJbikgXHJcbiAgICAgICAgICAgIG9wdHMuc3BlZWRJbiA9IG9wdHMuc3BlZWQ7XHJcbiAgICAgICAgaWYgKCFvcHRzLnNwZWVkT3V0KSBcclxuICAgICAgICAgICAgb3B0cy5zcGVlZE91dCA9IG9wdHMuc3BlZWQ7XHJcblxyXG4gXHRcdG9wdHMuc2xpZGVDb3VudCA9IGVscy5sZW5ndGg7XHJcbiAgICAgICAgb3B0cy5jdXJyU2xpZGUgPSBmaXJzdDtcclxuICAgICAgICBpZiAob3B0cy5yYW5kb20pIHtcclxuICAgICAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBvcHRzLmN1cnJTbGlkZTtcclxuICAgICAgICAgICAgaWYgKCsrb3B0cy5yYW5kb21JbmRleCA9PSBlbHMubGVuZ3RoKSBcclxuICAgICAgICAgICAgICAgIG9wdHMucmFuZG9tSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBvcHRzLm5leHRTbGlkZSA9IG9wdHMucmFuZG9tTWFwW29wdHMucmFuZG9tSW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG9wdHMubmV4dFNsaWRlID0gb3B0cy5zdGFydGluZ1NsaWRlID49IChlbHMubGVuZ3RoLTEpID8gMCA6IG9wdHMuc3RhcnRpbmdTbGlkZSsxO1xyXG5cclxuICAgICAgICAvLyBmaXJlIGFydGlmaWNpYWwgZXZlbnRzXHJcbiAgICAgICAgdmFyIGUwID0gJHNsaWRlc1tmaXJzdF07XHJcbiAgICAgICAgaWYgKG9wdHMuYmVmb3JlLmxlbmd0aClcclxuICAgICAgICAgICAgb3B0cy5iZWZvcmVbMF0uYXBwbHkoZTAsIFtlMCwgZTAsIG9wdHMsIHRydWVdKTtcclxuICAgICAgICBpZiAob3B0cy5hZnRlci5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgICBvcHRzLmFmdGVyWzFdLmFwcGx5KGUwLCBbZTAsIGUwLCBvcHRzLCB0cnVlXSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG9wdHMuY2xpY2sgJiYgIW9wdHMubmV4dClcclxuICAgICAgICAgICAgb3B0cy5uZXh0ID0gb3B0cy5jbGljaztcclxuICAgICAgICBpZiAob3B0cy5uZXh0KVxyXG4gICAgICAgICAgICAkKG9wdHMubmV4dCkuYmluZCgnY2xpY2snLCBmdW5jdGlvbigpe3JldHVybiBhZHZhbmNlKGVscyxvcHRzLG9wdHMucmV2Py0xOjEpfSk7XHJcbiAgICAgICAgaWYgKG9wdHMucHJldilcclxuICAgICAgICAgICAgJChvcHRzLnByZXYpLmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24oKXtyZXR1cm4gYWR2YW5jZShlbHMsb3B0cyxvcHRzLnJldj8xOi0xKX0pO1xyXG4gICAgICAgIGlmIChvcHRzLnBhZ2VyKVxyXG4gICAgICAgICAgICBidWlsZFBhZ2VyKGVscyxvcHRzKTtcclxuXHJcbiAgICAgICAgLy8gZXhwb3NlIGZuIGZvciBhZGRpbmcgc2xpZGVzIGFmdGVyIHRoZSBzaG93IGhhcyBzdGFydGVkXHJcbiAgICAgICAgb3B0cy5hZGRTbGlkZSA9IGZ1bmN0aW9uKG5ld1NsaWRlKSB7XHJcbiAgICAgICAgICAgIHZhciAkcyA9ICQobmV3U2xpZGUpLCBzID0gJHNbMF07XHJcbiAgICAgICAgICAgIGlmICghb3B0cy5hdXRvc3RvcENvdW50KVxyXG4gICAgICAgICAgICAgICAgb3B0cy5jb3VudGRvd24rKztcclxuICAgICAgICAgICAgZWxzLnB1c2gocyk7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmVscykgXHJcbiAgICAgICAgICAgICAgICBvcHRzLmVscy5wdXNoKHMpOyAvLyBzaHVmZmxlIG5lZWRzIHRoaXNcclxuICAgICAgICAgICAgb3B0cy5zbGlkZUNvdW50ID0gZWxzLmxlbmd0aDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICRzLmNzcygncG9zaXRpb24nLCdhYnNvbHV0ZScpLmFwcGVuZFRvKCRjb250KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpZTYgJiYgb3B0cy5jbGVhcnR5cGUgJiYgIW9wdHMuY2xlYXJ0eXBlTm9CZylcclxuICAgICAgICAgICAgICAgIGNsZWFyVHlwZUZpeCgkcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0cy5maXQgJiYgb3B0cy53aWR0aCkgXHJcbiAgICAgICAgICAgICAgICAkcy53aWR0aChvcHRzLndpZHRoKTtcclxuICAgICAgICAgICAgaWYgKG9wdHMuZml0ICYmIG9wdHMuaGVpZ2h0ICYmIG9wdHMuaGVpZ2h0ICE9ICdhdXRvJykgXHJcbiAgICAgICAgICAgICAgICAkc2xpZGVzLmhlaWdodChvcHRzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHMuY3ljbGVIID0gKG9wdHMuZml0ICYmIG9wdHMuaGVpZ2h0KSA/IG9wdHMuaGVpZ2h0IDogJHMuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHMuY3ljbGVXID0gKG9wdHMuZml0ICYmIG9wdHMud2lkdGgpID8gb3B0cy53aWR0aCA6ICRzLndpZHRoKCk7XHJcblxyXG4gICAgICAgICAgICAkcy5jc3Mob3B0cy5jc3NCZWZvcmUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMucGFnZXIpXHJcbiAgICAgICAgICAgICAgICAkLmZuLmN5Y2xlLmNyZWF0ZVBhZ2VyQW5jaG9yKGVscy5sZW5ndGgtMSwgcywgJChvcHRzLnBhZ2VyKSwgZWxzLCBvcHRzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbkFkZFNsaWRlID09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgICAgICBvcHRzLm9uQWRkU2xpZGUoJHMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChvcHRzLnRpbWVvdXQgfHwgb3B0cy5jb250aW51b3VzKVxyXG4gICAgICAgICAgICB0aGlzLmN5Y2xlVGltZW91dCA9IHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpe2dvKGVscyxvcHRzLDAsIW9wdHMucmV2KX0sIFxyXG4gICAgICAgICAgICAgICAgb3B0cy5jb250aW51b3VzID8gMTAgOiBvcHRzLnRpbWVvdXQgKyAob3B0cy5kZWxheXx8MCkpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnbyhlbHMsIG9wdHMsIG1hbnVhbCwgZndkKSB7XHJcbiAgICBpZiAob3B0cy5idXN5KSByZXR1cm47XHJcbiAgICB2YXIgcCA9IG9wdHMuY29udGFpbmVyLCBjdXJyID0gZWxzW29wdHMuY3VyclNsaWRlXSwgbmV4dCA9IGVsc1tvcHRzLm5leHRTbGlkZV07XHJcbiAgICBpZiAocC5jeWNsZVRpbWVvdXQgPT09IDAgJiYgIW1hbnVhbCkgXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICghbWFudWFsICYmICFwLmN5Y2xlUGF1c2UgJiYgXHJcbiAgICAgICAgKChvcHRzLmF1dG9zdG9wICYmICgtLW9wdHMuY291bnRkb3duIDw9IDApKSB8fFxyXG4gICAgICAgIChvcHRzLm5vd3JhcCAmJiAhb3B0cy5yYW5kb20gJiYgb3B0cy5uZXh0U2xpZGUgPCBvcHRzLmN1cnJTbGlkZSkpKSB7XHJcbiAgICAgICAgaWYgKG9wdHMuZW5kKVxyXG4gICAgICAgICAgICBvcHRzLmVuZChvcHRzKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hbnVhbCB8fCAhcC5jeWNsZVBhdXNlKSB7XHJcbiAgICAgICAgaWYgKG9wdHMuYmVmb3JlLmxlbmd0aClcclxuICAgICAgICAgICAgJC5lYWNoKG9wdHMuYmVmb3JlLCBmdW5jdGlvbihpLG8pIHsgby5hcHBseShuZXh0LCBbY3VyciwgbmV4dCwgb3B0cywgZndkXSk7IH0pO1xyXG4gICAgICAgIHZhciBhZnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoJC5icm93c2VyLm1zaWUgJiYgb3B0cy5jbGVhcnR5cGUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7XHJcbiAgICAgICAgICAgICQuZWFjaChvcHRzLmFmdGVyLCBmdW5jdGlvbihpLG8pIHsgby5hcHBseShuZXh0LCBbY3VyciwgbmV4dCwgb3B0cywgZndkXSk7IH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChvcHRzLm5leHRTbGlkZSAhPSBvcHRzLmN1cnJTbGlkZSkge1xyXG4gICAgICAgICAgICBvcHRzLmJ1c3kgPSAxO1xyXG4gICAgICAgICAgICBpZiAob3B0cy5meEZuKVxyXG4gICAgICAgICAgICAgICAgb3B0cy5meEZuKGN1cnIsIG5leHQsIG9wdHMsIGFmdGVyLCBmd2QpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24oJC5mbi5jeWNsZVtvcHRzLmZ4XSkpXHJcbiAgICAgICAgICAgICAgICAkLmZuLmN5Y2xlW29wdHMuZnhdKGN1cnIsIG5leHQsIG9wdHMsIGFmdGVyKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgJC5mbi5jeWNsZS5jdXN0b20oY3VyciwgbmV4dCwgb3B0cywgYWZ0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0cy5yYW5kb20pIHtcclxuICAgICAgICAgICAgb3B0cy5jdXJyU2xpZGUgPSBvcHRzLm5leHRTbGlkZTtcclxuICAgICAgICAgICAgaWYgKCsrb3B0cy5yYW5kb21JbmRleCA9PSBlbHMubGVuZ3RoKSBcclxuICAgICAgICAgICAgICAgIG9wdHMucmFuZG9tSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBvcHRzLm5leHRTbGlkZSA9IG9wdHMucmFuZG9tTWFwW29wdHMucmFuZG9tSW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHsgLy8gc2VxdWVuY2VcclxuICAgICAgICAgICAgdmFyIHJvbGwgPSAob3B0cy5uZXh0U2xpZGUgKyAxKSA9PSBlbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBvcHRzLm5leHRTbGlkZSA9IHJvbGwgPyAwIDogb3B0cy5uZXh0U2xpZGUrMTtcclxuICAgICAgICAgICAgb3B0cy5jdXJyU2xpZGUgPSByb2xsID8gZWxzLmxlbmd0aC0xIDogb3B0cy5uZXh0U2xpZGUtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMucGFnZXIpXHJcbiAgICAgICAgICAgICQuZm4uY3ljbGUudXBkYXRlQWN0aXZlUGFnZXJMaW5rKG9wdHMucGFnZXIsIG9wdHMuY3VyclNsaWRlKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRzLnRpbWVvdXQgJiYgIW9wdHMuY29udGludW91cylcclxuICAgICAgICBwLmN5Y2xlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGdvKGVscyxvcHRzLDAsIW9wdHMucmV2KSB9LCBvcHRzLnRpbWVvdXQpO1xyXG4gICAgZWxzZSBpZiAob3B0cy5jb250aW51b3VzICYmIHAuY3ljbGVQYXVzZSkgXHJcbiAgICAgICAgcC5jeWNsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBnbyhlbHMsb3B0cywwLCFvcHRzLnJldikgfSwgMTApO1xyXG59O1xyXG5cclxuJC5mbi5jeWNsZS51cGRhdGVBY3RpdmVQYWdlckxpbmsgPSBmdW5jdGlvbihwYWdlciwgY3VyclNsaWRlKSB7XHJcbiAgICAkKHBhZ2VyKS5maW5kKCdhJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZVNsaWRlJykuZmlsdGVyKCdhOmVxKCcrY3VyclNsaWRlKycpJykuYWRkQ2xhc3MoJ2FjdGl2ZVNsaWRlJyk7XHJcbn07XHJcblxyXG4vLyBhZHZhbmNlIHNsaWRlIGZvcndhcmQgb3IgYmFja1xyXG5mdW5jdGlvbiBhZHZhbmNlKGVscywgb3B0cywgdmFsKSB7XHJcbiAgICB2YXIgcCA9IG9wdHMuY29udGFpbmVyLCB0aW1lb3V0ID0gcC5jeWNsZVRpbWVvdXQ7XHJcbiAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICBwLmN5Y2xlVGltZW91dCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0cy5yYW5kb20gJiYgdmFsIDwgMCkge1xyXG4gICAgICAgIC8vIG1vdmUgYmFjayB0byB0aGUgcHJldmlvdXNseSBkaXNwbGF5IHNsaWRlXHJcbiAgICAgICAgb3B0cy5yYW5kb21JbmRleC0tO1xyXG4gICAgICAgIGlmICgtLW9wdHMucmFuZG9tSW5kZXggPT0gLTIpXHJcbiAgICAgICAgICAgIG9wdHMucmFuZG9tSW5kZXggPSBlbHMubGVuZ3RoLTI7XHJcbiAgICAgICAgZWxzZSBpZiAob3B0cy5yYW5kb21JbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgb3B0cy5yYW5kb21JbmRleCA9IGVscy5sZW5ndGgtMTtcclxuICAgICAgICBvcHRzLm5leHRTbGlkZSA9IG9wdHMucmFuZG9tTWFwW29wdHMucmFuZG9tSW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3B0cy5yYW5kb20pIHtcclxuICAgICAgICBpZiAoKytvcHRzLnJhbmRvbUluZGV4ID09IGVscy5sZW5ndGgpIFxyXG4gICAgICAgICAgICBvcHRzLnJhbmRvbUluZGV4ID0gMDtcclxuICAgICAgICBvcHRzLm5leHRTbGlkZSA9IG9wdHMucmFuZG9tTWFwW29wdHMucmFuZG9tSW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb3B0cy5uZXh0U2xpZGUgPSBvcHRzLmN1cnJTbGlkZSArIHZhbDtcclxuICAgICAgICBpZiAob3B0cy5uZXh0U2xpZGUgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLm5vd3JhcCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBvcHRzLm5leHRTbGlkZSA9IGVscy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRzLm5leHRTbGlkZSA+PSBlbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLm5vd3JhcCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBvcHRzLm5leHRTbGlkZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbmxvZygnbmV4dFNsaWRlOiAnICsgb3B0cy5uZXh0U2xpZGUgKyAnOyByYW5kb21JbmRleDogJyArIG9wdHMucmFuZG9tSW5kZXgpOyAgICBcclxuICAgIGlmIChvcHRzLnByZXZOZXh0Q2xpY2sgJiYgdHlwZW9mIG9wdHMucHJldk5leHRDbGljayA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIG9wdHMucHJldk5leHRDbGljayh2YWwgPiAwLCBvcHRzLm5leHRTbGlkZSwgZWxzW29wdHMubmV4dFNsaWRlXSk7XHJcbiAgICBnbyhlbHMsIG9wdHMsIDEsIHZhbD49MCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBidWlsZFBhZ2VyKGVscywgb3B0cykge1xyXG4gICAgdmFyICRwID0gJChvcHRzLnBhZ2VyKTtcclxuICAgICQuZWFjaChlbHMsIGZ1bmN0aW9uKGksbykge1xyXG4gICAgICAgICQuZm4uY3ljbGUuY3JlYXRlUGFnZXJBbmNob3IoaSxvLCRwLGVscyxvcHRzKTtcclxuICAgIH0pO1xyXG4gICAkLmZuLmN5Y2xlLnVwZGF0ZUFjdGl2ZVBhZ2VyTGluayhvcHRzLnBhZ2VyLCBvcHRzLnN0YXJ0aW5nU2xpZGUpO1xyXG59O1xyXG5cclxuJC5mbi5jeWNsZS5jcmVhdGVQYWdlckFuY2hvciA9IGZ1bmN0aW9uKGksIGVsLCAkcCwgZWxzLCBvcHRzKSB7XHJcbiAgICB2YXIgJGEgPSAodHlwZW9mIG9wdHMucGFnZXJBbmNob3JCdWlsZGVyID09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgPyAkKG9wdHMucGFnZXJBbmNob3JCdWlsZGVyKGksZWwpKVxyXG4gICAgICAgIDogJCgnPGEgaHJlZj1cIiNcIj4nKyhpKzEpKyc8L2E+Jyk7XHJcbiAgICBcclxuICAgIC8vIGRvbid0IHJlcGFyZW50IGlmIGFuY2hvciBpcyBpbiB0aGUgZG9tXHJcbiAgICBpZiAoJGEucGFyZW50cygnYm9keScpLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICRhLmFwcGVuZFRvKCRwKTtcclxuICAgICAgICBcclxuICAgICRhLmJpbmQob3B0cy5wYWdlckV2ZW50LCBmdW5jdGlvbigpIHtcclxuICAgICAgICBvcHRzLm5leHRTbGlkZSA9IGk7XHJcbiAgICAgICAgdmFyIHAgPSBvcHRzLmNvbnRhaW5lciwgdGltZW91dCA9IHAuY3ljbGVUaW1lb3V0O1xyXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgcC5jeWNsZVRpbWVvdXQgPSAwO1xyXG4gICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICBpZiAodHlwZW9mIG9wdHMucGFnZXJDbGljayA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICBvcHRzLnBhZ2VyQ2xpY2sob3B0cy5uZXh0U2xpZGUsIGVsc1tvcHRzLm5leHRTbGlkZV0pO1xyXG4gICAgICAgIGdvKGVscyxvcHRzLDEsb3B0cy5jdXJyU2xpZGUgPCBpKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG4vLyB0aGlzIGZpeGVzIGNsZWFyVHlwZSBwcm9ibGVtcyBpbiBpZTYgYnkgc2V0dGluZyBhbiBleHBsaWNpdCBiZyBjb2xvclxyXG5mdW5jdGlvbiBjbGVhclR5cGVGaXgoJHNsaWRlcykge1xyXG4gICAgZnVuY3Rpb24gaGV4KHMpIHtcclxuICAgICAgICB2YXIgcyA9IHBhcnNlSW50KHMpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICByZXR1cm4gcy5sZW5ndGggPCAyID8gJzAnK3MgOiBzO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGdldEJnKGUpIHtcclxuICAgICAgICBmb3IgKCA7IGUgJiYgZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdodG1sJzsgZSA9IGUucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgdiA9ICQuY3NzKGUsJ2JhY2tncm91bmQtY29sb3InKTtcclxuICAgICAgICAgICAgaWYgKHYuaW5kZXhPZigncmdiJykgPj0gMCApIHsgXHJcbiAgICAgICAgICAgICAgICB2YXIgcmdiID0gdi5tYXRjaCgvXFxkKy9nKTsgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyMnKyBoZXgocmdiWzBdKSArIGhleChyZ2JbMV0pICsgaGV4KHJnYlsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHYgJiYgdiAhPSAndHJhbnNwYXJlbnQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnI2ZmZmZmZic7XHJcbiAgICB9O1xyXG4gICAgJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCkgeyAkKHRoaXMpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGdldEJnKHRoaXMpKTsgfSk7XHJcbn07XHJcblxyXG5cclxuJC5mbi5jeWNsZS5jdXN0b20gPSBmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzLCBjYikge1xyXG4gICAgdmFyICRsID0gJChjdXJyKSwgJG4gPSAkKG5leHQpO1xyXG4gICAgJG4uY3NzKG9wdHMuY3NzQmVmb3JlKTtcclxuICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyRuLmFuaW1hdGUob3B0cy5hbmltSW4sIG9wdHMuc3BlZWRJbiwgb3B0cy5lYXNlSW4sIGNiKX07XHJcbiAgICAkbC5hbmltYXRlKG9wdHMuYW5pbU91dCwgb3B0cy5zcGVlZE91dCwgb3B0cy5lYXNlT3V0LCBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAob3B0cy5jc3NBZnRlcikgJGwuY3NzKG9wdHMuY3NzQWZ0ZXIpO1xyXG4gICAgICAgIGlmICghb3B0cy5zeW5jKSBmbigpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAob3B0cy5zeW5jKSBmbigpO1xyXG59O1xyXG5cclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucyA9IHtcclxuICAgIGZhZGU6IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICAgICAgJHNsaWRlcy5ub3QoJzplcSgnK29wdHMuc3RhcnRpbmdTbGlkZSsnKScpLmNzcygnb3BhY2l0eScsMCk7XHJcbiAgICAgICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbigpIHsgJCh0aGlzKS5zaG93KCkgfSk7XHJcbiAgICAgICAgb3B0cy5hbmltSW4gICAgPSB7IG9wYWNpdHk6IDEgfTtcclxuICAgICAgICBvcHRzLmFuaW1PdXQgICA9IHsgb3BhY2l0eTogMCB9O1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0geyBvcGFjaXR5OiAwIH07XHJcbiAgICAgICAgb3B0cy5jc3NBZnRlciAgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuJC5mbi5jeWNsZS52ZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHZlcjsgfTtcclxuXHJcbi8vIG92ZXJyaWRlIHRoZXNlIGdsb2JhbGx5IGlmIHlvdSBsaWtlICh0aGV5IGFyZSBhbGwgb3B0aW9uYWwpXHJcbiQuZm4uY3ljbGUuZGVmYXVsdHMgPSB7XHJcbiAgICBmeDogICAgICAgICAgICdmYWRlJywgLy8gb25lIG9mOiBmYWRlLCBzaHVmZmxlLCB6b29tLCBzY3JvbGxMZWZ0LCBldGNcclxuICAgIHRpbWVvdXQ6ICAgICAgIDQwMDAsICAvLyBtaWxsaXNlY29uZHMgYmV0d2VlbiBzbGlkZSB0cmFuc2l0aW9ucyAoMCB0byBkaXNhYmxlIGF1dG8gYWR2YW5jZSlcclxuICAgIGNvbnRpbnVvdXM6ICAgIDAsICAgICAvLyB0cnVlIHRvIHN0YXJ0IG5leHQgdHJhbnNpdGlvbiBpbW1lZGlhdGVseSBhZnRlciBjdXJyZW50IG9uZSBjb21wbGV0ZXNcclxuICAgIHNwZWVkOiAgICAgICAgIDEwMDAsICAvLyBzcGVlZCBvZiB0aGUgdHJhbnNpdGlvbiAoYW55IHZhbGlkIGZ4IHNwZWVkIHZhbHVlKVxyXG4gICAgc3BlZWRJbjogICAgICAgbnVsbCwgIC8vIHNwZWVkIG9mIHRoZSAnaW4nIHRyYW5zaXRpb25cclxuICAgIHNwZWVkT3V0OiAgICAgIG51bGwsICAvLyBzcGVlZCBvZiB0aGUgJ291dCcgdHJhbnNpdGlvblxyXG4gICAgbmV4dDogICAgICAgICAgbnVsbCwgIC8vIGlkIG9mIGVsZW1lbnQgdG8gdXNlIGFzIGNsaWNrIHRyaWdnZXIgZm9yIG5leHQgc2xpZGVcclxuICAgIHByZXY6ICAgICAgICAgIG51bGwsICAvLyBpZCBvZiBlbGVtZW50IHRvIHVzZSBhcyBjbGljayB0cmlnZ2VyIGZvciBwcmV2aW91cyBzbGlkZVxyXG4gICAgcHJldk5leHRDbGljazogbnVsbCwgIC8vIGNhbGxiYWNrIGZuIGZvciBwcmV2L25leHQgY2xpY2tzOiAgZnVuY3Rpb24oaXNOZXh0LCB6ZXJvQmFzZWRTbGlkZUluZGV4LCBzbGlkZUVsZW1lbnQpXHJcbiAgICBwYWdlcjogICAgICAgICBudWxsLCAgLy8gaWQgb2YgZWxlbWVudCB0byB1c2UgYXMgcGFnZXIgY29udGFpbmVyXHJcbiAgICBwYWdlckNsaWNrOiAgICBudWxsLCAgLy8gY2FsbGJhY2sgZm4gZm9yIHBhZ2VyIGNsaWNrczogIGZ1bmN0aW9uKHplcm9CYXNlZFNsaWRlSW5kZXgsIHNsaWRlRWxlbWVudClcclxuICAgIHBhZ2VyRXZlbnQ6ICAgJ2NsaWNrJywgLy8gZXZlbnQgd2hpY2ggZHJpdmVzIHRoZSBwYWdlciBuYXZpZ2F0aW9uXHJcbiAgICBwYWdlckFuY2hvckJ1aWxkZXI6IG51bGwsIC8vIGNhbGxiYWNrIGZuIGZvciBidWlsZGluZyBhbmNob3IgbGlua3NcclxuICAgIGJlZm9yZTogICAgICAgIG51bGwsICAvLyB0cmFuc2l0aW9uIGNhbGxiYWNrIChzY29wZSBzZXQgdG8gZWxlbWVudCB0byBiZSBzaG93bilcclxuICAgIGFmdGVyOiAgICAgICAgIG51bGwsICAvLyB0cmFuc2l0aW9uIGNhbGxiYWNrIChzY29wZSBzZXQgdG8gZWxlbWVudCB0aGF0IHdhcyBzaG93bilcclxuICAgIGVuZDogICAgICAgICAgIG51bGwsICAvLyBjYWxsYmFjayBpbnZva2VkIHdoZW4gdGhlIHNsaWRlc2hvdyB0ZXJtaW5hdGVzICh1c2Ugd2l0aCBhdXRvc3RvcCBvciBub3dyYXAgb3B0aW9ucylcclxuICAgIGVhc2luZzogICAgICAgIG51bGwsICAvLyBlYXNpbmcgbWV0aG9kIGZvciBib3RoIGluIGFuZCBvdXQgdHJhbnNpdGlvbnNcclxuICAgIGVhc2VJbjogICAgICAgIG51bGwsICAvLyBlYXNpbmcgZm9yIFwiaW5cIiB0cmFuc2l0aW9uXHJcbiAgICBlYXNlT3V0OiAgICAgICBudWxsLCAgLy8gZWFzaW5nIGZvciBcIm91dFwiIHRyYW5zaXRpb25cclxuICAgIHNodWZmbGU6ICAgICAgIG51bGwsICAvLyBjb29yZHMgZm9yIHNodWZmbGUgYW5pbWF0aW9uLCBleDogeyB0b3A6MTUsIGxlZnQ6IDIwMCB9XHJcbiAgICBhbmltSW46ICAgICAgICBudWxsLCAgLy8gcHJvcGVydGllcyB0aGF0IGRlZmluZSBob3cgdGhlIHNsaWRlIGFuaW1hdGVzIGluXHJcbiAgICBhbmltT3V0OiAgICAgICBudWxsLCAgLy8gcHJvcGVydGllcyB0aGF0IGRlZmluZSBob3cgdGhlIHNsaWRlIGFuaW1hdGVzIG91dFxyXG4gICAgY3NzQmVmb3JlOiAgICAgbnVsbCwgIC8vIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHNsaWRlIGJlZm9yZSB0cmFuc2l0aW9uaW5nIGluXHJcbiAgICBjc3NBZnRlcjogICAgICBudWxsLCAgLy8gcHJvcGVydGllcyB0aGF0IGRlZmluZWQgdGhlIHN0YXRlIG9mIHRoZSBzbGlkZSBhZnRlciB0cmFuc2l0aW9uaW5nIG91dFxyXG4gICAgZnhGbjogICAgICAgICAgbnVsbCwgIC8vIGZ1bmN0aW9uIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhbnNpdGlvblxyXG4gICAgaGVpZ2h0OiAgICAgICAnYXV0bycsIC8vIGNvbnRhaW5lciBoZWlnaHRcclxuICAgIHN0YXJ0aW5nU2xpZGU6IDAsICAgICAvLyB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBmaXJzdCBzbGlkZSB0byBiZSBkaXNwbGF5ZWRcclxuICAgIHN5bmM6ICAgICAgICAgIDEsICAgICAvLyB0cnVlIGlmIGluL291dCB0cmFuc2l0aW9ucyBzaG91bGQgb2NjdXIgc2ltdWx0YW5lb3VzbHlcclxuICAgIHJhbmRvbTogICAgICAgIDAsICAgICAvLyB0cnVlIGZvciByYW5kb20sIGZhbHNlIGZvciBzZXF1ZW5jZSAobm90IGFwcGxpY2FibGUgdG8gc2h1ZmZsZSBmeClcclxuICAgIGZpdDogICAgICAgICAgIDAsICAgICAvLyBmb3JjZSBzbGlkZXMgdG8gZml0IGNvbnRhaW5lclxyXG4gICAgcGF1c2U6ICAgICAgICAgMCwgICAgIC8vIHRydWUgdG8gZW5hYmxlIFwicGF1c2Ugb24gaG92ZXJcIlxyXG4gICAgYXV0b3N0b3A6ICAgICAgMCwgICAgIC8vIHRydWUgdG8gZW5kIHNsaWRlc2hvdyBhZnRlciBYIHRyYW5zaXRpb25zICh3aGVyZSBYID09IHNsaWRlIGNvdW50KVxyXG4gICAgYXV0b3N0b3BDb3VudDogMCwgICAgIC8vIG51bWJlciBvZiB0cmFuc2l0aW9ucyAob3B0aW9uYWxseSB1c2VkIHdpdGggYXV0b3N0b3AgdG8gZGVmaW5lIFgpXHJcbiAgICBkZWxheTogICAgICAgICAwLCAgICAgLy8gYWRkaXRpb25hbCBkZWxheSAoaW4gbXMpIGZvciBmaXJzdCB0cmFuc2l0aW9uIChoaW50OiBjYW4gYmUgbmVnYXRpdmUpXHJcbiAgICBzbGlkZUV4cHI6ICAgICBudWxsLCAgLy8gZXhwcmVzc2lvbiBmb3Igc2VsZWN0aW5nIHNsaWRlcyAoaWYgc29tZXRoaW5nIG90aGVyIHRoYW4gYWxsIGNoaWxkcmVuIGlzIHJlcXVpcmVkKVxyXG4gICAgY2xlYXJ0eXBlOiAgICAgMCwgICAgIC8vIHRydWUgaWYgY2xlYXJUeXBlIGNvcnJlY3Rpb25zIHNob3VsZCBiZSBhcHBsaWVkIChmb3IgSUUpXHJcbiAgICBub3dyYXA6ICAgICAgICAwICAgICAgLy8gdHJ1ZSB0byBwcmV2ZW50IHNsaWRlc2hvdyBmcm9tIHdyYXBwaW5nXHJcbn07XHJcblxyXG59KShqUXVlcnkpO1xyXG5cclxuXHJcbi8qXHJcbiAqIGpRdWVyeSBDeWNsZSBQbHVnaW4gVHJhbnNpdGlvbiBEZWZpbml0aW9uc1xyXG4gKiBUaGlzIHNjcmlwdCBpcyBhIHBsdWdpbiBmb3IgdGhlIGpRdWVyeSBDeWNsZSBQbHVnaW5cclxuICogRXhhbXBsZXMgYW5kIGRvY3VtZW50YXRpb24gYXQ6IGh0dHA6Ly9tYWxzdXAuY29tL2pxdWVyeS9jeWNsZS9cclxuICogQ29weXJpZ2h0IChjKSAyMDA3LTIwMDggTS4gQWxzdXBcclxuICogVmVyc2lvbjogIDIuMjJcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XHJcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcbiAqIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwuaHRtbFxyXG4gKi9cclxuKGZ1bmN0aW9uKCQpIHtcclxuXHJcbi8vXHJcbi8vIFRoZXNlIGZ1bmN0aW9ucyBkZWZpbmUgb25lLXRpbWUgc2xpZGUgaW5pdGlhbGl6YXRpb24gZm9yIHRoZSBuYW1lZFxyXG4vLyB0cmFuc2l0aW9ucy4gVG8gc2F2ZSBmaWxlIHNpemUgZmVlbCBmcmVlIHRvIHJlbW92ZSBhbnkgb2YgdGhlc2UgdGhhdCB5b3UgXHJcbi8vIGRvbid0IG5lZWQuXHJcbi8vXHJcblxyXG4vLyBzY3JvbGxVcC9Eb3duL0xlZnQvUmlnaHRcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5zY3JvbGxVcCA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICAkY29udC5jc3MoJ292ZXJmbG93JywnaGlkZGVuJyk7XHJcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcclxuICAgICAgICAkKHRoaXMpLnNob3coKTtcclxuICAgICAgICBvcHRzLmNzc0JlZm9yZS50b3AgPSBuZXh0Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBvcHRzLmFuaW1PdXQudG9wID0gMC1jdXJyLm9mZnNldEhlaWdodDtcclxuICAgIH0pO1xyXG4gICAgb3B0cy5jc3NGaXJzdCA9IHsgdG9wOiAwIH07XHJcbiAgICBvcHRzLmFuaW1JbiAgID0geyB0b3A6IDAgfTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xyXG59O1xyXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnNjcm9sbERvd24gPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xyXG4gICAgJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpO1xyXG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XHJcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XHJcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUudG9wID0gMC1uZXh0Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBvcHRzLmFuaW1PdXQudG9wID0gY3Vyci5vZmZzZXRIZWlnaHQ7XHJcbiAgICB9KTtcclxuICAgIG9wdHMuY3NzRmlyc3QgPSB7IHRvcDogMCB9O1xyXG4gICAgb3B0cy5hbmltSW4gICA9IHsgdG9wOiAwIH07XHJcbiAgICBvcHRzLmNzc0FmdGVyID0geyBkaXNwbGF5OiAnbm9uZScgfTtcclxufTtcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5zY3JvbGxMZWZ0ID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgICRjb250LmNzcygnb3ZlcmZsb3cnLCdoaWRkZW4nKTtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQodGhpcykuc2hvdygpO1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLmxlZnQgPSBuZXh0Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIG9wdHMuYW5pbU91dC5sZWZ0ID0gMC1jdXJyLm9mZnNldFdpZHRoO1xyXG4gICAgfSk7XHJcbiAgICBvcHRzLmNzc0ZpcnN0ID0geyBsZWZ0OiAwIH07XHJcbiAgICBvcHRzLmFuaW1JbiAgID0geyBsZWZ0OiAwIH07XHJcbn07XHJcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuc2Nyb2xsUmlnaHQgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xyXG4gICAgJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpO1xyXG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XHJcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XHJcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUubGVmdCA9IDAtbmV4dC5vZmZzZXRXaWR0aDtcclxuICAgICAgICBvcHRzLmFuaW1PdXQubGVmdCA9IGN1cnIub2Zmc2V0V2lkdGg7XHJcbiAgICB9KTtcclxuICAgIG9wdHMuY3NzRmlyc3QgPSB7IGxlZnQ6IDAgfTtcclxuICAgIG9wdHMuYW5pbUluICAgPSB7IGxlZnQ6IDAgfTtcclxufTtcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5zY3JvbGxIb3J6ID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgICRjb250LmNzcygnb3ZlcmZsb3cnLCdoaWRkZW4nKS53aWR0aCgpO1xyXG4vLyAgICAkc2xpZGVzLnNob3coKTtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cywgZndkKSB7XHJcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XHJcbiAgICAgICAgdmFyIGN1cnJXID0gY3Vyci5vZmZzZXRXaWR0aCwgbmV4dFcgPSBuZXh0Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0gZndkID8geyBsZWZ0OiBuZXh0VyB9IDogeyBsZWZ0OiAtbmV4dFcgfTtcclxuICAgICAgICBvcHRzLmFuaW1Jbi5sZWZ0ID0gMDtcclxuICAgICAgICBvcHRzLmFuaW1PdXQubGVmdCA9IGZ3ZCA/IC1jdXJyVyA6IGN1cnJXO1xyXG4gICAgICAgICRzbGlkZXMubm90KGN1cnIpLmNzcyhvcHRzLmNzc0JlZm9yZSk7XHJcbiAgICB9KTtcclxuICAgIG9wdHMuY3NzRmlyc3QgPSB7IGxlZnQ6IDAgfTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IGRpc3BsYXk6ICdub25lJyB9XHJcbn07XHJcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuc2Nyb2xsVmVydCA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICAkY29udC5jc3MoJ292ZXJmbG93JywnaGlkZGVuJyk7XHJcbi8vICAgICRzbGlkZXMuc2hvdygpO1xyXG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzLCBmd2QpIHtcclxuICAgICAgICAkKHRoaXMpLnNob3coKTtcclxuICAgICAgICB2YXIgY3VyckggPSBjdXJyLm9mZnNldEhlaWdodCwgbmV4dEggPSBuZXh0Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IGZ3ZCA/IHsgdG9wOiAtbmV4dEggfSA6IHsgdG9wOiBuZXh0SCB9O1xyXG4gICAgICAgIG9wdHMuYW5pbUluLnRvcCA9IDA7XHJcbiAgICAgICAgb3B0cy5hbmltT3V0LnRvcCA9IGZ3ZCA/IGN1cnJIIDogLWN1cnJIO1xyXG4gICAgICAgICRzbGlkZXMubm90KGN1cnIpLmNzcyhvcHRzLmNzc0JlZm9yZSk7XHJcbiAgICB9KTtcclxuICAgIG9wdHMuY3NzRmlyc3QgPSB7IHRvcDogMCB9O1xyXG4gICAgb3B0cy5jc3NBZnRlciA9IHsgZGlzcGxheTogJ25vbmUnIH1cclxufTtcclxuXHJcbi8vIHNsaWRlWC9zbGlkZVlcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5zbGlkZVggPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xyXG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XHJcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMSk7XHJcbiAgICB9KTsgICAgXHJcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XHJcbiAgICBvcHRzLmNzc0JlZm9yZSA9IHsgekluZGV4OiAyIH07XHJcbiAgICBvcHRzLmFuaW1JbiAgPSB7IHdpZHRoOiAnc2hvdycgfTtcclxuICAgIG9wdHMuYW5pbU91dCA9IHsgd2lkdGg6ICdoaWRlJyB9O1xyXG59O1xyXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnNsaWRlWSA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcclxuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywxKTtcclxuICAgIH0pOyAgICBcclxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcclxuICAgIG9wdHMuY3NzQmVmb3JlID0geyB6SW5kZXg6IDIgfTtcclxuICAgIG9wdHMuYW5pbUluICA9IHsgaGVpZ2h0OiAnc2hvdycgfTtcclxuICAgIG9wdHMuYW5pbU91dCA9IHsgaGVpZ2h0OiAnaGlkZScgfTtcclxufTtcclxuXHJcbi8vIHNodWZmbGVcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5zaHVmZmxlID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIHZhciB3ID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsICd2aXNpYmxlJykud2lkdGgoKTtcclxuICAgICRzbGlkZXMuY3NzKHtsZWZ0OiAwLCB0b3A6IDB9KTtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oKSB7ICQodGhpcykuc2hvdygpIH0pO1xyXG4gICAgb3B0cy5zcGVlZCA9IG9wdHMuc3BlZWQgLyAyOyAvLyBzaHVmZmxlIGhhcyAyIHRyYW5zaXRpb25zICAgICAgICBcclxuICAgIG9wdHMucmFuZG9tID0gMDtcclxuICAgIG9wdHMuc2h1ZmZsZSA9IG9wdHMuc2h1ZmZsZSB8fCB7bGVmdDotdywgdG9wOjE1fTtcclxuICAgIG9wdHMuZWxzID0gW107XHJcbiAgICBmb3IgKHZhciBpPTA7IGkgPCAkc2xpZGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIG9wdHMuZWxzLnB1c2goJHNsaWRlc1tpXSk7XHJcblxyXG4gICAgZm9yICh2YXIgaT0wOyBpIDwgb3B0cy5zdGFydGluZ1NsaWRlOyBpKyspXHJcbiAgICAgICAgb3B0cy5lbHMucHVzaChvcHRzLmVscy5zaGlmdCgpKTtcclxuXHJcbiAgICAvLyBjdXN0b20gdHJhbnNpdGlvbiBmbiAoaGF0IHRpcCB0byBCZW5qYW1pbiBTdGVybGluZyBmb3IgdGhpcyBiaXQgb2Ygc3dlZXRuZXNzISlcclxuICAgIG9wdHMuZnhGbiA9IGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMsIGNiLCBmd2QpIHtcclxuICAgICAgICB2YXIgJGVsID0gZndkID8gJChjdXJyKSA6ICQobmV4dCk7XHJcbiAgICAgICAgJGVsLmFuaW1hdGUob3B0cy5zaHVmZmxlLCBvcHRzLnNwZWVkSW4sIG9wdHMuZWFzZUluLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZndkID8gb3B0cy5lbHMucHVzaChvcHRzLmVscy5zaGlmdCgpKSA6IG9wdHMuZWxzLnVuc2hpZnQob3B0cy5lbHMucG9wKCkpO1xyXG4gICAgICAgICAgICBpZiAoZndkKSBcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbGVuPW9wdHMuZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICQob3B0cy5lbHNbaV0pLmNzcygnei1pbmRleCcsIGxlbi1pKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeiA9ICQoY3VycikuY3NzKCd6LWluZGV4Jyk7XHJcbiAgICAgICAgICAgICAgICAkZWwuY3NzKCd6LWluZGV4JywgcGFyc2VJbnQoeikrMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJGVsLmFuaW1hdGUoe2xlZnQ6MCwgdG9wOjB9LCBvcHRzLnNwZWVkT3V0LCBvcHRzLmVhc2VPdXQsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJChmd2QgPyB0aGlzIDogY3VycikuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNiKSBjYigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XHJcbn07XHJcblxyXG4vLyB0dXJuVXAvRG93bi9MZWZ0L1JpZ2h0XHJcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMudHVyblVwID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQodGhpcykuc2hvdygpO1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLnRvcCA9IG5leHQuY3ljbGVIO1xyXG4gICAgICAgIG9wdHMuYW5pbUluLmhlaWdodCA9IG5leHQuY3ljbGVIO1xyXG4gICAgfSk7XHJcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XHJcbiAgICBvcHRzLmNzc0ZpcnN0ICA9IHsgdG9wOiAwIH07XHJcbiAgICBvcHRzLmNzc0JlZm9yZSA9IHsgaGVpZ2h0OiAwIH07XHJcbiAgICBvcHRzLmFuaW1JbiAgICA9IHsgdG9wOiAwIH07XHJcbiAgICBvcHRzLmFuaW1PdXQgICA9IHsgaGVpZ2h0OiAwIH07XHJcbiAgICBvcHRzLmNzc0FmdGVyICA9IHsgZGlzcGxheTogJ25vbmUnIH07XHJcbn07XHJcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMudHVybkRvd24gPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xyXG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XHJcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XHJcbiAgICAgICAgb3B0cy5hbmltSW4uaGVpZ2h0ID0gbmV4dC5jeWNsZUg7XHJcbiAgICAgICAgb3B0cy5hbmltT3V0LnRvcCAgID0gY3Vyci5jeWNsZUg7XHJcbiAgICB9KTtcclxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcclxuICAgIG9wdHMuY3NzRmlyc3QgID0geyB0b3A6IDAgfTtcclxuICAgIG9wdHMuY3NzQmVmb3JlID0geyB0b3A6IDAsIGhlaWdodDogMCB9O1xyXG4gICAgb3B0cy5hbmltT3V0ICAgPSB7IGhlaWdodDogMCB9O1xyXG4gICAgb3B0cy5jc3NBZnRlciAgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xyXG59O1xyXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLnR1cm5MZWZ0ID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQodGhpcykuc2hvdygpO1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLmxlZnQgPSBuZXh0LmN5Y2xlVztcclxuICAgICAgICBvcHRzLmFuaW1Jbi53aWR0aCA9IG5leHQuY3ljbGVXO1xyXG4gICAgfSk7XHJcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XHJcbiAgICBvcHRzLmNzc0JlZm9yZSA9IHsgd2lkdGg6IDAgfTtcclxuICAgIG9wdHMuYW5pbUluICAgID0geyBsZWZ0OiAwIH07XHJcbiAgICBvcHRzLmFuaW1PdXQgICA9IHsgd2lkdGg6IDAgfTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIgID0geyBkaXNwbGF5OiAnbm9uZScgfTtcclxufTtcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy50dXJuUmlnaHQgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xyXG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XHJcbiAgICAgICAgJCh0aGlzKS5zaG93KCk7XHJcbiAgICAgICAgb3B0cy5hbmltSW4ud2lkdGggPSBuZXh0LmN5Y2xlVztcclxuICAgICAgICBvcHRzLmFuaW1PdXQubGVmdCA9IGN1cnIuY3ljbGVXO1xyXG4gICAgfSk7XHJcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XHJcbiAgICBvcHRzLmNzc0JlZm9yZSA9IHsgbGVmdDogMCwgd2lkdGg6IDAgfTtcclxuICAgIG9wdHMuYW5pbUluICAgID0geyBsZWZ0OiAwIH07XHJcbiAgICBvcHRzLmFuaW1PdXQgICA9IHsgd2lkdGg6IDAgfTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIgID0geyBkaXNwbGF5OiAnbm9uZScgfTtcclxufTtcclxuXHJcbi8vIHpvb21cclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy56b29tID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIG9wdHMuY3NzRmlyc3QgPSB7IHRvcDowLCBsZWZ0OiAwIH07IFxyXG4gICAgb3B0cy5jc3NBZnRlciA9IHsgZGlzcGxheTogJ25vbmUnIH07XHJcbiAgICBcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQodGhpcykuc2hvdygpO1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCB0b3A6IG5leHQuY3ljbGVILzIsIGxlZnQ6IG5leHQuY3ljbGVXLzIgfTtcclxuICAgICAgICBvcHRzLmNzc0FmdGVyICA9IHsgZGlzcGxheTogJ25vbmUnIH07XHJcbiAgICAgICAgb3B0cy5hbmltSW4gICAgPSB7IHRvcDogMCwgbGVmdDogMCwgd2lkdGg6IG5leHQuY3ljbGVXLCBoZWlnaHQ6IG5leHQuY3ljbGVIIH07XHJcbiAgICAgICAgb3B0cy5hbmltT3V0ICAgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHRvcDogY3Vyci5jeWNsZUgvMiwgbGVmdDogY3Vyci5jeWNsZVcvMiB9O1xyXG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDIpO1xyXG4gICAgICAgICQobmV4dCkuY3NzKCd6SW5kZXgnLDEpO1xyXG4gICAgfSk7ICAgIFxyXG4gICAgb3B0cy5vbkFkZFNsaWRlID0gZnVuY3Rpb24oJHMpIHsgJHMuaGlkZSgpOyB9O1xyXG59O1xyXG5cclxuLy8gZmFkZVpvb21cclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5mYWRlWm9vbSA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcclxuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCwgb3BhY2l0eTogMSwgbGVmdDogbmV4dC5jeWNsZVcvMiwgdG9wOiBuZXh0LmN5Y2xlSC8yLCB6SW5kZXg6IDEgfTtcclxuICAgICAgICBvcHRzLmFuaW1JbiAgICA9IHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogbmV4dC5jeWNsZVcsIGhlaWdodDogbmV4dC5jeWNsZUggfTtcclxuICAgIH0pOyAgICBcclxuICAgIG9wdHMuYW5pbU91dCAgPSB7IG9wYWNpdHk6IDAgfTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IHpJbmRleDogMCB9O1xyXG59O1xyXG5cclxuLy8gYmxpbmRYXHJcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMuYmxpbmRYID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIHZhciB3ID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpLndpZHRoKCk7XHJcbiAgICAkc2xpZGVzLnNob3coKTtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDEpO1xyXG4gICAgfSk7ICAgIFxyXG4gICAgb3B0cy5jc3NCZWZvcmUgPSB7IGxlZnQ6IHcsIHpJbmRleDogMiB9O1xyXG4gICAgb3B0cy5jc3NBZnRlciA9IHsgekluZGV4OiAxIH07XHJcbiAgICBvcHRzLmFuaW1JbiA9IHsgbGVmdDogMCB9O1xyXG4gICAgb3B0cy5hbmltT3V0ICA9IHsgbGVmdDogdyB9O1xyXG59O1xyXG4vLyBibGluZFlcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5ibGluZFkgPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xyXG4gICAgdmFyIGggPSAkY29udC5jc3MoJ292ZXJmbG93JywnaGlkZGVuJykuaGVpZ2h0KCk7XHJcbiAgICAkc2xpZGVzLnNob3coKTtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDEpO1xyXG4gICAgfSk7ICAgIFxyXG4gICAgb3B0cy5jc3NCZWZvcmUgPSB7IHRvcDogaCwgekluZGV4OiAyIH07XHJcbiAgICBvcHRzLmNzc0FmdGVyID0geyB6SW5kZXg6IDEgfTtcclxuICAgIG9wdHMuYW5pbUluID0geyB0b3A6IDAgfTtcclxuICAgIG9wdHMuYW5pbU91dCAgPSB7IHRvcDogaCB9O1xyXG59O1xyXG4vLyBibGluZFpcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5ibGluZFogPSBmdW5jdGlvbigkY29udCwgJHNsaWRlcywgb3B0cykge1xyXG4gICAgdmFyIGggPSAkY29udC5jc3MoJ292ZXJmbG93JywnaGlkZGVuJykuaGVpZ2h0KCk7XHJcbiAgICB2YXIgdyA9ICRjb250LndpZHRoKCk7XHJcbiAgICAkc2xpZGVzLnNob3coKTtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDEpO1xyXG4gICAgfSk7ICAgIFxyXG4gICAgb3B0cy5jc3NCZWZvcmUgPSB7IHRvcDogaCwgbGVmdDogdywgekluZGV4OiAyIH07XHJcbiAgICBvcHRzLmNzc0FmdGVyID0geyB6SW5kZXg6IDEgfTtcclxuICAgIG9wdHMuYW5pbUluID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcclxuICAgIG9wdHMuYW5pbU91dCAgPSB7IHRvcDogaCwgbGVmdDogdyB9O1xyXG59O1xyXG5cclxuLy8gZ3Jvd1ggLSBncm93IGhvcml6b250YWxseSBmcm9tIGNlbnRlcmVkIDAgd2lkdGhcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5ncm93WCA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcclxuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IHsgbGVmdDogdGhpcy5jeWNsZVcvMiwgd2lkdGg6IDAsIHpJbmRleDogMiB9O1xyXG4gICAgICAgIG9wdHMuYW5pbUluID0geyBsZWZ0OiAwLCB3aWR0aDogdGhpcy5jeWNsZVcgfTtcclxuICAgICAgICBvcHRzLmFuaW1PdXQgPSB7IGxlZnQ6IDAgfTtcclxuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywxKTtcclxuICAgIH0pOyAgICBcclxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKS5jc3MoJ3pJbmRleCcsMSk7IH07XHJcbn07XHJcbi8vIGdyb3dZIC0gZ3JvdyB2ZXJ0aWNhbGx5IGZyb20gY2VudGVyZWQgMCBoZWlnaHRcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5ncm93WSA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcclxuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IHsgdG9wOiB0aGlzLmN5Y2xlSC8yLCBoZWlnaHQ6IDAsIHpJbmRleDogMiB9O1xyXG4gICAgICAgIG9wdHMuYW5pbUluID0geyB0b3A6IDAsIGhlaWdodDogdGhpcy5jeWNsZUggfTtcclxuICAgICAgICBvcHRzLmFuaW1PdXQgPSB7IHRvcDogMCB9O1xyXG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDEpO1xyXG4gICAgfSk7ICAgIFxyXG4gICAgb3B0cy5vbkFkZFNsaWRlID0gZnVuY3Rpb24oJHMpIHsgJHMuaGlkZSgpLmNzcygnekluZGV4JywxKTsgfTtcclxufTtcclxuXHJcbi8vIGN1cnRhaW5YIC0gc3F1ZWV6ZSBpbiBib3RoIGVkZ2VzIGhvcml6b250YWxseVxyXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLmN1cnRhaW5YID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlID0geyBsZWZ0OiBuZXh0LmN5Y2xlVy8yLCB3aWR0aDogMCwgekluZGV4OiAxLCBkaXNwbGF5OiAnYmxvY2snIH07XHJcbiAgICAgICAgb3B0cy5hbmltSW4gPSB7IGxlZnQ6IDAsIHdpZHRoOiB0aGlzLmN5Y2xlVyB9O1xyXG4gICAgICAgIG9wdHMuYW5pbU91dCA9IHsgbGVmdDogY3Vyci5jeWNsZVcvMiwgd2lkdGg6IDAgfTtcclxuICAgICAgICAkKGN1cnIpLmNzcygnekluZGV4JywyKTtcclxuICAgIH0pOyAgICBcclxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IHpJbmRleDogMSwgZGlzcGxheTogJ25vbmUnIH07XHJcbn07XHJcbi8vIGN1cnRhaW5ZIC0gc3F1ZWV6ZSBpbiBib3RoIGVkZ2VzIHZlcnRpY2FsbHlcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy5jdXJ0YWluWSA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcclxuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IHsgdG9wOiBuZXh0LmN5Y2xlSC8yLCBoZWlnaHQ6IDAsIHpJbmRleDogMSwgZGlzcGxheTogJ2Jsb2NrJyB9O1xyXG4gICAgICAgIG9wdHMuYW5pbUluID0geyB0b3A6IDAsIGhlaWdodDogdGhpcy5jeWNsZUggfTtcclxuICAgICAgICBvcHRzLmFuaW1PdXQgPSB7IHRvcDogY3Vyci5jeWNsZUgvMiwgaGVpZ2h0OiAwIH07XHJcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMik7XHJcbiAgICB9KTsgICAgXHJcbiAgICBvcHRzLm9uQWRkU2xpZGUgPSBmdW5jdGlvbigkcykgeyAkcy5oaWRlKCk7IH07XHJcbiAgICBvcHRzLmNzc0FmdGVyID0geyB6SW5kZXg6IDEsIGRpc3BsYXk6ICdub25lJyB9O1xyXG59O1xyXG5cclxuLy8gY292ZXIgLSBjdXJyIHNsaWRlIGNvdmVyZWQgYnkgbmV4dCBzbGlkZVxyXG4kLmZuLmN5Y2xlLnRyYW5zaXRpb25zLmNvdmVyID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIHZhciBkID0gb3B0cy5kaXJlY3Rpb24gfHwgJ2xlZnQnO1xyXG4gICAgdmFyIHcgPSAkY29udC5jc3MoJ292ZXJmbG93JywnaGlkZGVuJykud2lkdGgoKTtcclxuICAgIHZhciBoID0gJGNvbnQuaGVpZ2h0KCk7XHJcbiAgICBvcHRzLmJlZm9yZS5wdXNoKGZ1bmN0aW9uKGN1cnIsIG5leHQsIG9wdHMpIHtcclxuICAgICAgICBvcHRzLmNzc0JlZm9yZSA9IG9wdHMuY3NzQmVmb3JlIHx8IHt9O1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLnpJbmRleCA9IDI7XHJcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGQgPT0gJ3JpZ2h0JykgXHJcbiAgICAgICAgICAgIG9wdHMuY3NzQmVmb3JlLmxlZnQgPSAtdztcclxuICAgICAgICBlbHNlIGlmIChkID09ICd1cCcpICAgIFxyXG4gICAgICAgICAgICBvcHRzLmNzc0JlZm9yZS50b3AgPSBoO1xyXG4gICAgICAgIGVsc2UgaWYgKGQgPT0gJ2Rvd24nKSAgXHJcbiAgICAgICAgICAgIG9wdHMuY3NzQmVmb3JlLnRvcCA9IC1oO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgb3B0cy5jc3NCZWZvcmUubGVmdCA9IHc7XHJcbiAgICAgICAgJChjdXJyKS5jc3MoJ3pJbmRleCcsMSk7XHJcbiAgICB9KTsgICAgXHJcbiAgICBpZiAoIW9wdHMuYW5pbUluKSAgb3B0cy5hbmltSW4gPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xyXG4gICAgaWYgKCFvcHRzLmFuaW1PdXQpIG9wdHMuYW5pbU91dCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XHJcbiAgICBvcHRzLmNzc0FmdGVyID0gb3B0cy5jc3NBZnRlciB8fCB7fTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIuekluZGV4ID0gMjtcclxuICAgIG9wdHMuY3NzQWZ0ZXIuZGlzcGxheSA9ICdub25lJztcclxufTtcclxuXHJcbi8vIHVuY292ZXIgLSBjdXJyIHNsaWRlIG1vdmVzIG9mZiBuZXh0IHNsaWRlXHJcbiQuZm4uY3ljbGUudHJhbnNpdGlvbnMudW5jb3ZlciA9IGZ1bmN0aW9uKCRjb250LCAkc2xpZGVzLCBvcHRzKSB7XHJcbiAgICB2YXIgZCA9IG9wdHMuZGlyZWN0aW9uIHx8ICdsZWZ0JztcclxuICAgIHZhciB3ID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpLndpZHRoKCk7XHJcbiAgICB2YXIgaCA9ICRjb250LmhlaWdodCgpO1xyXG4gICAgb3B0cy5iZWZvcmUucHVzaChmdW5jdGlvbihjdXJyLCBuZXh0LCBvcHRzKSB7XHJcbiAgICAgICAgb3B0cy5jc3NCZWZvcmUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgaWYgKGQgPT0gJ3JpZ2h0JykgXHJcbiAgICAgICAgICAgIG9wdHMuYW5pbU91dC5sZWZ0ID0gdztcclxuICAgICAgICBlbHNlIGlmIChkID09ICd1cCcpICAgIFxyXG4gICAgICAgICAgICBvcHRzLmFuaW1PdXQudG9wID0gLWg7XHJcbiAgICAgICAgZWxzZSBpZiAoZCA9PSAnZG93bicpICBcclxuICAgICAgICAgICAgb3B0cy5hbmltT3V0LnRvcCA9IGg7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBvcHRzLmFuaW1PdXQubGVmdCA9IC13O1xyXG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDIpO1xyXG4gICAgICAgICQobmV4dCkuY3NzKCd6SW5kZXgnLDEpO1xyXG4gICAgfSk7ICAgIFxyXG4gICAgb3B0cy5vbkFkZFNsaWRlID0gZnVuY3Rpb24oJHMpIHsgJHMuaGlkZSgpOyB9O1xyXG4gICAgaWYgKCFvcHRzLmFuaW1JbikgIG9wdHMuYW5pbUluID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcclxuICAgIG9wdHMuY3NzQmVmb3JlID0gb3B0cy5jc3NCZWZvcmUgfHwge307XHJcbiAgICBvcHRzLmNzc0JlZm9yZS50b3AgPSAwO1xyXG4gICAgb3B0cy5jc3NCZWZvcmUubGVmdCA9IDA7XHJcbiAgICBcclxuICAgIG9wdHMuY3NzQWZ0ZXIgPSBvcHRzLmNzc0FmdGVyIHx8IHt9O1xyXG4gICAgb3B0cy5jc3NBZnRlci56SW5kZXggPSAxO1xyXG4gICAgb3B0cy5jc3NBZnRlci5kaXNwbGF5ID0gJ25vbmUnO1xyXG59O1xyXG5cclxuLy8gdG9zcyAtIG1vdmUgdG9wIHNsaWRlIGFuZCBmYWRlIGF3YXlcclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy50b3NzID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIHZhciB3ID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsJ3Zpc2libGUnKS53aWR0aCgpO1xyXG4gICAgdmFyIGggPSAkY29udC5oZWlnaHQoKTtcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgICQoY3VycikuY3NzKCd6SW5kZXgnLDIpO1xyXG4gICAgICAgIG9wdHMuY3NzQmVmb3JlLmRpc3BsYXkgPSAnYmxvY2snOyBcclxuICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgdG9zcyBzZXR0aW5ncyBpZiBhbmltT3V0IG5vdCBwcm92aWRlZFxyXG4gICAgICAgIGlmICghb3B0cy5hbmltT3V0LmxlZnQgJiYgIW9wdHMuYW5pbU91dC50b3ApXHJcbiAgICAgICAgICAgIG9wdHMuYW5pbU91dCA9IHsgbGVmdDogdyoyLCB0b3A6IC1oLzIsIG9wYWNpdHk6IDAgfTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG9wdHMuYW5pbU91dC5vcGFjaXR5ID0gMDtcclxuICAgIH0pOyAgICBcclxuICAgIG9wdHMub25BZGRTbGlkZSA9IGZ1bmN0aW9uKCRzKSB7ICRzLmhpZGUoKTsgfTtcclxuICAgIG9wdHMuY3NzQmVmb3JlID0geyBsZWZ0OiAwLCB0b3A6IDAsIHpJbmRleDogMSwgb3BhY2l0eTogMSB9O1xyXG4gICAgb3B0cy5hbmltSW4gPSB7IGxlZnQ6IDAgfTtcclxuICAgIG9wdHMuY3NzQWZ0ZXIgPSB7IHpJbmRleDogMiwgZGlzcGxheTogJ25vbmUnIH07XHJcbn07XHJcblxyXG4vLyB3aXBlIC0gY2xpcCBhbmltYXRpb25cclxuJC5mbi5jeWNsZS50cmFuc2l0aW9ucy53aXBlID0gZnVuY3Rpb24oJGNvbnQsICRzbGlkZXMsIG9wdHMpIHtcclxuICAgIHZhciB3ID0gJGNvbnQuY3NzKCdvdmVyZmxvdycsJ2hpZGRlbicpLndpZHRoKCk7XHJcbiAgICB2YXIgaCA9ICRjb250LmhlaWdodCgpO1xyXG4gICAgb3B0cy5jc3NCZWZvcmUgPSBvcHRzLmNzc0JlZm9yZSB8fCB7fTtcclxuICAgIHZhciBjbGlwO1xyXG4gICAgaWYgKG9wdHMuY2xpcCkge1xyXG4gICAgICAgIGlmICgvbDJyLy50ZXN0KG9wdHMuY2xpcCkpXHJcbiAgICAgICAgICAgIGNsaXAgPSAncmVjdCgwcHggMHB4ICcraCsncHggMHB4KSc7XHJcbiAgICAgICAgZWxzZSBpZiAoL3IybC8udGVzdChvcHRzLmNsaXApKVxyXG4gICAgICAgICAgICBjbGlwID0gJ3JlY3QoMHB4ICcrdysncHggJytoKydweCAnK3crJ3B4KSc7XHJcbiAgICAgICAgZWxzZSBpZiAoL3QyYi8udGVzdChvcHRzLmNsaXApKVxyXG4gICAgICAgICAgICBjbGlwID0gJ3JlY3QoMHB4ICcrdysncHggMHB4IDBweCknO1xyXG4gICAgICAgIGVsc2UgaWYgKC9iMnQvLnRlc3Qob3B0cy5jbGlwKSlcclxuICAgICAgICAgICAgY2xpcCA9ICdyZWN0KCcraCsncHggJyt3KydweCAnK2grJ3B4IDBweCknO1xyXG4gICAgICAgIGVsc2UgaWYgKC96b29tLy50ZXN0KG9wdHMuY2xpcCkpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBwYXJzZUludChoLzIpO1xyXG4gICAgICAgICAgICB2YXIgbCA9IHBhcnNlSW50KHcvMik7XHJcbiAgICAgICAgICAgIGNsaXAgPSAncmVjdCgnK3QrJ3B4ICcrbCsncHggJyt0KydweCAnK2wrJ3B4KSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBvcHRzLmNzc0JlZm9yZS5jbGlwID0gb3B0cy5jc3NCZWZvcmUuY2xpcCB8fCBjbGlwIHx8ICdyZWN0KDBweCAwcHggMHB4IDBweCknO1xyXG4gICAgXHJcbiAgICB2YXIgZCA9IG9wdHMuY3NzQmVmb3JlLmNsaXAubWF0Y2goLyhcXGQrKS9nKTtcclxuICAgIHZhciB0ID0gcGFyc2VJbnQoZFswXSksIHIgPSBwYXJzZUludChkWzFdKSwgYiA9IHBhcnNlSW50KGRbMl0pLCBsID0gcGFyc2VJbnQoZFszXSk7XHJcbiAgICBcclxuICAgIG9wdHMuYmVmb3JlLnB1c2goZnVuY3Rpb24oY3VyciwgbmV4dCwgb3B0cykge1xyXG4gICAgICAgIGlmIChjdXJyID09IG5leHQpIHJldHVybjtcclxuICAgICAgICB2YXIgJGN1cnIgPSAkKGN1cnIpLmNzcygnekluZGV4JywyKTtcclxuICAgICAgICB2YXIgJG5leHQgPSAkKG5leHQpLmNzcyh7XHJcbiAgICAgICAgICAgIHpJbmRleDogIDMsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RlcCA9IDEsIGNvdW50ID0gcGFyc2VJbnQoKG9wdHMuc3BlZWRJbiAvIDEzKSkgLSAxO1xyXG4gICAgICAgIGZ1bmN0aW9uIGYoKSB7XHJcbiAgICAgICAgICAgIHZhciB0dCA9IHQgPyB0IC0gcGFyc2VJbnQoc3RlcCAqICh0L2NvdW50KSkgOiAwO1xyXG4gICAgICAgICAgICB2YXIgbGwgPSBsID8gbCAtIHBhcnNlSW50KHN0ZXAgKiAobC9jb3VudCkpIDogMDtcclxuICAgICAgICAgICAgdmFyIGJiID0gYiA8IGggPyBiICsgcGFyc2VJbnQoc3RlcCAqICgoaC1iKS9jb3VudCB8fCAxKSkgOiBoO1xyXG4gICAgICAgICAgICB2YXIgcnIgPSByIDwgdyA/IHIgKyBwYXJzZUludChzdGVwICogKCh3LXIpL2NvdW50IHx8IDEpKSA6IHc7XHJcbiAgICAgICAgICAgICRuZXh0LmNzcyh7IGNsaXA6ICdyZWN0KCcrdHQrJ3B4ICcrcnIrJ3B4ICcrYmIrJ3B4ICcrbGwrJ3B4KScgfSk7XHJcbiAgICAgICAgICAgIChzdGVwKysgPD0gY291bnQpID8gc2V0VGltZW91dChmLCAxMykgOiAkY3Vyci5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmKCk7XHJcbiAgICB9KTsgICAgXHJcbiAgICBvcHRzLmNzc0FmdGVyICA9IHsgfTtcclxuICAgIG9wdHMuYW5pbUluICAgID0geyBsZWZ0OiAwIH07XHJcbiAgICBvcHRzLmFuaW1PdXQgICA9IHsgbGVmdDogMCB9O1xyXG59O1xyXG5cclxufSkoalF1ZXJ5KTtcclxuLypcclxuIGpRdWVyeSBkZWxheWVkIG9ic2VydmVyIC0gMC44XHJcbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvanF1ZXJ5LXV0aWxzL1xyXG5cclxuIChjKSBNYXhpbWUgSGFpbmVhdWx0IDxoYWluZWF1bHRAZ21haWwuY29tPlxyXG4gaHR0cDovL2hhaW5lYXVsdC5jb21cclxuIFxyXG4gTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxyXG4gXHJcbiovXHJcblxyXG4oZnVuY3Rpb24oJCl7XHJcbiAgICAkLmV4dGVuZCgkLmZuLCB7XHJcbiAgICAgICAgZGVsYXllZE9ic2VydmVyOiBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIG9wdGlvbnMpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGVsLmRhdGEoJ29sZHZhbCcsIGVsLnZhbCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKCdkZWxheScsIGRlbGF5IHx8IDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YSgnY29uZGl0aW9uJywgb3AuY29uZGl0aW9uIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gKCQodGhpcykuZGF0YSgnb2xkdmFsJykgPT0gJCh0aGlzKS52YWwoKSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoJ2NhbGxiYWNrJywgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgWyhvcC5ldmVudHx8J2tleXVwJyldKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5kYXRhKCdjb25kaXRpb24nKS5hcHBseShlbCkpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmRhdGEoJ3RpbWVyJykpIHsgY2xlYXJUaW1lb3V0KGVsLmRhdGEoJ3RpbWVyJykpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCd0aW1lcicsIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdjYWxsYmFjaycpLmFwcGx5KGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGVsLmRhdGEoJ2RlbGF5JykgKiAxMDAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdvbGR2YWwnLCBlbC52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0pKGpRdWVyeSk7XHJcbi8qKlxyXG4gKiBGbGFzaCAoaHR0cDovL2pxdWVyeS5sdWtlbHV0bWFuLmNvbS9wbHVnaW5zL2ZsYXNoKVxyXG4gKiBBIGpRdWVyeSBwbHVnaW4gZm9yIGVtYmVkZGluZyBGbGFzaCBtb3ZpZXMuXHJcbiAqIFxyXG4gKiBWZXJzaW9uIDEuMFxyXG4gKiBOb3ZlbWJlciA5dGgsIDIwMDZcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDA2IEx1a2UgTHV0bWFuIChodHRwOi8vd3d3Lmx1a2VsdXRtYW4uY29tKVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cclxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9ncGwtbGljZW5zZS5waHBcclxuICogXHJcbiAqIEluc3BpcmVkIGJ5OlxyXG4gKiBTV0ZPYmplY3QgKGh0dHA6Ly9ibG9nLmRlY29uY2VwdC5jb20vc3dmb2JqZWN0LylcclxuICogVUZPIChodHRwOi8vd3d3LmJvYmJ5dmFuZGVyc2x1aXMuY29tL3Vmby8pXHJcbiAqIHNJRlIgKGh0dHA6Ly93d3cubWlrZWluZHVzdHJpZXMuY29tL3NpZnIvKVxyXG4gKiBcclxuICogSU1QT1JUQU5UOiBcclxuICogVGhlIHBhY2tlZCB2ZXJzaW9uIG9mIGpRdWVyeSBicmVha3MgQWN0aXZlWCBjb250cm9sXHJcbiAqIGFjdGl2YXRpb24gaW4gSW50ZXJuZXQgRXhwbG9yZXIuIFVzZSBKU01pbiB0byBtaW5pZml5XHJcbiAqIGpRdWVyeSAoc2VlOiBodHRwOi8vanF1ZXJ5Lmx1a2VsdXRtYW4uY29tL3BsdWdpbnMvZmxhc2gjYWN0aXZleCkuXHJcbiAqXHJcbiAqKi8gXHJcbjsoZnVuY3Rpb24oKXtcclxuXHRcclxudmFyICQkO1xyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBAZGVzYyBSZXBsYWNlIG1hdGNoaW5nIGVsZW1lbnRzIHdpdGggYSBmbGFzaCBtb3ZpZS5cclxuICogQGF1dGhvciBMdWtlIEx1dG1hblxyXG4gKiBAdmVyc2lvbiAxLjAuMVxyXG4gKlxyXG4gKiBAbmFtZSBmbGFzaFxyXG4gKiBAcGFyYW0gSGFzaCBodG1sT3B0aW9ucyBPcHRpb25zIGZvciB0aGUgZW1iZWQvb2JqZWN0IHRhZy5cclxuICogQHBhcmFtIEhhc2ggcGx1Z2luT3B0aW9ucyBPcHRpb25zIGZvciBkZXRlY3RpbmcvdXBkYXRpbmcgdGhlIEZsYXNoIHBsdWdpbiAob3B0aW9uYWwpLlxyXG4gKiBAcGFyYW0gRnVuY3Rpb24gcmVwbGFjZSBDdXN0b20gYmxvY2sgY2FsbGVkIGZvciBlYWNoIG1hdGNoZWQgZWxlbWVudCBpZiBmbGFzaCBpcyBpbnN0YWxsZWQgKG9wdGlvbmFsKS5cclxuICogQHBhcmFtIEZ1bmN0aW9uIHVwZGF0ZSBDdXN0b20gYmxvY2sgY2FsbGVkIGZvciBlYWNoIG1hdGNoZWQgaWYgZmxhc2ggaXNuJ3QgaW5zdGFsbGVkIChvcHRpb25hbCkuXHJcbiAqIEB0eXBlIGpRdWVyeVxyXG4gKlxyXG4gKiBAY2F0IHBsdWdpbnMvZmxhc2hcclxuICogXHJcbiAqIEBleGFtcGxlICQoJyNoZWxsbycpLmZsYXNoKHsgc3JjOiAnaGVsbG8uc3dmJyB9KTtcclxuICogQGRlc2MgRW1iZWQgYSBGbGFzaCBtb3ZpZS5cclxuICpcclxuICogQGV4YW1wbGUgJCgnI2hlbGxvJykuZmxhc2goeyBzcmM6ICdoZWxsby5zd2YnIH0sIHsgdmVyc2lvbjogOCB9KTtcclxuICogQGRlc2MgRW1iZWQgYSBGbGFzaCA4IG1vdmllLlxyXG4gKlxyXG4gKiBAZXhhbXBsZSAkKCcjaGVsbG8nKS5mbGFzaCh7IHNyYzogJ2hlbGxvLnN3ZicgfSwgeyBleHByZXNzSW5zdGFsbDogdHJ1ZSB9KTtcclxuICogQGRlc2MgRW1iZWQgYSBGbGFzaCBtb3ZpZSB1c2luZyBFeHByZXNzIEluc3RhbGwgaWYgZmxhc2ggaXNuJ3QgaW5zdGFsbGVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZSAkKCcjaGVsbG8nKS5mbGFzaCh7IHNyYzogJ2hlbGxvLnN3ZicgfSwgeyB1cGRhdGU6IGZhbHNlIH0pO1xyXG4gKiBAZGVzYyBFbWJlZCBhIEZsYXNoIG1vdmllLCBkb24ndCBzaG93IGFuIHVwZGF0ZSBtZXNzYWdlIGlmIEZsYXNoIGlzbid0IGluc3RhbGxlZC5cclxuICpcclxuKiovXHJcbiQkID0galF1ZXJ5LmZuLmZsYXNoID0gZnVuY3Rpb24oaHRtbE9wdGlvbnMsIHBsdWdpbk9wdGlvbnMsIHJlcGxhY2UsIHVwZGF0ZSkge1xyXG5cdFxyXG5cdC8vIFNldCB0aGUgZGVmYXVsdCBibG9jay5cclxuXHR2YXIgYmxvY2sgPSByZXBsYWNlIHx8ICQkLnJlcGxhY2U7XHJcblx0XHJcblx0Ly8gTWVyZ2UgdGhlIGRlZmF1bHQgYW5kIHBhc3NlZCBwbHVnaW4gb3B0aW9ucy5cclxuXHRwbHVnaW5PcHRpb25zID0gJCQuY29weSgkJC5wbHVnaW5PcHRpb25zLCBwbHVnaW5PcHRpb25zKTtcclxuXHRcclxuXHQvLyBEZXRlY3QgRmxhc2guXHJcblx0aWYoISQkLmhhc0ZsYXNoKHBsdWdpbk9wdGlvbnMudmVyc2lvbikpIHtcclxuXHRcdC8vIFVzZSBFeHByZXNzIEluc3RhbGwgKGlmIHNwZWNpZmllZCBhbmQgRmxhc2ggcGx1Z2luIDYsMCw2NSBvciBoaWdoZXIgaXMgaW5zdGFsbGVkKS5cclxuXHRcdGlmKHBsdWdpbk9wdGlvbnMuZXhwcmVzc0luc3RhbGwgJiYgJCQuaGFzRmxhc2goNiwwLDY1KSkge1xyXG5cdFx0XHQvLyBBZGQgdGhlIG5lY2Vzc2FyeSBmbGFzaHZhcnMgKG1lcmdlZCBsYXRlcikuXHJcblx0XHRcdHZhciBleHByZXNzSW5zdGFsbE9wdGlvbnMgPSB7XHJcblx0XHRcdFx0Zmxhc2h2YXJzOiB7ICBcdFxyXG5cdFx0XHRcdFx0TU1yZWRpcmVjdFVSTDogbG9jYXRpb24sXHJcblx0XHRcdFx0XHRNTXBsYXllclR5cGU6ICdQbHVnSW4nLFxyXG5cdFx0XHRcdFx0TU1kb2N0aXRsZTogalF1ZXJ5KCd0aXRsZScpLnRleHQoKSBcclxuXHRcdFx0XHR9XHRcdFx0XHRcdFxyXG5cdFx0XHR9O1xyXG5cdFx0Ly8gQXNrIHRoZSB1c2VyIHRvIHVwZGF0ZSAoaWYgc3BlY2lmaWVkKS5cclxuXHRcdH0gZWxzZSBpZiAocGx1Z2luT3B0aW9ucy51cGRhdGUpIHtcclxuXHRcdFx0Ly8gQ2hhbmdlIHRoZSBibG9jayB0byBpbnNlcnQgdGhlIHVwZGF0ZSBtZXNzYWdlIGluc3RlYWQgb2YgdGhlIGZsYXNoIG1vdmllLlxyXG5cdFx0XHRibG9jayA9IHVwZGF0ZSB8fCAkJC51cGRhdGU7XHJcblx0XHQvLyBGYWlsXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBUaGUgcmVxdWlyZWQgdmVyc2lvbiBvZiBmbGFzaCBpc24ndCBpbnN0YWxsZWQuXHJcblx0XHRcdC8vIEV4cHJlc3MgSW5zdGFsbCBpcyB0dXJuZWQgb2ZmLCBvciBmbGFzaCA2LDAsNjUgaXNuJ3QgaW5zdGFsbGVkLlxyXG5cdFx0XHQvLyBVcGRhdGUgaXMgdHVybmVkIG9mZi5cclxuXHRcdFx0Ly8gUmV0dXJuIHdpdGhvdXQgZG9pbmcgYW55dGhpbmcuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHQvLyBNZXJnZSB0aGUgZGVmYXVsdCwgZXhwcmVzcyBpbnN0YWxsIGFuZCBwYXNzZWQgaHRtbCBvcHRpb25zLlxyXG5cdGh0bWxPcHRpb25zID0gJCQuY29weSgkJC5odG1sT3B0aW9ucywgZXhwcmVzc0luc3RhbGxPcHRpb25zLCBodG1sT3B0aW9ucyk7XHJcblx0XHJcblx0Ly8gSW52b2tlICRibG9jayAod2l0aCBhIGNvcHkgb2YgdGhlIG1lcmdlZCBodG1sIG9wdGlvbnMpIGZvciBlYWNoIGVsZW1lbnQuXHJcblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG5cdFx0YmxvY2suY2FsbCh0aGlzLCAkJC5jb3B5KGh0bWxPcHRpb25zKSk7XHJcblx0fSk7XHJcblx0XHJcbn07XHJcbi8qKlxyXG4gKlxyXG4gKiBAbmFtZSBmbGFzaC5jb3B5XHJcbiAqIEBkZXNjIENvcHkgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBvYmplY3RzIGludG8gYSBuZXcgb2JqZWN0LlxyXG4gKiBAdHlwZSBPYmplY3RcclxuICogXHJcbiAqIEBleGFtcGxlICQkLmNvcHkoeyBmb286IDEgfSwgeyBiYXI6IDIgfSk7XHJcbiAqIEByZXN1bHQgeyBmb286IDEsIGJhcjogMiB9O1xyXG4gKlxyXG4qKi9cclxuJCQuY29weSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBvcHRpb25zID0ge30sIGZsYXNodmFycyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XHJcblx0XHRpZihhcmcgPT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuXHRcdGpRdWVyeS5leHRlbmQob3B0aW9ucywgYXJnKTtcclxuXHRcdC8vIGRvbid0IGNsb2JiZXIgb25lIGZsYXNoIHZhcnMgb2JqZWN0IHdpdGggYW5vdGhlclxyXG5cdFx0Ly8gbWVyZ2UgdGhlbSBpbnN0ZWFkXHJcblx0XHRpZihhcmcuZmxhc2h2YXJzID09IHVuZGVmaW5lZCkgY29udGludWU7XHJcblx0XHRqUXVlcnkuZXh0ZW5kKGZsYXNodmFycywgYXJnLmZsYXNodmFycyk7XHJcblx0fVxyXG5cdG9wdGlvbnMuZmxhc2h2YXJzID0gZmxhc2h2YXJzO1xyXG5cdHJldHVybiBvcHRpb25zO1xyXG59O1xyXG4vKlxyXG4gKiBAbmFtZSBmbGFzaC5oYXNGbGFzaFxyXG4gKiBAZGVzYyBDaGVjayBpZiBhIHNwZWNpZmljIHZlcnNpb24gb2YgdGhlIEZsYXNoIHBsdWdpbiBpcyBpbnN0YWxsZWRcclxuICogQHR5cGUgQm9vbGVhblxyXG4gKlxyXG4qKi9cclxuJCQuaGFzRmxhc2ggPSBmdW5jdGlvbigpIHtcclxuXHQvLyBsb29rIGZvciBhIGZsYWcgaW4gdGhlIHF1ZXJ5IHN0cmluZyB0byBieXBhc3MgZmxhc2ggZGV0ZWN0aW9uXHJcblx0aWYoL2hhc0ZsYXNoXFw9dHJ1ZS8udGVzdChsb2NhdGlvbikpIHJldHVybiB0cnVlO1xyXG5cdGlmKC9oYXNGbGFzaFxcPWZhbHNlLy50ZXN0KGxvY2F0aW9uKSkgcmV0dXJuIGZhbHNlO1xyXG5cdHZhciBwdiA9ICQkLmhhc0ZsYXNoLnBsYXllclZlcnNpb24oKS5tYXRjaCgvXFxkKy9nKTtcclxuXHR2YXIgcnYgPSBTdHJpbmcoW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl1dKS5tYXRjaCgvXFxkKy9nKSB8fCBTdHJpbmcoJCQucGx1Z2luT3B0aW9ucy52ZXJzaW9uKS5tYXRjaCgvXFxkKy9nKTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcblx0XHRwdltpXSA9IHBhcnNlSW50KHB2W2ldIHx8IDApO1xyXG5cdFx0cnZbaV0gPSBwYXJzZUludChydltpXSB8fCAwKTtcclxuXHRcdC8vIHBsYXllciBpcyBsZXNzIHRoYW4gcmVxdWlyZWRcclxuXHRcdGlmKHB2W2ldIDwgcnZbaV0pIHJldHVybiBmYWxzZTtcclxuXHRcdC8vIHBsYXllciBpcyBncmVhdGVyIHRoYW4gcmVxdWlyZWRcclxuXHRcdGlmKHB2W2ldID4gcnZbaV0pIHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyBtYWpvciB2ZXJzaW9uLCBtaW5vciB2ZXJzaW9uIGFuZCByZXZpc2lvbiBtYXRjaCBleGFjdGx5XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG4gKlxyXG4gKiBAbmFtZSBmbGFzaC5oYXNGbGFzaC5wbGF5ZXJWZXJzaW9uXHJcbiAqIEBkZXNjIEdldCB0aGUgdmVyc2lvbiBvZiB0aGUgaW5zdGFsbGVkIEZsYXNoIHBsdWdpbi5cclxuICogQHR5cGUgU3RyaW5nXHJcbiAqXHJcbioqL1xyXG4kJC5oYXNGbGFzaC5wbGF5ZXJWZXJzaW9uID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gaWVcclxuXHR0cnkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gYXZvaWQgZnA2IG1pbm9yIHZlcnNpb24gbG9va3VwIGlzc3Vlc1xyXG5cdFx0XHQvLyBzZWU6IGh0dHA6Ly9ibG9nLmRlY29uY2VwdC5jb20vMjAwNi8wMS8xMS9nZXR2YXJpYWJsZS1zZXR2YXJpYWJsZS1jcmFzaC1pbnRlcm5ldC1leHBsb3Jlci1mbGFzaC02L1xyXG5cdFx0XHR2YXIgYXhvID0gbmV3IEFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoLjYnKTtcclxuXHRcdFx0dHJ5IHsgYXhvLkFsbG93U2NyaXB0QWNjZXNzID0gJ2Fsd2F5cyc7XHR9IFxyXG5cdFx0XHRjYXRjaChlKSB7IHJldHVybiAnNiwwLDAnOyB9XHRcdFx0XHRcclxuXHRcdH0gY2F0Y2goZSkge31cclxuXHRcdHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2gnKS5HZXRWYXJpYWJsZSgnJHZlcnNpb24nKS5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXTtcclxuXHQvLyBvdGhlciBicm93c2Vyc1xyXG5cdH0gY2F0Y2goZSkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0aWYobmF2aWdhdG9yLm1pbWVUeXBlc1tcImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCJdLmVuYWJsZWRQbHVnaW4pe1xyXG5cdFx0XHRcdHJldHVybiAobmF2aWdhdG9yLnBsdWdpbnNbXCJTaG9ja3dhdmUgRmxhc2ggMi4wXCJdIHx8IG5hdmlnYXRvci5wbHVnaW5zW1wiU2hvY2t3YXZlIEZsYXNoXCJdKS5kZXNjcmlwdGlvbi5yZXBsYWNlKC9cXEQrL2csIFwiLFwiKS5tYXRjaCgvXiw/KC4rKSw/JC8pWzFdO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoKGUpIHt9XHRcdFxyXG5cdH1cclxuXHRyZXR1cm4gJzAsMCwwJztcclxufTtcclxuLyoqXHJcbiAqXHJcbiAqIEBuYW1lIGZsYXNoLmh0bWxPcHRpb25zXHJcbiAqIEBkZXNjIFRoZSBkZWZhdWx0IHNldCBvZiBvcHRpb25zIGZvciB0aGUgb2JqZWN0IG9yIGVtYmVkIHRhZy5cclxuICpcclxuKiovXHJcbiQkLmh0bWxPcHRpb25zID0ge1xyXG5cdGhlaWdodDogMjQwLFxyXG5cdGZsYXNodmFyczoge30sXHJcblx0cGx1Z2luc3BhZ2U6ICdodHRwOi8vd3d3LmFkb2JlLmNvbS9nby9nZXRmbGFzaHBsYXllcicsXHJcblx0c3JjOiAnIycsXHJcblx0dHlwZTogJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJyxcclxuXHR3aWR0aDogMzIwXHRcdFxyXG59O1xyXG4vKipcclxuICpcclxuICogQG5hbWUgZmxhc2gucGx1Z2luT3B0aW9uc1xyXG4gKiBAZGVzYyBUaGUgZGVmYXVsdCBzZXQgb2Ygb3B0aW9ucyBmb3IgY2hlY2tpbmcvdXBkYXRpbmcgdGhlIGZsYXNoIFBsdWdpbi5cclxuICpcclxuKiovXHJcbiQkLnBsdWdpbk9wdGlvbnMgPSB7XHJcblx0ZXhwcmVzc0luc3RhbGw6IGZhbHNlLFxyXG5cdHVwZGF0ZTogdHJ1ZSxcclxuXHR2ZXJzaW9uOiAnNi4wLjY1J1xyXG59O1xyXG4vKipcclxuICpcclxuICogQG5hbWUgZmxhc2gucmVwbGFjZVxyXG4gKiBAZGVzYyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIHJlcGxhY2luZyBhbiBlbGVtZW50IHdpdGggYSBGbGFzaCBtb3ZpZS5cclxuICpcclxuKiovXHJcbiQkLnJlcGxhY2UgPSBmdW5jdGlvbihodG1sT3B0aW9ucykge1xyXG5cdHRoaXMuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJhbHRcIj4nK3RoaXMuaW5uZXJIVE1MKyc8L2Rpdj4nO1xyXG5cdGpRdWVyeSh0aGlzKVxyXG5cdFx0LmFkZENsYXNzKCdmbGFzaC1yZXBsYWNlZCcpXHJcblx0XHQucHJlcGVuZCgkJC50cmFuc2Zvcm0oaHRtbE9wdGlvbnMpKTtcclxufTtcclxuLyoqXHJcbiAqXHJcbiAqIEBuYW1lIGZsYXNoLnVwZGF0ZVxyXG4gKiBAZGVzYyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIHJlcGxhY2luZyBhbiBlbGVtZW50IHdpdGggYW4gdXBkYXRlIG1lc3NhZ2UuXHJcbiAqXHJcbioqL1xyXG4kJC51cGRhdGUgPSBmdW5jdGlvbihodG1sT3B0aW9ucykge1xyXG5cdHZhciB1cmwgPSBTdHJpbmcobG9jYXRpb24pLnNwbGl0KCc/Jyk7XHJcblx0dXJsLnNwbGljZSgxLDAsJz9oYXNGbGFzaD10cnVlJicpO1xyXG5cdHVybCA9IHVybC5qb2luKCcnKTtcclxuXHR2YXIgbXNnID0gJzxwPlRoaXMgY29udGVudCByZXF1aXJlcyB0aGUgRmxhc2ggUGxheWVyLiA8YSBocmVmPVwiaHR0cDovL3d3dy5hZG9iZS5jb20vZ28vZ2V0Zmxhc2hwbGF5ZXJcIj5Eb3dubG9hZCBGbGFzaCBQbGF5ZXI8L2E+LiBBbHJlYWR5IGhhdmUgRmxhc2ggUGxheWVyPyA8YSBocmVmPVwiJyt1cmwrJ1wiPkNsaWNrIGhlcmUuPC9hPjwvcD4nO1xyXG5cdHRoaXMuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwiYWx0XCI+Jyt0aGlzLmlubmVySFRNTCsnPC9zcGFuPic7XHJcblx0alF1ZXJ5KHRoaXMpXHJcblx0XHQuYWRkQ2xhc3MoJ2ZsYXNoLXVwZGF0ZScpXHJcblx0XHQucHJlcGVuZChtc2cpO1xyXG59O1xyXG4vKipcclxuICpcclxuICogQGRlc2MgQ29udmVydCBhIGhhc2ggb2YgaHRtbCBvcHRpb25zIHRvIGEgc3RyaW5nIG9mIGF0dHJpYnV0ZXMsIHVzaW5nIEZ1bmN0aW9uLmFwcGx5KCkuIFxyXG4gKiBAZXhhbXBsZSB0b0F0dHJpYnV0ZVN0cmluZy5hcHBseShodG1sT3B0aW9ucylcclxuICogQHJlc3VsdCBmb289XCJiYXJcIiBmb289XCJiYXJcIlxyXG4gKlxyXG4qKi9cclxuZnVuY3Rpb24gdG9BdHRyaWJ1dGVTdHJpbmcoKSB7XHJcblx0dmFyIHMgPSAnJztcclxuXHRmb3IodmFyIGtleSBpbiB0aGlzKVxyXG5cdFx0aWYodHlwZW9mIHRoaXNba2V5XSAhPSAnZnVuY3Rpb24nKVxyXG5cdFx0XHRzICs9IGtleSsnPVwiJyt0aGlzW2tleV0rJ1wiICc7XHJcblx0cmV0dXJuIHM7XHRcdFxyXG59O1xyXG4vKipcclxuICpcclxuICogQGRlc2MgQ29udmVydCBhIGhhc2ggb2YgZmxhc2h2YXJzIHRvIGEgdXJsLWVuY29kZWQgc3RyaW5nLCB1c2luZyBGdW5jdGlvbi5hcHBseSgpLiBcclxuICogQGV4YW1wbGUgdG9GbGFzaHZhcnNTdHJpbmcuYXBwbHkoZmxhc2h2YXJzT2JqZWN0KVxyXG4gKiBAcmVzdWx0IGZvbz1iYXImZm9vPWJhclxyXG4gKlxyXG4qKi9cclxuZnVuY3Rpb24gdG9GbGFzaHZhcnNTdHJpbmcoKSB7XHJcblx0dmFyIHMgPSAnJztcclxuXHRmb3IodmFyIGtleSBpbiB0aGlzKVxyXG5cdFx0aWYodHlwZW9mIHRoaXNba2V5XSAhPSAnZnVuY3Rpb24nKVxyXG5cdFx0XHRzICs9IGtleSsnPScrZW5jb2RlVVJJQ29tcG9uZW50KHRoaXNba2V5XSkrJyYnO1xyXG5cdHJldHVybiBzLnJlcGxhY2UoLyYkLywgJycpO1x0XHRcclxufTtcclxuLyoqXHJcbiAqXHJcbiAqIEBuYW1lIGZsYXNoLnRyYW5zZm9ybVxyXG4gKiBAZGVzYyBUcmFuc2Zvcm0gYSBzZXQgb2YgaHRtbCBvcHRpb25zIGludG8gYW4gZW1iZWQgdGFnLlxyXG4gKiBAdHlwZSBTdHJpbmcgXHJcbiAqXHJcbiAqIEBleGFtcGxlICQkLnRyYW5zZm9ybShodG1sT3B0aW9ucylcclxuICogQHJlc3VsdCA8ZW1iZWQgc3JjPVwiZm9vLnN3ZlwiIC4uLiAvPlxyXG4gKlxyXG4gKiBOb3RlOiBUaGUgZW1iZWQgdGFnIGlzIE5PVCBzdGFuZGFyZHMtY29tcGxpYW50LCBidXQgaXQgXHJcbiAqIHdvcmtzIGluIGFsbCBjdXJyZW50IGJyb3dzZXJzLiBmbGFzaC50cmFuc2Zvcm0gY2FuIGJlXHJcbiAqIG92ZXJ3cml0dGVuIHdpdGggYSBjdXN0b20gZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbW9yZSBcclxuICogc3RhbmRhcmRzLWNvbXBsaWFudCBtYXJrdXAuXHJcbiAqXHJcbioqL1xyXG4kJC50cmFuc2Zvcm0gPSBmdW5jdGlvbihodG1sT3B0aW9ucykge1xyXG5cdGh0bWxPcHRpb25zLnRvU3RyaW5nID0gdG9BdHRyaWJ1dGVTdHJpbmc7XHJcblx0aWYoaHRtbE9wdGlvbnMuZmxhc2h2YXJzKSBodG1sT3B0aW9ucy5mbGFzaHZhcnMudG9TdHJpbmcgPSB0b0ZsYXNodmFyc1N0cmluZztcclxuXHRyZXR1cm4gJzxlbWJlZCAnICsgU3RyaW5nKGh0bWxPcHRpb25zKSArICcvPic7XHRcdFxyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEZsYXNoIFBsYXllciA5IEZpeCAoaHR0cDovL2Jsb2cuZGVjb25jZXB0LmNvbS8yMDA2LzA3LzI4L3N3Zm9iamVjdC0xNDMtcmVsZWFzZWQvKVxyXG4gKlxyXG4qKi9cclxuaWYgKHdpbmRvdy5hdHRhY2hFdmVudCkge1xyXG5cdHdpbmRvdy5hdHRhY2hFdmVudChcIm9uYmVmb3JldW5sb2FkXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRfX2ZsYXNoX3VubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0X19mbGFzaF9zYXZlZFVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xyXG5cdH0pO1xyXG59XHJcblx0XHJcbn0pKCk7XHJcbihmdW5jdGlvbigkKXtcclxuICAgICQuX2kxOG4gPSB7IHRyYW5zOiB7fSwgJ2RlZmF1bHQnOiAgJ2VuJywgbGFuZ3VhZ2U6ICdlbicgfTtcclxuICAgICQuaTE4biA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBnZXRUcmFucyA9IGZ1bmN0aW9uKG5zLCBzdHIpIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHN0cmluZyBleGlzdHMgaW4gdHJhbnNsYXRpb25cclxuICAgICAgICAgICAgaWYgKCQuX2kxOG4udHJhbnNbJC5faTE4bi5sYW5ndWFnZV0gXHJcbiAgICAgICAgICAgICAgICAmJiAkLl9pMThuLnRyYW5zWyQuX2kxOG4ubGFuZ3VhZ2VdW25zXVxyXG4gICAgICAgICAgICAgICAgJiYgJC5faTE4bi50cmFuc1skLl9pMThuLmxhbmd1YWdlXVtuc11bc3RyXSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnMgPSAkLl9pMThuLnRyYW5zWyQuX2kxOG4ubGFuZ3VhZ2VdW25zXVtzdHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG9yIGV4aXN0cyBpbiBkZWZhdWx0XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCQuX2kxOG4udHJhbnNbJC5faTE4blsnZGVmYXVsdCddXSBcclxuICAgICAgICAgICAgICAgICAgICAgJiYgJC5faTE4bi50cmFuc1skLl9pMThuWydkZWZhdWx0J11dW25zXVxyXG4gICAgICAgICAgICAgICAgICAgICAmJiAkLl9pMThuLnRyYW5zWyQuX2kxOG5bJ2RlZmF1bHQnXV1bbnNdW3N0cl0pIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zID0gJC5faTE4bi50cmFuc1skLl9pMThuWydkZWZhdWx0J11dW25zXVtzdHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB0cmFucyBvciBvcmlnaW5hbCBzdHJpbmdcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zIHx8IHN0cjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNldCBsYW5ndWFnZSAoYWNjZXB0ZWQgZm9ybWF0czogZW4gb3IgZW4tVVMpXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICQuX2kxOG4ubGFuZ3VhZ2UgPSBhcmd1bWVudHNbMF07IFxyXG4gICAgICAgICAgICByZXR1cm4gJC5faTE4bi5sYW5ndWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGdldCB0cmFuc2xhdGlvblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZ3VtZW50c1sxXSkgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IGdldFRyYW5zKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgIC8vIGhhcyB2YXJpYWJsZXMgZm9yIHN0cmluZyBmb3JtYXRpbmdcclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMl0gJiYgdHlwZW9mKGFyZ3VtZW50c1syXSkgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5mb3JtYXQodHJhbnMsIGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0IHRyYW5zbGF0aW9uXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCAgPSBhcmd1bWVudHNbMF0uc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYW5nID0gdG1wWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5zICAgPSB0bXBbMV0gfHwgJ2pRdWVyeSc7XHJcbiAgICAgICAgICAgICAgICBpZiAoISQuX2kxOG4udHJhbnNbbGFuZ10pIHtcclxuICAgICAgICAgICAgICAgICAgICAkLl9pMThuLnRyYW5zW2xhbmddID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgJC5faTE4bi50cmFuc1tsYW5nXVtuc10gPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCgkLl9pMThuLnRyYW5zW2xhbmddW25zXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKGpRdWVyeSk7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAwNy0yMDA4IEpvc2ggQnVzaCAoZGlnaXRhbGJ1c2guY29tKVxyXG4gKiBcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuICogY29uZGl0aW9uczpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqIFxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4gXHJcbiAqL1xyXG4gXHJcbi8qXHJcbiAqIFZlcnNpb246IDEuMS4zXHJcbiAqIFJlbGVhc2U6IDIwMDgtMDQtMTZcclxuICovIFxyXG4oZnVuY3Rpb24oJCkge1xyXG5cclxuXHQvL0hlbHBlciBGdW5jdGlvbiBmb3IgQ2FyZXQgcG9zaXRpb25pbmdcclxuXHQkLmZuLmNhcmV0PWZ1bmN0aW9uKGJlZ2luLGVuZCl7XHRcclxuXHRcdGlmKHRoaXMubGVuZ3RoPT0wKSByZXR1cm47XHJcblx0XHRpZiAodHlwZW9mIGJlZ2luID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGVuZCA9ICh0eXBlb2YgZW5kID09ICdudW1iZXInKT9lbmQ6YmVnaW47ICBcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdGlmKHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2Upe1xyXG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xyXG5cdFx0XHRcdFx0dGhpcy5zZXRTZWxlY3Rpb25SYW5nZShiZWdpbixlbmQpO1xyXG5cdFx0XHRcdH1lbHNlIGlmICh0aGlzLmNyZWF0ZVRleHRSYW5nZSl7XHJcblx0XHRcdFx0XHR2YXIgcmFuZ2UgPSB0aGlzLmNyZWF0ZVRleHRSYW5nZSgpO1xyXG5cdFx0XHRcdFx0cmFuZ2UuY29sbGFwc2UodHJ1ZSk7XHJcblx0XHRcdFx0XHRyYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xyXG5cdFx0XHRcdFx0cmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBiZWdpbik7XHJcblx0XHRcdFx0XHRyYW5nZS5zZWxlY3QoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzWzBdLnNldFNlbGVjdGlvblJhbmdlKXtcclxuXHRcdFx0XHRiZWdpbiA9IHRoaXNbMF0uc2VsZWN0aW9uU3RhcnQ7XHJcblx0XHRcdFx0ZW5kID0gdGhpc1swXS5zZWxlY3Rpb25FbmQ7XHJcblx0XHRcdH1lbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKXtcclxuXHRcdFx0XHR2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcdFx0XHRcclxuXHRcdFx0XHRiZWdpbiA9IDAgLSByYW5nZS5kdXBsaWNhdGUoKS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC0xMDAwMDApO1xyXG5cdFx0XHRcdGVuZCA9IGJlZ2luICsgcmFuZ2UudGV4dC5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHtiZWdpbjpiZWdpbixlbmQ6ZW5kfTtcclxuICAgICAgICB9ICAgICAgIFxyXG5cdH07XHJcblxyXG5cdC8vUHJlZGVmaW5lZCBjaGFyYWN0ZXIgZGVmaW5pdGlvbnNcclxuXHR2YXIgY2hhck1hcD17XHJcblx0XHQnOSc6XCJbMC05XVwiLFxyXG5cdFx0J2EnOlwiW0EtWmEtel1cIixcclxuXHRcdCcqJzpcIltBLVphLXowLTldXCJcclxuXHR9O1xyXG5cdFxyXG5cdC8vSGVscGVyIG1ldGhvZCB0byBpbmplY3QgY2hhcmFjdGVyIGRlZmluaXRpb25zXHJcblx0JC5tYXNrPXtcclxuXHRcdGFkZFBsYWNlaG9sZGVyIDogZnVuY3Rpb24oYyxyKXtcclxuXHRcdFx0Y2hhck1hcFtjXT1yO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0JC5mbi51bm1hc2s9ZnVuY3Rpb24oKXtcclxuXHRcdHJldHVybiB0aGlzLnRyaWdnZXIoXCJ1bm1hc2tcIik7XHJcblx0fTtcclxuXHRcclxuXHQvL01haW4gTWV0aG9kXHJcblx0JC5mbi5tYXNrID0gZnVuY3Rpb24obWFzayxzZXR0aW5ncykge1x0XHJcblx0XHRzZXR0aW5ncyA9ICQuZXh0ZW5kKHtcclxuXHRcdFx0cGxhY2Vob2xkZXI6IFwiX1wiLFx0XHRcdFxyXG5cdFx0XHRjb21wbGV0ZWQ6IG51bGxcclxuXHRcdH0sIHNldHRpbmdzKTtcdFx0XHJcblx0XHRcclxuXHRcdC8vQnVpbGQgUmVnZXggZm9yIGZvcm1hdCB2YWxpZGF0aW9uXHJcblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXlwiK1x0XHJcblx0XHQkLm1hcCggbWFzay5zcGxpdChcIlwiKSwgZnVuY3Rpb24oYyxpKXtcdFx0ICBcdFx0ICBcclxuXHRcdCAgcmV0dXJuIGNoYXJNYXBbY118fCgoL1tBLVphLXowLTldLy50ZXN0KGMpP1wiXCI6XCJcXFxcXCIpK2MpO1xyXG5cdFx0fSkuam9pbignJykrXHRcdFx0XHRcclxuXHRcdFwiJFwiKTtcdFx0XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1x0XHRcclxuXHRcdFx0dmFyIGlucHV0PSQodGhpcyk7XHJcblx0XHRcdHZhciBidWZmZXI9bmV3IEFycmF5KG1hc2subGVuZ3RoKTtcclxuXHRcdFx0dmFyIGxvY2tlZD1uZXcgQXJyYXkobWFzay5sZW5ndGgpO1xyXG5cdFx0XHR2YXIgdmFsaWQ9ZmFsc2U7ICAgXHJcblx0XHRcdHZhciBpZ25vcmU9ZmFsc2U7ICBcdFx0XHQvL1ZhcmlhYmxlIGZvciBpZ25vcmluZyBjb250cm9sIGtleXNcclxuXHRcdFx0dmFyIGZpcnN0Tm9uTWFza1Bvcz1udWxsOyBcclxuXHRcdFx0XHJcblx0XHRcdC8vQnVpbGQgYnVmZmVyIGxheW91dCBmcm9tIG1hc2sgJiBkZXRlcm1pbmUgdGhlIGZpcnN0IG5vbiBtYXNrZWQgY2hhcmFjdGVyXHRcdFx0XHJcblx0XHRcdCQuZWFjaCggbWFzay5zcGxpdChcIlwiKSwgZnVuY3Rpb24oaSxjKXtcdFx0XHRcdFxyXG5cdFx0XHRcdGxvY2tlZFtpXT0oY2hhck1hcFtjXT09bnVsbCk7XHRcdFx0XHRcclxuXHRcdFx0XHRidWZmZXJbaV09bG9ja2VkW2ldP2M6c2V0dGluZ3MucGxhY2Vob2xkZXI7XHRcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0aWYoIWxvY2tlZFtpXSAmJiBmaXJzdE5vbk1hc2tQb3M9PW51bGwpXHJcblx0XHRcdFx0XHRmaXJzdE5vbk1hc2tQb3M9aTtcclxuXHRcdFx0fSk7XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0ZnVuY3Rpb24gZm9jdXNFdmVudCgpe1x0XHRcdFx0XHRcclxuXHRcdFx0XHRjaGVja1ZhbCgpO1xyXG5cdFx0XHRcdHdyaXRlQnVmZmVyKCk7XHJcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0JChpbnB1dFswXSkuY2FyZXQodmFsaWQ/bWFzay5sZW5ndGg6Zmlyc3ROb25NYXNrUG9zKTtcdFx0XHRcdFx0XHJcblx0XHRcdFx0fSwwKTtcclxuXHRcdFx0fTtcclxuXHRcdFx0XHJcblx0XHRcdGZ1bmN0aW9uIGtleWRvd25FdmVudChlKXtcdFx0XHRcdFxyXG5cdFx0XHRcdHZhciBwb3M9JCh0aGlzKS5jYXJldCgpO1xyXG5cdFx0XHRcdHZhciBrID0gZS5rZXlDb2RlO1xyXG5cdFx0XHRcdGlnbm9yZT0oayA8IDE2IHx8IChrID4gMTYgJiYgayA8IDMyICkgfHwgKGsgPiAzMiAmJiBrIDwgNDEpKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvL2RlbGV0ZSBzZWxlY3Rpb24gYmVmb3JlIHByb2NlZWRpbmdcclxuXHRcdFx0XHRpZigocG9zLmJlZ2luLXBvcy5lbmQpIT0wICYmICghaWdub3JlIHx8IGs9PTggfHwgaz09NDYpKXtcclxuXHRcdFx0XHRcdGNsZWFyQnVmZmVyKHBvcy5iZWdpbixwb3MuZW5kKTtcclxuXHRcdFx0XHR9XHRcclxuXHRcdFx0XHQvL2JhY2tzcGFjZSBhbmQgZGVsZXRlIGdldCBzcGVjaWFsIHRyZWF0bWVudFxyXG5cdFx0XHRcdGlmKGs9PTgpey8vYmFja3NwYWNlXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0d2hpbGUocG9zLmJlZ2luLS0+PTApe1xyXG5cdFx0XHRcdFx0XHRpZighbG9ja2VkW3Bvcy5iZWdpbl0pe1x0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRidWZmZXJbcG9zLmJlZ2luXT1zZXR0aW5ncy5wbGFjZWhvbGRlcjtcclxuXHRcdFx0XHRcdFx0XHRpZigkLmJyb3dzZXIub3BlcmEpe1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly9PcGVyYSB3b24ndCBsZXQgeW91IGNhbmNlbCB0aGUgYmFja3NwYWNlLCBzbyB3ZSdsbCBsZXQgaXQgYmFja3NwYWNlIG92ZXIgYSBkdW1teSBjaGFyYWN0ZXIuXHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdFx0cz13cml0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aW5wdXQudmFsKHMuc3Vic3RyaW5nKDAscG9zLmJlZ2luKStcIiBcIitzLnN1YnN0cmluZyhwb3MuYmVnaW4pKTtcclxuXHRcdFx0XHRcdFx0XHRcdCQodGhpcykuY2FyZXQocG9zLmJlZ2luKzEpO1x0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0XHRcdHdyaXRlQnVmZmVyKCk7XHJcblx0XHRcdFx0XHRcdFx0XHQkKHRoaXMpLmNhcmV0KE1hdGgubWF4KGZpcnN0Tm9uTWFza1Bvcyxwb3MuYmVnaW4pKTtcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0fVx0XHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHR9ZWxzZSBpZihrPT00Nil7Ly9kZWxldGVcclxuXHRcdFx0XHRcdGNsZWFyQnVmZmVyKHBvcy5iZWdpbixwb3MuYmVnaW4rMSk7XHJcblx0XHRcdFx0XHR3cml0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRcdFx0JCh0aGlzKS5jYXJldChNYXRoLm1heChmaXJzdE5vbk1hc2tQb3MscG9zLmJlZ2luKSk7XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1lbHNlIGlmIChrPT0yNyl7Ly9lc2NhcGVcclxuXHRcdFx0XHRcdGNsZWFyQnVmZmVyKDAsbWFzay5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0d3JpdGVCdWZmZXIoKTtcclxuXHRcdFx0XHRcdCQodGhpcykuY2FyZXQoZmlyc3ROb25NYXNrUG9zKTtcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVx0XHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHR9O1xyXG5cdFx0XHRcclxuXHRcdFx0ZnVuY3Rpb24ga2V5cHJlc3NFdmVudChlKXtcdFx0XHRcdFx0XHJcblx0XHRcdFx0aWYoaWdub3JlKXtcclxuXHRcdFx0XHRcdGlnbm9yZT1mYWxzZTtcclxuXHRcdFx0XHRcdC8vRml4ZXMgTWFjIEZGIGJ1ZyBvbiBiYWNrc3BhY2VcclxuXHRcdFx0XHRcdHJldHVybiAoZS5rZXlDb2RlID09IDgpPyBmYWxzZTogbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZT1lfHx3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdFx0dmFyIGs9ZS5jaGFyQ29kZXx8ZS5rZXlDb2RlfHxlLndoaWNoO1x0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdHZhciBwb3M9JCh0aGlzKS5jYXJldCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0aWYoZS5jdHJsS2V5IHx8IGUuYWx0S2V5KXsvL0lnbm9yZVxyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fWVsc2UgaWYgKChrPj00MSAmJiBrPD0xMjIpIHx8az09MzIgfHwgaz4xODYpey8vdHlwZWFibGUgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdFx0dmFyIHA9c2Vla05leHQocG9zLmJlZ2luLTEpO1x0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmKHA8bWFzay5sZW5ndGgpe1xyXG5cdFx0XHRcdFx0XHRpZihuZXcgUmVnRXhwKGNoYXJNYXBbbWFzay5jaGFyQXQocCldKS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaykpKXtcclxuXHRcdFx0XHRcdFx0XHRidWZmZXJbcF09U3RyaW5nLmZyb21DaGFyQ29kZShrKTtcdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHR3cml0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBuZXh0PXNlZWtOZXh0KHApO1xyXG5cdFx0XHRcdFx0XHRcdCQodGhpcykuY2FyZXQobmV4dCk7XHJcblx0XHRcdFx0XHRcdFx0aWYoc2V0dGluZ3MuY29tcGxldGVkICYmIG5leHQgPT0gbWFzay5sZW5ndGgpXHJcblx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncy5jb21wbGV0ZWQuY2FsbChpbnB1dCk7XHJcblx0XHRcdFx0XHRcdH1cdFx0XHRcdFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cdFx0XHRcdFxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcdFx0XHRcdFxyXG5cdFx0XHR9O1xyXG5cdFx0XHRcclxuXHRcdFx0ZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RhcnQsZW5kKXtcclxuXHRcdFx0XHRmb3IodmFyIGk9c3RhcnQ7aTxlbmQmJmk8bWFzay5sZW5ndGg7aSsrKXtcclxuXHRcdFx0XHRcdGlmKCFsb2NrZWRbaV0pXHJcblx0XHRcdFx0XHRcdGJ1ZmZlcltpXT1zZXR0aW5ncy5wbGFjZWhvbGRlcjtcclxuXHRcdFx0XHR9XHRcdFx0XHRcclxuXHRcdFx0fTtcclxuXHRcdFx0XHJcblx0XHRcdGZ1bmN0aW9uIHdyaXRlQnVmZmVyKCl7XHRcdFx0XHRcclxuXHRcdFx0XHRyZXR1cm4gaW5wdXQudmFsKGJ1ZmZlci5qb2luKCcnKSkudmFsKCk7XHRcdFx0XHRcclxuXHRcdFx0fTtcclxuXHRcdFx0XHJcblx0XHRcdGZ1bmN0aW9uIGNoZWNrVmFsKCl7XHRcclxuXHRcdFx0XHQvL3RyeSB0byBwbGFjZSBjaGFyY3RlcnMgd2hlcmUgdGhleSBiZWxvbmdcclxuXHRcdFx0XHR2YXIgdGVzdD1pbnB1dC52YWwoKTtcclxuXHRcdFx0XHR2YXIgcG9zPTA7XHJcblx0XHRcdFx0Zm9yKHZhciBpPTA7aTxtYXNrLmxlbmd0aDtpKyspe1x0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmKCFsb2NrZWRbaV0pe1xyXG5cdFx0XHRcdFx0XHRidWZmZXJbaV09c2V0dGluZ3MucGxhY2Vob2xkZXI7XHJcblx0XHRcdFx0XHRcdHdoaWxlKHBvcysrPHRlc3QubGVuZ3RoKXtcclxuXHRcdFx0XHRcdFx0XHQvL1JlZ2V4IFRlc3QgZWFjaCBjaGFyIGhlcmUuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHJlQ2hhcj1uZXcgUmVnRXhwKGNoYXJNYXBbbWFzay5jaGFyQXQoaSldKTtcclxuXHRcdFx0XHRcdFx0XHRpZih0ZXN0LmNoYXJBdChwb3MtMSkubWF0Y2gocmVDaGFyKSl7XHJcblx0XHRcdFx0XHRcdFx0XHRidWZmZXJbaV09dGVzdC5jaGFyQXQocG9zLTEpO1x0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgcz13cml0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRcdGlmKCFzLm1hdGNoKHJlKSl7XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlucHV0LnZhbChcIlwiKTtcdFxyXG5cdFx0XHRcdFx0Y2xlYXJCdWZmZXIoMCxtYXNrLmxlbmd0aCk7XHJcblx0XHRcdFx0XHR2YWxpZD1mYWxzZTtcclxuXHRcdFx0XHR9ZWxzZVxyXG5cdFx0XHRcdFx0dmFsaWQ9dHJ1ZTtcclxuXHRcdFx0fTtcclxuXHRcdFx0XHJcblx0XHRcdGZ1bmN0aW9uIHNlZWtOZXh0KHBvcyl7XHRcdFx0XHRcclxuXHRcdFx0XHR3aGlsZSgrK3BvczxtYXNrLmxlbmd0aCl7XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0aWYoIWxvY2tlZFtwb3NdKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcG9zO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbWFzay5sZW5ndGg7XHJcblx0XHRcdH07XHJcblx0XHRcdFxyXG5cdFx0XHRpbnB1dC5vbmUoXCJ1bm1hc2tcIixmdW5jdGlvbigpe1xyXG5cdFx0XHRcdGlucHV0LnVuYmluZChcImZvY3VzXCIsZm9jdXNFdmVudCk7XHJcblx0XHRcdFx0aW5wdXQudW5iaW5kKFwiYmx1clwiLGNoZWNrVmFsKTtcclxuXHRcdFx0XHRpbnB1dC51bmJpbmQoXCJrZXlkb3duXCIsa2V5ZG93bkV2ZW50KTtcclxuXHRcdFx0XHRpbnB1dC51bmJpbmQoXCJrZXlwcmVzc1wiLGtleXByZXNzRXZlbnQpO1xyXG5cdFx0XHRcdGlmICgkLmJyb3dzZXIubXNpZSkgXHJcblx0XHRcdFx0XHR0aGlzLm9ucGFzdGU9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgXHJcblx0XHRcdFx0ZWxzZSBpZiAoJC5icm93c2VyLm1vemlsbGEpXHJcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JyxjaGVja1ZhbCxmYWxzZSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpbnB1dC5iaW5kKFwiZm9jdXNcIixmb2N1c0V2ZW50KTtcclxuXHRcdFx0aW5wdXQuYmluZChcImJsdXJcIixjaGVja1ZhbCk7XHJcblx0XHRcdGlucHV0LmJpbmQoXCJrZXlkb3duXCIsa2V5ZG93bkV2ZW50KTtcclxuXHRcdFx0aW5wdXQuYmluZChcImtleXByZXNzXCIsa2V5cHJlc3NFdmVudCk7XHJcblx0XHRcdC8vUGFzdGUgZXZlbnRzIGZvciBJRSBhbmQgTW96aWxsYSB0aGFua3MgdG8gS3Jpc3Rpbm4gU2lnbXVuZHNzb25cclxuXHRcdFx0aWYgKCQuYnJvd3Nlci5tc2llKSBcclxuXHRcdFx0XHR0aGlzLm9ucGFzdGU9IGZ1bmN0aW9uKCl7c2V0VGltZW91dChjaGVja1ZhbCwwKTt9OyAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRlbHNlIGlmICgkLmJyb3dzZXIubW96aWxsYSlcclxuXHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JyxjaGVja1ZhbCxmYWxzZSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdGNoZWNrVmFsKCk7Ly9QZXJmb3JtIGluaXRpYWwgY2hlY2sgZm9yIGV4aXN0aW5nIHZhbHVlc1xyXG5cdFx0fSk7XHJcblx0fTtcclxufSkoalF1ZXJ5KTtcclxuLyogQ29weXJpZ2h0IChjKSAyMDA2IEJyYW5kb24gQWFyb24gKGJyYW5kb24uYWFyb25AZ21haWwuY29tIHx8IGh0dHA6Ly9icmFuZG9uYWFyb24ubmV0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxyXG4gKiBhbmQgR1BMIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL2dwbC1saWNlbnNlLnBocCkgbGljZW5zZXMuXHJcbiAqIFRoYW5rcyB0bzogaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC8gZm9yIHNvbWUgcG9pbnRlcnMuXHJcbiAqIFRoYW5rcyB0bzogTWF0aGlhcyBCYW5rKGh0dHA6Ly93d3cubWF0aGlhcy1iYW5rLmRlKSBmb3IgYSBzY29wZSBidWcgZml4LlxyXG4gKlxyXG4gKiAkTGFzdENoYW5nZWREYXRlOiAyMDA3LTEyLTIwIDA5OjAyOjA4IC0wNjAwIChUaHUsIDIwIERlYyAyMDA3KSAkXHJcbiAqICRSZXY6IDQyNjUgJFxyXG4gKlxyXG4gKiBWZXJzaW9uOiAzLjBcclxuICogXHJcbiAqIFJlcXVpcmVzOiAkIDEuMi4yK1xyXG4gKi9cclxuXHJcbihmdW5jdGlvbigkKSB7XHJcblxyXG4kLmV2ZW50LnNwZWNpYWwubW91c2V3aGVlbCA9IHtcclxuXHRzZXR1cDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgaGFuZGxlciA9ICQuZXZlbnQuc3BlY2lhbC5tb3VzZXdoZWVsLmhhbmRsZXI7XHJcblx0XHRcclxuXHRcdC8vIEZpeCBwYWdlWCwgcGFnZVksIGNsaWVudFggYW5kIGNsaWVudFkgZm9yIG1vemlsbGFcclxuXHRcdGlmICggJC5icm93c2VyLm1vemlsbGEgKVxyXG5cdFx0XHQkKHRoaXMpLmJpbmQoJ21vdXNlbW92ZS5tb3VzZXdoZWVsJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0XHQkLmRhdGEodGhpcywgJ213Y3Vyc29ycG9zZGF0YScsIHtcclxuXHRcdFx0XHRcdHBhZ2VYOiBldmVudC5wYWdlWCxcclxuXHRcdFx0XHRcdHBhZ2VZOiBldmVudC5wYWdlWSxcclxuXHRcdFx0XHRcdGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcblx0XHRcdFx0XHRjbGllbnRZOiBldmVudC5jbGllbnRZXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFxyXG5cdFx0aWYgKCB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgKVxyXG5cdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoICgkLmJyb3dzZXIubW96aWxsYSA/ICdET01Nb3VzZVNjcm9sbCcgOiAnbW91c2V3aGVlbCcpLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoaXMub25tb3VzZXdoZWVsID0gaGFuZGxlcjtcclxuXHR9LFxyXG5cdFxyXG5cdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBoYW5kbGVyID0gJC5ldmVudC5zcGVjaWFsLm1vdXNld2hlZWwuaGFuZGxlcjtcclxuXHRcdFxyXG5cdFx0JCh0aGlzKS51bmJpbmQoJ21vdXNlbW92ZS5tb3VzZXdoZWVsJyk7XHJcblx0XHRcclxuXHRcdGlmICggdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyIClcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCAoJC5icm93c2VyLm1vemlsbGEgPyAnRE9NTW91c2VTY3JvbGwnIDogJ21vdXNld2hlZWwnKSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aGlzLm9ubW91c2V3aGVlbCA9IGZ1bmN0aW9uKCl7fTtcclxuXHRcdFxyXG5cdFx0JC5yZW1vdmVEYXRhKHRoaXMsICdtd2N1cnNvcnBvc2RhdGEnKTtcclxuXHR9LFxyXG5cdFxyXG5cdGhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcclxuXHRcdFxyXG5cdFx0ZXZlbnQgPSAkLmV2ZW50LmZpeChldmVudCB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdFx0Ly8gR2V0IGNvcnJlY3QgcGFnZVgsIHBhZ2VZLCBjbGllbnRYIGFuZCBjbGllbnRZIGZvciBtb3ppbGxhXHJcblx0XHQkLmV4dGVuZCggZXZlbnQsICQuZGF0YSh0aGlzLCAnbXdjdXJzb3Jwb3NkYXRhJykgfHwge30gKTtcclxuXHRcdHZhciBkZWx0YSA9IDAsIHJldHVyblZhbHVlID0gdHJ1ZTtcclxuXHRcdFxyXG5cdFx0aWYgKCBldmVudC53aGVlbERlbHRhICkgZGVsdGEgPSBldmVudC53aGVlbERlbHRhLzEyMDtcclxuXHRcdGlmICggZXZlbnQuZGV0YWlsICAgICApIGRlbHRhID0gLWV2ZW50LmRldGFpbC8zO1xyXG5cdFx0aWYgKCAkLmJyb3dzZXIub3BlcmEgICkgZGVsdGEgPSAtZXZlbnQud2hlZWxEZWx0YTtcclxuXHRcdFxyXG5cdFx0ZXZlbnQuZGF0YSAgPSBldmVudC5kYXRhIHx8IHt9O1xyXG5cdFx0ZXZlbnQudHlwZSAgPSBcIm1vdXNld2hlZWxcIjtcclxuXHRcdFxyXG5cdFx0Ly8gQWRkIGRlbHRhIHRvIHRoZSBmcm9udCBvZiB0aGUgYXJndW1lbnRzXHJcblx0XHRhcmdzLnVuc2hpZnQoZGVsdGEpO1xyXG5cdFx0Ly8gQWRkIGV2ZW50IHRvIHRoZSBmcm9udCBvZiB0aGUgYXJndW1lbnRzXHJcblx0XHRhcmdzLnVuc2hpZnQoZXZlbnQpO1xyXG5cclxuXHRcdHJldHVybiAkLmV2ZW50LmhhbmRsZS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9XHJcbn07XHJcblxyXG4kLmZuLmV4dGVuZCh7XHJcblx0bW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcclxuXHRcdHJldHVybiBmbiA/IHRoaXMuYmluZChcIm1vdXNld2hlZWxcIiwgZm4pIDogdGhpcy50cmlnZ2VyKFwibW91c2V3aGVlbFwiKTtcclxuXHR9LFxyXG5cdFxyXG5cdHVubW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcclxuXHRcdHJldHVybiB0aGlzLnVuYmluZChcIm1vdXNld2hlZWxcIiwgZm4pO1xyXG5cdH1cclxufSk7XHJcblxyXG59KShqUXVlcnkpOy8qIVxyXG4gICAgICAgIFNsaW1ib3ggdjIuMDIgLSBUaGUgdWx0aW1hdGUgbGlnaHR3ZWlnaHQgTGlnaHRib3ggY2xvbmUgZm9yIGpRdWVyeVxyXG4gICAgICAgIChjKSAyMDA3LTIwMDkgQ2hyaXN0b3BoZSBCZXlscyA8aHR0cDovL3d3dy5kaWdpdGFsaWEuYmU+XHJcbiAgICAgICAgTUlULXN0eWxlIGxpY2Vuc2UuXHJcbiovXHJcblxyXG4oZnVuY3Rpb24oJCkge1xyXG5cclxuICAgICAgICAvLyBHbG9iYWwgdmFyaWFibGVzLCBhY2Nlc3NpYmxlIHRvIFNsaW1ib3ggb25seVxyXG4gICAgICAgIHZhciB3aW4gPSAkKHdpbmRvdyksIG9wdGlvbnMsIGltYWdlcywgYWN0aXZlSW1hZ2UgPSAtMSwgYWN0aXZlVVJMLCBwcmV2SW1hZ2UsIG5leHRJbWFnZSwgY29tcGF0aWJsZU92ZXJsYXksIG1pZGRsZSwgY2VudGVyV2lkdGgsIGNlbnRlckhlaWdodCwgaWU2ID0gIXdpbmRvdy5YTUxIdHRwUmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIG9wZXJhRml4ID0gd2luZG93Lm9wZXJhICYmIChkb2N1bWVudC5jb21wYXRNb2RlID09IFwiQ1NTMUNvbXBhdFwiKSAmJiAoJC5icm93c2VyLnZlcnNpb24gPj0gOS4zKSwgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG5cclxuICAgICAgICAvLyBQcmVsb2FkIGltYWdlc1xyXG4gICAgICAgIHByZWxvYWQgPSB7fSwgcHJlbG9hZFByZXYgPSBuZXcgSW1hZ2UoKSwgcHJlbG9hZE5leHQgPSBuZXcgSW1hZ2UoKSxcclxuXHJcbiAgICAgICAgLy8gRE9NIGVsZW1lbnRzXHJcbiAgICAgICAgb3ZlcmxheSwgY2VudGVyLCBpbWFnZSwgc2l6ZXIsIHByZXZMaW5rLCBuZXh0TGluaywgYm90dG9tQ29udGFpbmVyLCBib3R0b20sIGNhcHRpb24sIG51bWJlcjtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgICAgIEluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgJChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgU2xpbWJveCBIVE1MIGNvZGUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICQoXCJib2R5XCIpLmFwcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9ICQoJzxkaXYgaWQ9XCJsYk92ZXJsYXlcIiAvPicpWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlciA9ICQoJzxkaXYgaWQ9XCJsYkNlbnRlclwiIC8+JylbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gJCgnPGRpdiBpZD1cImxiQm90dG9tQ29udGFpbmVyXCIgLz4nKVswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdKS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbWFnZSA9ICQoJzxkaXYgaWQ9XCJsYkltYWdlXCIgLz4nKS5hcHBlbmRUbyhjZW50ZXIpLmFwcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZXIgPSAkKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlO1wiIC8+JykuYXBwZW5kKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGluayA9ICQoJzxhIGlkPVwibGJQcmV2TGlua1wiIGhyZWY9XCIjXCIgLz4nKS5jbGljayhwcmV2aW91cylbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmsgPSAkKCc8YSBpZD1cImxiTmV4dExpbmtcIiBocmVmPVwiI1wiIC8+JykuY2xpY2sobmV4dClbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSlbMF1cclxuICAgICAgICAgICAgICAgIClbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgYm90dG9tID0gJCgnPGRpdiBpZD1cImxiQm90dG9tXCIgLz4nKS5hcHBlbmRUbyhib3R0b21Db250YWluZXIpLmFwcGVuZChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxhIGlkPVwibGJDbG9zZUxpbmtcIiBocmVmPVwiI1wiIC8+JykuYWRkKG92ZXJsYXkpLmNsaWNrKGNsb3NlKVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdGlvbiA9ICQoJzxkaXYgaWQ9XCJsYkNhcHRpb25cIiAvPicpWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgPSAkKCc8ZGl2IGlkPVwibGJOdW1iZXJcIiAvPicpWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8ZGl2IHN0eWxlPVwiY2xlYXI6IGJvdGg7XCIgLz4nKVswXVxyXG4gICAgICAgICAgICAgICAgXSlbMF07XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgQVBJXHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gT3BlbiBTbGltYm94IHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgJC5zbGltYm94ID0gZnVuY3Rpb24oX2ltYWdlcywgc3RhcnRJbWFnZSwgX29wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3A6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd3MgdG8gbmF2aWdhdGUgYmV0d2VlbiBmaXJzdCBhbmQgbGFzdCBpbWFnZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheU9wYWNpdHk6IDAuOCwgICAgICAgICAgICAgICAgICAgIC8vIDEgaXMgb3BhcXVlLCAwIGlzIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnQgKGNoYW5nZSB0aGUgY29sb3IgaW4gdGhlIENTUyBmaWxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5RmFkZUR1cmF0aW9uOiA0MDAsICAgICAgICAgICAgICAgLy8gRHVyYXRpb24gb2YgdGhlIG92ZXJsYXkgZmFkZS1pbiBhbmQgZmFkZS1vdXQgYW5pbWF0aW9ucyAoaW4gbWlsbGlzZWNvbmRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVEdXJhdGlvbjogNDAwLCAgICAgICAgICAgICAgICAgICAgLy8gRHVyYXRpb24gb2YgZWFjaCBvZiB0aGUgYm94IHJlc2l6ZSBhbmltYXRpb25zIChpbiBtaWxsaXNlY29uZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZUVhc2luZzogXCJzd2luZ1wiLCAgICAgICAgICAgICAgICAgIC8vIFwic3dpbmdcIiBpcyBqUXVlcnkncyBkZWZhdWx0IGVhc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsV2lkdGg6IDI1MCwgICAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbCB3aWR0aCBvZiB0aGUgYm94IChpbiBwaXhlbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxIZWlnaHQ6IDI1MCwgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsIGhlaWdodCBvZiB0aGUgYm94IChpbiBwaXhlbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRmFkZUR1cmF0aW9uOiA0MDAsICAgICAgICAgICAgICAgICAvLyBEdXJhdGlvbiBvZiB0aGUgaW1hZ2UgZmFkZS1pbiBhbmltYXRpb24gKGluIG1pbGxpc2Vjb25kcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdGlvbkFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsICAgICAgICAgIC8vIER1cmF0aW9uIG9mIHRoZSBjYXB0aW9uIGFuaW1hdGlvbiAoaW4gbWlsbGlzZWNvbmRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyVGV4dDogXCJJbWFnZSB7eH0gb2Yge3l9XCIsICAgICAgICAvLyBUcmFuc2xhdGUgb3IgY2hhbmdlIGFzIHlvdSB3aXNoLCBvciBzZXQgaXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjb3VudGVyIHRleHQgZm9yIGltYWdlIGdyb3Vwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUtleXM6IFsyNywgODgsIDY3XSwgICAgICAgICAgICAgICAgLy8gQXJyYXkgb2Yga2V5Y29kZXMgdG8gY2xvc2UgU2xpbWJveCwgZGVmYXVsdDogRXNjICgyNyksICd4JyAoODgpLCAnYycgKDY3KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0tleXM6IFszNywgODBdLCAgICAgICAgICAgICAgICAgLy8gQXJyYXkgb2Yga2V5Y29kZXMgdG8gbmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIGltYWdlLCBkZWZhdWx0OiBMZWZ0IGFycm93ICgzNyksICdwJyAoODApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRLZXlzOiBbMzksIDc4XSAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBrZXljb2RlcyB0byBuYXZpZ2F0ZSB0byB0aGUgbmV4dCBpbWFnZSwgZGVmYXVsdDogUmlnaHQgYXJyb3cgKDM5KSwgJ24nICg3OClcclxuICAgICAgICAgICAgICAgIH0sIF9vcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBhIHNpbmdsZSBpbWFnZSwgd2l0aCBVUkwgYW5kIFRpdGxlIGFzIGZpcnN0IHR3byBhcmd1bWVudHNcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX2ltYWdlcyA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbWFnZXMgPSBbW19pbWFnZXMsIHN0YXJ0SW1hZ2VdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbWFnZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWlkZGxlID0gd2luLnNjcm9sbFRvcCgpICsgKChvcGVyYUZpeCA/IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiB3aW4uaGVpZ2h0KCkpIC8gMik7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXJXaWR0aCA9IG9wdGlvbnMuaW5pdGlhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY2VudGVySGVpZ2h0ID0gb3B0aW9ucy5pbml0aWFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgJChjZW50ZXIpLmNzcyh7dG9wOiBNYXRoLm1heCgwLCBtaWRkbGUgLSAoY2VudGVySGVpZ2h0IC8gMikpLCB3aWR0aDogY2VudGVyV2lkdGgsIGhlaWdodDogY2VudGVySGVpZ2h0LCBtYXJnaW5MZWZ0OiAtY2VudGVyV2lkdGgvMn0pLnNob3coKTtcclxuICAgICAgICAgICAgICAgIGNvbXBhdGlibGVPdmVybGF5ID0gaWU2IHx8IChvdmVybGF5LmN1cnJlbnRTdHlsZSAmJiAob3ZlcmxheS5jdXJyZW50U3R5bGUucG9zaXRpb24gIT0gXCJmaXhlZFwiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGF0aWJsZU92ZXJsYXkpIG92ZXJsYXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgICAgICAgICAkKG92ZXJsYXkpLmNzcyhcIm9wYWNpdHlcIiwgb3B0aW9ucy5vdmVybGF5T3BhY2l0eSkuZmFkZUluKG9wdGlvbnMub3ZlcmxheUZhZGVEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgc2V0dXAoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzID0gX2ltYWdlcztcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCA9IG9wdGlvbnMubG9vcCAmJiAoaW1hZ2VzLmxlbmd0aCA+IDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUltYWdlKHN0YXJ0SW1hZ2UpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiAgICAgICAgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QsIHNlZSBqUXVlcnkuc2xpbWJveCgpXHJcbiAgICAgICAgICAgICAgICBsaW5rTWFwcGVyOiAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdGFraW5nIGEgbGluayBET00gZWxlbWVudCBhbmQgYW4gaW5kZXggYXMgYXJndW1lbnRzIGFuZCByZXR1cm5pbmcgYW4gYXJyYXkgY29udGFpbmluZyAyIGVsZW1lbnRzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbWFnZSBVUkwgYW5kIHRoZSBpbWFnZSBjYXB0aW9uIChtYXkgY29udGFpbiBIVE1MKVxyXG4gICAgICAgICAgICAgICAgbGlua3NGaWx0ZXI6ICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRha2luZyBhIGxpbmsgRE9NIGVsZW1lbnQgYW5kIGFuIGluZGV4IGFzIGFyZ3VtZW50cyBhbmQgcmV0dXJuaW5nIHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgcGFydCBvZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbWFnZSBjb2xsZWN0aW9uIHRoYXQgd2lsbCBiZSBzaG93biBvbiBjbGljaywgZmFsc2UgaWYgbm90LiBcInRoaXNcIiByZWZlcnMgdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIG11c3QgYWx3YXlzIHJldHVybiB0cnVlIHdoZW4gdGhlIERPTSBlbGVtZW50IGFyZ3VtZW50IGlzIFwidGhpc1wiLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgJC5mbi5zbGltYm94ID0gZnVuY3Rpb24oX29wdGlvbnMsIGxpbmtNYXBwZXIsIGxpbmtzRmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rTWFwcGVyID0gbGlua01hcHBlciB8fCBmdW5jdGlvbihlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsLmhyZWYsIGVsLnRpdGxlXTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgbGlua3NGaWx0ZXIgPSBsaW5rc0ZpbHRlciB8fCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsaW5rcyA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtzLnVuYmluZChcImNsaWNrXCIpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgbGlzdCBvZiBpbWFnZXMgdGhhdCB3aWxsIGJlIGRpc3BsYXllZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMsIHN0YXJ0SW5kZXggPSAwLCBmaWx0ZXJlZExpbmtzLCBpID0gMCwgbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZExpbmtzID0gJC5ncmVwKGxpbmtzLCBmdW5jdGlvbihlbCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rc0ZpbHRlci5jYWxsKGxpbmssIGVsLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGpRdWVyeS5tYXAoKSBiZWNhdXNlIGl0IGZsYXR0ZW5zIHRoZSByZXR1cm5lZCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IGZpbHRlcmVkTGlua3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRMaW5rc1tpXSA9PSBsaW5rKSBzdGFydEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZExpbmtzW2ldID0gbGlua01hcHBlcihmaWx0ZXJlZExpbmtzW2ldLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuc2xpbWJveChmaWx0ZXJlZExpbmtzLCBzdGFydEluZGV4LCBfb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgICAgIEludGVybmFsIGZ1bmN0aW9uc1xyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSB3aW4uc2Nyb2xsTGVmdCgpLCB3ID0gb3BlcmFGaXggPyBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiB3aW4ud2lkdGgoKTtcclxuICAgICAgICAgICAgICAgICQoW2NlbnRlciwgYm90dG9tQ29udGFpbmVyXSkuY3NzKFwibGVmdFwiLCBsICsgKHcgLyAyKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGF0aWJsZU92ZXJsYXkpICQob3ZlcmxheSkuY3NzKHtsZWZ0OiBsLCB0b3A6IHdpbi5zY3JvbGxUb3AoKSwgd2lkdGg6IHcsIGhlaWdodDogd2luLmhlaWdodCgpfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzZXR1cChvcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAkKFwib2JqZWN0XCIpLmFkZChpZTYgPyBcInNlbGVjdFwiIDogXCJlbWJlZFwiKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbikgJC5kYXRhKGVsLCBcInNsaW1ib3hcIiwgZWwuc3R5bGUudmlzaWJpbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLnZpc2liaWxpdHkgPSBvcGVuID8gXCJoaWRkZW5cIiA6ICQuZGF0YShlbCwgXCJzbGltYm94XCIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBvcGVuID8gXCJiaW5kXCIgOiBcInVuYmluZFwiO1xyXG4gICAgICAgICAgICAgICAgd2luW2ZuXShcInNjcm9sbCByZXNpemVcIiwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudClbZm5dKFwia2V5ZG93blwiLCBrZXlEb3duKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGtleURvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZXZlbnQua2V5Q29kZSwgZm4gPSAkLmluQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQga2V5Ym9hcmQgYWN0aW9uIChsaWtlIG5hdmlnYXRpbmcgaW5zaWRlIHRoZSBwYWdlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChmbihjb2RlLCBvcHRpb25zLmNsb3NlS2V5cykgPj0gMCkgPyBjbG9zZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGZuKGNvZGUsIG9wdGlvbnMubmV4dEtleXMpID49IDApID8gbmV4dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGZuKGNvZGUsIG9wdGlvbnMucHJldmlvdXNLZXlzKSA+PSAwKSA/IHByZXZpb3VzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHByZXZpb3VzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUltYWdlKHByZXZJbWFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUltYWdlKG5leHRJbWFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VJbWFnZShpbWFnZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUltYWdlID0gaW1hZ2VJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVVJMID0gaW1hZ2VzW2FjdGl2ZUltYWdlXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkltYWdlID0gKGFjdGl2ZUltYWdlIHx8IChvcHRpb25zLmxvb3AgPyBpbWFnZXMubGVuZ3RoIDogMCkpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEltYWdlID0gKChhY3RpdmVJbWFnZSArIDEpICUgaW1hZ2VzLmxlbmd0aCkgfHwgKG9wdGlvbnMubG9vcCA/IDAgOiAtMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlci5jbGFzc05hbWUgPSBcImxiTG9hZGluZ1wiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVsb2FkLm9ubG9hZCA9IGFuaW1hdGVCb3g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWxvYWQuc3JjID0gYWN0aXZlVVJMO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFuaW1hdGVCb3goKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIuY2xhc3NOYW1lID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICQoaW1hZ2UpLmNzcyh7YmFja2dyb3VuZEltYWdlOiBcInVybChcIiArIGFjdGl2ZVVSTCArIFwiKVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcIlwifSk7XHJcbiAgICAgICAgICAgICAgICAkKHNpemVyKS53aWR0aChwcmVsb2FkLndpZHRoKTtcclxuICAgICAgICAgICAgICAgICQoW3NpemVyLCBwcmV2TGluaywgbmV4dExpbmtdKS5oZWlnaHQocHJlbG9hZC5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICQoY2FwdGlvbikuaHRtbChpbWFnZXNbYWN0aXZlSW1hZ2VdWzFdIHx8IFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgJChudW1iZXIpLmh0bWwoKCgoaW1hZ2VzLmxlbmd0aCA+IDEpICYmIG9wdGlvbnMuY291bnRlclRleHQpIHx8IFwiXCIpLnJlcGxhY2UoL3t4fS8sIGFjdGl2ZUltYWdlICsgMSkucmVwbGFjZSgve3l9LywgaW1hZ2VzLmxlbmd0aCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcmV2SW1hZ2UgPj0gMCkgcHJlbG9hZFByZXYuc3JjID0gaW1hZ2VzW3ByZXZJbWFnZV1bMF07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dEltYWdlID49IDApIHByZWxvYWROZXh0LnNyYyA9IGltYWdlc1tuZXh0SW1hZ2VdWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGNlbnRlcldpZHRoID0gaW1hZ2Uub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXJIZWlnaHQgPSBpbWFnZS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gTWF0aC5tYXgoMCwgbWlkZGxlIC0gKGNlbnRlckhlaWdodCAvIDIpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjZW50ZXIub2Zmc2V0SGVpZ2h0ICE9IGNlbnRlckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGNlbnRlcikuYW5pbWF0ZSh7aGVpZ2h0OiBjZW50ZXJIZWlnaHQsIHRvcDogdG9wfSwgb3B0aW9ucy5yZXNpemVEdXJhdGlvbiwgb3B0aW9ucy5yZXNpemVFYXNpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlci5vZmZzZXRXaWR0aCAhPSBjZW50ZXJXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGNlbnRlcikuYW5pbWF0ZSh7d2lkdGg6IGNlbnRlcldpZHRoLCBtYXJnaW5MZWZ0OiAtY2VudGVyV2lkdGgvMn0sIG9wdGlvbnMucmVzaXplRHVyYXRpb24sIG9wdGlvbnMucmVzaXplRWFzaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICQoY2VudGVyKS5xdWV1ZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJChib3R0b21Db250YWluZXIpLmNzcyh7d2lkdGg6IGNlbnRlcldpZHRoLCB0b3A6IHRvcCArIGNlbnRlckhlaWdodCwgbWFyZ2luTGVmdDogLWNlbnRlcldpZHRoLzIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiXCJ9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJChpbWFnZSkuY3NzKHtkaXNwbGF5OiBcIm5vbmVcIiwgdmlzaWJpbGl0eTogXCJcIiwgb3BhY2l0eTogXCJcIn0pLmZhZGVJbihvcHRpb25zLmltYWdlRmFkZUR1cmF0aW9uLCBhbmltYXRlQ2FwdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhbmltYXRlQ2FwdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2SW1hZ2UgPj0gMCkgJChwcmV2TGluaykuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRJbWFnZSA+PSAwKSAkKG5leHRMaW5rKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAkKGJvdHRvbSkuY3NzKFwibWFyZ2luVG9wXCIsIC1ib3R0b20ub2Zmc2V0SGVpZ2h0KS5hbmltYXRlKHttYXJnaW5Ub3A6IDB9LCBvcHRpb25zLmNhcHRpb25BbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBib3R0b21Db250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzdG9wKCkge1xyXG4gICAgICAgICAgICAgICAgcHJlbG9hZC5vbmxvYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcHJlbG9hZC5zcmMgPSBwcmVsb2FkUHJldi5zcmMgPSBwcmVsb2FkTmV4dC5zcmMgPSBhY3RpdmVVUkw7XHJcbiAgICAgICAgICAgICAgICAkKFtjZW50ZXIsIGltYWdlLCBib3R0b21dKS5zdG9wKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgJChbcHJldkxpbmssIG5leHRMaW5rLCBpbWFnZSwgYm90dG9tQ29udGFpbmVyXSkuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlSW1hZ2UgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUltYWdlID0gcHJldkltYWdlID0gbmV4dEltYWdlID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoY2VudGVyKS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQob3ZlcmxheSkuc3RvcCgpLmZhZGVPdXQob3B0aW9ucy5vdmVybGF5RmFkZUR1cmF0aW9uLCBzZXR1cCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbn0pKGpRdWVyeSk7XHJcbi8qXHJcbiAqIHRpbWVhZ286IGEgalF1ZXJ5IHBsdWdpbiwgdmVyc2lvbjogMC41LjEgKDA4LzIwLzIwMDgpXHJcbiAqIEByZXF1aXJlcyBqUXVlcnkgdjEuMiBvciBsYXRlclxyXG4gKlxyXG4gKiBUaW1lYWdvIGlzIGEgalF1ZXJ5IHBsdWdpbiB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gc3VwcG9ydCBhdXRvbWF0aWNhbGx5XHJcbiAqIHVwZGF0aW5nIGZ1enp5IHRpbWVzdGFtcHMgKGUuZy4gXCI0IG1pbnV0ZXMgYWdvXCIgb3IgXCJhYm91dCAxIGRheSBhZ29cIikuXHJcbiAqXHJcbiAqIEZvciB1c2FnZSBhbmQgZXhhbXBsZXMsIHZpc2l0OlxyXG4gKiBodHRwOi8vdGltZWFnby55YXJwLmNvbS9cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVDpcclxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDA4LCBSeWFuIE1jR2VhcnkgKHJ5YW5vbmphdmFzY3JpcHQgLVthdF0tIG1jZ2VhcnkgWypkb3QqXSBvcmcpXHJcbiAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG4gICQudGltZWFnbyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xyXG4gICAgaWYgKHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBpbldvcmRzKHRpbWVzdGFtcCk7XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdGltZXN0YW1wID09IFwic3RyaW5nXCIpIHJldHVybiBpbldvcmRzKCQudGltZWFnby5wYXJzZSh0aW1lc3RhbXApKTtcclxuICAgIGVsc2UgcmV0dXJuIGluV29yZHMoJC50aW1lYWdvLnBhcnNlKCQodGltZXN0YW1wKS5hdHRyKFwidGl0bGVcIikpKTtcclxuICB9O1xyXG4gIHZhciAkdCA9ICQudGltZWFnbztcclxuXHJcbiAgJC5leHRlbmQoJC50aW1lYWdvLCB7XHJcbiAgICBzZXR0aW5nczoge1xyXG4gICAgICByZWZyZXNoTWlsbGlzOiA2MDAwMCxcclxuICAgICAgYWxsb3dGdXR1cmU6IGZhbHNlLFxyXG4gICAgICBzdHJpbmdzOiB7XHJcbiAgICAgICAgYWdvOiBcImFnb1wiLFxyXG4gICAgICAgIGZyb21Ob3c6IFwiZnJvbSBub3dcIixcclxuICAgICAgICBzZWNvbmRzOiBcImxlc3MgdGhhbiBhIG1pbnV0ZVwiLFxyXG4gICAgICAgIG1pbnV0ZTogXCJhYm91dCBhIG1pbnV0ZVwiLFxyXG4gICAgICAgIG1pbnV0ZXM6IFwiJWQgbWludXRlc1wiLFxyXG4gICAgICAgIGhvdXI6IFwiYWJvdXQgYW4gaG91clwiLFxyXG4gICAgICAgIGhvdXJzOiBcImFib3V0ICVkIGhvdXJzXCIsXHJcbiAgICAgICAgZGF5OiBcImEgZGF5XCIsXHJcbiAgICAgICAgZGF5czogXCIlZCBkYXlzXCIsXHJcbiAgICAgICAgbW9udGg6IFwiYWJvdXQgYSBtb250aFwiLFxyXG4gICAgICAgIG1vbnRoczogXCIlZCBtb250aHNcIixcclxuICAgICAgICB5ZWFyOiBcImFib3V0IGEgeWVhclwiLFxyXG4gICAgICAgIHllYXJzOiBcIiVkIHllYXJzXCJcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGluV29yZHM6IGZ1bmN0aW9uKGRpc3RhbmNlTWlsbGlzKSB7XHJcbiAgICAgIHZhciAkbCA9IHRoaXMuc2V0dGluZ3Muc3RyaW5ncztcclxuICAgICAgdmFyIHN1ZmZpeCA9ICRsLmFnbztcclxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dGdXR1cmUpIHtcclxuICAgICAgICBpZiAoZGlzdGFuY2VNaWxsaXMgPCAwKSBzdWZmaXggPSAkbC5mcm9tTm93O1xyXG4gICAgICAgIGRpc3RhbmNlTWlsbGlzID0gTWF0aC5hYnMoZGlzdGFuY2VNaWxsaXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2Vjb25kcyA9IGRpc3RhbmNlTWlsbGlzIC8gMTAwMDtcclxuICAgICAgdmFyIG1pbnV0ZXMgPSBzZWNvbmRzIC8gNjA7XHJcbiAgICAgIHZhciBob3VycyA9IG1pbnV0ZXMgLyA2MDtcclxuICAgICAgdmFyIGRheXMgPSBob3VycyAvIDI0O1xyXG4gICAgICB2YXIgeWVhcnMgPSBkYXlzIC8gMzY1O1xyXG5cclxuICAgICAgdmFyIHdvcmRzID0gc2Vjb25kcyA8IDQ1ICYmIHNwcmludGYoJGwuc2Vjb25kcywgTWF0aC5yb3VuZChzZWNvbmRzKSkgfHxcclxuICAgICAgICBzZWNvbmRzIDwgOTAgJiYgJGwubWludXRlIHx8XHJcbiAgICAgICAgbWludXRlcyA8IDQ1ICYmIHNwcmludGYoJGwubWludXRlcywgTWF0aC5yb3VuZChtaW51dGVzKSkgfHxcclxuICAgICAgICBtaW51dGVzIDwgOTAgJiYgJGwuaG91ciB8fFxyXG4gICAgICAgIGhvdXJzIDwgMjQgJiYgc3ByaW50ZigkbC5ob3VycywgTWF0aC5yb3VuZChob3VycykpIHx8XHJcbiAgICAgICAgaG91cnMgPCA0OCAmJiAkbC5kYXkgfHxcclxuICAgICAgICBkYXlzIDwgMzAgJiYgc3ByaW50ZigkbC5kYXlzLCBNYXRoLmZsb29yKGRheXMpKSB8fFxyXG4gICAgICAgIGRheXMgPCA2MCAmJiAkbC5tb250aCB8fFxyXG4gICAgICAgIGRheXMgPCAzNjUgJiYgc3ByaW50ZigkbC5tb250aHMsIE1hdGguZmxvb3IoZGF5cyAvIDMwKSkgfHxcclxuICAgICAgICB5ZWFycyA8IDIgJiYgJGwueWVhciB8fFxyXG4gICAgICAgIHNwcmludGYoJGwueWVhcnMsIE1hdGguZmxvb3IoeWVhcnMpKTtcclxuXHJcbiAgICAgIHJldHVybiB3b3JkcyArIFwiIFwiICsgc3VmZml4O1xyXG4gICAgfSxcclxuICAgIHBhcnNlOiBmdW5jdGlvbihpc284NjAxKSB7XHJcbiAgICAgIHZhciBzID0gJC50cmltKGlzbzg2MDEpO1xyXG4gICAgICBzID0gcy5yZXBsYWNlKC8tLyxcIi9cIikucmVwbGFjZSgvLS8sXCIvXCIpO1xyXG4gICAgICBzID0gcy5yZXBsYWNlKC9ULyxcIiBcIikucmVwbGFjZSgvWi8sXCIgVVRDXCIpO1xyXG4gICAgICBzID0gcy5yZXBsYWNlKC8oW1xcKy1dXFxkXFxkKVxcOj8oXFxkXFxkKS8sXCIgJDEkMlwiKTsgLy8gLTA0OjAwIC0+IC0wNDAwXHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZShzKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgJC5mbi50aW1lYWdvID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBzZWxmLmVhY2gocmVmcmVzaCk7XHJcblxyXG4gICAgdmFyICRzID0gJHQuc2V0dGluZ3M7XHJcbiAgICBpZiAoJHMucmVmcmVzaE1pbGxpcyA+IDApIHtcclxuICAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IHNlbGYuZWFjaChyZWZyZXNoKTsgfSwgJHMucmVmcmVzaE1pbGxpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VsZjtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiByZWZyZXNoKCkge1xyXG4gICAgdmFyIGRhdGUgPSAkdC5wYXJzZSh0aGlzLnRpdGxlKTtcclxuICAgIGlmICghaXNOYU4oZGF0ZSkpIHtcclxuICAgICAgJCh0aGlzKS50ZXh0KGluV29yZHMoZGF0ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbldvcmRzKGRhdGUpIHtcclxuICAgIHJldHVybiAkdC5pbldvcmRzKGRpc3RhbmNlKGRhdGUpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRpc3RhbmNlKGRhdGUpIHtcclxuICAgIHJldHVybiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWUoKSk7XHJcbiAgfVxyXG5cclxuICAvLyBsYW1lIHNwcmludGYgaW1wbGVtZW50YXRpb25cclxuICBmdW5jdGlvbiBzcHJpbnRmKHN0cmluZywgdmFsdWUpIHtcclxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJWQvaSwgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gZml4IGZvciBJRTYgc3Vja2FnZVxyXG4gIGlmICgkLmJyb3dzZXIubXNpZSAmJiAkLmJyb3dzZXIudmVyc2lvbiA8IDcuMCkge1xyXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYWJicicpO1xyXG4gIH1cclxufSkoalF1ZXJ5KTtcclxuXHJcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
